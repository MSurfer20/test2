{-
   Zulip REST API
   Powerful open source group chat 

   The version of the OpenAPI document: 1.0.0

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git

   DO NOT EDIT THIS FILE MANUALLY.

   For more info on generating Elm code, see https://eriktim.github.io/openapi-elm/
-}


module Api.Request.Messages exposing
    ( addReaction
    , checkMessagesMatchNarrow
    , deleteMessage
    , getFileTemporaryUrl
    , getMessageHistory
    , getMessages
    , getRawMessage
    , markAllAsRead
    , markStreamAsRead
    , markTopicAsRead
    , removeReaction
    , renderMessage
    , sendMessage, Type(..), type_Variants
    , updateMessage, PropagateMode(..), propagateModeVariants
    , updateMessageFlags, Op(..), opVariants
    , uploadFile
    )

import Api
import Api.Data
import Dict
import Http
import Json.Decode
import Json.Encode


type Type
    = TypePrivate
    | TypeStream


type_Variants : List Type
type_Variants =
    [ TypePrivate
    , TypeStream
    ]


stringFromType : Type -> String
stringFromType model =
    case model of
        TypePrivate ->
            "private"

        TypeStream ->
            "stream"




type PropagateMode
    = PropagateModeOne
    | PropagateModeLater
    | PropagateModeAll


propagateModeVariants : List PropagateMode
propagateModeVariants =
    [ PropagateModeOne
    , PropagateModeLater
    , PropagateModeAll
    ]


stringFromPropagateMode : PropagateMode -> String
stringFromPropagateMode model =
    case model of
        PropagateModeOne ->
            "change_one"

        PropagateModeLater ->
            "change_later"

        PropagateModeAll ->
            "change_all"




type Op
    = OpAdd
    | OpRemove


opVariants : List Op
opVariants =
    [ OpAdd
    , OpRemove
    ]


stringFromOp : Op -> String
stringFromOp model =
    case model of
        OpAdd ->
            "add"

        OpRemove ->
            "remove"





{-| Add an [emoji reaction](/help/emoji-reactions) to a message.  `POST {{ api_url }}/v1/messages/{message_id}/reactions` 
-}
addReaction : Int -> String -> Maybe String -> Maybe String -> Api.Request Api.Data.JsonSuccess
addReaction messageId_path emojiName_query emojiCode_query reactionType_query =
    Api.request
        "POST"
        "/messages/{message_id}/reactions"
        [ ( "messageId", String.fromInt messageId_path ) ]
        [ ( "emoji_name", Just <| identity emojiName_query ), ( "emoji_code", Maybe.map identity emojiCode_query ), ( "reaction_type", Maybe.map identity reactionType_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Check whether a set of messages match a [narrow](/api/construct-narrow).  `GET {{ api_url }}/v1/messages/matches_narrow`  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the `match_subject` and `match_content` objects is designed to match those of `GET /messages`, so that a client can splice these fields into a `message` object received from `GET /events` and end up with an extended message object identical to how a `GET /messages` for the current narrow would have returned the message. 
-}
checkMessagesMatchNarrow : List Int -> List Object -> Api.Request Api.Data.AnyType
checkMessagesMatchNarrow msgIds_query narrow_query =
    Api.request
        "GET"
        "/messages/matches_narrow"
        []
        [ ( "msg_ids", Just <| String.join "," << List.map String.fromInt msgIds_query ), ( "narrow", Just <| String.join "," << List.map  narrow_query ) ]
        []
        Nothing
        Api.Data.anyTypeDecoder



{-| Permanently delete a message.  `DELETE {{ api_url }}/v1/messages/{msg_id}`  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
-}
deleteMessage : Int -> Api.Request Api.Data.JsonSuccess
deleteMessage messageId_path =
    Api.request
        "DELETE"
        "/messages/{message_id}"
        [ ( "messageId", String.fromInt messageId_path ) ]
        []
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Get a temporary URL for access to the file that doesn't require authentication. 
-}
getFileTemporaryUrl : Int -> String -> Api.Request Api.Data.JsonSuccessBase
getFileTemporaryUrl realmIdStr_path filename_path =
    Api.request
        "GET"
        "/user_uploads/{realm_id_str}/{filename}"
        [ ( "realmIdStr", String.fromInt realmIdStr_path ), ( "filename", identity filename_path ) ]
        []
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Fetch the message edit history of a previously edited message.  `GET {{ api_url }}/v1/messages/{message_id}/history`  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
-}
getMessageHistory : Int -> Api.Request Api.Data.JsonSuccessBase
getMessageHistory messageId_path =
    Api.request
        "GET"
        "/messages/{message_id}/history"
        [ ( "messageId", String.fromInt messageId_path ) ]
        []
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Fetch message history from a Zulip server.  `GET {{ api_url }}/v1/messages`  This `GET /api/v1/messages` endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip's powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user's message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an `anchor` message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the `num_before` and `num_after` limits.  We recommend using `num_before <= 1000` and `num_after <= 1000` to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
-}
getMessages : Int -> Int -> Maybe Api.Data.OneOf&lt;string,integer&gt; -> Maybe List Object -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Api.Request Api.Data.JsonSuccessBase
getMessages numBefore_query numAfter_query anchor_query narrow_query clientGravatar_query applyMarkdown_query useFirstUnreadAnchor_query =
    Api.request
        "GET"
        "/messages"
        []
        [ ( "anchor", Maybe.map  anchor_query ), ( "num_before", Just <| String.fromInt numBefore_query ), ( "num_after", Just <| String.fromInt numAfter_query ), ( "narrow", Maybe.map String.join "," << List.map  narrow_query ), ( "client_gravatar", Maybe.map (\val -> if val then "true" else "false") clientGravatar_query ), ( "apply_markdown", Maybe.map (\val -> if val then "true" else "false") applyMarkdown_query ), ( "use_first_unread_anchor", Maybe.map (\val -> if val then "true" else "false") useFirstUnreadAnchor_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Get the raw content of a message.  `GET {{ api_url }}/v1/messages/{msg_id}`  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message's raw Markdown (e.g. for pre-filling a message-editing UI). 
-}
getRawMessage : Int -> Api.Request Api.Data.JsonSuccessBase
getRawMessage messageId_path =
    Api.request
        "GET"
        "/messages/{message_id}"
        [ ( "messageId", String.fromInt messageId_path ) ]
        []
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Marks all of the current user's unread messages as read.  `POST {{ api_url }}/v1/mark_all_as_read` 
-}
markAllAsRead : Api.Request Api.Data.JsonSuccess
markAllAsRead =
    Api.request
        "POST"
        "/mark_all_as_read"
        []
        []
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Mark all the unread messages in a stream as read. 
-}
markStreamAsRead : Int -> Api.Request Api.Data.JsonSuccess
markStreamAsRead streamId_query =
    Api.request
        "POST"
        "/mark_stream_as_read"
        []
        [ ( "stream_id", Just <| String.fromInt streamId_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Mark all the unread messages in a topic as read. 
-}
markTopicAsRead : Int -> String -> Api.Request Api.Data.JsonSuccess
markTopicAsRead streamId_query topicName_query =
    Api.request
        "POST"
        "/mark_topic_as_read"
        []
        [ ( "stream_id", Just <| String.fromInt streamId_query ), ( "topic_name", Just <| identity topicName_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Remove an [emoji reaction](/help/emoji-reactions) from a message.  `DELETE {{ api_url }}/v1/messages/{message_id}/reactions` 
-}
removeReaction : Int -> Maybe String -> Maybe String -> Maybe String -> Api.Request Api.Data.JsonSuccess
removeReaction messageId_path emojiName_query emojiCode_query reactionType_query =
    Api.request
        "DELETE"
        "/messages/{message_id}/reactions"
        [ ( "messageId", String.fromInt messageId_path ) ]
        [ ( "emoji_name", Maybe.map identity emojiName_query ), ( "emoji_code", Maybe.map identity emojiCode_query ), ( "reaction_type", Maybe.map identity reactionType_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Render a message to HTML.  `POST {{ api_url }}/v1/messages/render` 
-}
renderMessage : String -> Api.Request Api.Data.JsonSuccessBase
renderMessage content_query =
    Api.request
        "POST"
        "/messages/render"
        []
        [ ( "content", Just <| identity content_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Send a stream or a private message.  `POST {{ api_url }}/v1/messages` 
-}
sendMessage : Type -> List Int -> String -> Maybe String -> Maybe String -> Maybe String -> Api.Request Api.Data.JsonSuccessBase
sendMessage type__query to_query content_query topic_query queueId_query localId_query =
    Api.request
        "POST"
        "/messages"
        []
        [ ( "type", Just <| stringFromType type__query ), ( "to", Just <| String.join "," << List.map String.fromInt to_query ), ( "content", Just <| identity content_query ), ( "topic", Maybe.map identity topic_query ), ( "queue_id", Maybe.map identity queueId_query ), ( "local_id", Maybe.map identity localId_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Edit/update the content or topic of a message.  `PATCH {{ api_url }}/v1/messages/{msg_id}`  `{msg_id}` in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to `✔ {original_topic}`.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
-}
updateMessage : Int -> Maybe String -> Maybe PropagateMode -> Maybe Bool -> Maybe Bool -> Maybe String -> Maybe Int -> Api.Request Api.Data.JsonSuccess
updateMessage messageId_path topic_query propagateMode_query sendNotificationToOldThread_query sendNotificationToNewThread_query content_query streamId_query =
    Api.request
        "PATCH"
        "/messages/{message_id}"
        [ ( "messageId", String.fromInt messageId_path ) ]
        [ ( "topic", Maybe.map identity topic_query ), ( "propagate_mode", Maybe.map stringFromPropagateMode propagateMode_query ), ( "send_notification_to_old_thread", Maybe.map (\val -> if val then "true" else "false") sendNotificationToOldThread_query ), ( "send_notification_to_new_thread", Maybe.map (\val -> if val then "true" else "false") sendNotificationToNewThread_query ), ( "content", Maybe.map identity content_query ), ( "stream_id", Maybe.map String.fromInt streamId_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Add or remove personal message flags like `read` and `starred` on a collection of message IDs.  `POST {{ api_url }}/v1/messages/flags`  For updating the `read` flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
-}
updateMessageFlags : List Int -> Op -> String -> Api.Request Api.Data.JsonSuccessBase
updateMessageFlags messages_query op_query flag_query =
    Api.request
        "POST"
        "/messages/flags"
        []
        [ ( "messages", Just <| String.join "," << List.map String.fromInt messages_query ), ( "op", Just <| stringFromOp op_query ), ( "flag", Just <| identity flag_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Upload a single file and get the corresponding URI.  `POST {{ api_url }}/v1/user_uploads`  Initially, only you will be able to access the link.  To share the uploaded file, you'll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
-}
uploadFile : Maybe String -> Api.Request Api.Data.JsonSuccessBase
uploadFile filename =
    Api.request
        "POST"
        "/user_uploads"
        []
        []
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder
