{-
   Zulip REST API
   Powerful open source group chat 

   The version of the OpenAPI document: 1.0.0

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git

   DO NOT EDIT THIS FILE MANUALLY.

   For more info on generating Elm code, see https://eriktim.github.io/openapi-elm/
-}


module Api.Request.Users exposing
    ( createUser
    , createUserGroup
    , deactivateOwnUser
    , deactivateUser
    , getAttachments
    , getOwnUser
    , getUser
    , getUserByEmail
    , getUserGroups
    , getUserPresence
    , getUsers
    , muteUser
    , reactivateUser
    , removeUserGroup
    , setTypingStatus, Op(..), opVariants, Type(..), type_Variants
    , unmuteUser
    , updateDisplaySettings, ColorScheme(..), colorSchemeVariants, DemoteInactiveStreams(..), demoteInactiveStreamsVariants
    , updateNotificationSettings, DesktopIconCountDisplay(..), desktopIconCountDisplayVariants
    , updateUser
    , updateUserGroup
    , updateUserGroupMembers
    )

import Api
import Api.Data
import Dict
import Http
import Json.Decode
import Json.Encode


type Op
    = OpStart
    | OpStop


opVariants : List Op
opVariants =
    [ OpStart
    , OpStop
    ]


stringFromOp : Op -> String
stringFromOp model =
    case model of
        OpStart ->
            "start"

        OpStop ->
            "stop"




type Type
    = TypePrivate
    | TypeStream


type_Variants : List Type
type_Variants =
    [ TypePrivate
    , TypeStream
    ]


stringFromType : Type -> String
stringFromType model =
    case model of
        TypePrivate ->
            "private"

        TypeStream ->
            "stream"




type ColorScheme
    = ColorScheme1
    | ColorScheme2
    | ColorScheme3


colorSchemeVariants : List ColorScheme
colorSchemeVariants =
    [ ColorScheme1
    , ColorScheme2
    , ColorScheme3
    ]


stringFromColorScheme : ColorScheme -> String
stringFromColorScheme model =
    case model of
        ColorScheme1 ->
            1

        ColorScheme2 ->
            2

        ColorScheme3 ->
            3




type DemoteInactiveStreams
    = DemoteInactiveStreams1
    | DemoteInactiveStreams2
    | DemoteInactiveStreams3


demoteInactiveStreamsVariants : List DemoteInactiveStreams
demoteInactiveStreamsVariants =
    [ DemoteInactiveStreams1
    , DemoteInactiveStreams2
    , DemoteInactiveStreams3
    ]


stringFromDemoteInactiveStreams : DemoteInactiveStreams -> String
stringFromDemoteInactiveStreams model =
    case model of
        DemoteInactiveStreams1 ->
            1

        DemoteInactiveStreams2 ->
            2

        DemoteInactiveStreams3 ->
            3




type DesktopIconCountDisplay
    = DesktopIconCountDisplay1
    | DesktopIconCountDisplay2
    | DesktopIconCountDisplay3


desktopIconCountDisplayVariants : List DesktopIconCountDisplay
desktopIconCountDisplayVariants =
    [ DesktopIconCountDisplay1
    , DesktopIconCountDisplay2
    , DesktopIconCountDisplay3
    ]


stringFromDesktopIconCountDisplay : DesktopIconCountDisplay -> String
stringFromDesktopIconCountDisplay model =
    case model of
        DesktopIconCountDisplay1 ->
            1

        DesktopIconCountDisplay2 ->
            2

        DesktopIconCountDisplay3 ->
            3





{-| {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
-}
createUser : String -> String -> String -> Api.Request Api.Data.JsonSuccessBase
createUser email_query password_query fullName_query =
    Api.request
        "POST"
        "/users"
        []
        [ ( "email", Just <| identity email_query ), ( "password", Just <| identity password_query ), ( "full_name", Just <| identity fullName_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
-}
createUserGroup : String -> String -> List Int -> Api.Request Api.Data.JsonSuccess
createUserGroup name_query description_query members_query =
    Api.request
        "POST"
        "/user_groups/create"
        []
        [ ( "name", Just <| identity name_query ), ( "description", Just <| identity description_query ), ( "members", Just <| String.join "," << List.map String.fromInt members_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Deactivates the user's account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
-}
deactivateOwnUser : Api.Request Api.Data.JsonSuccess
deactivateOwnUser =
    Api.request
        "DELETE"
        "/users/me"
        []
        []
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
-}
deactivateUser : Int -> Api.Request Api.Data.JsonSuccess
deactivateUser userId_path =
    Api.request
        "DELETE"
        "/users/{user_id}"
        [ ( "userId", String.fromInt userId_path ) ]
        []
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
-}
getAttachments : Api.Request Api.Data.JsonSuccessBase
getAttachments =
    Api.request
        "GET"
        "/attachments"
        []
        []
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
-}
getOwnUser : Api.Request Api.Data.JsonSuccessBase
getOwnUser =
    Api.request
        "GET"
        "/users/me"
        []
        []
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
-}
getUser : Int -> Maybe Bool -> Maybe Bool -> Api.Request Api.Data.JsonSuccessBase
getUser userId_path clientGravatar_query includeCustomProfileFields_query =
    Api.request
        "GET"
        "/users/{user_id}"
        [ ( "userId", String.fromInt userId_path ) ]
        [ ( "client_gravatar", Maybe.map (\val -> if val then "true" else "false") clientGravatar_query ), ( "include_custom_profile_fields", Maybe.map (\val -> if val then "true" else "false") includeCustomProfileFields_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
-}
getUserByEmail : String -> Maybe Bool -> Maybe Bool -> Api.Request Api.Data.JsonSuccessBase
getUserByEmail email_path clientGravatar_query includeCustomProfileFields_query =
    Api.request
        "GET"
        "/users/{email}"
        [ ( "email", identity email_path ) ]
        [ ( "client_gravatar", Maybe.map (\val -> if val then "true" else "false") clientGravatar_query ), ( "include_custom_profile_fields", Maybe.map (\val -> if val then "true" else "false") includeCustomProfileFields_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
-}
getUserGroups : Api.Request Api.Data.JsonSuccessBase
getUserGroups =
    Api.request
        "GET"
        "/user_groups"
        []
        []
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user's presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip's developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
-}
getUserPresence : String -> Api.Request Api.Data.JsonSuccessBase
getUserPresence userIdOrEmail_path =
    Api.request
        "GET"
        "/users/{user_id_or_email}/presence"
        [ ( "userIdOrEmail", identity userIdOrEmail_path ) ]
        []
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
-}
getUsers : Maybe Bool -> Maybe Bool -> Api.Request Api.Data.JsonSuccessBase
getUsers clientGravatar_query includeCustomProfileFields_query =
    Api.request
        "GET"
        "/users"
        []
        [ ( "client_gravatar", Maybe.map (\val -> if val then "true" else "false") clientGravatar_query ), ( "include_custom_profile_fields", Maybe.map (\val -> if val then "true" else "false") includeCustomProfileFields_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you've muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user's name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
-}
muteUser : Int -> Api.Request Api.Data.JsonSuccess
muteUser mutedUserId_path =
    Api.request
        "POST"
        "/users/me/muted_users/{muted_user_id}"
        [ ( "mutedUserId", String.fromInt mutedUserId_path ) ]
        []
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
-}
reactivateUser : Int -> Api.Request Api.Data.AnyType
reactivateUser userId_path =
    Api.request
        "POST"
        "/users/{user_id}/reactivate"
        [ ( "userId", String.fromInt userId_path ) ]
        []
        []
        Nothing
        Api.Data.anyTypeDecoder



{-| Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
-}
removeUserGroup : Int -> Api.Request Api.Data.JsonSuccess
removeUserGroup userGroupId_path =
    Api.request
        "DELETE"
        "/user_groups/{user_group_id}"
        [ ( "userGroupId", String.fromInt userGroupId_path ) ]
        []
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip's typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip's typing notifications protocol. 
-}
setTypingStatus : Op -> List Int -> Maybe Type -> Maybe String -> Api.Request Api.Data.JsonSuccess
setTypingStatus op_query to_query type__query topic_query =
    Api.request
        "POST"
        "/typing"
        []
        [ ( "type", Maybe.map stringFromType type__query ), ( "op", Just <| stringFromOp op_query ), ( "to", Just <| String.join "," << List.map String.fromInt to_query ), ( "topic", Maybe.map identity topic_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
-}
unmuteUser : Int -> Api.Request Api.Data.JsonSuccess
unmuteUser mutedUserId_path =
    Api.request
        "DELETE"
        "/users/me/muted_users/{muted_user_id}"
        [ ( "mutedUserId", String.fromInt mutedUserId_path ) ]
        []
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| This endpoint is used to edit the current user's user interface settings.  `PATCH {{ api_url }}/v1/settings/display` 
-}
updateDisplaySettings : Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe ColorScheme -> Maybe Bool -> Maybe String -> Maybe String -> Maybe Bool -> Maybe String -> Maybe DemoteInactiveStreams -> Maybe String -> Api.Request Api.Data.JsonSuccessBase
updateDisplaySettings twentyFourHourTime_query denseMode_query starredMessageCounts_query fluidLayoutWidth_query highContrastMode_query colorScheme_query translateEmoticons_query defaultLanguage_query defaultView_query leftSideUserlist_query emojiset_query demoteInactiveStreams_query timezone_query =
    Api.request
        "PATCH"
        "/settings/display"
        []
        [ ( "twenty_four_hour_time", Maybe.map (\val -> if val then "true" else "false") twentyFourHourTime_query ), ( "dense_mode", Maybe.map (\val -> if val then "true" else "false") denseMode_query ), ( "starred_message_counts", Maybe.map (\val -> if val then "true" else "false") starredMessageCounts_query ), ( "fluid_layout_width", Maybe.map (\val -> if val then "true" else "false") fluidLayoutWidth_query ), ( "high_contrast_mode", Maybe.map (\val -> if val then "true" else "false") highContrastMode_query ), ( "color_scheme", Maybe.map String.fromIntstringFromColorScheme colorScheme_query ), ( "translate_emoticons", Maybe.map (\val -> if val then "true" else "false") translateEmoticons_query ), ( "default_language", Maybe.map identity defaultLanguage_query ), ( "default_view", Maybe.map identity defaultView_query ), ( "left_side_userlist", Maybe.map (\val -> if val then "true" else "false") leftSideUserlist_query ), ( "emojiset", Maybe.map identity emojiset_query ), ( "demote_inactive_streams", Maybe.map String.fromIntstringFromDemoteInactiveStreams demoteInactiveStreams_query ), ( "timezone", Maybe.map identity timezone_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| This endpoint is used to edit the user's global notification settings. See [this endpoint](/api/update-subscription-settings) for per-stream notification settings.  `PATCH {{ api_url }}/v1/settings/notifications` 
-}
updateNotificationSettings : Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe String -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe Bool -> Maybe DesktopIconCountDisplay -> Maybe Bool -> Maybe Bool -> Api.Request Api.Data.JsonSuccessBase
updateNotificationSettings enableStreamDesktopNotifications_query enableStreamEmailNotifications_query enableStreamPushNotifications_query enableStreamAudibleNotifications_query notificationSound_query enableDesktopNotifications_query enableSounds_query enableOfflineEmailNotifications_query enableOfflinePushNotifications_query enableOnlinePushNotifications_query enableDigestEmails_query enableMarketingEmails_query enableLoginEmails_query messageContentInEmailNotifications_query pmContentInDesktopNotifications_query wildcardMentionsNotify_query desktopIconCountDisplay_query realmNameInNotifications_query presenceEnabled_query =
    Api.request
        "PATCH"
        "/settings/notifications"
        []
        [ ( "enable_stream_desktop_notifications", Maybe.map (\val -> if val then "true" else "false") enableStreamDesktopNotifications_query ), ( "enable_stream_email_notifications", Maybe.map (\val -> if val then "true" else "false") enableStreamEmailNotifications_query ), ( "enable_stream_push_notifications", Maybe.map (\val -> if val then "true" else "false") enableStreamPushNotifications_query ), ( "enable_stream_audible_notifications", Maybe.map (\val -> if val then "true" else "false") enableStreamAudibleNotifications_query ), ( "notification_sound", Maybe.map identity notificationSound_query ), ( "enable_desktop_notifications", Maybe.map (\val -> if val then "true" else "false") enableDesktopNotifications_query ), ( "enable_sounds", Maybe.map (\val -> if val then "true" else "false") enableSounds_query ), ( "enable_offline_email_notifications", Maybe.map (\val -> if val then "true" else "false") enableOfflineEmailNotifications_query ), ( "enable_offline_push_notifications", Maybe.map (\val -> if val then "true" else "false") enableOfflinePushNotifications_query ), ( "enable_online_push_notifications", Maybe.map (\val -> if val then "true" else "false") enableOnlinePushNotifications_query ), ( "enable_digest_emails", Maybe.map (\val -> if val then "true" else "false") enableDigestEmails_query ), ( "enable_marketing_emails", Maybe.map (\val -> if val then "true" else "false") enableMarketingEmails_query ), ( "enable_login_emails", Maybe.map (\val -> if val then "true" else "false") enableLoginEmails_query ), ( "message_content_in_email_notifications", Maybe.map (\val -> if val then "true" else "false") messageContentInEmailNotifications_query ), ( "pm_content_in_desktop_notifications", Maybe.map (\val -> if val then "true" else "false") pmContentInDesktopNotifications_query ), ( "wildcard_mentions_notify", Maybe.map (\val -> if val then "true" else "false") wildcardMentionsNotify_query ), ( "desktop_icon_count_display", Maybe.map String.fromIntstringFromDesktopIconCountDisplay desktopIconCountDisplay_query ), ( "realm_name_in_notifications", Maybe.map (\val -> if val then "true" else "false") realmNameInNotifications_query ), ( "presence_enabled", Maybe.map (\val -> if val then "true" else "false") presenceEnabled_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessBaseDecoder



{-| Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user's account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
-}
updateUser : Int -> Maybe String -> Maybe Int -> Maybe List Object -> Api.Request Api.Data.JsonSuccess
updateUser userId_path fullName_query role_query profileData_query =
    Api.request
        "PATCH"
        "/users/{user_id}"
        [ ( "userId", String.fromInt userId_path ) ]
        [ ( "full_name", Maybe.map identity fullName_query ), ( "role", Maybe.map String.fromInt role_query ), ( "profile_data", Maybe.map String.join "," << List.map  profileData_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
-}
updateUserGroup : Int -> String -> String -> Api.Request Api.Data.JsonSuccess
updateUserGroup userGroupId_path name_query description_query =
    Api.request
        "PATCH"
        "/user_groups/{user_group_id}"
        [ ( "userGroupId", String.fromInt userGroupId_path ) ]
        [ ( "name", Just <| identity name_query ), ( "description", Just <| identity description_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessDecoder



{-| Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
-}
updateUserGroupMembers : Int -> Maybe List Int -> Maybe List Int -> Api.Request Api.Data.JsonSuccess
updateUserGroupMembers userGroupId_path delete_query add_query =
    Api.request
        "POST"
        "/user_groups/{user_group_id}/members"
        [ ( "userGroupId", String.fromInt userGroupId_path ) ]
        [ ( "delete", Maybe.map String.join "," << List.map String.fromInt delete_query ), ( "add", Maybe.map String.join "," << List.map String.fromInt add_query ) ]
        []
        Nothing
        Api.Data.jsonSuccessDecoder
