# #Zulip REST API
#
##Powerful open source group chat 
#
#The version of the OpenAPI document: 1.0.0
#
#Generated by: https://openapi-generator.tech
#OpenAPI Generator version: 5.2.0
#

require "uri"

module 
  class MessagesApi
    property api_client : ApiClient

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Add an emoji reaction
    # Add an [emoji reaction](/help/emoji-reactions) to a message.  `POST {{ api_url }}/v1/messages/{message_id}/reactions` 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @param emoji_name [String] The target emoji&#39;s human-readable name.  To find an emoji&#39;s name, hover over a message to reveal three icons on the right, then click the smiley face icon. Images of available reaction emojis appear. Hover over the emoji you want, and note that emoji&#39;s text name. 
    # @return [JsonSuccess]
    def add_reaction(message_id : Int32, emoji_name : String, emoji_code : String?, reaction_type : String?)
      data, _status_code, _headers = add_reaction_with_http_info(message_id, emoji_name, emoji_code, reaction_type)
      data
    end

    # Add an emoji reaction
    # Add an [emoji reaction](/help/emoji-reactions) to a message.  &#x60;POST {{ api_url }}/v1/messages/{message_id}/reactions&#x60; 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @param emoji_name [String] The target emoji&#39;s human-readable name.  To find an emoji&#39;s name, hover over a message to reveal three icons on the right, then click the smiley face icon. Images of available reaction emojis appear. Hover over the emoji you want, and note that emoji&#39;s text name. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def add_reaction_with_http_info(message_id : Int32, emoji_name : String, emoji_code : String?, reaction_type : String?)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.add_reaction ..."}
      end
      # verify the required parameter "message_id" is set
      if @api_client.config.client_side_validation && message_id.nil?
        raise ArgumentError.new("Missing the required parameter 'message_id' when calling MessagesApi.add_reaction")
      end
      # verify the required parameter "emoji_name" is set
      if @api_client.config.client_side_validation && emoji_name.nil?
        raise ArgumentError.new("Missing the required parameter 'emoji_name' when calling MessagesApi.add_reaction")
      end
      # resource path
      local_var_path = "/messages/{message_id}/reactions".sub("{" + "message_id" + "}", URI.encode(message_id.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["emoji_name"] = emoji_name
      query_params["emoji_code"] = emoji_code
      query_params["reaction_type"] = reaction_type

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"MessagesApi.add_reaction",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#add_reaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Check if messages match a narrow
    # Check whether a set of messages match a [narrow](/api/construct-narrow).  `GET {{ api_url }}/v1/messages/matches_narrow`  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the `match_subject` and `match_content` objects is designed to match those of `GET /messages`, so that a client can splice these fields into a `message` object received from `GET /events` and end up with an extended message object identical to how a `GET /messages` for the current narrow would have returned the message. 
    # @param msg_ids [Array(Int32)] List of IDs for the messages to check.
    # @param narrow [Array(Object)] A structure defining the narrow to check against. See how to [construct a narrow](/api/construct-narrow).
    # @return [AnyType]
    def check_messages_match_narrow(msg_ids : Array(Int32), narrow : Array(Object))
      data, _status_code, _headers = check_messages_match_narrow_with_http_info(msg_ids, narrow)
      data
    end

    # Check if messages match a narrow
    # Check whether a set of messages match a [narrow](/api/construct-narrow).  &#x60;GET {{ api_url }}/v1/messages/matches_narrow&#x60;  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the &#x60;match_subject&#x60; and &#x60;match_content&#x60; objects is designed to match those of &#x60;GET /messages&#x60;, so that a client can splice these fields into a &#x60;message&#x60; object received from &#x60;GET /events&#x60; and end up with an extended message object identical to how a &#x60;GET /messages&#x60; for the current narrow would have returned the message. 
    # @param msg_ids [Array(Int32)] List of IDs for the messages to check.
    # @param narrow [Array(Object)] A structure defining the narrow to check against. See how to [construct a narrow](/api/construct-narrow).
    # @return [Array<(AnyType, Integer, Hash)>] AnyType data, response status code and response headers
    def check_messages_match_narrow_with_http_info(msg_ids : Array(Int32), narrow : Array(Object))
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.check_messages_match_narrow ..."}
      end
      # verify the required parameter "msg_ids" is set
      if @api_client.config.client_side_validation && msg_ids.nil?
        raise ArgumentError.new("Missing the required parameter 'msg_ids' when calling MessagesApi.check_messages_match_narrow")
      end
      # verify the required parameter "narrow" is set
      if @api_client.config.client_side_validation && narrow.nil?
        raise ArgumentError.new("Missing the required parameter 'narrow' when calling MessagesApi.check_messages_match_narrow")
      end
      # resource path
      local_var_path = "/messages/matches_narrow"

      # query parameters
      query_params = Hash(String, String).new
      query_params["msg_ids"] = @api_client.build_collection_param(msg_ids, :multi)
      query_params["narrow"] = @api_client.build_collection_param(narrow, :multi)

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "AnyType"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"MessagesApi.check_messages_match_narrow",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#check_messages_match_narrow\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return AnyType.from_json(data), status_code, headers
    end

    # Delete a message
    # Permanently delete a message.  `DELETE {{ api_url }}/v1/messages/{msg_id}`  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @return [JsonSuccess]
    def delete_message(message_id : Int32)
      data, _status_code, _headers = delete_message_with_http_info(message_id)
      data
    end

    # Delete a message
    # Permanently delete a message.  &#x60;DELETE {{ api_url }}/v1/messages/{msg_id}&#x60;  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def delete_message_with_http_info(message_id : Int32)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.delete_message ..."}
      end
      # verify the required parameter "message_id" is set
      if @api_client.config.client_side_validation && message_id.nil?
        raise ArgumentError.new("Missing the required parameter 'message_id' when calling MessagesApi.delete_message")
      end
      # resource path
      local_var_path = "/messages/{message_id}".sub("{" + "message_id" + "}", URI.encode(message_id.to_s))

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:DELETE,
                                                        local_var_path,
                                                        :"MessagesApi.delete_message",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#delete_message\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Get public temporary URL
    # Get a temporary URL for access to the file that doesn't require authentication. 
    # @param realm_id_str [Int32] The realm id. 
    # @param filename [String] Path to the URL. 
    # @return [JsonSuccessBase]
    def get_file_temporary_url(realm_id_str : Int32, filename : String)
      data, _status_code, _headers = get_file_temporary_url_with_http_info(realm_id_str, filename)
      data
    end

    # Get public temporary URL
    # Get a temporary URL for access to the file that doesn&#39;t require authentication. 
    # @param realm_id_str [Int32] The realm id. 
    # @param filename [String] Path to the URL. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_file_temporary_url_with_http_info(realm_id_str : Int32, filename : String)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.get_file_temporary_url ..."}
      end
      # verify the required parameter "realm_id_str" is set
      if @api_client.config.client_side_validation && realm_id_str.nil?
        raise ArgumentError.new("Missing the required parameter 'realm_id_str' when calling MessagesApi.get_file_temporary_url")
      end
      # verify the required parameter "filename" is set
      if @api_client.config.client_side_validation && filename.nil?
        raise ArgumentError.new("Missing the required parameter 'filename' when calling MessagesApi.get_file_temporary_url")
      end
      # resource path
      local_var_path = "/user_uploads/{realm_id_str}/{filename}".sub("{" + "realm_id_str" + "}", URI.encode(realm_id_str.to_s)).sub("{" + "filename" + "}", URI.encode(filename.to_s))

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"MessagesApi.get_file_temporary_url",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#get_file_temporary_url\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Get a message's edit history
    # Fetch the message edit history of a previously edited message.  `GET {{ api_url }}/v1/messages/{message_id}/history`  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @return [JsonSuccessBase]
    def get_message_history(message_id : Int32)
      data, _status_code, _headers = get_message_history_with_http_info(message_id)
      data
    end

    # Get a message&#39;s edit history
    # Fetch the message edit history of a previously edited message.  &#x60;GET {{ api_url }}/v1/messages/{message_id}/history&#x60;  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_message_history_with_http_info(message_id : Int32)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.get_message_history ..."}
      end
      # verify the required parameter "message_id" is set
      if @api_client.config.client_side_validation && message_id.nil?
        raise ArgumentError.new("Missing the required parameter 'message_id' when calling MessagesApi.get_message_history")
      end
      # resource path
      local_var_path = "/messages/{message_id}/history".sub("{" + "message_id" + "}", URI.encode(message_id.to_s))

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"MessagesApi.get_message_history",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#get_message_history\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Get messages
    # Fetch message history from a Zulip server.  `GET {{ api_url }}/v1/messages`  This `GET /api/v1/messages` endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip's powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user's message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an `anchor` message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the `num_before` and `num_after` limits.  We recommend using `num_before <= 1000` and `num_after <= 1000` to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
    # @param num_before [Int32] The number of messages with IDs less than the anchor to retrieve. 
    # @param num_after [Int32] The number of messages with IDs greater than the anchor to retrieve. 
    # @return [JsonSuccessBase]
    def get_messages(num_before : Int32, num_after : Int32, anchor : OneOfstringinteger?, narrow : Array(Object)?, client_gravatar : Bool?, apply_markdown : Bool?, use_first_unread_anchor : Bool?)
      data, _status_code, _headers = get_messages_with_http_info(num_before, num_after, anchor, narrow, client_gravatar, apply_markdown, use_first_unread_anchor)
      data
    end

    # Get messages
    # Fetch message history from a Zulip server.  &#x60;GET {{ api_url }}/v1/messages&#x60;  This &#x60;GET /api/v1/messages&#x60; endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip&#39;s powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user&#39;s message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an &#x60;anchor&#x60; message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the &#x60;num_before&#x60; and &#x60;num_after&#x60; limits.  We recommend using &#x60;num_before &lt;&#x3D; 1000&#x60; and &#x60;num_after &lt;&#x3D; 1000&#x60; to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
    # @param num_before [Int32] The number of messages with IDs less than the anchor to retrieve. 
    # @param num_after [Int32] The number of messages with IDs greater than the anchor to retrieve. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_messages_with_http_info(num_before : Int32, num_after : Int32, anchor : OneOfstringinteger?, narrow : Array(Object)?, client_gravatar : Bool?, apply_markdown : Bool?, use_first_unread_anchor : Bool?)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.get_messages ..."}
      end
      # verify the required parameter "num_before" is set
      if @api_client.config.client_side_validation && num_before.nil?
        raise ArgumentError.new("Missing the required parameter 'num_before' when calling MessagesApi.get_messages")
      end
      if @api_client.config.client_side_validation && num_before < 0
        raise ArgumentError.new("invalid value for \"num_before\" when calling MessagesApi.get_messages, must be greater than or equal to 0.")
      end

      # verify the required parameter "num_after" is set
      if @api_client.config.client_side_validation && num_after.nil?
        raise ArgumentError.new("Missing the required parameter 'num_after' when calling MessagesApi.get_messages")
      end
      if @api_client.config.client_side_validation && num_after < 0
        raise ArgumentError.new("invalid value for \"num_after\" when calling MessagesApi.get_messages, must be greater than or equal to 0.")
      end

      # resource path
      local_var_path = "/messages"

      # query parameters
      query_params = Hash(String, String).new
      query_params["anchor"] = anchor
      query_params["num_before"] = num_before
      query_params["num_after"] = num_after
      query_params["narrow"] = @api_client.build_collection_param(narrow, :multi)
      query_params["client_gravatar"] = client_gravatar
      query_params["apply_markdown"] = apply_markdown
      query_params["use_first_unread_anchor"] = use_first_unread_anchor

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"MessagesApi.get_messages",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#get_messages\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Get a message's raw Markdown
    # Get the raw content of a message.  `GET {{ api_url }}/v1/messages/{msg_id}`  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message's raw Markdown (e.g. for pre-filling a message-editing UI). 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @return [JsonSuccessBase]
    def get_raw_message(message_id : Int32)
      data, _status_code, _headers = get_raw_message_with_http_info(message_id)
      data
    end

    # Get a message&#39;s raw Markdown
    # Get the raw content of a message.  &#x60;GET {{ api_url }}/v1/messages/{msg_id}&#x60;  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message&#39;s raw Markdown (e.g. for pre-filling a message-editing UI). 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_raw_message_with_http_info(message_id : Int32)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.get_raw_message ..."}
      end
      # verify the required parameter "message_id" is set
      if @api_client.config.client_side_validation && message_id.nil?
        raise ArgumentError.new("Missing the required parameter 'message_id' when calling MessagesApi.get_raw_message")
      end
      # resource path
      local_var_path = "/messages/{message_id}".sub("{" + "message_id" + "}", URI.encode(message_id.to_s))

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"MessagesApi.get_raw_message",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#get_raw_message\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Mark all messages as read
    # Marks all of the current user's unread messages as read.  `POST {{ api_url }}/v1/mark_all_as_read` 
    # @return [JsonSuccess]
    def mark_all_as_read()
      data, _status_code, _headers = mark_all_as_read_with_http_info()
      data
    end

    # Mark all messages as read
    # Marks all of the current user&#39;s unread messages as read.  &#x60;POST {{ api_url }}/v1/mark_all_as_read&#x60; 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def mark_all_as_read_with_http_info()
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.mark_all_as_read ..."}
      end
      # resource path
      local_var_path = "/mark_all_as_read"

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"MessagesApi.mark_all_as_read",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#mark_all_as_read\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Mark messages in a stream as read
    # Mark all the unread messages in a stream as read. 
    # @param stream_id [Int32] The ID of the stream to access. 
    # @return [JsonSuccess]
    def mark_stream_as_read(stream_id : Int32)
      data, _status_code, _headers = mark_stream_as_read_with_http_info(stream_id)
      data
    end

    # Mark messages in a stream as read
    # Mark all the unread messages in a stream as read. 
    # @param stream_id [Int32] The ID of the stream to access. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def mark_stream_as_read_with_http_info(stream_id : Int32)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.mark_stream_as_read ..."}
      end
      # verify the required parameter "stream_id" is set
      if @api_client.config.client_side_validation && stream_id.nil?
        raise ArgumentError.new("Missing the required parameter 'stream_id' when calling MessagesApi.mark_stream_as_read")
      end
      # resource path
      local_var_path = "/mark_stream_as_read"

      # query parameters
      query_params = Hash(String, String).new
      query_params["stream_id"] = stream_id

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"MessagesApi.mark_stream_as_read",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#mark_stream_as_read\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Mark messages in a topic as read
    # Mark all the unread messages in a topic as read. 
    # @param stream_id [Int32] The ID of the stream to access. 
    # @param topic_name [String] The name of the topic whose messages should be marked as read. 
    # @return [JsonSuccess]
    def mark_topic_as_read(stream_id : Int32, topic_name : String)
      data, _status_code, _headers = mark_topic_as_read_with_http_info(stream_id, topic_name)
      data
    end

    # Mark messages in a topic as read
    # Mark all the unread messages in a topic as read. 
    # @param stream_id [Int32] The ID of the stream to access. 
    # @param topic_name [String] The name of the topic whose messages should be marked as read. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def mark_topic_as_read_with_http_info(stream_id : Int32, topic_name : String)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.mark_topic_as_read ..."}
      end
      # verify the required parameter "stream_id" is set
      if @api_client.config.client_side_validation && stream_id.nil?
        raise ArgumentError.new("Missing the required parameter 'stream_id' when calling MessagesApi.mark_topic_as_read")
      end
      # verify the required parameter "topic_name" is set
      if @api_client.config.client_side_validation && topic_name.nil?
        raise ArgumentError.new("Missing the required parameter 'topic_name' when calling MessagesApi.mark_topic_as_read")
      end
      # resource path
      local_var_path = "/mark_topic_as_read"

      # query parameters
      query_params = Hash(String, String).new
      query_params["stream_id"] = stream_id
      query_params["topic_name"] = topic_name

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"MessagesApi.mark_topic_as_read",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#mark_topic_as_read\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Remove an emoji reaction
    # Remove an [emoji reaction](/help/emoji-reactions) from a message.  `DELETE {{ api_url }}/v1/messages/{message_id}/reactions` 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @return [JsonSuccess]
    def remove_reaction(message_id : Int32, emoji_name : String?, emoji_code : String?, reaction_type : String?)
      data, _status_code, _headers = remove_reaction_with_http_info(message_id, emoji_name, emoji_code, reaction_type)
      data
    end

    # Remove an emoji reaction
    # Remove an [emoji reaction](/help/emoji-reactions) from a message.  &#x60;DELETE {{ api_url }}/v1/messages/{message_id}/reactions&#x60; 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def remove_reaction_with_http_info(message_id : Int32, emoji_name : String?, emoji_code : String?, reaction_type : String?)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.remove_reaction ..."}
      end
      # verify the required parameter "message_id" is set
      if @api_client.config.client_side_validation && message_id.nil?
        raise ArgumentError.new("Missing the required parameter 'message_id' when calling MessagesApi.remove_reaction")
      end
      # resource path
      local_var_path = "/messages/{message_id}/reactions".sub("{" + "message_id" + "}", URI.encode(message_id.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["emoji_name"] = emoji_name
      query_params["emoji_code"] = emoji_code
      query_params["reaction_type"] = reaction_type

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:DELETE,
                                                        local_var_path,
                                                        :"MessagesApi.remove_reaction",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#remove_reaction\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Render message
    # Render a message to HTML.  `POST {{ api_url }}/v1/messages/render` 
    # @param content [String] The content of the message. Maximum message size of 10000 bytes. 
    # @return [JsonSuccessBase]
    def render_message(content : String)
      data, _status_code, _headers = render_message_with_http_info(content)
      data
    end

    # Render message
    # Render a message to HTML.  &#x60;POST {{ api_url }}/v1/messages/render&#x60; 
    # @param content [String] The content of the message. Maximum message size of 10000 bytes. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def render_message_with_http_info(content : String)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.render_message ..."}
      end
      # verify the required parameter "content" is set
      if @api_client.config.client_side_validation && content.nil?
        raise ArgumentError.new("Missing the required parameter 'content' when calling MessagesApi.render_message")
      end
      # resource path
      local_var_path = "/messages/render"

      # query parameters
      query_params = Hash(String, String).new
      query_params["content"] = content

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"MessagesApi.render_message",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#render_message\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Send a message
    # Send a stream or a private message.  `POST {{ api_url }}/v1/messages` 
    # @param _type [String] The type of message to be sent. &#x60;private&#x60; for a private message and &#x60;stream&#x60; for a stream message. 
    # @param to [Array(Int32)] For stream messages, either the name or integer ID of the stream. For private messages, either a list containing integer user IDs or a list containing string email addresses.  **Changes**: Support for using user/stream IDs was added in Zulip 2.0.0. 
    # @param content [String] The content of the message. Maximum message size of 10000 bytes. 
    # @return [JsonSuccessBase]
    def send_message(_type : String, to : Array(Int32), content : String, topic : String?, queue_id : String?, local_id : String?)
      data, _status_code, _headers = send_message_with_http_info(_type, to, content, topic, queue_id, local_id)
      data
    end

    # Send a message
    # Send a stream or a private message.  &#x60;POST {{ api_url }}/v1/messages&#x60; 
    # @param _type [String] The type of message to be sent. &#x60;private&#x60; for a private message and &#x60;stream&#x60; for a stream message. 
    # @param to [Array(Int32)] For stream messages, either the name or integer ID of the stream. For private messages, either a list containing integer user IDs or a list containing string email addresses.  **Changes**: Support for using user/stream IDs was added in Zulip 2.0.0. 
    # @param content [String] The content of the message. Maximum message size of 10000 bytes. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def send_message_with_http_info(_type : String, to : Array(Int32), content : String, topic : String?, queue_id : String?, local_id : String?)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.send_message ..."}
      end
      # verify the required parameter "_type" is set
      if @api_client.config.client_side_validation && _type.nil?
        raise ArgumentError.new("Missing the required parameter '_type' when calling MessagesApi.send_message")
      end
      # verify enum value
      allowable_values = ["private", "stream"]
      if @api_client.config.client_side_validation && !allowable_values.includes?(_type)
        raise ArgumentError.new("invalid value for \"_type\", must be one of #{allowable_values}")
      end
      # verify the required parameter "to" is set
      if @api_client.config.client_side_validation && to.nil?
        raise ArgumentError.new("Missing the required parameter 'to' when calling MessagesApi.send_message")
      end
      # verify the required parameter "content" is set
      if @api_client.config.client_side_validation && content.nil?
        raise ArgumentError.new("Missing the required parameter 'content' when calling MessagesApi.send_message")
      end
      # resource path
      local_var_path = "/messages"

      # query parameters
      query_params = Hash(String, String).new
      query_params["type"] = _type
      query_params["to"] = @api_client.build_collection_param(to, :multi)
      query_params["content"] = content
      query_params["topic"] = topic
      query_params["queue_id"] = queue_id
      query_params["local_id"] = local_id

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"MessagesApi.send_message",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#send_message\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Edit a message
    # Edit/update the content or topic of a message.  `PATCH {{ api_url }}/v1/messages/{msg_id}`  `{msg_id}` in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to `✔ {original_topic}`.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @return [JsonSuccess]
    def update_message(message_id : Int32, topic : String?, propagate_mode : String?, send_notification_to_old_thread : Bool?, send_notification_to_new_thread : Bool?, content : String?, stream_id : Int32?)
      data, _status_code, _headers = update_message_with_http_info(message_id, topic, propagate_mode, send_notification_to_old_thread, send_notification_to_new_thread, content, stream_id)
      data
    end

    # Edit a message
    # Edit/update the content or topic of a message.  &#x60;PATCH {{ api_url }}/v1/messages/{msg_id}&#x60;  &#x60;{msg_id}&#x60; in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to &#x60;✔ {original_topic}&#x60;.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
    # @param message_id [Int32] The target message&#39;s ID. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def update_message_with_http_info(message_id : Int32, topic : String?, propagate_mode : String?, send_notification_to_old_thread : Bool?, send_notification_to_new_thread : Bool?, content : String?, stream_id : Int32?)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.update_message ..."}
      end
      # verify the required parameter "message_id" is set
      if @api_client.config.client_side_validation && message_id.nil?
        raise ArgumentError.new("Missing the required parameter 'message_id' when calling MessagesApi.update_message")
      end
      allowable_values = ["change_one", "change_later", "change_all"]
      if @api_client.config.client_side_validation && propagate_mode && !allowable_values.includes?(propagate_mode)
        raise ArgumentError.new("invalid value for \"propagate_mode\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/messages/{message_id}".sub("{" + "message_id" + "}", URI.encode(message_id.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["topic"] = topic
      query_params["propagate_mode"] = propagate_mode
      query_params["send_notification_to_old_thread"] = send_notification_to_old_thread
      query_params["send_notification_to_new_thread"] = send_notification_to_new_thread
      query_params["content"] = content
      query_params["stream_id"] = stream_id

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:PATCH,
                                                        local_var_path,
                                                        :"MessagesApi.update_message",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#update_message\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Update personal message flags
    # Add or remove personal message flags like `read` and `starred` on a collection of message IDs.  `POST {{ api_url }}/v1/messages/flags`  For updating the `read` flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
    # @param messages [Array(Int32)] An array containing the IDs of the target messages. 
    # @param op [String] Whether to &#x60;add&#x60; the flag or &#x60;remove&#x60; it. 
    # @param flag [String] The flag that should be added/removed. 
    # @return [JsonSuccessBase]
    def update_message_flags(messages : Array(Int32), op : String, flag : String)
      data, _status_code, _headers = update_message_flags_with_http_info(messages, op, flag)
      data
    end

    # Update personal message flags
    # Add or remove personal message flags like &#x60;read&#x60; and &#x60;starred&#x60; on a collection of message IDs.  &#x60;POST {{ api_url }}/v1/messages/flags&#x60;  For updating the &#x60;read&#x60; flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
    # @param messages [Array(Int32)] An array containing the IDs of the target messages. 
    # @param op [String] Whether to &#x60;add&#x60; the flag or &#x60;remove&#x60; it. 
    # @param flag [String] The flag that should be added/removed. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def update_message_flags_with_http_info(messages : Array(Int32), op : String, flag : String)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.update_message_flags ..."}
      end
      # verify the required parameter "messages" is set
      if @api_client.config.client_side_validation && messages.nil?
        raise ArgumentError.new("Missing the required parameter 'messages' when calling MessagesApi.update_message_flags")
      end
      # verify the required parameter "op" is set
      if @api_client.config.client_side_validation && op.nil?
        raise ArgumentError.new("Missing the required parameter 'op' when calling MessagesApi.update_message_flags")
      end
      # verify enum value
      allowable_values = ["add", "remove"]
      if @api_client.config.client_side_validation && !allowable_values.includes?(op)
        raise ArgumentError.new("invalid value for \"op\", must be one of #{allowable_values}")
      end
      # verify the required parameter "flag" is set
      if @api_client.config.client_side_validation && flag.nil?
        raise ArgumentError.new("Missing the required parameter 'flag' when calling MessagesApi.update_message_flags")
      end
      # resource path
      local_var_path = "/messages/flags"

      # query parameters
      query_params = Hash(String, String).new
      query_params["messages"] = @api_client.build_collection_param(messages, :multi)
      query_params["op"] = op
      query_params["flag"] = flag

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"MessagesApi.update_message_flags",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#update_message_flags\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Upload a file
    # Upload a single file and get the corresponding URI.  `POST {{ api_url }}/v1/user_uploads`  Initially, only you will be able to access the link.  To share the uploaded file, you'll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
    # @return [JsonSuccessBase]
    def upload_file(filename : File?)
      data, _status_code, _headers = upload_file_with_http_info(filename)
      data
    end

    # Upload a file
    # Upload a single file and get the corresponding URI.  &#x60;POST {{ api_url }}/v1/user_uploads&#x60;  Initially, only you will be able to access the link.  To share the uploaded file, you&#39;ll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def upload_file_with_http_info(filename : File?)
      if @api_client.config.debugging
        Log.debug {"Calling API: MessagesApi.upload_file ..."}
      end
      # resource path
      local_var_path = "/user_uploads"

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])
      # HTTP header "Content-Type"
      header_params["Content-Type"] = @api_client.select_header_content_type(["multipart/form-data"])

      # form parameters
      form_params = Hash(Symbol, String).new
      form_params[:"filename"] = filename

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"MessagesApi.upload_file",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: MessagesApi#upload_file\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end
  end
end
