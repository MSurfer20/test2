# #Zulip REST API
#
##Powerful open source group chat 
#
#The version of the OpenAPI document: 1.0.0
#
#Generated by: https://openapi-generator.tech
#OpenAPI Generator version: 5.2.0
#

require "uri"

module 
  class UsersApi
    property api_client : ApiClient

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create a user
    # {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
    # @param email [String] The email address of the new user. 
    # @param password [String] The password of the new user. 
    # @param full_name [String] The full name of the new user. 
    # @return [JsonSuccessBase]
    def create_user(email : String, password : String, full_name : String)
      data, _status_code, _headers = create_user_with_http_info(email, password, full_name)
      data
    end

    # Create a user
    # {!can-create-users-only.md!}  Create a new user account via the API.  &#x60;POST {{ api_url }}/v1/users&#x60; 
    # @param email [String] The email address of the new user. 
    # @param password [String] The password of the new user. 
    # @param full_name [String] The full name of the new user. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def create_user_with_http_info(email : String, password : String, full_name : String)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.create_user ..."}
      end
      # verify the required parameter "email" is set
      if @api_client.config.client_side_validation && email.nil?
        raise ArgumentError.new("Missing the required parameter 'email' when calling UsersApi.create_user")
      end
      # verify the required parameter "password" is set
      if @api_client.config.client_side_validation && password.nil?
        raise ArgumentError.new("Missing the required parameter 'password' when calling UsersApi.create_user")
      end
      # verify the required parameter "full_name" is set
      if @api_client.config.client_side_validation && full_name.nil?
        raise ArgumentError.new("Missing the required parameter 'full_name' when calling UsersApi.create_user")
      end
      # resource path
      local_var_path = "/users"

      # query parameters
      query_params = Hash(String, String).new
      query_params["email"] = email
      query_params["password"] = password
      query_params["full_name"] = full_name

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"UsersApi.create_user",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#create_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Create a user group
    # Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
    # @param name [String] The name of the user group. 
    # @param description [String] The description of the user group. 
    # @param members [Array(Int32)] An array containing the user IDs of the initial members for the new user group. 
    # @return [JsonSuccess]
    def create_user_group(name : String, description : String, members : Array(Int32))
      data, _status_code, _headers = create_user_group_with_http_info(name, description, members)
      data
    end

    # Create a user group
    # Create a new [user group](/help/user-groups).  &#x60;POST {{ api_url }}/v1/user_groups/create&#x60; 
    # @param name [String] The name of the user group. 
    # @param description [String] The description of the user group. 
    # @param members [Array(Int32)] An array containing the user IDs of the initial members for the new user group. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def create_user_group_with_http_info(name : String, description : String, members : Array(Int32))
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.create_user_group ..."}
      end
      # verify the required parameter "name" is set
      if @api_client.config.client_side_validation && name.nil?
        raise ArgumentError.new("Missing the required parameter 'name' when calling UsersApi.create_user_group")
      end
      # verify the required parameter "description" is set
      if @api_client.config.client_side_validation && description.nil?
        raise ArgumentError.new("Missing the required parameter 'description' when calling UsersApi.create_user_group")
      end
      # verify the required parameter "members" is set
      if @api_client.config.client_side_validation && members.nil?
        raise ArgumentError.new("Missing the required parameter 'members' when calling UsersApi.create_user_group")
      end
      # resource path
      local_var_path = "/user_groups/create"

      # query parameters
      query_params = Hash(String, String).new
      query_params["name"] = name
      query_params["description"] = description
      query_params["members"] = @api_client.build_collection_param(members, :multi)

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"UsersApi.create_user_group",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#create_user_group\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Deactivate own user
    # Deactivates the user's account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
    # @return [JsonSuccess]
    def deactivate_own_user()
      data, _status_code, _headers = deactivate_own_user_with_http_info()
      data
    end

    # Deactivate own user
    # Deactivates the user&#39;s account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  &#x60;DELETE {{ api_url }}/v1/users/me&#x60;  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def deactivate_own_user_with_http_info()
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.deactivate_own_user ..."}
      end
      # resource path
      local_var_path = "/users/me"

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:DELETE,
                                                        local_var_path,
                                                        :"UsersApi.deactivate_own_user",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#deactivate_own_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Deactivate a user
    # [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
    # @param user_id [Int32] The target user&#39;s ID. 
    # @return [JsonSuccess]
    def deactivate_user(user_id : Int32)
      data, _status_code, _headers = deactivate_user_with_http_info(user_id)
      data
    end

    # Deactivate a user
    # [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  &#x60;DELETE {{ api_url }}/v1/users/{user_id}&#x60; 
    # @param user_id [Int32] The target user&#39;s ID. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def deactivate_user_with_http_info(user_id : Int32)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.deactivate_user ..."}
      end
      # verify the required parameter "user_id" is set
      if @api_client.config.client_side_validation && user_id.nil?
        raise ArgumentError.new("Missing the required parameter 'user_id' when calling UsersApi.deactivate_user")
      end
      # resource path
      local_var_path = "/users/{user_id}".sub("{" + "user_id" + "}", URI.encode(user_id.to_s))

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:DELETE,
                                                        local_var_path,
                                                        :"UsersApi.deactivate_user",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#deactivate_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Get attachments
    # Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
    # @return [JsonSuccessBase]
    def get_attachments()
      data, _status_code, _headers = get_attachments_with_http_info()
      data
    end

    # Get attachments
    # Fetch metadata on files uploaded by the requesting user.  &#x60;GET {{ api_url }}/v1/attachments&#x60; 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_attachments_with_http_info()
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.get_attachments ..."}
      end
      # resource path
      local_var_path = "/attachments"

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"UsersApi.get_attachments",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#get_attachments\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Get own user
    # Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
    # @return [JsonSuccessBase]
    def get_own_user()
      data, _status_code, _headers = get_own_user_with_http_info()
      data
    end

    # Get own user
    # Get basic data about the user/bot that requests this endpoint.  &#x60;GET {{ api_url }}/v1/users/me&#x60; 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_own_user_with_http_info()
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.get_own_user ..."}
      end
      # resource path
      local_var_path = "/users/me"

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"UsersApi.get_own_user",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#get_own_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Get a user
    # Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
    # @param user_id [Int32] The target user&#39;s ID. 
    # @return [JsonSuccessBase]
    def get_user(user_id : Int32, client_gravatar : Bool?, include_custom_profile_fields : Bool?)
      data, _status_code, _headers = get_user_with_http_info(user_id, client_gravatar, include_custom_profile_fields)
      data
    end

    # Get a user
    # Fetch details for a single user in the organization.  &#x60;GET {{ api_url }}/v1/users/{user_id}&#x60;  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
    # @param user_id [Int32] The target user&#39;s ID. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_user_with_http_info(user_id : Int32, client_gravatar : Bool?, include_custom_profile_fields : Bool?)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.get_user ..."}
      end
      # verify the required parameter "user_id" is set
      if @api_client.config.client_side_validation && user_id.nil?
        raise ArgumentError.new("Missing the required parameter 'user_id' when calling UsersApi.get_user")
      end
      # resource path
      local_var_path = "/users/{user_id}".sub("{" + "user_id" + "}", URI.encode(user_id.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["client_gravatar"] = client_gravatar
      query_params["include_custom_profile_fields"] = include_custom_profile_fields

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"UsersApi.get_user",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#get_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Get a user by email
    # Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
    # @param email [String] The email address of the user whose details you want to fetch. 
    # @return [JsonSuccessBase]
    def get_user_by_email(email : String, client_gravatar : Bool?, include_custom_profile_fields : Bool?)
      data, _status_code, _headers = get_user_by_email_with_http_info(email, client_gravatar, include_custom_profile_fields)
      data
    end

    # Get a user by email
    # Fetch details for a single user in the organization given a Zulip display email address.  &#x60;GET {{ api_url }}/v1/users/{email}&#x60;  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
    # @param email [String] The email address of the user whose details you want to fetch. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_user_by_email_with_http_info(email : String, client_gravatar : Bool?, include_custom_profile_fields : Bool?)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.get_user_by_email ..."}
      end
      # verify the required parameter "email" is set
      if @api_client.config.client_side_validation && email.nil?
        raise ArgumentError.new("Missing the required parameter 'email' when calling UsersApi.get_user_by_email")
      end
      # resource path
      local_var_path = "/users/{email}".sub("{" + "email" + "}", URI.encode(email.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["client_gravatar"] = client_gravatar
      query_params["include_custom_profile_fields"] = include_custom_profile_fields

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"UsersApi.get_user_by_email",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#get_user_by_email\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Get user groups
    # {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
    # @return [JsonSuccessBase]
    def get_user_groups()
      data, _status_code, _headers = get_user_groups_with_http_info()
      data
    end

    # Get user groups
    # {!api-members-only.md!}  Fetches all of the user groups in the organization.  &#x60;GET {{ api_url }}/v1/user_groups&#x60; 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_user_groups_with_http_info()
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.get_user_groups ..."}
      end
      # resource path
      local_var_path = "/user_groups"

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"UsersApi.get_user_groups",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#get_user_groups\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Get user presence
    # Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user's presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip's developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
    # @param user_id_or_email [String] The user_id or Zulip display email address of the user whose presence you want to fetch.  **Changes**: New in Zulip 4.0 (feature level 43). Previous versions only supported identifying the user by Zulip display email. 
    # @return [JsonSuccessBase]
    def get_user_presence(user_id_or_email : String)
      data, _status_code, _headers = get_user_presence_with_http_info(user_id_or_email)
      data
    end

    # Get user presence
    # Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user&#39;s presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  &#x60;GET {{ api_url }}/v1/users/{user_id_or_email}/presence&#x60;  See [Zulip&#39;s developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
    # @param user_id_or_email [String] The user_id or Zulip display email address of the user whose presence you want to fetch.  **Changes**: New in Zulip 4.0 (feature level 43). Previous versions only supported identifying the user by Zulip display email. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_user_presence_with_http_info(user_id_or_email : String)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.get_user_presence ..."}
      end
      # verify the required parameter "user_id_or_email" is set
      if @api_client.config.client_side_validation && user_id_or_email.nil?
        raise ArgumentError.new("Missing the required parameter 'user_id_or_email' when calling UsersApi.get_user_presence")
      end
      # resource path
      local_var_path = "/users/{user_id_or_email}/presence".sub("{" + "user_id_or_email" + "}", URI.encode(user_id_or_email.to_s))

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"UsersApi.get_user_presence",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#get_user_presence\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Get all users
    # Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
    # @return [JsonSuccessBase]
    def get_users(client_gravatar : Bool?, include_custom_profile_fields : Bool?)
      data, _status_code, _headers = get_users_with_http_info(client_gravatar, include_custom_profile_fields)
      data
    end

    # Get all users
    # Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  &#x60;GET {{ api_url }}/v1/users&#x60;  You can also [fetch details on a single user](/api/get-user). 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_users_with_http_info(client_gravatar : Bool?, include_custom_profile_fields : Bool?)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.get_users ..."}
      end
      # resource path
      local_var_path = "/users"

      # query parameters
      query_params = Hash(String, String).new
      query_params["client_gravatar"] = client_gravatar
      query_params["include_custom_profile_fields"] = include_custom_profile_fields

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:GET,
                                                        local_var_path,
                                                        :"UsersApi.get_users",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#get_users\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Mute a user
    # This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you've muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user's name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
    # @param muted_user_id [Int32] The ID of the user to mute/un-mute. 
    # @return [JsonSuccess]
    def mute_user(muted_user_id : Int32)
      data, _status_code, _headers = mute_user_with_http_info(muted_user_id)
      data
    end

    # Mute a user
    # This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you&#39;ve muted will be automatically marked as read and hidden.  &#x60;POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}&#x60;  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \&quot;Muted user\&quot;, rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \&quot;All users that exist   on this stream or realm\&quot;, e.g. for organization   administration or showing stream subscribers, should display   the user&#39;s name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
    # @param muted_user_id [Int32] The ID of the user to mute/un-mute. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def mute_user_with_http_info(muted_user_id : Int32)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.mute_user ..."}
      end
      # verify the required parameter "muted_user_id" is set
      if @api_client.config.client_side_validation && muted_user_id.nil?
        raise ArgumentError.new("Missing the required parameter 'muted_user_id' when calling UsersApi.mute_user")
      end
      # resource path
      local_var_path = "/users/me/muted_users/{muted_user_id}".sub("{" + "muted_user_id" + "}", URI.encode(muted_user_id.to_s))

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"UsersApi.mute_user",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#mute_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Reactivate a user
    # [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
    # @param user_id [Int32] The target user&#39;s ID. 
    # @return [AnyType]
    def reactivate_user(user_id : Int32)
      data, _status_code, _headers = reactivate_user_with_http_info(user_id)
      data
    end

    # Reactivate a user
    # [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  &#x60;POST {{ api_url }}/v1/users/{user_id}/reactivate&#x60; 
    # @param user_id [Int32] The target user&#39;s ID. 
    # @return [Array<(AnyType, Integer, Hash)>] AnyType data, response status code and response headers
    def reactivate_user_with_http_info(user_id : Int32)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.reactivate_user ..."}
      end
      # verify the required parameter "user_id" is set
      if @api_client.config.client_side_validation && user_id.nil?
        raise ArgumentError.new("Missing the required parameter 'user_id' when calling UsersApi.reactivate_user")
      end
      # resource path
      local_var_path = "/users/{user_id}/reactivate".sub("{" + "user_id" + "}", URI.encode(user_id.to_s))

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "AnyType"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"UsersApi.reactivate_user",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#reactivate_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return AnyType.from_json(data), status_code, headers
    end

    # Delete a user group
    # Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
    # @param user_group_id [Int32] The ID of the target user group. 
    # @return [JsonSuccess]
    def remove_user_group(user_group_id : Int32)
      data, _status_code, _headers = remove_user_group_with_http_info(user_group_id)
      data
    end

    # Delete a user group
    # Delete a [user group](/help/user-groups).  &#x60;DELETE {{ api_url }}/v1/user_groups/{user_group_id}&#x60; 
    # @param user_group_id [Int32] The ID of the target user group. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def remove_user_group_with_http_info(user_group_id : Int32)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.remove_user_group ..."}
      end
      # verify the required parameter "user_group_id" is set
      if @api_client.config.client_side_validation && user_group_id.nil?
        raise ArgumentError.new("Missing the required parameter 'user_group_id' when calling UsersApi.remove_user_group")
      end
      # resource path
      local_var_path = "/user_groups/{user_group_id}".sub("{" + "user_group_id" + "}", URI.encode(user_group_id.to_s))

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:DELETE,
                                                        local_var_path,
                                                        :"UsersApi.remove_user_group",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#remove_user_group\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Set \"typing\" status
    # Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip's typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip's typing notifications protocol. 
    # @param op [String] Whether the user has started (&#x60;start&#x60;) or stopped (&#x60;stop&#x60;) to type. 
    # @param to [Array(Int32)] For &#39;private&#39; type it is the user_ids of the recipients of the message being typed. Send a JSON-encoded list of user_ids. (Use a list even if there is only one recipient.)  For &#39;stream&#39; type it is a single element list containing ID of stream in which the message is being typed.  **Changes**: Before Zulip 2.0, this parameter accepted only a JSON-encoded list of email addresses.  Support for the email address-based format was removed in Zulip 3.0 (feature level 11). 
    # @return [JsonSuccess]
    def set_typing_status(op : String, to : Array(Int32), _type : String?, topic : String?)
      data, _status_code, _headers = set_typing_status_with_http_info(op, to, _type, topic)
      data
    end

    # Set \&quot;typing\&quot; status
    # Notify other users whether the current user is typing a message.  &#x60;POST {{ api_url }}/v1/typing&#x60;  Clients implementing Zulip&#39;s typing notifications protocol should work as follows:  * Send a request to this endpoint with &#x60;op&#x3D;\&quot;start\&quot;&#x60; when a user starts typing a message,   and also every &#x60;TYPING_STARTED_WAIT_PERIOD&#x3D;10&#x60; seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with &#x60;op&#x3D;\&quot;stop\&quot;&#x60; when a user pauses using the   compose UI for at least &#x60;TYPING_STOPPED_WAIT_PERIOD&#x3D;5&#x60; seconds or cancels   the compose action (if it had previously sent a \&quot;start\&quot; operation for that   compose action). * Start displaying \&quot;Sender is typing\&quot; for a given conversation when the client   receives an &#x60;op&#x3D;\&quot;start\&quot;&#x60; event from the [events API](/api/get-events). * Continue displaying \&quot;Sender is typing\&quot; until they receive an &#x60;op&#x3D;\&quot;stop\&quot;&#x60; event   from the [events API](/api/get-events) or &#x60;TYPING_STARTED_EXPIRY_PERIOD&#x3D;15&#x60;   seconds have passed without a new &#x60;op&#x3D;\&quot;start\&quot;&#x60; event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   &#x60;stream_typing_notifications&#x60; in the &#x60;client_capabilities&#x60; parameter to &#x60;/register&#x60;.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip&#39;s typing notifications protocol. 
    # @param op [String] Whether the user has started (&#x60;start&#x60;) or stopped (&#x60;stop&#x60;) to type. 
    # @param to [Array(Int32)] For &#39;private&#39; type it is the user_ids of the recipients of the message being typed. Send a JSON-encoded list of user_ids. (Use a list even if there is only one recipient.)  For &#39;stream&#39; type it is a single element list containing ID of stream in which the message is being typed.  **Changes**: Before Zulip 2.0, this parameter accepted only a JSON-encoded list of email addresses.  Support for the email address-based format was removed in Zulip 3.0 (feature level 11). 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def set_typing_status_with_http_info(op : String, to : Array(Int32), _type : String?, topic : String?)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.set_typing_status ..."}
      end
      # verify the required parameter "op" is set
      if @api_client.config.client_side_validation && op.nil?
        raise ArgumentError.new("Missing the required parameter 'op' when calling UsersApi.set_typing_status")
      end
      # verify enum value
      allowable_values = ["start", "stop"]
      if @api_client.config.client_side_validation && !allowable_values.includes?(op)
        raise ArgumentError.new("invalid value for \"op\", must be one of #{allowable_values}")
      end
      # verify the required parameter "to" is set
      if @api_client.config.client_side_validation && to.nil?
        raise ArgumentError.new("Missing the required parameter 'to' when calling UsersApi.set_typing_status")
      end
      allowable_values = ["private", "stream"]
      if @api_client.config.client_side_validation && _type && !allowable_values.includes?(_type)
        raise ArgumentError.new("invalid value for \"_type\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/typing"

      # query parameters
      query_params = Hash(String, String).new
      query_params["type"] = _type
      query_params["op"] = op
      query_params["to"] = @api_client.build_collection_param(to, :multi)
      query_params["topic"] = topic

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"UsersApi.set_typing_status",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#set_typing_status\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Unmute a user
    # This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
    # @param muted_user_id [Int32] The ID of the user to mute/un-mute. 
    # @return [JsonSuccess]
    def unmute_user(muted_user_id : Int32)
      data, _status_code, _headers = unmute_user_with_http_info(muted_user_id)
      data
    end

    # Unmute a user
    # This endpoint unmutes a user.  &#x60;DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}&#x60;  **Changes**: New in Zulip 4.0 (feature level 48). 
    # @param muted_user_id [Int32] The ID of the user to mute/un-mute. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def unmute_user_with_http_info(muted_user_id : Int32)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.unmute_user ..."}
      end
      # verify the required parameter "muted_user_id" is set
      if @api_client.config.client_side_validation && muted_user_id.nil?
        raise ArgumentError.new("Missing the required parameter 'muted_user_id' when calling UsersApi.unmute_user")
      end
      # resource path
      local_var_path = "/users/me/muted_users/{muted_user_id}".sub("{" + "muted_user_id" + "}", URI.encode(muted_user_id.to_s))

      # query parameters
      query_params = Hash(String, String).new

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:DELETE,
                                                        local_var_path,
                                                        :"UsersApi.unmute_user",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#unmute_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Update display settings
    # This endpoint is used to edit the current user's user interface settings.  `PATCH {{ api_url }}/v1/settings/display` 
    # @return [JsonSuccessBase]
    def update_display_settings(twenty_four_hour_time : Bool?, dense_mode : Bool?, starred_message_counts : Bool?, fluid_layout_width : Bool?, high_contrast_mode : Bool?, color_scheme : Int32?, translate_emoticons : Bool?, default_language : String?, default_view : String?, left_side_userlist : Bool?, emojiset : String?, demote_inactive_streams : Int32?, timezone : String?)
      data, _status_code, _headers = update_display_settings_with_http_info(twenty_four_hour_time, dense_mode, starred_message_counts, fluid_layout_width, high_contrast_mode, color_scheme, translate_emoticons, default_language, default_view, left_side_userlist, emojiset, demote_inactive_streams, timezone)
      data
    end

    # Update display settings
    # This endpoint is used to edit the current user&#39;s user interface settings.  &#x60;PATCH {{ api_url }}/v1/settings/display&#x60; 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def update_display_settings_with_http_info(twenty_four_hour_time : Bool?, dense_mode : Bool?, starred_message_counts : Bool?, fluid_layout_width : Bool?, high_contrast_mode : Bool?, color_scheme : Int32?, translate_emoticons : Bool?, default_language : String?, default_view : String?, left_side_userlist : Bool?, emojiset : String?, demote_inactive_streams : Int32?, timezone : String?)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.update_display_settings ..."}
      end
      allowable_values = ["1", "2", "3"]
      if @api_client.config.client_side_validation && color_scheme && !allowable_values.includes?(color_scheme)
        raise ArgumentError.new("invalid value for \"color_scheme\", must be one of #{allowable_values}")
      end
      allowable_values = ["1", "2", "3"]
      if @api_client.config.client_side_validation && demote_inactive_streams && !allowable_values.includes?(demote_inactive_streams)
        raise ArgumentError.new("invalid value for \"demote_inactive_streams\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/settings/display"

      # query parameters
      query_params = Hash(String, String).new
      query_params["twenty_four_hour_time"] = twenty_four_hour_time
      query_params["dense_mode"] = dense_mode
      query_params["starred_message_counts"] = starred_message_counts
      query_params["fluid_layout_width"] = fluid_layout_width
      query_params["high_contrast_mode"] = high_contrast_mode
      query_params["color_scheme"] = color_scheme
      query_params["translate_emoticons"] = translate_emoticons
      query_params["default_language"] = default_language
      query_params["default_view"] = default_view
      query_params["left_side_userlist"] = left_side_userlist
      query_params["emojiset"] = emojiset
      query_params["demote_inactive_streams"] = demote_inactive_streams
      query_params["timezone"] = timezone

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:PATCH,
                                                        local_var_path,
                                                        :"UsersApi.update_display_settings",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#update_display_settings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Update notification settings
    # This endpoint is used to edit the user's global notification settings. See [this endpoint](/api/update-subscription-settings) for per-stream notification settings.  `PATCH {{ api_url }}/v1/settings/notifications` 
    # @return [JsonSuccessBase]
    def update_notification_settings(enable_stream_desktop_notifications : Bool?, enable_stream_email_notifications : Bool?, enable_stream_push_notifications : Bool?, enable_stream_audible_notifications : Bool?, notification_sound : String?, enable_desktop_notifications : Bool?, enable_sounds : Bool?, enable_offline_email_notifications : Bool?, enable_offline_push_notifications : Bool?, enable_online_push_notifications : Bool?, enable_digest_emails : Bool?, enable_marketing_emails : Bool?, enable_login_emails : Bool?, message_content_in_email_notifications : Bool?, pm_content_in_desktop_notifications : Bool?, wildcard_mentions_notify : Bool?, desktop_icon_count_display : Int32?, realm_name_in_notifications : Bool?, presence_enabled : Bool?)
      data, _status_code, _headers = update_notification_settings_with_http_info(enable_stream_desktop_notifications, enable_stream_email_notifications, enable_stream_push_notifications, enable_stream_audible_notifications, notification_sound, enable_desktop_notifications, enable_sounds, enable_offline_email_notifications, enable_offline_push_notifications, enable_online_push_notifications, enable_digest_emails, enable_marketing_emails, enable_login_emails, message_content_in_email_notifications, pm_content_in_desktop_notifications, wildcard_mentions_notify, desktop_icon_count_display, realm_name_in_notifications, presence_enabled)
      data
    end

    # Update notification settings
    # This endpoint is used to edit the user&#39;s global notification settings. See [this endpoint](/api/update-subscription-settings) for per-stream notification settings.  &#x60;PATCH {{ api_url }}/v1/settings/notifications&#x60; 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def update_notification_settings_with_http_info(enable_stream_desktop_notifications : Bool?, enable_stream_email_notifications : Bool?, enable_stream_push_notifications : Bool?, enable_stream_audible_notifications : Bool?, notification_sound : String?, enable_desktop_notifications : Bool?, enable_sounds : Bool?, enable_offline_email_notifications : Bool?, enable_offline_push_notifications : Bool?, enable_online_push_notifications : Bool?, enable_digest_emails : Bool?, enable_marketing_emails : Bool?, enable_login_emails : Bool?, message_content_in_email_notifications : Bool?, pm_content_in_desktop_notifications : Bool?, wildcard_mentions_notify : Bool?, desktop_icon_count_display : Int32?, realm_name_in_notifications : Bool?, presence_enabled : Bool?)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.update_notification_settings ..."}
      end
      allowable_values = ["1", "2", "3"]
      if @api_client.config.client_side_validation && desktop_icon_count_display && !allowable_values.includes?(desktop_icon_count_display)
        raise ArgumentError.new("invalid value for \"desktop_icon_count_display\", must be one of #{allowable_values}")
      end
      # resource path
      local_var_path = "/settings/notifications"

      # query parameters
      query_params = Hash(String, String).new
      query_params["enable_stream_desktop_notifications"] = enable_stream_desktop_notifications
      query_params["enable_stream_email_notifications"] = enable_stream_email_notifications
      query_params["enable_stream_push_notifications"] = enable_stream_push_notifications
      query_params["enable_stream_audible_notifications"] = enable_stream_audible_notifications
      query_params["notification_sound"] = notification_sound
      query_params["enable_desktop_notifications"] = enable_desktop_notifications
      query_params["enable_sounds"] = enable_sounds
      query_params["enable_offline_email_notifications"] = enable_offline_email_notifications
      query_params["enable_offline_push_notifications"] = enable_offline_push_notifications
      query_params["enable_online_push_notifications"] = enable_online_push_notifications
      query_params["enable_digest_emails"] = enable_digest_emails
      query_params["enable_marketing_emails"] = enable_marketing_emails
      query_params["enable_login_emails"] = enable_login_emails
      query_params["message_content_in_email_notifications"] = message_content_in_email_notifications
      query_params["pm_content_in_desktop_notifications"] = pm_content_in_desktop_notifications
      query_params["wildcard_mentions_notify"] = wildcard_mentions_notify
      query_params["desktop_icon_count_display"] = desktop_icon_count_display
      query_params["realm_name_in_notifications"] = realm_name_in_notifications
      query_params["presence_enabled"] = presence_enabled

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccessBase"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:PATCH,
                                                        local_var_path,
                                                        :"UsersApi.update_notification_settings",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#update_notification_settings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccessBase.from_json(data), status_code, headers
    end

    # Update a user
    # Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user's account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
    # @param user_id [Int32] The target user&#39;s ID. 
    # @return [JsonSuccess]
    def update_user(user_id : Int32, full_name : String?, role : Int32?, profile_data : Array(Object)?)
      data, _status_code, _headers = update_user_with_http_info(user_id, full_name, role, profile_data)
      data
    end

    # Update a user
    # Administrative endpoint to update the details of another user in the organization.  &#x60;PATCH {{ api_url }}/v1/users/{user_id}&#x60;  Supports everything an administrator can do to edit details of another user&#39;s account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
    # @param user_id [Int32] The target user&#39;s ID. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def update_user_with_http_info(user_id : Int32, full_name : String?, role : Int32?, profile_data : Array(Object)?)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.update_user ..."}
      end
      # verify the required parameter "user_id" is set
      if @api_client.config.client_side_validation && user_id.nil?
        raise ArgumentError.new("Missing the required parameter 'user_id' when calling UsersApi.update_user")
      end
      # resource path
      local_var_path = "/users/{user_id}".sub("{" + "user_id" + "}", URI.encode(user_id.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["full_name"] = full_name
      query_params["role"] = role
      query_params["profile_data"] = @api_client.build_collection_param(profile_data, :multi)

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:PATCH,
                                                        local_var_path,
                                                        :"UsersApi.update_user",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#update_user\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Update a user group
    # Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
    # @param user_group_id [Int32] The ID of the target user group. 
    # @param name [String] The new name of the group. 
    # @param description [String] The new description of the group. 
    # @return [JsonSuccess]
    def update_user_group(user_group_id : Int32, name : String, description : String)
      data, _status_code, _headers = update_user_group_with_http_info(user_group_id, name, description)
      data
    end

    # Update a user group
    # Update the name or description of a [user group](/help/user-groups).  &#x60;PATCH {{ api_url }}/v1/user_groups/{user_group_id}&#x60; 
    # @param user_group_id [Int32] The ID of the target user group. 
    # @param name [String] The new name of the group. 
    # @param description [String] The new description of the group. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def update_user_group_with_http_info(user_group_id : Int32, name : String, description : String)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.update_user_group ..."}
      end
      # verify the required parameter "user_group_id" is set
      if @api_client.config.client_side_validation && user_group_id.nil?
        raise ArgumentError.new("Missing the required parameter 'user_group_id' when calling UsersApi.update_user_group")
      end
      # verify the required parameter "name" is set
      if @api_client.config.client_side_validation && name.nil?
        raise ArgumentError.new("Missing the required parameter 'name' when calling UsersApi.update_user_group")
      end
      # verify the required parameter "description" is set
      if @api_client.config.client_side_validation && description.nil?
        raise ArgumentError.new("Missing the required parameter 'description' when calling UsersApi.update_user_group")
      end
      # resource path
      local_var_path = "/user_groups/{user_group_id}".sub("{" + "user_group_id" + "}", URI.encode(user_group_id.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["name"] = name
      query_params["description"] = description

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:PATCH,
                                                        local_var_path,
                                                        :"UsersApi.update_user_group",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#update_user_group\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end

    # Update user group members
    # Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
    # @param user_group_id [Int32] The ID of the target user group. 
    # @return [JsonSuccess]
    def update_user_group_members(user_group_id : Int32, delete : Array(Int32)?, add : Array(Int32)?)
      data, _status_code, _headers = update_user_group_members_with_http_info(user_group_id, delete, add)
      data
    end

    # Update user group members
    # Update the members of a [user group](/help/user-groups).  &#x60;POST {{ api_url }}/v1/user_groups/{user_group_id}/members&#x60; 
    # @param user_group_id [Int32] The ID of the target user group. 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def update_user_group_members_with_http_info(user_group_id : Int32, delete : Array(Int32)?, add : Array(Int32)?)
      if @api_client.config.debugging
        Log.debug {"Calling API: UsersApi.update_user_group_members ..."}
      end
      # verify the required parameter "user_group_id" is set
      if @api_client.config.client_side_validation && user_group_id.nil?
        raise ArgumentError.new("Missing the required parameter 'user_group_id' when calling UsersApi.update_user_group_members")
      end
      # resource path
      local_var_path = "/user_groups/{user_group_id}/members".sub("{" + "user_group_id" + "}", URI.encode(user_group_id.to_s))

      # query parameters
      query_params = Hash(String, String).new
      query_params["delete"] = @api_client.build_collection_param(delete, :multi)
      query_params["add"] = @api_client.build_collection_param(add, :multi)

      # header parameters
      header_params = Hash(String, String).new
      # HTTP header "Accept" (if needed)
      header_params["Accept"] = @api_client.select_header_accept(["application/json"])

      # form parameters
      form_params = Hash(Symbol, String).new

      # http body (model)
      post_body = nil

      # return_type
      return_type = "JsonSuccess"

      # auth_names
      auth_names = [] of String

      data, status_code, headers = @api_client.call_api(:POST,
                                                        local_var_path,
                                                        :"UsersApi.update_user_group_members",
                                                        return_type,
                                                        post_body,
                                                        auth_names,
                                                        header_params,
                                                        query_params,
                                                        form_params)
      if @api_client.config.debugging
        Log.debug {"API called: UsersApi#update_user_group_members\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"}
      end
      return JsonSuccess.from_json(data), status_code, headers
    end
  end
end
