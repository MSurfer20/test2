/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// A MessagesApiController binds http requests to an api service and writes the service results to the http response
type MessagesApiController struct {
	service MessagesApiServicer
}

// NewMessagesApiController creates a default api controller
func NewMessagesApiController(s MessagesApiServicer) Router {
	return &MessagesApiController{service: s}
}

// Routes returns all of the api route for the MessagesApiController
func (c *MessagesApiController) Routes() Routes {
	return Routes{ 
		{
			"AddReaction",
			strings.ToUpper("Post"),
			"/api/v1/messages/{message_id}/reactions",
			c.AddReaction,
		},
		{
			"CheckMessagesMatchNarrow",
			strings.ToUpper("Get"),
			"/api/v1/messages/matches_narrow",
			c.CheckMessagesMatchNarrow,
		},
		{
			"DeleteMessage",
			strings.ToUpper("Delete"),
			"/api/v1/messages/{message_id}",
			c.DeleteMessage,
		},
		{
			"GetFileTemporaryUrl",
			strings.ToUpper("Get"),
			"/api/v1/user_uploads/{realm_id_str}/{filename}",
			c.GetFileTemporaryUrl,
		},
		{
			"GetMessageHistory",
			strings.ToUpper("Get"),
			"/api/v1/messages/{message_id}/history",
			c.GetMessageHistory,
		},
		{
			"GetMessages",
			strings.ToUpper("Get"),
			"/api/v1/messages",
			c.GetMessages,
		},
		{
			"GetRawMessage",
			strings.ToUpper("Get"),
			"/api/v1/messages/{message_id}",
			c.GetRawMessage,
		},
		{
			"MarkAllAsRead",
			strings.ToUpper("Post"),
			"/api/v1/mark_all_as_read",
			c.MarkAllAsRead,
		},
		{
			"MarkStreamAsRead",
			strings.ToUpper("Post"),
			"/api/v1/mark_stream_as_read",
			c.MarkStreamAsRead,
		},
		{
			"MarkTopicAsRead",
			strings.ToUpper("Post"),
			"/api/v1/mark_topic_as_read",
			c.MarkTopicAsRead,
		},
		{
			"RemoveReaction",
			strings.ToUpper("Delete"),
			"/api/v1/messages/{message_id}/reactions",
			c.RemoveReaction,
		},
		{
			"RenderMessage",
			strings.ToUpper("Post"),
			"/api/v1/messages/render",
			c.RenderMessage,
		},
		{
			"SendMessage",
			strings.ToUpper("Post"),
			"/api/v1/messages",
			c.SendMessage,
		},
		{
			"UpdateMessage",
			strings.ToUpper("Patch"),
			"/api/v1/messages/{message_id}",
			c.UpdateMessage,
		},
		{
			"UpdateMessageFlags",
			strings.ToUpper("Post"),
			"/api/v1/messages/flags",
			c.UpdateMessageFlags,
		},
		{
			"UploadFile",
			strings.ToUpper("Post"),
			"/api/v1/user_uploads",
			c.UploadFile,
		},
	}
}

// AddReaction - Add an emoji reaction
func (c *MessagesApiController) AddReaction(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	messageId, err := parseInt32Parameter(params["message_id"], true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	emojiName := query.Get("emoji_name")
	emojiCode := query.Get("emoji_code")
	reactionType := query.Get("reaction_type")
	result, err := c.service.AddReaction(r.Context(), messageId, emojiName, emojiCode, reactionType)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// CheckMessagesMatchNarrow - Check if messages match a narrow
func (c *MessagesApiController) CheckMessagesMatchNarrow(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	msgIds := strings.Split(query.Get("msg_ids"), ",")
	narrow := strings.Split(query.Get("narrow"), ",")
	result, err := c.service.CheckMessagesMatchNarrow(r.Context(), msgIds, narrow)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// DeleteMessage - Delete a message
func (c *MessagesApiController) DeleteMessage(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	messageId, err := parseInt32Parameter(params["message_id"], true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	result, err := c.service.DeleteMessage(r.Context(), messageId)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// GetFileTemporaryUrl - Get public temporary URL
func (c *MessagesApiController) GetFileTemporaryUrl(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	realmIdStr, err := parseInt32Parameter(params["realm_id_str"], true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	filename := params["filename"]
	
	result, err := c.service.GetFileTemporaryUrl(r.Context(), realmIdStr, filename)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// GetMessageHistory - Get a message's edit history
func (c *MessagesApiController) GetMessageHistory(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	messageId, err := parseInt32Parameter(params["message_id"], true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	result, err := c.service.GetMessageHistory(r.Context(), messageId)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// GetMessages - Get messages
func (c *MessagesApiController) GetMessages(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	numBefore, err := parseInt32Parameter(query.Get("num_before"), true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	numAfter, err := parseInt32Parameter(query.Get("num_after"), true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	anchor := query.Get("anchor")
	narrow := strings.Split(query.Get("narrow"), ",")
	clientGravatar, err := parseBoolParameter(query.Get("client_gravatar"))
	if err != nil {
		w.WriteHeader(500)
		return
	}
	applyMarkdown, err := parseBoolParameter(query.Get("apply_markdown"))
	if err != nil {
		w.WriteHeader(500)
		return
	}
	useFirstUnreadAnchor, err := parseBoolParameter(query.Get("use_first_unread_anchor"))
	if err != nil {
		w.WriteHeader(500)
		return
	}
	result, err := c.service.GetMessages(r.Context(), numBefore, numAfter, anchor, narrow, clientGravatar, applyMarkdown, useFirstUnreadAnchor)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// GetRawMessage - Get a message's raw Markdown
func (c *MessagesApiController) GetRawMessage(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	messageId, err := parseInt32Parameter(params["message_id"], true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	result, err := c.service.GetRawMessage(r.Context(), messageId)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// MarkAllAsRead - Mark all messages as read
func (c *MessagesApiController) MarkAllAsRead(w http.ResponseWriter, r *http.Request) {
	result, err := c.service.MarkAllAsRead(r.Context())
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// MarkStreamAsRead - Mark messages in a stream as read
func (c *MessagesApiController) MarkStreamAsRead(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	streamId, err := parseInt32Parameter(query.Get("stream_id"), true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	result, err := c.service.MarkStreamAsRead(r.Context(), streamId)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// MarkTopicAsRead - Mark messages in a topic as read
func (c *MessagesApiController) MarkTopicAsRead(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	streamId, err := parseInt32Parameter(query.Get("stream_id"), true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	topicName := query.Get("topic_name")
	result, err := c.service.MarkTopicAsRead(r.Context(), streamId, topicName)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// RemoveReaction - Remove an emoji reaction
func (c *MessagesApiController) RemoveReaction(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	messageId, err := parseInt32Parameter(params["message_id"], true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	emojiName := query.Get("emoji_name")
	emojiCode := query.Get("emoji_code")
	reactionType := query.Get("reaction_type")
	result, err := c.service.RemoveReaction(r.Context(), messageId, emojiName, emojiCode, reactionType)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// RenderMessage - Render message
func (c *MessagesApiController) RenderMessage(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	content := query.Get("content")
	result, err := c.service.RenderMessage(r.Context(), content)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// SendMessage - Send a message
func (c *MessagesApiController) SendMessage(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	type_ := query.Get("type")
	to := strings.Split(query.Get("to"), ",")
	content := query.Get("content")
	topic := query.Get("topic")
	queueId := query.Get("queue_id")
	localId := query.Get("local_id")
	result, err := c.service.SendMessage(r.Context(), type_, to, content, topic, queueId, localId)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// UpdateMessage - Edit a message
func (c *MessagesApiController) UpdateMessage(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	messageId, err := parseInt32Parameter(params["message_id"], true)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	topic := query.Get("topic")
	propagateMode := query.Get("propagate_mode")
	sendNotificationToOldThread, err := parseBoolParameter(query.Get("send_notification_to_old_thread"))
	if err != nil {
		w.WriteHeader(500)
		return
	}
	sendNotificationToNewThread, err := parseBoolParameter(query.Get("send_notification_to_new_thread"))
	if err != nil {
		w.WriteHeader(500)
		return
	}
	content := query.Get("content")
	streamId, err := parseInt32Parameter(query.Get("stream_id"), false)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	result, err := c.service.UpdateMessage(r.Context(), messageId, topic, propagateMode, sendNotificationToOldThread, sendNotificationToNewThread, content, streamId)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// UpdateMessageFlags - Update personal message flags
func (c *MessagesApiController) UpdateMessageFlags(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	messages := strings.Split(query.Get("messages"), ",")
	op := query.Get("op")
	flag := query.Get("flag")
	result, err := c.service.UpdateMessageFlags(r.Context(), messages, op, flag)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}

// UploadFile - Upload a file
func (c *MessagesApiController) UploadFile(w http.ResponseWriter, r *http.Request) {
	if err := r.ParseMultipartForm(32 << 20); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	
	filename, err := ReadFormFileToTempFile(r, "filename")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
			result, err := c.service.UploadFile(r.Context(), filename)
	// If an error occurred, encode the error with the status code
	if err != nil {
		EncodeJSONResponse(err.Error(), &result.Code, w)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)

}
