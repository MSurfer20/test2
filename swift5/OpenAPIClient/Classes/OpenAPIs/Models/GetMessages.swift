//
// GetMessages.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct GetMessages: Codable, Hashable {

    public var avatarUrl: AnyCodable?
    public var client: AnyCodable?
    public var content: AnyCodable?
    public var contentType: AnyCodable?
    public var displayRecipient: AnyCodable?
    public var id: AnyCodable?
    public var isMeMessage: AnyCodable?
    public var reactions: AnyCodable?
    public var recipientId: AnyCodable?
    public var senderEmail: AnyCodable?
    public var senderFullName: AnyCodable?
    public var senderId: AnyCodable?
    public var senderRealmStr: AnyCodable?
    public var streamId: AnyCodable?
    public var subject: AnyCodable?
    public var topicLinks: AnyCodable?
    public var submessages: AnyCodable?
    public var timestamp: AnyCodable?
    public var type: AnyCodable?
    /** The user's [message flags][message-flags] for the message.  [message-flags]: /api/update-message-flags#available-flags  */
    public var flags: [String]?
    /** The UNIX timestamp for when the message was last edited, in UTC seconds.  */
    public var lastEditTimestamp: Int?
    /** Only present if keyword search was included among the narrow parameters. HTML content of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords.  */
    public var matchContent: String?
    /** Only present if keyword search was included among the narrow parameters. HTML-escaped topic of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords.  */
    public var matchSubject: String?

    public init(avatarUrl: AnyCodable? = nil, client: AnyCodable? = nil, content: AnyCodable? = nil, contentType: AnyCodable? = nil, displayRecipient: AnyCodable? = nil, id: AnyCodable? = nil, isMeMessage: AnyCodable? = nil, reactions: AnyCodable? = nil, recipientId: AnyCodable? = nil, senderEmail: AnyCodable? = nil, senderFullName: AnyCodable? = nil, senderId: AnyCodable? = nil, senderRealmStr: AnyCodable? = nil, streamId: AnyCodable? = nil, subject: AnyCodable? = nil, topicLinks: AnyCodable? = nil, submessages: AnyCodable? = nil, timestamp: AnyCodable? = nil, type: AnyCodable? = nil, flags: [String]? = nil, lastEditTimestamp: Int? = nil, matchContent: String? = nil, matchSubject: String? = nil) {
        self.avatarUrl = avatarUrl
        self.client = client
        self.content = content
        self.contentType = contentType
        self.displayRecipient = displayRecipient
        self.id = id
        self.isMeMessage = isMeMessage
        self.reactions = reactions
        self.recipientId = recipientId
        self.senderEmail = senderEmail
        self.senderFullName = senderFullName
        self.senderId = senderId
        self.senderRealmStr = senderRealmStr
        self.streamId = streamId
        self.subject = subject
        self.topicLinks = topicLinks
        self.submessages = submessages
        self.timestamp = timestamp
        self.type = type
        self.flags = flags
        self.lastEditTimestamp = lastEditTimestamp
        self.matchContent = matchContent
        self.matchSubject = matchSubject
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case avatarUrl = "avatar_url"
        case client
        case content
        case contentType = "content_type"
        case displayRecipient = "display_recipient"
        case id
        case isMeMessage = "is_me_message"
        case reactions
        case recipientId = "recipient_id"
        case senderEmail = "sender_email"
        case senderFullName = "sender_full_name"
        case senderId = "sender_id"
        case senderRealmStr = "sender_realm_str"
        case streamId = "stream_id"
        case subject
        case topicLinks = "topic_links"
        case submessages
        case timestamp
        case type
        case flags
        case lastEditTimestamp = "last_edit_timestamp"
        case matchContent = "match_content"
        case matchSubject = "match_subject"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(avatarUrl, forKey: .avatarUrl)
        try container.encodeIfPresent(client, forKey: .client)
        try container.encodeIfPresent(content, forKey: .content)
        try container.encodeIfPresent(contentType, forKey: .contentType)
        try container.encodeIfPresent(displayRecipient, forKey: .displayRecipient)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(isMeMessage, forKey: .isMeMessage)
        try container.encodeIfPresent(reactions, forKey: .reactions)
        try container.encodeIfPresent(recipientId, forKey: .recipientId)
        try container.encodeIfPresent(senderEmail, forKey: .senderEmail)
        try container.encodeIfPresent(senderFullName, forKey: .senderFullName)
        try container.encodeIfPresent(senderId, forKey: .senderId)
        try container.encodeIfPresent(senderRealmStr, forKey: .senderRealmStr)
        try container.encodeIfPresent(streamId, forKey: .streamId)
        try container.encodeIfPresent(subject, forKey: .subject)
        try container.encodeIfPresent(topicLinks, forKey: .topicLinks)
        try container.encodeIfPresent(submessages, forKey: .submessages)
        try container.encodeIfPresent(timestamp, forKey: .timestamp)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(flags, forKey: .flags)
        try container.encodeIfPresent(lastEditTimestamp, forKey: .lastEditTimestamp)
        try container.encodeIfPresent(matchContent, forKey: .matchContent)
        try container.encodeIfPresent(matchSubject, forKey: .matchSubject)
    }
}

