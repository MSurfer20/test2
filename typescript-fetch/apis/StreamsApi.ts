/* tslint:disable */
/* eslint-disable */
/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AddSubscriptionsResponse,
    AddSubscriptionsResponseFromJSON,
    AddSubscriptionsResponseToJSON,
    CodedError,
    CodedErrorFromJSON,
    CodedErrorToJSON,
    JsonError,
    JsonErrorFromJSON,
    JsonErrorToJSON,
    JsonSuccess,
    JsonSuccessFromJSON,
    JsonSuccessToJSON,
    JsonSuccessBase,
    JsonSuccessBaseFromJSON,
    JsonSuccessBaseToJSON,
    NonExistingStreamError,
    NonExistingStreamErrorFromJSON,
    NonExistingStreamErrorToJSON,
} from '../models';

export interface ArchiveStreamRequest {
    streamId: number;
}

export interface GetStreamIdRequest {
    stream: string;
}

export interface GetStreamTopicsRequest {
    streamId: number;
}

export interface GetStreamsRequest {
    includePublic?: boolean;
    includeWebPublic?: boolean;
    includeSubscribed?: boolean;
    includeAllActive?: boolean;
    includeDefault?: boolean;
    includeOwnerSubscribed?: boolean;
}

export interface GetSubscriptionStatusRequest {
    userId: number;
    streamId: number;
}

export interface GetSubscriptionsRequest {
    includeSubscribers?: boolean;
}

export interface MuteTopicRequest {
    topic: string;
    op: MuteTopicOpEnum;
    stream?: string;
    streamId?: number;
}

export interface SubscribeRequest {
    subscriptions: Array<object>;
    principals?: Array<string | number>;
    authorizationErrorsFatal?: boolean;
    announce?: boolean;
    inviteOnly?: boolean;
    historyPublicToSubscribers?: boolean;
    streamPostPolicy?: number;
    messageRetentionDays?: string | number;
}

export interface UnsubscribeRequest {
    subscriptions: Array<string>;
    principals?: Array<string | number>;
}

export interface UpdateStreamRequest {
    streamId: number;
    description?: string;
    newName?: string;
    isPrivate?: boolean;
    isAnnouncementOnly?: boolean;
    streamPostPolicy?: number;
    historyPublicToSubscribers?: boolean;
    messageRetentionDays?: string | number;
}

export interface UpdateSubscriptionSettingsRequest {
    subscriptionData: Array<object>;
}

export interface UpdateSubscriptionsRequest {
    _delete?: Array<string>;
    add?: Array<object>;
}

/**
 * 
 */
export class StreamsApi extends runtime.BaseAPI {

    /**
     * [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
     * Archive a stream
     */
    async archiveStreamRaw(requestParameters: ArchiveStreamRequest): Promise<runtime.ApiResponse<JsonSuccess>> {
        if (requestParameters.streamId === null || requestParameters.streamId === undefined) {
            throw new runtime.RequiredError('streamId','Required parameter requestParameters.streamId was null or undefined when calling archiveStream.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/streams/{stream_id}`.replace(`{${"stream_id"}}`, encodeURIComponent(String(requestParameters.streamId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessFromJSON(jsonValue));
    }

    /**
     * [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
     * Archive a stream
     */
    async archiveStream(requestParameters: ArchiveStreamRequest): Promise<JsonSuccess> {
        const response = await this.archiveStreamRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
     * Create BigBlueButton video call
     */
    async createBigBlueButtonVideoCallRaw(): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/calls/bigbluebutton/create`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
     * Create BigBlueButton video call
     */
    async createBigBlueButtonVideoCall(): Promise<JsonSuccessBase & object> {
        const response = await this.createBigBlueButtonVideoCallRaw();
        return await response.value();
    }

    /**
     * Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
     * Get stream ID
     */
    async getStreamIdRaw(requestParameters: GetStreamIdRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        if (requestParameters.stream === null || requestParameters.stream === undefined) {
            throw new runtime.RequiredError('stream','Required parameter requestParameters.stream was null or undefined when calling getStreamId.');
        }

        const queryParameters: any = {};

        if (requestParameters.stream !== undefined) {
            queryParameters['stream'] = requestParameters.stream;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/get_stream_id`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
     * Get stream ID
     */
    async getStreamId(requestParameters: GetStreamIdRequest): Promise<JsonSuccessBase & object> {
        const response = await this.getStreamIdRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
     * Get topics in a stream
     */
    async getStreamTopicsRaw(requestParameters: GetStreamTopicsRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        if (requestParameters.streamId === null || requestParameters.streamId === undefined) {
            throw new runtime.RequiredError('streamId','Required parameter requestParameters.streamId was null or undefined when calling getStreamTopics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/me/{stream_id}/topics`.replace(`{${"stream_id"}}`, encodeURIComponent(String(requestParameters.streamId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
     * Get topics in a stream
     */
    async getStreamTopics(requestParameters: GetStreamTopicsRequest): Promise<JsonSuccessBase & object> {
        const response = await this.getStreamTopicsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
     * Get all streams
     */
    async getStreamsRaw(requestParameters: GetStreamsRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        const queryParameters: any = {};

        if (requestParameters.includePublic !== undefined) {
            queryParameters['include_public'] = requestParameters.includePublic;
        }

        if (requestParameters.includeWebPublic !== undefined) {
            queryParameters['include_web_public'] = requestParameters.includeWebPublic;
        }

        if (requestParameters.includeSubscribed !== undefined) {
            queryParameters['include_subscribed'] = requestParameters.includeSubscribed;
        }

        if (requestParameters.includeAllActive !== undefined) {
            queryParameters['include_all_active'] = requestParameters.includeAllActive;
        }

        if (requestParameters.includeDefault !== undefined) {
            queryParameters['include_default'] = requestParameters.includeDefault;
        }

        if (requestParameters.includeOwnerSubscribed !== undefined) {
            queryParameters['include_owner_subscribed'] = requestParameters.includeOwnerSubscribed;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/streams`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
     * Get all streams
     */
    async getStreams(requestParameters: GetStreamsRequest): Promise<JsonSuccessBase & object> {
        const response = await this.getStreamsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
     * Get subscription status
     */
    async getSubscriptionStatusRaw(requestParameters: GetSubscriptionStatusRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getSubscriptionStatus.');
        }

        if (requestParameters.streamId === null || requestParameters.streamId === undefined) {
            throw new runtime.RequiredError('streamId','Required parameter requestParameters.streamId was null or undefined when calling getSubscriptionStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{user_id}/subscriptions/{stream_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"stream_id"}}`, encodeURIComponent(String(requestParameters.streamId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
     * Get subscription status
     */
    async getSubscriptionStatus(requestParameters: GetSubscriptionStatusRequest): Promise<JsonSuccessBase & object> {
        const response = await this.getSubscriptionStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
     * Get subscribed streams
     */
    async getSubscriptionsRaw(requestParameters: GetSubscriptionsRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        const queryParameters: any = {};

        if (requestParameters.includeSubscribers !== undefined) {
            queryParameters['include_subscribers'] = requestParameters.includeSubscribers;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/me/subscriptions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
     * Get subscribed streams
     */
    async getSubscriptions(requestParameters: GetSubscriptionsRequest): Promise<JsonSuccessBase & object> {
        const response = await this.getSubscriptionsRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user\'s unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
     * Topic muting
     */
    async muteTopicRaw(requestParameters: MuteTopicRequest): Promise<runtime.ApiResponse<JsonSuccess>> {
        if (requestParameters.topic === null || requestParameters.topic === undefined) {
            throw new runtime.RequiredError('topic','Required parameter requestParameters.topic was null or undefined when calling muteTopic.');
        }

        if (requestParameters.op === null || requestParameters.op === undefined) {
            throw new runtime.RequiredError('op','Required parameter requestParameters.op was null or undefined when calling muteTopic.');
        }

        const queryParameters: any = {};

        if (requestParameters.stream !== undefined) {
            queryParameters['stream'] = requestParameters.stream;
        }

        if (requestParameters.streamId !== undefined) {
            queryParameters['stream_id'] = requestParameters.streamId;
        }

        if (requestParameters.topic !== undefined) {
            queryParameters['topic'] = requestParameters.topic;
        }

        if (requestParameters.op !== undefined) {
            queryParameters['op'] = requestParameters.op;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/me/subscriptions/muted_topics`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessFromJSON(jsonValue));
    }

    /**
     * This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user\'s unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
     * Topic muting
     */
    async muteTopic(requestParameters: MuteTopicRequest): Promise<JsonSuccess> {
        const response = await this.muteTopicRaw(requestParameters);
        return await response.value();
    }

    /**
     * Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
     * Subscribe to a stream
     */
    async subscribeRaw(requestParameters: SubscribeRequest): Promise<runtime.ApiResponse<AddSubscriptionsResponse>> {
        if (requestParameters.subscriptions === null || requestParameters.subscriptions === undefined) {
            throw new runtime.RequiredError('subscriptions','Required parameter requestParameters.subscriptions was null or undefined when calling subscribe.');
        }

        const queryParameters: any = {};

        if (requestParameters.subscriptions) {
            queryParameters['subscriptions'] = requestParameters.subscriptions;
        }

        if (requestParameters.principals) {
            queryParameters['principals'] = requestParameters.principals;
        }

        if (requestParameters.authorizationErrorsFatal !== undefined) {
            queryParameters['authorization_errors_fatal'] = requestParameters.authorizationErrorsFatal;
        }

        if (requestParameters.announce !== undefined) {
            queryParameters['announce'] = requestParameters.announce;
        }

        if (requestParameters.inviteOnly !== undefined) {
            queryParameters['invite_only'] = requestParameters.inviteOnly;
        }

        if (requestParameters.historyPublicToSubscribers !== undefined) {
            queryParameters['history_public_to_subscribers'] = requestParameters.historyPublicToSubscribers;
        }

        if (requestParameters.streamPostPolicy !== undefined) {
            queryParameters['stream_post_policy'] = requestParameters.streamPostPolicy;
        }

        if (requestParameters.messageRetentionDays !== undefined) {
            queryParameters['message_retention_days'] = requestParameters.messageRetentionDays;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/me/subscriptions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AddSubscriptionsResponseFromJSON(jsonValue));
    }

    /**
     * Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
     * Subscribe to a stream
     */
    async subscribe(requestParameters: SubscribeRequest): Promise<AddSubscriptionsResponse> {
        const response = await this.subscribeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
     * Unsubscribe from a stream
     */
    async unsubscribeRaw(requestParameters: UnsubscribeRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        if (requestParameters.subscriptions === null || requestParameters.subscriptions === undefined) {
            throw new runtime.RequiredError('subscriptions','Required parameter requestParameters.subscriptions was null or undefined when calling unsubscribe.');
        }

        const queryParameters: any = {};

        if (requestParameters.subscriptions) {
            queryParameters['subscriptions'] = requestParameters.subscriptions;
        }

        if (requestParameters.principals) {
            queryParameters['principals'] = requestParameters.principals;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/me/subscriptions`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
     * Unsubscribe from a stream
     */
    async unsubscribe(requestParameters: UnsubscribeRequest): Promise<JsonSuccessBase & object> {
        const response = await this.unsubscribeRaw(requestParameters);
        return await response.value();
    }

    /**
     * Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
     * Update a stream
     */
    async updateStreamRaw(requestParameters: UpdateStreamRequest): Promise<runtime.ApiResponse<JsonSuccess>> {
        if (requestParameters.streamId === null || requestParameters.streamId === undefined) {
            throw new runtime.RequiredError('streamId','Required parameter requestParameters.streamId was null or undefined when calling updateStream.');
        }

        const queryParameters: any = {};

        if (requestParameters.description !== undefined) {
            queryParameters['description'] = requestParameters.description;
        }

        if (requestParameters.newName !== undefined) {
            queryParameters['new_name'] = requestParameters.newName;
        }

        if (requestParameters.isPrivate !== undefined) {
            queryParameters['is_private'] = requestParameters.isPrivate;
        }

        if (requestParameters.isAnnouncementOnly !== undefined) {
            queryParameters['is_announcement_only'] = requestParameters.isAnnouncementOnly;
        }

        if (requestParameters.streamPostPolicy !== undefined) {
            queryParameters['stream_post_policy'] = requestParameters.streamPostPolicy;
        }

        if (requestParameters.historyPublicToSubscribers !== undefined) {
            queryParameters['history_public_to_subscribers'] = requestParameters.historyPublicToSubscribers;
        }

        if (requestParameters.messageRetentionDays !== undefined) {
            queryParameters['message_retention_days'] = requestParameters.messageRetentionDays;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/streams/{stream_id}`.replace(`{${"stream_id"}}`, encodeURIComponent(String(requestParameters.streamId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessFromJSON(jsonValue));
    }

    /**
     * Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
     * Update a stream
     */
    async updateStream(requestParameters: UpdateStreamRequest): Promise<JsonSuccess> {
        const response = await this.updateStreamRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint is used to update the user\'s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
     * Update subscription settings
     */
    async updateSubscriptionSettingsRaw(requestParameters: UpdateSubscriptionSettingsRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        if (requestParameters.subscriptionData === null || requestParameters.subscriptionData === undefined) {
            throw new runtime.RequiredError('subscriptionData','Required parameter requestParameters.subscriptionData was null or undefined when calling updateSubscriptionSettings.');
        }

        const queryParameters: any = {};

        if (requestParameters.subscriptionData) {
            queryParameters['subscription_data'] = requestParameters.subscriptionData;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/me/subscriptions/properties`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * This endpoint is used to update the user\'s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
     * Update subscription settings
     */
    async updateSubscriptionSettings(requestParameters: UpdateSubscriptionSettingsRequest): Promise<JsonSuccessBase & object> {
        const response = await this.updateSubscriptionSettingsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update which streams you are are subscribed to. 
     * Update subscriptions
     */
    async updateSubscriptionsRaw(requestParameters: UpdateSubscriptionsRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        const queryParameters: any = {};

        if (requestParameters._delete) {
            queryParameters['delete'] = requestParameters._delete;
        }

        if (requestParameters.add) {
            queryParameters['add'] = requestParameters.add;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/me/subscriptions`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Update which streams you are are subscribed to. 
     * Update subscriptions
     */
    async updateSubscriptions(requestParameters: UpdateSubscriptionsRequest): Promise<JsonSuccessBase & object> {
        const response = await this.updateSubscriptionsRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum MuteTopicOpEnum {
    Add = 'add',
    Remove = 'remove'
}
