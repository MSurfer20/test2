/* tslint:disable */
/* eslint-disable */
/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    JsonSuccess,
    JsonSuccessFromJSON,
    JsonSuccessToJSON,
    JsonSuccessBase,
    JsonSuccessBaseFromJSON,
    JsonSuccessBaseToJSON,
} from '../models';

export interface AddCodePlaygroundRequest {
    name: string;
    pygmentsLanguage: string;
    urlPrefix: string;
}

export interface AddLinkifierRequest {
    pattern: string;
    urlFormatString: string;
}

export interface CreateCustomProfileFieldRequest {
    fieldType: number;
    name?: string;
    hint?: string;
    fieldData?: object;
}

export interface RemoveCodePlaygroundRequest {
    playgroundId: number;
}

export interface RemoveLinkifierRequest {
    filterId: number;
}

export interface ReorderCustomProfileFieldsRequest {
    order: Array<number>;
}

export interface UpdateLinkifierRequest {
    filterId: number;
    pattern: string;
    urlFormatString: string;
}

export interface UploadCustomEmojiRequest {
    emojiName: string;
    filename?: Blob;
}

/**
 * 
 */
export class ServerAndOrganizationsApi extends runtime.BaseAPI {

    /**
     * Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  `POST {{ api_url }}/v1/realm/playgrounds`  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
     * Add a code playground
     */
    async addCodePlaygroundRaw(requestParameters: AddCodePlaygroundRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling addCodePlayground.');
        }

        if (requestParameters.pygmentsLanguage === null || requestParameters.pygmentsLanguage === undefined) {
            throw new runtime.RequiredError('pygmentsLanguage','Required parameter requestParameters.pygmentsLanguage was null or undefined when calling addCodePlayground.');
        }

        if (requestParameters.urlPrefix === null || requestParameters.urlPrefix === undefined) {
            throw new runtime.RequiredError('urlPrefix','Required parameter requestParameters.urlPrefix was null or undefined when calling addCodePlayground.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.pygmentsLanguage !== undefined) {
            queryParameters['pygments_language'] = requestParameters.pygmentsLanguage;
        }

        if (requestParameters.urlPrefix !== undefined) {
            queryParameters['url_prefix'] = requestParameters.urlPrefix;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/realm/playgrounds`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  `POST {{ api_url }}/v1/realm/playgrounds`  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
     * Add a code playground
     */
    async addCodePlayground(requestParameters: AddCodePlaygroundRequest): Promise<JsonSuccessBase & object> {
        const response = await this.addCodePlaygroundRaw(requestParameters);
        return await response.value();
    }

    /**
     * Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `POST {{ api_url }}/v1/realm/filters` 
     * Add a linkifier
     */
    async addLinkifierRaw(requestParameters: AddLinkifierRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        if (requestParameters.pattern === null || requestParameters.pattern === undefined) {
            throw new runtime.RequiredError('pattern','Required parameter requestParameters.pattern was null or undefined when calling addLinkifier.');
        }

        if (requestParameters.urlFormatString === null || requestParameters.urlFormatString === undefined) {
            throw new runtime.RequiredError('urlFormatString','Required parameter requestParameters.urlFormatString was null or undefined when calling addLinkifier.');
        }

        const queryParameters: any = {};

        if (requestParameters.pattern !== undefined) {
            queryParameters['pattern'] = requestParameters.pattern;
        }

        if (requestParameters.urlFormatString !== undefined) {
            queryParameters['url_format_string'] = requestParameters.urlFormatString;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/realm/filters`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `POST {{ api_url }}/v1/realm/filters` 
     * Add a linkifier
     */
    async addLinkifier(requestParameters: AddLinkifierRequest): Promise<JsonSuccessBase & object> {
        const response = await this.addLinkifierRaw(requestParameters);
        return await response.value();
    }

    /**
     * [Create a custom profile field](/help/add-custom-profile-fields) in the user\'s organization.  `POST {{ api_url }}/v1/realm/profile_fields` 
     * Create a custom profile field
     */
    async createCustomProfileFieldRaw(requestParameters: CreateCustomProfileFieldRequest): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        if (requestParameters.fieldType === null || requestParameters.fieldType === undefined) {
            throw new runtime.RequiredError('fieldType','Required parameter requestParameters.fieldType was null or undefined when calling createCustomProfileField.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.hint !== undefined) {
            queryParameters['hint'] = requestParameters.hint;
        }

        if (requestParameters.fieldType !== undefined) {
            queryParameters['field_type'] = requestParameters.fieldType;
        }

        if (requestParameters.fieldData !== undefined) {
            queryParameters['field_data'] = requestParameters.fieldData;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/realm/profile_fields`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * [Create a custom profile field](/help/add-custom-profile-fields) in the user\'s organization.  `POST {{ api_url }}/v1/realm/profile_fields` 
     * Create a custom profile field
     */
    async createCustomProfileField(requestParameters: CreateCustomProfileFieldRequest): Promise<JsonSuccessBase & object> {
        const response = await this.createCustomProfileFieldRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all the custom emoji in the user\'s organization.  `GET {{ api_url }}/v1/realm/emoji` 
     * Get all custom emoji
     */
    async getCustomEmojiRaw(): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/realm/emoji`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Get all the custom emoji in the user\'s organization.  `GET {{ api_url }}/v1/realm/emoji` 
     * Get all custom emoji
     */
    async getCustomEmoji(): Promise<JsonSuccessBase & object> {
        const response = await this.getCustomEmojiRaw();
        return await response.value();
    }

    /**
     * Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user\'s organization.  `GET {{ api_url }}/v1/realm/profile_fields` 
     * Get all custom profile fields
     */
    async getCustomProfileFieldsRaw(): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/realm/profile_fields`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user\'s organization.  `GET {{ api_url }}/v1/realm/profile_fields` 
     * Get all custom profile fields
     */
    async getCustomProfileFields(): Promise<JsonSuccessBase & object> {
        const response = await this.getCustomProfileFieldsRaw();
        return await response.value();
    }

    /**
     * List all of an organization\'s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `GET {{ api_url }}/v1/realm/linkifiers`  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar `GET /realm/filters` endpoint was available with each entry in a `[pattern, url_format, id]` tuple format. 
     * Get linkifiers
     */
    async getLinkifiersRaw(): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/realm/linkifiers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * List all of an organization\'s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `GET {{ api_url }}/v1/realm/linkifiers`  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar `GET /realm/filters` endpoint was available with each entry in a `[pattern, url_format, id]` tuple format. 
     * Get linkifiers
     */
    async getLinkifiers(): Promise<JsonSuccessBase & object> {
        const response = await this.getLinkifiersRaw();
        return await response.value();
    }

    /**
     * Fetch global settings for a Zulip server.  `GET {{ api_url }}/v1/server_settings`  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it\'s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
     * Get server settings
     */
    async getServerSettingsRaw(): Promise<runtime.ApiResponse<JsonSuccessBase & object>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/server_settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessBase &amp; objectFromJSON(jsonValue));
    }

    /**
     * Fetch global settings for a Zulip server.  `GET {{ api_url }}/v1/server_settings`  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it\'s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
     * Get server settings
     */
    async getServerSettings(): Promise<JsonSuccessBase & object> {
        const response = await this.getServerSettingsRaw();
        return await response.value();
    }

    /**
     * Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  `DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}`  **Changes**: New in Zulip 4.0 (feature level 49). 
     * Remove a code playground
     */
    async removeCodePlaygroundRaw(requestParameters: RemoveCodePlaygroundRequest): Promise<runtime.ApiResponse<JsonSuccess>> {
        if (requestParameters.playgroundId === null || requestParameters.playgroundId === undefined) {
            throw new runtime.RequiredError('playgroundId','Required parameter requestParameters.playgroundId was null or undefined when calling removeCodePlayground.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/realm/playgrounds/{playground_id}`.replace(`{${"playground_id"}}`, encodeURIComponent(String(requestParameters.playgroundId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessFromJSON(jsonValue));
    }

    /**
     * Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  `DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}`  **Changes**: New in Zulip 4.0 (feature level 49). 
     * Remove a code playground
     */
    async removeCodePlayground(requestParameters: RemoveCodePlaygroundRequest): Promise<JsonSuccess> {
        const response = await this.removeCodePlaygroundRaw(requestParameters);
        return await response.value();
    }

    /**
     * Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `DELETE {{ api_url }}/v1/realm/filters/{filter_id}` 
     * Remove a linkifier
     */
    async removeLinkifierRaw(requestParameters: RemoveLinkifierRequest): Promise<runtime.ApiResponse<JsonSuccess>> {
        if (requestParameters.filterId === null || requestParameters.filterId === undefined) {
            throw new runtime.RequiredError('filterId','Required parameter requestParameters.filterId was null or undefined when calling removeLinkifier.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/realm/filters/{filter_id}`.replace(`{${"filter_id"}}`, encodeURIComponent(String(requestParameters.filterId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessFromJSON(jsonValue));
    }

    /**
     * Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `DELETE {{ api_url }}/v1/realm/filters/{filter_id}` 
     * Remove a linkifier
     */
    async removeLinkifier(requestParameters: RemoveLinkifierRequest): Promise<JsonSuccess> {
        const response = await this.removeLinkifierRaw(requestParameters);
        return await response.value();
    }

    /**
     * Reorder the custom profile fields in the user\'s organization.  `PATCH {{ api_url }}/v1/realm/profile_fields`  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
     * Reorder custom profile fields
     */
    async reorderCustomProfileFieldsRaw(requestParameters: ReorderCustomProfileFieldsRequest): Promise<runtime.ApiResponse<JsonSuccess>> {
        if (requestParameters.order === null || requestParameters.order === undefined) {
            throw new runtime.RequiredError('order','Required parameter requestParameters.order was null or undefined when calling reorderCustomProfileFields.');
        }

        const queryParameters: any = {};

        if (requestParameters.order) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/realm/profile_fields`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessFromJSON(jsonValue));
    }

    /**
     * Reorder the custom profile fields in the user\'s organization.  `PATCH {{ api_url }}/v1/realm/profile_fields`  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
     * Reorder custom profile fields
     */
    async reorderCustomProfileFields(requestParameters: ReorderCustomProfileFieldsRequest): Promise<JsonSuccess> {
        const response = await this.reorderCustomProfileFieldsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `PATCH {{ api_url }}/v1/realm/filters/{filter_id}`  **Changes**: New in Zulip 4.0 (feature level 57). 
     * Update a linkifier
     */
    async updateLinkifierRaw(requestParameters: UpdateLinkifierRequest): Promise<runtime.ApiResponse<JsonSuccess>> {
        if (requestParameters.filterId === null || requestParameters.filterId === undefined) {
            throw new runtime.RequiredError('filterId','Required parameter requestParameters.filterId was null or undefined when calling updateLinkifier.');
        }

        if (requestParameters.pattern === null || requestParameters.pattern === undefined) {
            throw new runtime.RequiredError('pattern','Required parameter requestParameters.pattern was null or undefined when calling updateLinkifier.');
        }

        if (requestParameters.urlFormatString === null || requestParameters.urlFormatString === undefined) {
            throw new runtime.RequiredError('urlFormatString','Required parameter requestParameters.urlFormatString was null or undefined when calling updateLinkifier.');
        }

        const queryParameters: any = {};

        if (requestParameters.pattern !== undefined) {
            queryParameters['pattern'] = requestParameters.pattern;
        }

        if (requestParameters.urlFormatString !== undefined) {
            queryParameters['url_format_string'] = requestParameters.urlFormatString;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/realm/filters/{filter_id}`.replace(`{${"filter_id"}}`, encodeURIComponent(String(requestParameters.filterId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessFromJSON(jsonValue));
    }

    /**
     * Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `PATCH {{ api_url }}/v1/realm/filters/{filter_id}`  **Changes**: New in Zulip 4.0 (feature level 57). 
     * Update a linkifier
     */
    async updateLinkifier(requestParameters: UpdateLinkifierRequest): Promise<JsonSuccess> {
        const response = await this.updateLinkifierRaw(requestParameters);
        return await response.value();
    }

    /**
     * This endpoint is used to upload a custom emoji for use in the user\'s organization.  Access to this endpoint depends on the [organization\'s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  `POST {{ api_url }}/v1/realm/emoji/{emoji_name}` 
     * Upload custom emoji
     */
    async uploadCustomEmojiRaw(requestParameters: UploadCustomEmojiRequest): Promise<runtime.ApiResponse<JsonSuccess>> {
        if (requestParameters.emojiName === null || requestParameters.emojiName === undefined) {
            throw new runtime.RequiredError('emojiName','Required parameter requestParameters.emojiName was null or undefined when calling uploadCustomEmoji.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.filename !== undefined) {
            formParams.append('filename', requestParameters.filename as any);
        }

        const response = await this.request({
            path: `/realm/emoji/{emoji_name}`.replace(`{${"emoji_name"}}`, encodeURIComponent(String(requestParameters.emojiName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => JsonSuccessFromJSON(jsonValue));
    }

    /**
     * This endpoint is used to upload a custom emoji for use in the user\'s organization.  Access to this endpoint depends on the [organization\'s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  `POST {{ api_url }}/v1/realm/emoji/{emoji_name}` 
     * Upload custom emoji
     */
    async uploadCustomEmoji(requestParameters: UploadCustomEmojiRequest): Promise<JsonSuccess> {
        const response = await this.uploadCustomEmojiRaw(requestParameters);
        return await response.value();
    }

}
