/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */

using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Org.OpenAPITools.Converters;

namespace Org.OpenAPITools.Models
{ 
    /// <summary>
    /// Object containing details of the message. 
    /// </summary>
    [DataContract]
    public partial class MessagesBase : IEquatable<MessagesBase>
    {
        /// <summary>
        /// The URL of the user&#39;s avatar.  Can be null only if client_gravatar was passed, which means that the user has not uploaded an avatar in Zulip, and the client should compute the gravatar URL by hashing the user&#39;s email address itself for this user. 
        /// </summary>
        /// <value>The URL of the user&#39;s avatar.  Can be null only if client_gravatar was passed, which means that the user has not uploaded an avatar in Zulip, and the client should compute the gravatar URL by hashing the user&#39;s email address itself for this user. </value>
        [DataMember(Name="avatar_url", EmitDefaultValue=true)]
        public string AvatarUrl { get; set; }

        /// <summary>
        /// A Zulip \&quot;client\&quot; string, describing what Zulip client sent the message. 
        /// </summary>
        /// <value>A Zulip \&quot;client\&quot; string, describing what Zulip client sent the message. </value>
        [DataMember(Name="client", EmitDefaultValue=false)]
        public string _Client { get; set; }

        /// <summary>
        /// The content/body of the message. 
        /// </summary>
        /// <value>The content/body of the message. </value>
        [DataMember(Name="content", EmitDefaultValue=false)]
        public string Content { get; set; }

        /// <summary>
        /// The HTTP &#x60;content_type&#x60; for the message content.  This will be &#x60;text/html&#x60; or &#x60;text/x-markdown&#x60;, depending on whether &#x60;apply_markdown&#x60; was set. 
        /// </summary>
        /// <value>The HTTP &#x60;content_type&#x60; for the message content.  This will be &#x60;text/html&#x60; or &#x60;text/x-markdown&#x60;, depending on whether &#x60;apply_markdown&#x60; was set. </value>
        [DataMember(Name="content_type", EmitDefaultValue=false)]
        public string ContentType { get; set; }

        /// <summary>
        /// Data on the recipient of the message; either the name of a stream or a dictionary containing basic data on the users who received the message. 
        /// </summary>
        /// <value>Data on the recipient of the message; either the name of a stream or a dictionary containing basic data on the users who received the message. </value>
        [DataMember(Name="display_recipient", EmitDefaultValue=false)]
        public OneOfstringarray DisplayRecipient { get; set; }

        /// <summary>
        /// The unique message ID.  Messages should always be displayed sorted by ID. 
        /// </summary>
        /// <value>The unique message ID.  Messages should always be displayed sorted by ID. </value>
        [DataMember(Name="id", EmitDefaultValue=false)]
        public int Id { get; set; }

        /// <summary>
        /// Whether the message is a [/me status message][status-messages]  [status-messages]: /help/format-your-message-using-markdown#status-messages 
        /// </summary>
        /// <value>Whether the message is a [/me status message][status-messages]  [status-messages]: /help/format-your-message-using-markdown#status-messages </value>
        [DataMember(Name="is_me_message", EmitDefaultValue=false)]
        public bool IsMeMessage { get; set; }

        /// <summary>
        /// Data on any reactions to the message. 
        /// </summary>
        /// <value>Data on any reactions to the message. </value>
        [DataMember(Name="reactions", EmitDefaultValue=false)]
        public List<EmojiReaction> Reactions { get; set; }

        /// <summary>
        /// A unique ID for the set of users receiving the message (either a stream or group of users).  Useful primarily for hashing. 
        /// </summary>
        /// <value>A unique ID for the set of users receiving the message (either a stream or group of users).  Useful primarily for hashing. </value>
        [DataMember(Name="recipient_id", EmitDefaultValue=false)]
        public int RecipientId { get; set; }

        /// <summary>
        /// The Zulip display email address of the message&#39;s sender. 
        /// </summary>
        /// <value>The Zulip display email address of the message&#39;s sender. </value>
        [DataMember(Name="sender_email", EmitDefaultValue=false)]
        public string SenderEmail { get; set; }

        /// <summary>
        /// The full name of the message&#39;s sender. 
        /// </summary>
        /// <value>The full name of the message&#39;s sender. </value>
        [DataMember(Name="sender_full_name", EmitDefaultValue=false)]
        public string SenderFullName { get; set; }

        /// <summary>
        /// The user ID of the message&#39;s sender. 
        /// </summary>
        /// <value>The user ID of the message&#39;s sender. </value>
        [DataMember(Name="sender_id", EmitDefaultValue=false)]
        public int SenderId { get; set; }

        /// <summary>
        /// A string identifier for the realm the sender is in.  Unique only within the context of a given Zulip server.  E.g. on &#x60;example.zulip.com&#x60;, this will be &#x60;example&#x60;. 
        /// </summary>
        /// <value>A string identifier for the realm the sender is in.  Unique only within the context of a given Zulip server.  E.g. on &#x60;example.zulip.com&#x60;, this will be &#x60;example&#x60;. </value>
        [DataMember(Name="sender_realm_str", EmitDefaultValue=false)]
        public string SenderRealmStr { get; set; }

        /// <summary>
        /// Only present for stream messages; the ID of the stream. 
        /// </summary>
        /// <value>Only present for stream messages; the ID of the stream. </value>
        [DataMember(Name="stream_id", EmitDefaultValue=false)]
        public int StreamId { get; set; }

        /// <summary>
        /// The &#x60;topic&#x60; of the message.  Currently always &#x60;\&quot;\&quot;&#x60; for private messages, though this could change if Zulip adds support for topics in private message conversations.  The field name is a legacy holdover from when topics were called \&quot;subjects\&quot; and will eventually change. 
        /// </summary>
        /// <value>The &#x60;topic&#x60; of the message.  Currently always &#x60;\&quot;\&quot;&#x60; for private messages, though this could change if Zulip adds support for topics in private message conversations.  The field name is a legacy holdover from when topics were called \&quot;subjects\&quot; and will eventually change. </value>
        [DataMember(Name="subject", EmitDefaultValue=false)]
        public string Subject { get; set; }

        /// <summary>
        /// Data on any links to be included in the &#x60;topic&#x60; line (these are generated by [custom linkification filters](/help/add-a-custom-linkifier) that match content in the message&#39;s topic.)  **Changes**: This field contained a list of urls before   Zulip 4.0 (feature level 46).  New in Zulip 3.0 (feature level 1): Previously, this field was called &#x60;subject_links&#x60;; clients are recommended to rename &#x60;subject_links&#x60; to &#x60;topic_links&#x60; if present for compatibility with older Zulip servers. 
        /// </summary>
        /// <value>Data on any links to be included in the &#x60;topic&#x60; line (these are generated by [custom linkification filters](/help/add-a-custom-linkifier) that match content in the message&#39;s topic.)  **Changes**: This field contained a list of urls before   Zulip 4.0 (feature level 46).  New in Zulip 3.0 (feature level 1): Previously, this field was called &#x60;subject_links&#x60;; clients are recommended to rename &#x60;subject_links&#x60; to &#x60;topic_links&#x60; if present for compatibility with older Zulip servers. </value>
        [DataMember(Name="topic_links", EmitDefaultValue=false)]
        public List<MessagesBaseTopicLinks> TopicLinks { get; set; }

        /// <summary>
        /// Data used for certain experimental Zulip integrations. 
        /// </summary>
        /// <value>Data used for certain experimental Zulip integrations. </value>
        [DataMember(Name="submessages", EmitDefaultValue=false)]
        public List<string> Submessages { get; set; }

        /// <summary>
        /// The UNIX timestamp for when the message was sent, in UTC seconds. 
        /// </summary>
        /// <value>The UNIX timestamp for when the message was sent, in UTC seconds. </value>
        [DataMember(Name="timestamp", EmitDefaultValue=false)]
        public int Timestamp { get; set; }

        /// <summary>
        /// The type of the message: &#x60;stream&#x60; or &#x60;private&#x60;. 
        /// </summary>
        /// <value>The type of the message: &#x60;stream&#x60; or &#x60;private&#x60;. </value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public string Type { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class MessagesBase {\n");
            sb.Append("  AvatarUrl: ").Append(AvatarUrl).Append("\n");
            sb.Append("  _Client: ").Append(_Client).Append("\n");
            sb.Append("  Content: ").Append(Content).Append("\n");
            sb.Append("  ContentType: ").Append(ContentType).Append("\n");
            sb.Append("  DisplayRecipient: ").Append(DisplayRecipient).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  IsMeMessage: ").Append(IsMeMessage).Append("\n");
            sb.Append("  Reactions: ").Append(Reactions).Append("\n");
            sb.Append("  RecipientId: ").Append(RecipientId).Append("\n");
            sb.Append("  SenderEmail: ").Append(SenderEmail).Append("\n");
            sb.Append("  SenderFullName: ").Append(SenderFullName).Append("\n");
            sb.Append("  SenderId: ").Append(SenderId).Append("\n");
            sb.Append("  SenderRealmStr: ").Append(SenderRealmStr).Append("\n");
            sb.Append("  StreamId: ").Append(StreamId).Append("\n");
            sb.Append("  Subject: ").Append(Subject).Append("\n");
            sb.Append("  TopicLinks: ").Append(TopicLinks).Append("\n");
            sb.Append("  Submessages: ").Append(Submessages).Append("\n");
            sb.Append("  Timestamp: ").Append(Timestamp).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (obj is null) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((MessagesBase)obj);
        }

        /// <summary>
        /// Returns true if MessagesBase instances are equal
        /// </summary>
        /// <param name="other">Instance of MessagesBase to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MessagesBase other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    AvatarUrl == other.AvatarUrl ||
                    AvatarUrl != null &&
                    AvatarUrl.Equals(other.AvatarUrl)
                ) && 
                (
                    _Client == other._Client ||
                    _Client != null &&
                    _Client.Equals(other._Client)
                ) && 
                (
                    Content == other.Content ||
                    Content != null &&
                    Content.Equals(other.Content)
                ) && 
                (
                    ContentType == other.ContentType ||
                    ContentType != null &&
                    ContentType.Equals(other.ContentType)
                ) && 
                (
                    DisplayRecipient == other.DisplayRecipient ||
                    DisplayRecipient != null &&
                    DisplayRecipient.Equals(other.DisplayRecipient)
                ) && 
                (
                    Id == other.Id ||
                    
                    Id.Equals(other.Id)
                ) && 
                (
                    IsMeMessage == other.IsMeMessage ||
                    
                    IsMeMessage.Equals(other.IsMeMessage)
                ) && 
                (
                    Reactions == other.Reactions ||
                    Reactions != null &&
                    other.Reactions != null &&
                    Reactions.SequenceEqual(other.Reactions)
                ) && 
                (
                    RecipientId == other.RecipientId ||
                    
                    RecipientId.Equals(other.RecipientId)
                ) && 
                (
                    SenderEmail == other.SenderEmail ||
                    SenderEmail != null &&
                    SenderEmail.Equals(other.SenderEmail)
                ) && 
                (
                    SenderFullName == other.SenderFullName ||
                    SenderFullName != null &&
                    SenderFullName.Equals(other.SenderFullName)
                ) && 
                (
                    SenderId == other.SenderId ||
                    
                    SenderId.Equals(other.SenderId)
                ) && 
                (
                    SenderRealmStr == other.SenderRealmStr ||
                    SenderRealmStr != null &&
                    SenderRealmStr.Equals(other.SenderRealmStr)
                ) && 
                (
                    StreamId == other.StreamId ||
                    
                    StreamId.Equals(other.StreamId)
                ) && 
                (
                    Subject == other.Subject ||
                    Subject != null &&
                    Subject.Equals(other.Subject)
                ) && 
                (
                    TopicLinks == other.TopicLinks ||
                    TopicLinks != null &&
                    other.TopicLinks != null &&
                    TopicLinks.SequenceEqual(other.TopicLinks)
                ) && 
                (
                    Submessages == other.Submessages ||
                    Submessages != null &&
                    other.Submessages != null &&
                    Submessages.SequenceEqual(other.Submessages)
                ) && 
                (
                    Timestamp == other.Timestamp ||
                    
                    Timestamp.Equals(other.Timestamp)
                ) && 
                (
                    Type == other.Type ||
                    Type != null &&
                    Type.Equals(other.Type)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (AvatarUrl != null)
                    hashCode = hashCode * 59 + AvatarUrl.GetHashCode();
                    if (_Client != null)
                    hashCode = hashCode * 59 + _Client.GetHashCode();
                    if (Content != null)
                    hashCode = hashCode * 59 + Content.GetHashCode();
                    if (ContentType != null)
                    hashCode = hashCode * 59 + ContentType.GetHashCode();
                    if (DisplayRecipient != null)
                    hashCode = hashCode * 59 + DisplayRecipient.GetHashCode();
                    
                    hashCode = hashCode * 59 + Id.GetHashCode();
                    
                    hashCode = hashCode * 59 + IsMeMessage.GetHashCode();
                    if (Reactions != null)
                    hashCode = hashCode * 59 + Reactions.GetHashCode();
                    
                    hashCode = hashCode * 59 + RecipientId.GetHashCode();
                    if (SenderEmail != null)
                    hashCode = hashCode * 59 + SenderEmail.GetHashCode();
                    if (SenderFullName != null)
                    hashCode = hashCode * 59 + SenderFullName.GetHashCode();
                    
                    hashCode = hashCode * 59 + SenderId.GetHashCode();
                    if (SenderRealmStr != null)
                    hashCode = hashCode * 59 + SenderRealmStr.GetHashCode();
                    
                    hashCode = hashCode * 59 + StreamId.GetHashCode();
                    if (Subject != null)
                    hashCode = hashCode * 59 + Subject.GetHashCode();
                    if (TopicLinks != null)
                    hashCode = hashCode * 59 + TopicLinks.GetHashCode();
                    if (Submessages != null)
                    hashCode = hashCode * 59 + Submessages.GetHashCode();
                    
                    hashCode = hashCode * 59 + Timestamp.GetHashCode();
                    if (Type != null)
                    hashCode = hashCode * 59 + Type.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(MessagesBase left, MessagesBase right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(MessagesBase left, MessagesBase right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
