/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.2.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "UserBase.h"

#include <string>
#include <sstream>
#include <stdexcept>
#include <algorithm>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

namespace org {
namespace openapitools {
namespace server {
namespace model {

UserBase::UserBase()
{
	m_Email = "";
	m_Is_bot = false;
	m_Avatar_url = "";
	m_Avatar_version = 0;
	m_Full_name = "";
	m_Is_admin = false;
	m_Is_owner = false;
	m_Is_billing_admin = false;
	m_Role = 0;
	m_Bot_type = 0;
	m_User_id = 0;
	m_Bot_owner_id = 0;
	m_Is_active = false;
	m_Is_guest = false;
	m_Timezone = "";
	m_Date_joined = "";
	m_Delivery_email = "";
}

UserBase::~UserBase()
{
}

std::string UserBase::toJsonString(bool prettyJson)
{
	std::stringstream ss;
	write_json(ss, this->toPropertyTree(), prettyJson);
	return ss.str();
}

void UserBase::fromJsonString(std::string const& jsonString)
{
	std::stringstream ss(jsonString);
	ptree pt;
	read_json(ss,pt);
	this->fromPropertyTree(pt);
}

ptree UserBase::toPropertyTree()
{
	ptree pt;
	ptree tmp_node;
	pt.put("email", m_Email);
	pt.put("is_bot", m_Is_bot);
	pt.put("avatar_url", m_Avatar_url);
	pt.put("avatar_version", m_Avatar_version);
	pt.put("full_name", m_Full_name);
	pt.put("is_admin", m_Is_admin);
	pt.put("is_owner", m_Is_owner);
	pt.put("is_billing_admin", m_Is_billing_admin);
	pt.put("role", m_Role);
	pt.put("bot_type", m_Bot_type);
	pt.put("user_id", m_User_id);
	pt.put("bot_owner_id", m_Bot_owner_id);
	pt.put("is_active", m_Is_active);
	pt.put("is_guest", m_Is_guest);
	pt.put("timezone", m_Timezone);
	pt.put("date_joined", m_Date_joined);
	pt.put("delivery_email", m_Delivery_email);
	// generate tree for Profile_data
	if (!m_Profile_data.empty()) {
		for (const auto &childEntry : m_Profile_data) {
			ptree Profile_data_node;
			Profile_data_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Profile_data_node));
		}
		pt.add_child("profile_data", tmp_node);
		tmp_node.clear();
	}
	return pt;
}

void UserBase::fromPropertyTree(ptree const &pt)
{
	ptree tmp_node;
	m_Email = pt.get("email", "");
	m_Is_bot = pt.get("is_bot", false);
	m_Avatar_url = pt.get("avatar_url", "");
	m_Avatar_version = pt.get("avatar_version", 0);
	m_Full_name = pt.get("full_name", "");
	m_Is_admin = pt.get("is_admin", false);
	m_Is_owner = pt.get("is_owner", false);
	m_Is_billing_admin = pt.get("is_billing_admin", false);
	setRole(pt.get("role", 0));
	m_Bot_type = pt.get("bot_type", 0);
	m_User_id = pt.get("user_id", 0);
	m_Bot_owner_id = pt.get("bot_owner_id", 0);
	m_Is_active = pt.get("is_active", false);
	m_Is_guest = pt.get("is_guest", false);
	m_Timezone = pt.get("timezone", "");
	m_Date_joined = pt.get("date_joined", "");
	m_Delivery_email = pt.get("delivery_email", "");
	// push all items of Profile_data into member vector
	if (pt.get_child_optional("profile_data")) {
		for (const auto &childTree : pt.get_child("profile_data")) {
			m_Inner.emplace_back(childTree.second.data());
		}
	}
}

std::string UserBase::getEmail() const
{
    return m_Email;
}
void UserBase::setEmail(std::string value)
{
	m_Email = value;
}
bool UserBase::isIsBot() const
{
    return m_Is_bot;
}
void UserBase::setIsBot(bool value)
{
	m_Is_bot = value;
}
std::string UserBase::getAvatarUrl() const
{
    return m_Avatar_url;
}
void UserBase::setAvatarUrl(std::string value)
{
	m_Avatar_url = value;
}
int32_t UserBase::getAvatarVersion() const
{
    return m_Avatar_version;
}
void UserBase::setAvatarVersion(int32_t value)
{
	m_Avatar_version = value;
}
std::string UserBase::getFullName() const
{
    return m_Full_name;
}
void UserBase::setFullName(std::string value)
{
	m_Full_name = value;
}
bool UserBase::isIsAdmin() const
{
    return m_Is_admin;
}
void UserBase::setIsAdmin(bool value)
{
	m_Is_admin = value;
}
bool UserBase::isIsOwner() const
{
    return m_Is_owner;
}
void UserBase::setIsOwner(bool value)
{
	m_Is_owner = value;
}
bool UserBase::isIsBillingAdmin() const
{
    return m_Is_billing_admin;
}
void UserBase::setIsBillingAdmin(bool value)
{
	m_Is_billing_admin = value;
}
int32_t UserBase::getRole() const
{
    return m_Role;
}
void UserBase::setRole(int32_t value)
{
	if (std::find(m_RoleEnum.begin(), m_RoleEnum.end(), value) != m_RoleEnum.end()) {
		m_Role = value;
	} else {
		throw std::runtime_error("Value " + value + " not allowed");
	}
}
int32_t UserBase::getBotType() const
{
    return m_Bot_type;
}
void UserBase::setBotType(int32_t value)
{
	m_Bot_type = value;
}
int32_t UserBase::getUserId() const
{
    return m_User_id;
}
void UserBase::setUserId(int32_t value)
{
	m_User_id = value;
}
int32_t UserBase::getBotOwnerId() const
{
    return m_Bot_owner_id;
}
void UserBase::setBotOwnerId(int32_t value)
{
	m_Bot_owner_id = value;
}
bool UserBase::isIsActive() const
{
    return m_Is_active;
}
void UserBase::setIsActive(bool value)
{
	m_Is_active = value;
}
bool UserBase::isIsGuest() const
{
    return m_Is_guest;
}
void UserBase::setIsGuest(bool value)
{
	m_Is_guest = value;
}
std::string UserBase::getTimezone() const
{
    return m_Timezone;
}
void UserBase::setTimezone(std::string value)
{
	m_Timezone = value;
}
std::string UserBase::getDateJoined() const
{
    return m_Date_joined;
}
void UserBase::setDateJoined(std::string value)
{
	m_Date_joined = value;
}
std::string UserBase::getDeliveryEmail() const
{
    return m_Delivery_email;
}
void UserBase::setDeliveryEmail(std::string value)
{
	m_Delivery_email = value;
}
std::map<std::string, std::shared_ptr<Object>> UserBase::getProfileData() const
{
    return m_Profile_data;
}
void UserBase::setProfileData(std::map<std::string, std::shared_ptr<Object>> value)
{
	m_Profile_data = value;
}

}
}
}
}

