/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.2.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "MessagesBase.h"

#include <string>
#include <sstream>
#include <stdexcept>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

namespace org {
namespace openapitools {
namespace server {
namespace model {

MessagesBase::MessagesBase()
{
	m_Avatar_url = "";
	m_Client = "";
	m_Content = "";
	m_Content_type = "";
	m_Id = 0;
	m_Is_me_message = false;
	m_Recipient_id = 0;
	m_Sender_email = "";
	m_Sender_full_name = "";
	m_Sender_id = 0;
	m_Sender_realm_str = "";
	m_Stream_id = 0;
	m_Subject = "";
	m_Timestamp = 0;
	m_Type = "";
}

MessagesBase::~MessagesBase()
{
}

std::string MessagesBase::toJsonString(bool prettyJson)
{
	std::stringstream ss;
	write_json(ss, this->toPropertyTree(), prettyJson);
	return ss.str();
}

void MessagesBase::fromJsonString(std::string const& jsonString)
{
	std::stringstream ss(jsonString);
	ptree pt;
	read_json(ss,pt);
	this->fromPropertyTree(pt);
}

ptree MessagesBase::toPropertyTree()
{
	ptree pt;
	ptree tmp_node;
	pt.put("avatar_url", m_Avatar_url);
	pt.put("client", m_Client);
	pt.put("content", m_Content);
	pt.put("content_type", m_Content_type);
	if (m_Display_recipient != nullptr) {
		pt.add_child("display_recipient", m_Display_recipient->toPropertyTree());
	}
	pt.put("id", m_Id);
	pt.put("is_me_message", m_Is_me_message);
	// generate tree for Reactions
	if (!m_Reactions.empty()) {
		for (const auto &childEntry : m_Reactions) {
			ptree Reactions_node;
			Reactions_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Reactions_node));
		}
		pt.add_child("reactions", tmp_node);
		tmp_node.clear();
	}
	pt.put("recipient_id", m_Recipient_id);
	pt.put("sender_email", m_Sender_email);
	pt.put("sender_full_name", m_Sender_full_name);
	pt.put("sender_id", m_Sender_id);
	pt.put("sender_realm_str", m_Sender_realm_str);
	pt.put("stream_id", m_Stream_id);
	pt.put("subject", m_Subject);
	// generate tree for Topic_links
	if (!m_Topic_links.empty()) {
		for (const auto &childEntry : m_Topic_links) {
			ptree Topic_links_node;
			Topic_links_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Topic_links_node));
		}
		pt.add_child("topic_links", tmp_node);
		tmp_node.clear();
	}
	// generate tree for Submessages
	if (!m_Submessages.empty()) {
		for (const auto &childEntry : m_Submessages) {
			ptree Submessages_node;
			Submessages_node.put("", childEntry);
			tmp_node.push_back(std::make_pair("", Submessages_node));
		}
		pt.add_child("submessages", tmp_node);
		tmp_node.clear();
	}
	pt.put("timestamp", m_Timestamp);
	pt.put("type", m_Type);
	return pt;
}

void MessagesBase::fromPropertyTree(ptree const &pt)
{
	ptree tmp_node;
	m_Avatar_url = pt.get("avatar_url", "");
	m_Client = pt.get("client", "");
	m_Content = pt.get("content", "");
	m_Content_type = pt.get("content_type", "");
	if (pt.get_child_optional("display_recipient")) {
		m_Display_recipient = nullptr;
		m_Display_recipient->fromPropertyTree(pt.get_child("display_recipient"));
	}
	m_Id = pt.get("id", 0);
	m_Is_me_message = pt.get("is_me_message", false);
	// push all items of Reactions into member vector
	if (pt.get_child_optional("reactions")) {
		for (const auto &childTree : pt.get_child("reactions")) {
			m_Reactions.emplace_back(childTree.second.data());
		}
	}
	m_Recipient_id = pt.get("recipient_id", 0);
	m_Sender_email = pt.get("sender_email", "");
	m_Sender_full_name = pt.get("sender_full_name", "");
	m_Sender_id = pt.get("sender_id", 0);
	m_Sender_realm_str = pt.get("sender_realm_str", "");
	m_Stream_id = pt.get("stream_id", 0);
	m_Subject = pt.get("subject", "");
	// push all items of Topic_links into member vector
	if (pt.get_child_optional("topic_links")) {
		for (const auto &childTree : pt.get_child("topic_links")) {
			m_Topic_links.emplace_back(childTree.second.data());
		}
	}
	// push all items of Submessages into member vector
	if (pt.get_child_optional("submessages")) {
		for (const auto &childTree : pt.get_child("submessages")) {
			m_Submessages.emplace_back(childTree.second.data());
		}
	}
	m_Timestamp = pt.get("timestamp", 0);
	m_Type = pt.get("type", "");
}

std::string MessagesBase::getAvatarUrl() const
{
    return m_Avatar_url;
}
void MessagesBase::setAvatarUrl(std::string value)
{
	m_Avatar_url = value;
}
std::string MessagesBase::getClient() const
{
    return m_Client;
}
void MessagesBase::setClient(std::string value)
{
	m_Client = value;
}
std::string MessagesBase::getContent() const
{
    return m_Content;
}
void MessagesBase::setContent(std::string value)
{
	m_Content = value;
}
std::string MessagesBase::getContentType() const
{
    return m_Content_type;
}
void MessagesBase::setContentType(std::string value)
{
	m_Content_type = value;
}
std::shared_ptr<OneOfstringarray> MessagesBase::getDisplayRecipient() const
{
    return m_Display_recipient;
}
void MessagesBase::setDisplayRecipient(std::shared_ptr<OneOfstringarray> value)
{
	m_Display_recipient = value;
}
int32_t MessagesBase::getId() const
{
    return m_Id;
}
void MessagesBase::setId(int32_t value)
{
	m_Id = value;
}
bool MessagesBase::isIsMeMessage() const
{
    return m_Is_me_message;
}
void MessagesBase::setIsMeMessage(bool value)
{
	m_Is_me_message = value;
}
std::vector<std::shared_ptr<EmojiReaction>> MessagesBase::getReactions() const
{
    return m_Reactions;
}
void MessagesBase::setReactions(std::vector<std::shared_ptr<EmojiReaction>> value)
{
	m_Reactions = value;
}
int32_t MessagesBase::getRecipientId() const
{
    return m_Recipient_id;
}
void MessagesBase::setRecipientId(int32_t value)
{
	m_Recipient_id = value;
}
std::string MessagesBase::getSenderEmail() const
{
    return m_Sender_email;
}
void MessagesBase::setSenderEmail(std::string value)
{
	m_Sender_email = value;
}
std::string MessagesBase::getSenderFullName() const
{
    return m_Sender_full_name;
}
void MessagesBase::setSenderFullName(std::string value)
{
	m_Sender_full_name = value;
}
int32_t MessagesBase::getSenderId() const
{
    return m_Sender_id;
}
void MessagesBase::setSenderId(int32_t value)
{
	m_Sender_id = value;
}
std::string MessagesBase::getSenderRealmStr() const
{
    return m_Sender_realm_str;
}
void MessagesBase::setSenderRealmStr(std::string value)
{
	m_Sender_realm_str = value;
}
int32_t MessagesBase::getStreamId() const
{
    return m_Stream_id;
}
void MessagesBase::setStreamId(int32_t value)
{
	m_Stream_id = value;
}
std::string MessagesBase::getSubject() const
{
    return m_Subject;
}
void MessagesBase::setSubject(std::string value)
{
	m_Subject = value;
}
std::vector<std::shared_ptr<MessagesBase_topic_links>> MessagesBase::getTopicLinks() const
{
    return m_Topic_links;
}
void MessagesBase::setTopicLinks(std::vector<std::shared_ptr<MessagesBase_topic_links>> value)
{
	m_Topic_links = value;
}
std::vector<std::string> MessagesBase::getSubmessages() const
{
    return m_Submessages;
}
void MessagesBase::setSubmessages(std::vector<std::string> value)
{
	m_Submessages = value;
}
int32_t MessagesBase::getTimestamp() const
{
    return m_Timestamp;
}
void MessagesBase::setTimestamp(int32_t value)
{
	m_Timestamp = value;
}
std::string MessagesBase::getType() const
{
    return m_Type;
}
void MessagesBase::setType(std::string value)
{
	m_Type = value;
}

}
}
}
}

