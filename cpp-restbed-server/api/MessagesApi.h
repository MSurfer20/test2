/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.2.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * MessagesApi.h
 *
 * 
 */

#ifndef MessagesApi_H_
#define MessagesApi_H_


#include <memory>
#include <utility>

#include <corvusoft/restbed/session.hpp>
#include <corvusoft/restbed/resource.hpp>
#include <corvusoft/restbed/service.hpp>

#include "AnyType.h"
#include "CodedError.h"
#include "InvalidMessageError.h"
#include "JsonSuccess.h"
#include "JsonSuccessBase.h"
#include "Object.h"
#include "OneOfobjectobject.h"
#include "OneOfstringinteger.h"
#include <string>

namespace org {
namespace openapitools {
namespace server {
namespace api {

using namespace org::openapitools::server::model;

/// <summary>
/// Add an emoji reaction
/// </summary>
/// <remarks>
/// Add an [emoji reaction](/help/emoji-reactions) to a message.  &#x60;POST {{ api_url }}/v1/messages/{message_id}/reactions&#x60; 
/// </remarks>
class  MessagesApiMessagesMessage_idReactionsResource: public restbed::Resource
{
public:
	MessagesApiMessagesMessage_idReactionsResource();
    virtual ~MessagesApiMessagesMessage_idReactionsResource();
    void POST_method_handler(const std::shared_ptr<restbed::Session> session);
    void DELETE_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_POST(
		std::function<std::pair<int, std::string>(
			int32_t const &, std::string const &, std::string const &, std::string const &
		)> handler
	);

	void set_handler_DELETE(
		std::function<std::pair<int, std::string>(
			int32_t const &, std::string const &, std::string const &, std::string const &
		)> handler
	);

private:
	std::function<std::pair<int, std::string>(
		int32_t const &, std::string const &, std::string const &, std::string const &
	)> handler_POST_;

	std::function<std::pair<int, std::string>(
		int32_t const &, std::string const &, std::string const &, std::string const &
	)> handler_DELETE_;

	int32_t messageId{};
	std::string emojiName{};
	std::string emojiCode{};
	std::string reactionType{};
};

/// <summary>
/// Check if messages match a narrow
/// </summary>
/// <remarks>
/// Check whether a set of messages match a [narrow](/api/construct-narrow).  &#x60;GET {{ api_url }}/v1/messages/matches_narrow&#x60;  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the &#x60;match_subject&#x60; and &#x60;match_content&#x60; objects is designed to match those of &#x60;GET /messages&#x60;, so that a client can splice these fields into a &#x60;message&#x60; object received from &#x60;GET /events&#x60; and end up with an extended message object identical to how a &#x60;GET /messages&#x60; for the current narrow would have returned the message. 
/// </remarks>
class  MessagesApiMessagesMatches_narrowResource: public restbed::Resource
{
public:
	MessagesApiMessagesMatches_narrowResource();
    virtual ~MessagesApiMessagesMatches_narrowResource();
    void GET_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_GET(
		std::function<std::pair<int, std::string>(
			std::vector<int32_t> const &, std::vector<std::shared_ptr<Object>> const &
		)> handler
	);


private:
	std::function<std::pair<int, std::string>(
		std::vector<int32_t> const &, std::vector<std::shared_ptr<Object>> const &
	)> handler_GET_;


	std::vector<int32_t> msgIds{};
	std::vector<std::shared_ptr<Object>> narrow{};
};

/// <summary>
/// Delete a message
/// </summary>
/// <remarks>
/// Permanently delete a message.  &#x60;DELETE {{ api_url }}/v1/messages/{msg_id}&#x60;  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
/// </remarks>
class  MessagesApiMessagesMessage_idResource: public restbed::Resource
{
public:
	MessagesApiMessagesMessage_idResource();
    virtual ~MessagesApiMessagesMessage_idResource();
    void DELETE_method_handler(const std::shared_ptr<restbed::Session> session);
    void PATCH_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_DELETE(
		std::function<std::pair<int, std::string>(
			int32_t const &
		)> handler
	);

	void set_handler_PATCH(
		std::function<std::pair<int, std::string>(
			int32_t const &, std::string const &, std::string const &, bool const &, bool const &, std::string const &, int32_t const &
		)> handler
	);

private:
	std::function<std::pair<int, std::string>(
		int32_t const &
	)> handler_DELETE_;

	std::function<std::pair<int, std::string>(
		int32_t const &, std::string const &, std::string const &, bool const &, bool const &, std::string const &, int32_t const &
	)> handler_PATCH_;

	int32_t messageId{};
};

/// <summary>
/// Get public temporary URL
/// </summary>
/// <remarks>
/// Get a temporary URL for access to the file that doesn&#39;t require authentication. 
/// </remarks>
class  MessagesApiUser_uploadsRealm_id_strFilenameResource: public restbed::Resource
{
public:
	MessagesApiUser_uploadsRealm_id_strFilenameResource();
    virtual ~MessagesApiUser_uploadsRealm_id_strFilenameResource();
    void GET_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_GET(
		std::function<std::pair<int, std::string>(
			int32_t const &, std::string const &
		)> handler
	);


private:
	std::function<std::pair<int, std::string>(
		int32_t const &, std::string const &
	)> handler_GET_;


	int32_t realmIdStr{};
	std::string filename{};
};

/// <summary>
/// Get a message&#39;s edit history
/// </summary>
/// <remarks>
/// Fetch the message edit history of a previously edited message.  &#x60;GET {{ api_url }}/v1/messages/{message_id}/history&#x60;  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
/// </remarks>
class  MessagesApiMessagesMessage_idHistoryResource: public restbed::Resource
{
public:
	MessagesApiMessagesMessage_idHistoryResource();
    virtual ~MessagesApiMessagesMessage_idHistoryResource();
    void GET_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_GET(
		std::function<std::pair<int, std::string>(
			int32_t const &
		)> handler
	);


private:
	std::function<std::pair<int, std::string>(
		int32_t const &
	)> handler_GET_;


	int32_t messageId{};
};

/// <summary>
/// Get messages
/// </summary>
/// <remarks>
/// Fetch message history from a Zulip server.  &#x60;GET {{ api_url }}/v1/messages&#x60;  This &#x60;GET /api/v1/messages&#x60; endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip&#39;s powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user&#39;s message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an &#x60;anchor&#x60; message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the &#x60;num_before&#x60; and &#x60;num_after&#x60; limits.  We recommend using &#x60;num_before &lt;&#x3D; 1000&#x60; and &#x60;num_after &lt;&#x3D; 1000&#x60; to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
/// </remarks>
class  MessagesApiMessagesResource: public restbed::Resource
{
public:
	MessagesApiMessagesResource();
    virtual ~MessagesApiMessagesResource();
    void GET_method_handler(const std::shared_ptr<restbed::Session> session);
    void POST_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_GET(
		std::function<std::pair<int, std::string>(
			int32_t const &, int32_t const &, std::shared_ptr<OneOfstringinteger> const &, std::vector<std::shared_ptr<Object>> const &, bool const &, bool const &, bool const &
		)> handler
	);

	void set_handler_POST(
		std::function<std::pair<int, std::string>(
			std::string const &, std::vector<int32_t> const &, std::string const &, std::string const &, std::string const &, std::string const &
		)> handler
	);

private:
	std::function<std::pair<int, std::string>(
		int32_t const &, int32_t const &, std::shared_ptr<OneOfstringinteger> const &, std::vector<std::shared_ptr<Object>> const &, bool const &, bool const &, bool const &
	)> handler_GET_;

	std::function<std::pair<int, std::string>(
		std::string const &, std::vector<int32_t> const &, std::string const &, std::string const &, std::string const &, std::string const &
	)> handler_POST_;

	int32_t numBefore{};
	int32_t numAfter{};
	std::shared_ptr<OneOfstringinteger> anchor{};
	std::vector<std::shared_ptr<Object>> narrow{};
	bool clientGravatar{};
	bool applyMarkdown{};
	bool useFirstUnreadAnchor{};
};

/// <summary>
/// Mark all messages as read
/// </summary>
/// <remarks>
/// Marks all of the current user&#39;s unread messages as read.  &#x60;POST {{ api_url }}/v1/mark_all_as_read&#x60; 
/// </remarks>
class  MessagesApiMark_all_as_readResource: public restbed::Resource
{
public:
	MessagesApiMark_all_as_readResource();
    virtual ~MessagesApiMark_all_as_readResource();
    void POST_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_POST(
		std::function<std::pair<int, std::string>(
			
		)> handler
	);


private:
	std::function<std::pair<int, std::string>(
		
	)> handler_POST_;


};

/// <summary>
/// Mark messages in a stream as read
/// </summary>
/// <remarks>
/// Mark all the unread messages in a stream as read. 
/// </remarks>
class  MessagesApiMark_stream_as_readResource: public restbed::Resource
{
public:
	MessagesApiMark_stream_as_readResource();
    virtual ~MessagesApiMark_stream_as_readResource();
    void POST_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_POST(
		std::function<std::pair<int, std::string>(
			int32_t const &
		)> handler
	);


private:
	std::function<std::pair<int, std::string>(
		int32_t const &
	)> handler_POST_;


	int32_t streamId{};
};

/// <summary>
/// Mark messages in a topic as read
/// </summary>
/// <remarks>
/// Mark all the unread messages in a topic as read. 
/// </remarks>
class  MessagesApiMark_topic_as_readResource: public restbed::Resource
{
public:
	MessagesApiMark_topic_as_readResource();
    virtual ~MessagesApiMark_topic_as_readResource();
    void POST_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_POST(
		std::function<std::pair<int, std::string>(
			int32_t const &, std::string const &
		)> handler
	);


private:
	std::function<std::pair<int, std::string>(
		int32_t const &, std::string const &
	)> handler_POST_;


	int32_t streamId{};
	std::string topicName{};
};

/// <summary>
/// Render message
/// </summary>
/// <remarks>
/// Render a message to HTML.  &#x60;POST {{ api_url }}/v1/messages/render&#x60; 
/// </remarks>
class  MessagesApiMessagesRenderResource: public restbed::Resource
{
public:
	MessagesApiMessagesRenderResource();
    virtual ~MessagesApiMessagesRenderResource();
    void POST_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_POST(
		std::function<std::pair<int, std::string>(
			std::string const &
		)> handler
	);


private:
	std::function<std::pair<int, std::string>(
		std::string const &
	)> handler_POST_;


	std::string content{};
};

/// <summary>
/// Update personal message flags
/// </summary>
/// <remarks>
/// Add or remove personal message flags like &#x60;read&#x60; and &#x60;starred&#x60; on a collection of message IDs.  &#x60;POST {{ api_url }}/v1/messages/flags&#x60;  For updating the &#x60;read&#x60; flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
/// </remarks>
class  MessagesApiMessagesFlagsResource: public restbed::Resource
{
public:
	MessagesApiMessagesFlagsResource();
    virtual ~MessagesApiMessagesFlagsResource();
    void POST_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_POST(
		std::function<std::pair<int, std::string>(
			std::vector<int32_t> const &, std::string const &, std::string const &
		)> handler
	);


private:
	std::function<std::pair<int, std::string>(
		std::vector<int32_t> const &, std::string const &, std::string const &
	)> handler_POST_;


	std::vector<int32_t> messages{};
	std::string op{};
	std::string flag{};
};

/// <summary>
/// Upload a file
/// </summary>
/// <remarks>
/// Upload a single file and get the corresponding URI.  &#x60;POST {{ api_url }}/v1/user_uploads&#x60;  Initially, only you will be able to access the link.  To share the uploaded file, you&#39;ll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
/// </remarks>
class  MessagesApiUser_uploadsResource: public restbed::Resource
{
public:
	MessagesApiUser_uploadsResource();
    virtual ~MessagesApiUser_uploadsResource();
    void POST_method_handler(const std::shared_ptr<restbed::Session> session);

	void set_handler_POST(
		std::function<std::pair<int, std::string>(
			std::string const &
		)> handler
	);


private:
	std::function<std::pair<int, std::string>(
		std::string const &
	)> handler_POST_;


	std::string filename{};
};


//
// The restbed service to actually implement the REST server
//
class  MessagesApi: public restbed::Service
{
public:
	MessagesApi();
	~MessagesApi();
	void startService(int const& port);
	void stopService();
	
protected:
	std::shared_ptr<MessagesApiMessagesMessage_idReactionsResource> m_spMessagesApiMessagesMessage_idReactionsResource;
	std::shared_ptr<MessagesApiMessagesMatches_narrowResource> m_spMessagesApiMessagesMatches_narrowResource;
	std::shared_ptr<MessagesApiMessagesMessage_idResource> m_spMessagesApiMessagesMessage_idResource;
	std::shared_ptr<MessagesApiUser_uploadsRealm_id_strFilenameResource> m_spMessagesApiUser_uploadsRealm_id_strFilenameResource;
	std::shared_ptr<MessagesApiMessagesMessage_idHistoryResource> m_spMessagesApiMessagesMessage_idHistoryResource;
	std::shared_ptr<MessagesApiMessagesResource> m_spMessagesApiMessagesResource;
	std::shared_ptr<MessagesApiMark_all_as_readResource> m_spMessagesApiMark_all_as_readResource;
	std::shared_ptr<MessagesApiMark_stream_as_readResource> m_spMessagesApiMark_stream_as_readResource;
	std::shared_ptr<MessagesApiMark_topic_as_readResource> m_spMessagesApiMark_topic_as_readResource;
	std::shared_ptr<MessagesApiMessagesRenderResource> m_spMessagesApiMessagesRenderResource;
	std::shared_ptr<MessagesApiMessagesFlagsResource> m_spMessagesApiMessagesFlagsResource;
	std::shared_ptr<MessagesApiUser_uploadsResource> m_spMessagesApiUser_uploadsResource;
};


}
}
}
}

#endif /* MessagesApi_H_ */

