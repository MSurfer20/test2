/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `create_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `create_user_group`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateUserGroupError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `deactivate_own_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeactivateOwnUserError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `deactivate_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeactivateUserError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_attachments`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAttachmentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_own_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOwnUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_user_by_email`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserByEmailError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_user_groups`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserGroupsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_user_presence`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserPresenceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_users`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUsersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `mute_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MuteUserError {
    Status400(crate::models::OneOfobjectobjectobject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `reactivate_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactivateUserError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `remove_user_group`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveUserGroupError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `set_typing_status`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetTypingStatusError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `unmute_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnmuteUserError {
    Status400(crate::models::OneOfobjectobject),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_display_settings`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDisplaySettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_notification_settings`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateNotificationSettingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_user`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserError {
    Status400(crate::models::CodedError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_user_group`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserGroupError {
    Status400(crate::models::JsonError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `update_user_group_members`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserGroupMembersError {
    UnknownValue(serde_json::Value),
}


/// {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
pub async fn create_user(configuration: &configuration::Configuration, email: &str, password: &str, full_name: &str) -> Result<crate::models::JsonSuccessBase, Error<CreateUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("email", &email.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("password", &password.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("full_name", &full_name.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
pub async fn create_user_group(configuration: &configuration::Configuration, name: &str, description: &str, members: Vec<i32>) -> Result<crate::models::JsonSuccess, Error<CreateUserGroupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/user_groups/create", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("name", &name.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("description", &description.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("members", &members.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateUserGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deactivates the user's account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
pub async fn deactivate_own_user(configuration: &configuration::Configuration, ) -> Result<crate::models::JsonSuccess, Error<DeactivateOwnUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeactivateOwnUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
pub async fn deactivate_user(configuration: &configuration::Configuration, user_id: i32) -> Result<crate::models::JsonSuccess, Error<DeactivateUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{user_id}", configuration.base_path, user_id=user_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeactivateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
pub async fn get_attachments(configuration: &configuration::Configuration, ) -> Result<crate::models::JsonSuccessBase, Error<GetAttachmentsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/attachments", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAttachmentsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
pub async fn get_own_user(configuration: &configuration::Configuration, ) -> Result<crate::models::JsonSuccessBase, Error<GetOwnUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetOwnUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
pub async fn get_user(configuration: &configuration::Configuration, user_id: i32, client_gravatar: Option<bool>, include_custom_profile_fields: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<GetUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{user_id}", configuration.base_path, user_id=user_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = client_gravatar {
        local_var_req_builder = local_var_req_builder.query(&[("client_gravatar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_custom_profile_fields {
        local_var_req_builder = local_var_req_builder.query(&[("include_custom_profile_fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
pub async fn get_user_by_email(configuration: &configuration::Configuration, email: &str, client_gravatar: Option<bool>, include_custom_profile_fields: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<GetUserByEmailError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{email}", configuration.base_path, email=crate::apis::urlencode(email));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = client_gravatar {
        local_var_req_builder = local_var_req_builder.query(&[("client_gravatar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_custom_profile_fields {
        local_var_req_builder = local_var_req_builder.query(&[("include_custom_profile_fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetUserByEmailError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
pub async fn get_user_groups(configuration: &configuration::Configuration, ) -> Result<crate::models::JsonSuccessBase, Error<GetUserGroupsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/user_groups", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetUserGroupsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user's presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip's developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
pub async fn get_user_presence(configuration: &configuration::Configuration, user_id_or_email: &str) -> Result<crate::models::JsonSuccessBase, Error<GetUserPresenceError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{user_id_or_email}/presence", configuration.base_path, user_id_or_email=crate::apis::urlencode(user_id_or_email));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetUserPresenceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
pub async fn get_users(configuration: &configuration::Configuration, client_gravatar: Option<bool>, include_custom_profile_fields: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<GetUsersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = client_gravatar {
        local_var_req_builder = local_var_req_builder.query(&[("client_gravatar", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_custom_profile_fields {
        local_var_req_builder = local_var_req_builder.query(&[("include_custom_profile_fields", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetUsersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you've muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user's name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
pub async fn mute_user(configuration: &configuration::Configuration, muted_user_id: i32) -> Result<crate::models::JsonSuccess, Error<MuteUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me/muted_users/{muted_user_id}", configuration.base_path, muted_user_id=muted_user_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MuteUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
pub async fn reactivate_user(configuration: &configuration::Configuration, user_id: i32) -> Result<serde_json::Value, Error<ReactivateUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{user_id}/reactivate", configuration.base_path, user_id=user_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ReactivateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
pub async fn remove_user_group(configuration: &configuration::Configuration, user_group_id: i32) -> Result<crate::models::JsonSuccess, Error<RemoveUserGroupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/user_groups/{user_group_id}", configuration.base_path, user_group_id=user_group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RemoveUserGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip's typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip's typing notifications protocol. 
pub async fn set_typing_status(configuration: &configuration::Configuration, op: &str, to: Vec<i32>, _type: Option<&str>, topic: Option<&str>) -> Result<crate::models::JsonSuccess, Error<SetTypingStatusError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/typing", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = _type {
        local_var_req_builder = local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("op", &op.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("to", &to.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    if let Some(ref local_var_str) = topic {
        local_var_req_builder = local_var_req_builder.query(&[("topic", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SetTypingStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
pub async fn unmute_user(configuration: &configuration::Configuration, muted_user_id: i32) -> Result<crate::models::JsonSuccess, Error<UnmuteUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/me/muted_users/{muted_user_id}", configuration.base_path, muted_user_id=muted_user_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UnmuteUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint is used to edit the current user's user interface settings.  `PATCH {{ api_url }}/v1/settings/display` 
pub async fn update_display_settings(configuration: &configuration::Configuration, twenty_four_hour_time: Option<bool>, dense_mode: Option<bool>, starred_message_counts: Option<bool>, fluid_layout_width: Option<bool>, high_contrast_mode: Option<bool>, color_scheme: Option<i32>, translate_emoticons: Option<bool>, default_language: Option<&str>, default_view: Option<&str>, left_side_userlist: Option<bool>, emojiset: Option<&str>, demote_inactive_streams: Option<i32>, timezone: Option<&str>) -> Result<crate::models::JsonSuccessBase, Error<UpdateDisplaySettingsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/settings/display", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = twenty_four_hour_time {
        local_var_req_builder = local_var_req_builder.query(&[("twenty_four_hour_time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = dense_mode {
        local_var_req_builder = local_var_req_builder.query(&[("dense_mode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = starred_message_counts {
        local_var_req_builder = local_var_req_builder.query(&[("starred_message_counts", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = fluid_layout_width {
        local_var_req_builder = local_var_req_builder.query(&[("fluid_layout_width", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = high_contrast_mode {
        local_var_req_builder = local_var_req_builder.query(&[("high_contrast_mode", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = color_scheme {
        local_var_req_builder = local_var_req_builder.query(&[("color_scheme", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = translate_emoticons {
        local_var_req_builder = local_var_req_builder.query(&[("translate_emoticons", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = default_language {
        local_var_req_builder = local_var_req_builder.query(&[("default_language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = default_view {
        local_var_req_builder = local_var_req_builder.query(&[("default_view", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = left_side_userlist {
        local_var_req_builder = local_var_req_builder.query(&[("left_side_userlist", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = emojiset {
        local_var_req_builder = local_var_req_builder.query(&[("emojiset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = demote_inactive_streams {
        local_var_req_builder = local_var_req_builder.query(&[("demote_inactive_streams", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = timezone {
        local_var_req_builder = local_var_req_builder.query(&[("timezone", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateDisplaySettingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint is used to edit the user's global notification settings. See [this endpoint](/api/update-subscription-settings) for per-stream notification settings.  `PATCH {{ api_url }}/v1/settings/notifications` 
pub async fn update_notification_settings(configuration: &configuration::Configuration, enable_stream_desktop_notifications: Option<bool>, enable_stream_email_notifications: Option<bool>, enable_stream_push_notifications: Option<bool>, enable_stream_audible_notifications: Option<bool>, notification_sound: Option<&str>, enable_desktop_notifications: Option<bool>, enable_sounds: Option<bool>, enable_offline_email_notifications: Option<bool>, enable_offline_push_notifications: Option<bool>, enable_online_push_notifications: Option<bool>, enable_digest_emails: Option<bool>, enable_marketing_emails: Option<bool>, enable_login_emails: Option<bool>, message_content_in_email_notifications: Option<bool>, pm_content_in_desktop_notifications: Option<bool>, wildcard_mentions_notify: Option<bool>, desktop_icon_count_display: Option<i32>, realm_name_in_notifications: Option<bool>, presence_enabled: Option<bool>) -> Result<crate::models::JsonSuccessBase, Error<UpdateNotificationSettingsError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/settings/notifications", configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = enable_stream_desktop_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_stream_desktop_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_stream_email_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_stream_email_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_stream_push_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_stream_push_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_stream_audible_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_stream_audible_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = notification_sound {
        local_var_req_builder = local_var_req_builder.query(&[("notification_sound", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_desktop_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_desktop_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_sounds {
        local_var_req_builder = local_var_req_builder.query(&[("enable_sounds", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_offline_email_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_offline_email_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_offline_push_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_offline_push_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_online_push_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("enable_online_push_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_digest_emails {
        local_var_req_builder = local_var_req_builder.query(&[("enable_digest_emails", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_marketing_emails {
        local_var_req_builder = local_var_req_builder.query(&[("enable_marketing_emails", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enable_login_emails {
        local_var_req_builder = local_var_req_builder.query(&[("enable_login_emails", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_content_in_email_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("message_content_in_email_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pm_content_in_desktop_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("pm_content_in_desktop_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = wildcard_mentions_notify {
        local_var_req_builder = local_var_req_builder.query(&[("wildcard_mentions_notify", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = desktop_icon_count_display {
        local_var_req_builder = local_var_req_builder.query(&[("desktop_icon_count_display", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = realm_name_in_notifications {
        local_var_req_builder = local_var_req_builder.query(&[("realm_name_in_notifications", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = presence_enabled {
        local_var_req_builder = local_var_req_builder.query(&[("presence_enabled", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateNotificationSettingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user's account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
pub async fn update_user(configuration: &configuration::Configuration, user_id: i32, full_name: Option<&str>, role: Option<i32>, profile_data: Option<Vec<serde_json::Value>>) -> Result<crate::models::JsonSuccess, Error<UpdateUserError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/users/{user_id}", configuration.base_path, user_id=user_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = full_name {
        local_var_req_builder = local_var_req_builder.query(&[("full_name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = role {
        local_var_req_builder = local_var_req_builder.query(&[("role", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = profile_data {
        local_var_req_builder = local_var_req_builder.query(&[("profile_data", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateUserError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
pub async fn update_user_group(configuration: &configuration::Configuration, user_group_id: i32, name: &str, description: &str) -> Result<crate::models::JsonSuccess, Error<UpdateUserGroupError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/user_groups/{user_group_id}", configuration.base_path, user_group_id=user_group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("name", &name.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("description", &description.to_string())]);
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateUserGroupError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
pub async fn update_user_group_members(configuration: &configuration::Configuration, user_group_id: i32, delete: Option<Vec<i32>>, add: Option<Vec<i32>>) -> Result<crate::models::JsonSuccess, Error<UpdateUserGroupMembersError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/user_groups/{user_group_id}/members", configuration.base_path, user_group_id=user_group_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = delete {
        local_var_req_builder = local_var_req_builder.query(&[("delete", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_str) = add {
        local_var_req_builder = local_var_req_builder.query(&[("add", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateUserGroupMembersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

