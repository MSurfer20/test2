/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "OpenAPIStreamsApiOperations.h"

#include "OpenAPIModule.h"
#include "OpenAPIHelpers.h"

#include "Dom/JsonObject.h"
#include "Templates/SharedPointer.h"
#include "HttpModule.h"
#include "PlatformHttp.h"

namespace OpenAPI 
{

FString OpenAPIStreamsApi::ArchiveStreamRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("stream_id"), ToStringFormatArg(StreamId) } };

	FString Path = FString::Format(TEXT("/streams/{stream_id}"), PathParams);
	
	return Path;
}

void OpenAPIStreamsApi::ArchiveStreamRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::ArchiveStreamResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIStreamsApi::ArchiveStreamResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::CreateBigBlueButtonVideoCallRequest::ComputePath() const
{
	FString Path(TEXT("/calls/bigbluebutton/create"));
	return Path;
}

void OpenAPIStreamsApi::CreateBigBlueButtonVideoCallRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::CreateBigBlueButtonVideoCallResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIStreamsApi::CreateBigBlueButtonVideoCallResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::GetStreamIdRequest::ComputePath() const
{
	FString Path(TEXT("/get_stream_id"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("stream=")) + ToUrlString(Stream));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIStreamsApi::GetStreamIdRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::GetStreamIdResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIStreamsApi::GetStreamIdResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::GetStreamTopicsRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("stream_id"), ToStringFormatArg(StreamId) } };

	FString Path = FString::Format(TEXT("/users/me/{stream_id}/topics"), PathParams);
	
	return Path;
}

void OpenAPIStreamsApi::GetStreamTopicsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::GetStreamTopicsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIStreamsApi::GetStreamTopicsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::GetStreamsRequest::ComputePath() const
{
	FString Path(TEXT("/streams"));
	TArray<FString> QueryParams;
	if(IncludePublic.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_public=")) + ToUrlString(IncludePublic.GetValue()));
	}
	if(IncludeWebPublic.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_web_public=")) + ToUrlString(IncludeWebPublic.GetValue()));
	}
	if(IncludeSubscribed.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_subscribed=")) + ToUrlString(IncludeSubscribed.GetValue()));
	}
	if(IncludeAllActive.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_all_active=")) + ToUrlString(IncludeAllActive.GetValue()));
	}
	if(IncludeDefault.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_default=")) + ToUrlString(IncludeDefault.GetValue()));
	}
	if(IncludeOwnerSubscribed.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_owner_subscribed=")) + ToUrlString(IncludeOwnerSubscribed.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIStreamsApi::GetStreamsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::GetStreamsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIStreamsApi::GetStreamsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::GetSubscriptionStatusRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_id"), ToStringFormatArg(UserId) },
	{ TEXT("stream_id"), ToStringFormatArg(StreamId) } };

	FString Path = FString::Format(TEXT("/users/{user_id}/subscriptions/{stream_id}"), PathParams);
	
	return Path;
}

void OpenAPIStreamsApi::GetSubscriptionStatusRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::GetSubscriptionStatusResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIStreamsApi::GetSubscriptionStatusResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::GetSubscriptionsRequest::ComputePath() const
{
	FString Path(TEXT("/users/me/subscriptions"));
	TArray<FString> QueryParams;
	if(IncludeSubscribers.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_subscribers=")) + ToUrlString(IncludeSubscribers.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIStreamsApi::GetSubscriptionsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::GetSubscriptionsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIStreamsApi::GetSubscriptionsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIStreamsApi::MuteTopicRequest::OpEnum& Value)
{
	switch (Value)
	{
	case OpenAPIStreamsApi::MuteTopicRequest::OpEnum::Add:
		return TEXT("add");
	case OpenAPIStreamsApi::MuteTopicRequest::OpEnum::Remove:
		return TEXT("remove");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIStreamsApi::MuteTopicRequest::OpEnum Value (%d)"), (int)Value);	
	return TEXT("");
}

FString OpenAPIStreamsApi::MuteTopicRequest::EnumToString(const OpenAPIStreamsApi::MuteTopicRequest::OpEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIStreamsApi::MuteTopicRequest::OpEnum& Value)
{
	static TMap<FString, OpenAPIStreamsApi::MuteTopicRequest::OpEnum> StringToEnum = { 
		{ TEXT("add"), OpenAPIStreamsApi::MuteTopicRequest::OpEnum::Add },
		{ TEXT("remove"), OpenAPIStreamsApi::MuteTopicRequest::OpEnum::Remove }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;	
}

bool OpenAPIStreamsApi::MuteTopicRequest::EnumFromString(const FString& EnumAsString, OpenAPIStreamsApi::MuteTopicRequest::OpEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline FStringFormatArg ToStringFormatArg(const OpenAPIStreamsApi::MuteTopicRequest::OpEnum& Value)
{
	return FStringFormatArg(ToString(Value));
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIStreamsApi::MuteTopicRequest::OpEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIStreamsApi::MuteTopicRequest::OpEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIStreamsApi::MuteTopicRequest::ComputePath() const
{
	FString Path(TEXT("/users/me/subscriptions/muted_topics"));
	TArray<FString> QueryParams;
	if(Stream.IsSet())
	{
		QueryParams.Add(FString(TEXT("stream=")) + ToUrlString(Stream.GetValue()));
	}
	if(StreamId.IsSet())
	{
		QueryParams.Add(FString(TEXT("stream_id=")) + ToUrlString(StreamId.GetValue()));
	}
	QueryParams.Add(FString(TEXT("topic=")) + ToUrlString(Topic));
	QueryParams.Add(FString(TEXT("op=")) + ToUrlString(Op));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIStreamsApi::MuteTopicRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::MuteTopicResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIStreamsApi::MuteTopicResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::SubscribeRequest::ComputePath() const
{
	FString Path(TEXT("/users/me/subscriptions"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("subscriptions=")) + CollectionToUrlString_multi(Subscriptions, TEXT("subscriptions")));
	if(Principals.IsSet())
	{
		QueryParams.Add(FString(TEXT("principals=")) + CollectionToUrlString_multi(Principals.GetValue(), TEXT("principals")));
	}
	if(AuthorizationErrorsFatal.IsSet())
	{
		QueryParams.Add(FString(TEXT("authorization_errors_fatal=")) + ToUrlString(AuthorizationErrorsFatal.GetValue()));
	}
	if(Announce.IsSet())
	{
		QueryParams.Add(FString(TEXT("announce=")) + ToUrlString(Announce.GetValue()));
	}
	if(InviteOnly.IsSet())
	{
		QueryParams.Add(FString(TEXT("invite_only=")) + ToUrlString(InviteOnly.GetValue()));
	}
	if(HistoryPublicToSubscribers.IsSet())
	{
		QueryParams.Add(FString(TEXT("history_public_to_subscribers=")) + ToUrlString(HistoryPublicToSubscribers.GetValue()));
	}
	if(StreamPostPolicy.IsSet())
	{
		QueryParams.Add(FString(TEXT("stream_post_policy=")) + ToUrlString(StreamPostPolicy.GetValue()));
	}
	if(MessageRetentionDays.IsSet())
	{
		QueryParams.Add(FString(TEXT("message_retention_days=")) + ToUrlString(MessageRetentionDays.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIStreamsApi::SubscribeRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::SubscribeResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIStreamsApi::SubscribeResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::UnsubscribeRequest::ComputePath() const
{
	FString Path(TEXT("/users/me/subscriptions"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("subscriptions=")) + CollectionToUrlString_multi(Subscriptions, TEXT("subscriptions")));
	if(Principals.IsSet())
	{
		QueryParams.Add(FString(TEXT("principals=")) + CollectionToUrlString_multi(Principals.GetValue(), TEXT("principals")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIStreamsApi::UnsubscribeRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::UnsubscribeResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIStreamsApi::UnsubscribeResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::UpdateStreamRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("stream_id"), ToStringFormatArg(StreamId) } };

	FString Path = FString::Format(TEXT("/streams/{stream_id}"), PathParams);
	
	TArray<FString> QueryParams;
	if(Description.IsSet())
	{
		QueryParams.Add(FString(TEXT("description=")) + ToUrlString(Description.GetValue()));
	}
	if(NewName.IsSet())
	{
		QueryParams.Add(FString(TEXT("new_name=")) + ToUrlString(NewName.GetValue()));
	}
	if(IsPrivate.IsSet())
	{
		QueryParams.Add(FString(TEXT("is_private=")) + ToUrlString(IsPrivate.GetValue()));
	}
	if(IsAnnouncementOnly.IsSet())
	{
		QueryParams.Add(FString(TEXT("is_announcement_only=")) + ToUrlString(IsAnnouncementOnly.GetValue()));
	}
	if(StreamPostPolicy.IsSet())
	{
		QueryParams.Add(FString(TEXT("stream_post_policy=")) + ToUrlString(StreamPostPolicy.GetValue()));
	}
	if(HistoryPublicToSubscribers.IsSet())
	{
		QueryParams.Add(FString(TEXT("history_public_to_subscribers=")) + ToUrlString(HistoryPublicToSubscribers.GetValue()));
	}
	if(MessageRetentionDays.IsSet())
	{
		QueryParams.Add(FString(TEXT("message_retention_days=")) + ToUrlString(MessageRetentionDays.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIStreamsApi::UpdateStreamRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::UpdateStreamResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIStreamsApi::UpdateStreamResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::UpdateSubscriptionSettingsRequest::ComputePath() const
{
	FString Path(TEXT("/users/me/subscriptions/properties"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("subscription_data=")) + CollectionToUrlString_multi(SubscriptionData, TEXT("subscription_data")));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIStreamsApi::UpdateSubscriptionSettingsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::UpdateSubscriptionSettingsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIStreamsApi::UpdateSubscriptionSettingsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIStreamsApi::UpdateSubscriptionsRequest::ComputePath() const
{
	FString Path(TEXT("/users/me/subscriptions"));
	TArray<FString> QueryParams;
	if(_Delete.IsSet())
	{
		QueryParams.Add(FString(TEXT("delete=")) + CollectionToUrlString_multi(_Delete.GetValue(), TEXT("delete")));
	}
	if(Add.IsSet())
	{
		QueryParams.Add(FString(TEXT("add=")) + CollectionToUrlString_multi(Add.GetValue(), TEXT("add")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIStreamsApi::UpdateSubscriptionsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIStreamsApi::UpdateSubscriptionsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIStreamsApi::UpdateSubscriptionsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

}
