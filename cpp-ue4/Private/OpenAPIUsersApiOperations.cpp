/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "OpenAPIUsersApiOperations.h"

#include "OpenAPIModule.h"
#include "OpenAPIHelpers.h"

#include "Dom/JsonObject.h"
#include "Templates/SharedPointer.h"
#include "HttpModule.h"
#include "PlatformHttp.h"

namespace OpenAPI 
{

FString OpenAPIUsersApi::CreateUserRequest::ComputePath() const
{
	FString Path(TEXT("/users"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("email=")) + ToUrlString(Email));
	QueryParams.Add(FString(TEXT("password=")) + ToUrlString(Password));
	QueryParams.Add(FString(TEXT("full_name=")) + ToUrlString(FullName));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::CreateUserRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::CreateUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIUsersApi::CreateUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::CreateUserGroupRequest::ComputePath() const
{
	FString Path(TEXT("/user_groups/create"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("name=")) + ToUrlString(Name));
	QueryParams.Add(FString(TEXT("description=")) + ToUrlString(Description));
	QueryParams.Add(FString(TEXT("members=")) + CollectionToUrlString_multi(Members, TEXT("members")));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::CreateUserGroupRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::CreateUserGroupResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIUsersApi::CreateUserGroupResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::DeactivateOwnUserRequest::ComputePath() const
{
	FString Path(TEXT("/users/me"));
	return Path;
}

void OpenAPIUsersApi::DeactivateOwnUserRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::DeactivateOwnUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIUsersApi::DeactivateOwnUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::DeactivateUserRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_id"), ToStringFormatArg(UserId) } };

	FString Path = FString::Format(TEXT("/users/{user_id}"), PathParams);
	
	return Path;
}

void OpenAPIUsersApi::DeactivateUserRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::DeactivateUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Bad request"));
		break;
	}
}

bool OpenAPIUsersApi::DeactivateUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::GetAttachmentsRequest::ComputePath() const
{
	FString Path(TEXT("/attachments"));
	return Path;
}

void OpenAPIUsersApi::GetAttachmentsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::GetAttachmentsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIUsersApi::GetAttachmentsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::GetOwnUserRequest::ComputePath() const
{
	FString Path(TEXT("/users/me"));
	return Path;
}

void OpenAPIUsersApi::GetOwnUserRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::GetOwnUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIUsersApi::GetOwnUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::GetUserRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_id"), ToStringFormatArg(UserId) } };

	FString Path = FString::Format(TEXT("/users/{user_id}"), PathParams);
	
	TArray<FString> QueryParams;
	if(ClientGravatar.IsSet())
	{
		QueryParams.Add(FString(TEXT("client_gravatar=")) + ToUrlString(ClientGravatar.GetValue()));
	}
	if(IncludeCustomProfileFields.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_custom_profile_fields=")) + ToUrlString(IncludeCustomProfileFields.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::GetUserRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::GetUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIUsersApi::GetUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::GetUserByEmailRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("email"), ToStringFormatArg(Email) } };

	FString Path = FString::Format(TEXT("/users/{email}"), PathParams);
	
	TArray<FString> QueryParams;
	if(ClientGravatar.IsSet())
	{
		QueryParams.Add(FString(TEXT("client_gravatar=")) + ToUrlString(ClientGravatar.GetValue()));
	}
	if(IncludeCustomProfileFields.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_custom_profile_fields=")) + ToUrlString(IncludeCustomProfileFields.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::GetUserByEmailRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::GetUserByEmailResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIUsersApi::GetUserByEmailResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::GetUserGroupsRequest::ComputePath() const
{
	FString Path(TEXT("/user_groups"));
	return Path;
}

void OpenAPIUsersApi::GetUserGroupsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::GetUserGroupsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIUsersApi::GetUserGroupsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::GetUserPresenceRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_id_or_email"), ToStringFormatArg(UserIdOrEmail) } };

	FString Path = FString::Format(TEXT("/users/{user_id_or_email}/presence"), PathParams);
	
	return Path;
}

void OpenAPIUsersApi::GetUserPresenceRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::GetUserPresenceResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIUsersApi::GetUserPresenceResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::GetUsersRequest::ComputePath() const
{
	FString Path(TEXT("/users"));
	TArray<FString> QueryParams;
	if(ClientGravatar.IsSet())
	{
		QueryParams.Add(FString(TEXT("client_gravatar=")) + ToUrlString(ClientGravatar.GetValue()));
	}
	if(IncludeCustomProfileFields.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_custom_profile_fields=")) + ToUrlString(IncludeCustomProfileFields.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::GetUsersRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::GetUsersResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIUsersApi::GetUsersResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::MuteUserRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("muted_user_id"), ToStringFormatArg(MutedUserId) } };

	FString Path = FString::Format(TEXT("/users/me/muted_users/{muted_user_id}"), PathParams);
	
	return Path;
}

void OpenAPIUsersApi::MuteUserRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::MuteUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIUsersApi::MuteUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::ReactivateUserRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_id"), ToStringFormatArg(UserId) } };

	FString Path = FString::Format(TEXT("/users/{user_id}/reactivate"), PathParams);
	
	return Path;
}

void OpenAPIUsersApi::ReactivateUserRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::ReactivateUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIUsersApi::ReactivateUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::RemoveUserGroupRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_group_id"), ToStringFormatArg(UserGroupId) } };

	FString Path = FString::Format(TEXT("/user_groups/{user_group_id}"), PathParams);
	
	return Path;
}

void OpenAPIUsersApi::RemoveUserGroupRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::RemoveUserGroupResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIUsersApi::RemoveUserGroupResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsersApi::SetTypingStatusRequest::OpEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsersApi::SetTypingStatusRequest::OpEnum::Start:
		return TEXT("start");
	case OpenAPIUsersApi::SetTypingStatusRequest::OpEnum::Stop:
		return TEXT("stop");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsersApi::SetTypingStatusRequest::OpEnum Value (%d)"), (int)Value);	
	return TEXT("");
}

FString OpenAPIUsersApi::SetTypingStatusRequest::EnumToString(const OpenAPIUsersApi::SetTypingStatusRequest::OpEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsersApi::SetTypingStatusRequest::OpEnum& Value)
{
	static TMap<FString, OpenAPIUsersApi::SetTypingStatusRequest::OpEnum> StringToEnum = { 
		{ TEXT("start"), OpenAPIUsersApi::SetTypingStatusRequest::OpEnum::Start },
		{ TEXT("stop"), OpenAPIUsersApi::SetTypingStatusRequest::OpEnum::Stop }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;	
}

bool OpenAPIUsersApi::SetTypingStatusRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsersApi::SetTypingStatusRequest::OpEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline FStringFormatArg ToStringFormatArg(const OpenAPIUsersApi::SetTypingStatusRequest::OpEnum& Value)
{
	return FStringFormatArg(ToString(Value));
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsersApi::SetTypingStatusRequest::OpEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsersApi::SetTypingStatusRequest::OpEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum::_Private:
		return TEXT("private");
	case OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum::Stream:
		return TEXT("stream");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum Value (%d)"), (int)Value);	
	return TEXT("");
}

FString OpenAPIUsersApi::SetTypingStatusRequest::EnumToString(const OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum& Value)
{
	static TMap<FString, OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum> StringToEnum = { 
		{ TEXT("private"), OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum::_Private },
		{ TEXT("stream"), OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum::Stream }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;	
}

bool OpenAPIUsersApi::SetTypingStatusRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline FStringFormatArg ToStringFormatArg(const OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum& Value)
{
	return FStringFormatArg(ToString(Value));
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsersApi::SetTypingStatusRequest::TypeEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsersApi::SetTypingStatusRequest::ComputePath() const
{
	FString Path(TEXT("/typing"));
	TArray<FString> QueryParams;
	if(Type.IsSet())
	{
		QueryParams.Add(FString(TEXT("type=")) + ToUrlString(Type.GetValue()));
	}
	QueryParams.Add(FString(TEXT("op=")) + ToUrlString(Op));
	QueryParams.Add(FString(TEXT("to=")) + CollectionToUrlString_multi(To, TEXT("to")));
	if(Topic.IsSet())
	{
		QueryParams.Add(FString(TEXT("topic=")) + ToUrlString(Topic.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::SetTypingStatusRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::SetTypingStatusResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIUsersApi::SetTypingStatusResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::UnmuteUserRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("muted_user_id"), ToStringFormatArg(MutedUserId) } };

	FString Path = FString::Format(TEXT("/users/me/muted_users/{muted_user_id}"), PathParams);
	
	return Path;
}

void OpenAPIUsersApi::UnmuteUserRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::UnmuteUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIUsersApi::UnmuteUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum::_1:
		return TEXT("1");
	case OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum::_2:
		return TEXT("2");
	case OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum::_3:
		return TEXT("3");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum Value (%d)"), (int)Value);	
	return TEXT("");
}

FString OpenAPIUsersApi::UpdateDisplaySettingsRequest::EnumToString(const OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum& Value)
{
	static TMap<FString, OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum> StringToEnum = { 
		{ TEXT("1"), OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum::_1 },
		{ TEXT("2"), OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum::_2 },
		{ TEXT("3"), OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum::_3 }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;	
}

bool OpenAPIUsersApi::UpdateDisplaySettingsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline FStringFormatArg ToStringFormatArg(const OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum& Value)
{
	return FStringFormatArg(ToString(Value));
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsersApi::UpdateDisplaySettingsRequest::ColorSchemeEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum::_1:
		return TEXT("1");
	case OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum::_2:
		return TEXT("2");
	case OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum::_3:
		return TEXT("3");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum Value (%d)"), (int)Value);	
	return TEXT("");
}

FString OpenAPIUsersApi::UpdateDisplaySettingsRequest::EnumToString(const OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum& Value)
{
	static TMap<FString, OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum> StringToEnum = { 
		{ TEXT("1"), OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum::_1 },
		{ TEXT("2"), OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum::_2 },
		{ TEXT("3"), OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum::_3 }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;	
}

bool OpenAPIUsersApi::UpdateDisplaySettingsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline FStringFormatArg ToStringFormatArg(const OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum& Value)
{
	return FStringFormatArg(ToString(Value));
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsersApi::UpdateDisplaySettingsRequest::DemoteInactiveStreamsEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsersApi::UpdateDisplaySettingsRequest::ComputePath() const
{
	FString Path(TEXT("/settings/display"));
	TArray<FString> QueryParams;
	if(TwentyFourHourTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("twenty_four_hour_time=")) + ToUrlString(TwentyFourHourTime.GetValue()));
	}
	if(DenseMode.IsSet())
	{
		QueryParams.Add(FString(TEXT("dense_mode=")) + ToUrlString(DenseMode.GetValue()));
	}
	if(StarredMessageCounts.IsSet())
	{
		QueryParams.Add(FString(TEXT("starred_message_counts=")) + ToUrlString(StarredMessageCounts.GetValue()));
	}
	if(FluidLayoutWidth.IsSet())
	{
		QueryParams.Add(FString(TEXT("fluid_layout_width=")) + ToUrlString(FluidLayoutWidth.GetValue()));
	}
	if(HighContrastMode.IsSet())
	{
		QueryParams.Add(FString(TEXT("high_contrast_mode=")) + ToUrlString(HighContrastMode.GetValue()));
	}
	if(ColorScheme.IsSet())
	{
		QueryParams.Add(FString(TEXT("color_scheme=")) + ToUrlString(ColorScheme.GetValue()));
	}
	if(TranslateEmoticons.IsSet())
	{
		QueryParams.Add(FString(TEXT("translate_emoticons=")) + ToUrlString(TranslateEmoticons.GetValue()));
	}
	if(DefaultLanguage.IsSet())
	{
		QueryParams.Add(FString(TEXT("default_language=")) + ToUrlString(DefaultLanguage.GetValue()));
	}
	if(DefaultView.IsSet())
	{
		QueryParams.Add(FString(TEXT("default_view=")) + ToUrlString(DefaultView.GetValue()));
	}
	if(LeftSideUserlist.IsSet())
	{
		QueryParams.Add(FString(TEXT("left_side_userlist=")) + ToUrlString(LeftSideUserlist.GetValue()));
	}
	if(Emojiset.IsSet())
	{
		QueryParams.Add(FString(TEXT("emojiset=")) + ToUrlString(Emojiset.GetValue()));
	}
	if(DemoteInactiveStreams.IsSet())
	{
		QueryParams.Add(FString(TEXT("demote_inactive_streams=")) + ToUrlString(DemoteInactiveStreams.GetValue()));
	}
	if(Timezone.IsSet())
	{
		QueryParams.Add(FString(TEXT("timezone=")) + ToUrlString(Timezone.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::UpdateDisplaySettingsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::UpdateDisplaySettingsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIUsersApi::UpdateDisplaySettingsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum::_1:
		return TEXT("1");
	case OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum::_2:
		return TEXT("2");
	case OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum::_3:
		return TEXT("3");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum Value (%d)"), (int)Value);	
	return TEXT("");
}

FString OpenAPIUsersApi::UpdateNotificationSettingsRequest::EnumToString(const OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum& Value)
{
	static TMap<FString, OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum> StringToEnum = { 
		{ TEXT("1"), OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum::_1 },
		{ TEXT("2"), OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum::_2 },
		{ TEXT("3"), OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum::_3 }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;	
}

bool OpenAPIUsersApi::UpdateNotificationSettingsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline FStringFormatArg ToStringFormatArg(const OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum& Value)
{
	return FStringFormatArg(ToString(Value));
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsersApi::UpdateNotificationSettingsRequest::DesktopIconCountDisplayEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsersApi::UpdateNotificationSettingsRequest::ComputePath() const
{
	FString Path(TEXT("/settings/notifications"));
	TArray<FString> QueryParams;
	if(EnableStreamDesktopNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_stream_desktop_notifications=")) + ToUrlString(EnableStreamDesktopNotifications.GetValue()));
	}
	if(EnableStreamEmailNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_stream_email_notifications=")) + ToUrlString(EnableStreamEmailNotifications.GetValue()));
	}
	if(EnableStreamPushNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_stream_push_notifications=")) + ToUrlString(EnableStreamPushNotifications.GetValue()));
	}
	if(EnableStreamAudibleNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_stream_audible_notifications=")) + ToUrlString(EnableStreamAudibleNotifications.GetValue()));
	}
	if(NotificationSound.IsSet())
	{
		QueryParams.Add(FString(TEXT("notification_sound=")) + ToUrlString(NotificationSound.GetValue()));
	}
	if(EnableDesktopNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_desktop_notifications=")) + ToUrlString(EnableDesktopNotifications.GetValue()));
	}
	if(EnableSounds.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_sounds=")) + ToUrlString(EnableSounds.GetValue()));
	}
	if(EnableOfflineEmailNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_offline_email_notifications=")) + ToUrlString(EnableOfflineEmailNotifications.GetValue()));
	}
	if(EnableOfflinePushNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_offline_push_notifications=")) + ToUrlString(EnableOfflinePushNotifications.GetValue()));
	}
	if(EnableOnlinePushNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_online_push_notifications=")) + ToUrlString(EnableOnlinePushNotifications.GetValue()));
	}
	if(EnableDigestEmails.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_digest_emails=")) + ToUrlString(EnableDigestEmails.GetValue()));
	}
	if(EnableMarketingEmails.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_marketing_emails=")) + ToUrlString(EnableMarketingEmails.GetValue()));
	}
	if(EnableLoginEmails.IsSet())
	{
		QueryParams.Add(FString(TEXT("enable_login_emails=")) + ToUrlString(EnableLoginEmails.GetValue()));
	}
	if(MessageContentInEmailNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("message_content_in_email_notifications=")) + ToUrlString(MessageContentInEmailNotifications.GetValue()));
	}
	if(PmContentInDesktopNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("pm_content_in_desktop_notifications=")) + ToUrlString(PmContentInDesktopNotifications.GetValue()));
	}
	if(WildcardMentionsNotify.IsSet())
	{
		QueryParams.Add(FString(TEXT("wildcard_mentions_notify=")) + ToUrlString(WildcardMentionsNotify.GetValue()));
	}
	if(DesktopIconCountDisplay.IsSet())
	{
		QueryParams.Add(FString(TEXT("desktop_icon_count_display=")) + ToUrlString(DesktopIconCountDisplay.GetValue()));
	}
	if(RealmNameInNotifications.IsSet())
	{
		QueryParams.Add(FString(TEXT("realm_name_in_notifications=")) + ToUrlString(RealmNameInNotifications.GetValue()));
	}
	if(PresenceEnabled.IsSet())
	{
		QueryParams.Add(FString(TEXT("presence_enabled=")) + ToUrlString(PresenceEnabled.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::UpdateNotificationSettingsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::UpdateNotificationSettingsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIUsersApi::UpdateNotificationSettingsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::UpdateUserRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_id"), ToStringFormatArg(UserId) } };

	FString Path = FString::Format(TEXT("/users/{user_id}"), PathParams);
	
	TArray<FString> QueryParams;
	if(FullName.IsSet())
	{
		QueryParams.Add(FString(TEXT("full_name=")) + ToUrlString(FullName.GetValue()));
	}
	if(Role.IsSet())
	{
		QueryParams.Add(FString(TEXT("role=")) + ToUrlString(Role.GetValue()));
	}
	if(ProfileData.IsSet())
	{
		QueryParams.Add(FString(TEXT("profile_data=")) + CollectionToUrlString_multi(ProfileData.GetValue(), TEXT("profile_data")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::UpdateUserRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::UpdateUserResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIUsersApi::UpdateUserResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::UpdateUserGroupRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_group_id"), ToStringFormatArg(UserGroupId) } };

	FString Path = FString::Format(TEXT("/user_groups/{user_group_id}"), PathParams);
	
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("name=")) + ToUrlString(Name));
	QueryParams.Add(FString(TEXT("description=")) + ToUrlString(Description));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::UpdateUserGroupRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::UpdateUserGroupResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	case 400:
		SetResponseString(TEXT("Bad request."));
		break;
	}
}

bool OpenAPIUsersApi::UpdateUserGroupResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIUsersApi::UpdateUserGroupMembersRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_group_id"), ToStringFormatArg(UserGroupId) } };

	FString Path = FString::Format(TEXT("/user_groups/{user_group_id}/members"), PathParams);
	
	TArray<FString> QueryParams;
	if(_Delete.IsSet())
	{
		QueryParams.Add(FString(TEXT("delete=")) + CollectionToUrlString_multi(_Delete.GetValue(), TEXT("delete")));
	}
	if(Add.IsSet())
	{
		QueryParams.Add(FString(TEXT("add=")) + CollectionToUrlString_multi(Add.GetValue(), TEXT("add")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsersApi::UpdateUserGroupMembersRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIUsersApi::UpdateUserGroupMembersResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success."));
		break;
	}
}

bool OpenAPIUsersApi::UpdateUserGroupMembersResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

}
