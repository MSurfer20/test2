/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api

import java.text.SimpleDateFormat

import java.io.File
import org.openapitools.client.model.JsonSuccess
import org.openapitools.client.model.JsonSuccessBase
import org.openapitools.client.{ApiInvoker, ApiException}

import collection.mutable
import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart
import com.wordnik.swagger.client._
import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._
import javax.ws.rs.core.Response.Status.Family

import java.net.URI
import java.io.File
import java.util.Date
import java.util.TimeZone
import javax.ws.rs.core.{MediaType, Response}

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.collection.mutable.HashMap
import scala.util.{Failure, Success, Try}

import org.json4s._

class ServerAndOrganizationsApi(
  val defBasePath: String = "https://example.zulipchat.com/api/v1",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new ServerAndOrganizationsApiAsyncHelper(client, config)

  /**
   * Add a code playground
   * Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  &#x60;POST {{ api_url }}/v1/realm/playgrounds&#x60;  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
   *
   * @param name The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language.  
   * @param pygmentsLanguage The name of the Pygments language lexer for that programming language.  
   * @param urlPrefix The url prefix for the playground.  
   * @return JsonSuccessBase
   */
  def addCodePlayground(name: String, pygmentsLanguage: String, urlPrefix: String): Option[JsonSuccessBase] = {
    val await = Try(Await.result(addCodePlaygroundAsync(name, pygmentsLanguage, urlPrefix), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a code playground asynchronously
   * Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  &#x60;POST {{ api_url }}/v1/realm/playgrounds&#x60;  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
   *
   * @param name The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language.  
   * @param pygmentsLanguage The name of the Pygments language lexer for that programming language.  
   * @param urlPrefix The url prefix for the playground.  
   * @return Future(JsonSuccessBase)
   */
  def addCodePlaygroundAsync(name: String, pygmentsLanguage: String, urlPrefix: String): Future[JsonSuccessBase] = {
      helper.addCodePlayground(name, pygmentsLanguage, urlPrefix)
  }

  /**
   * Add a linkifier
   * Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;POST {{ api_url }}/v1/realm/filters&#x60; 
   *
   * @param pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier.  
   * @param urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;.  
   * @return JsonSuccessBase
   */
  def addLinkifier(pattern: String, urlFormatString: String): Option[JsonSuccessBase] = {
    val await = Try(Await.result(addLinkifierAsync(pattern, urlFormatString), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a linkifier asynchronously
   * Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;POST {{ api_url }}/v1/realm/filters&#x60; 
   *
   * @param pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier.  
   * @param urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;.  
   * @return Future(JsonSuccessBase)
   */
  def addLinkifierAsync(pattern: String, urlFormatString: String): Future[JsonSuccessBase] = {
      helper.addLinkifier(pattern, urlFormatString)
  }

  /**
   * Create a custom profile field
   * [Create a custom profile field](/help/add-custom-profile-fields) in the user&#39;s organization.  &#x60;POST {{ api_url }}/v1/realm/profile_fields&#x60; 
   *
   * @param fieldType The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/add-custom-profile-fields) more details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account  
   * @param name The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user&#39;s profile.  (optional)
   * @param hint The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields.  (optional)
   * @param fieldData Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the &#x60;field_data&#x60; attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized.  (optional)
   * @return JsonSuccessBase
   */
  def createCustomProfileField(fieldType: Integer, name: Option[String] = None, hint: Option[String] = None, fieldData: Option[Any] = None): Option[JsonSuccessBase] = {
    val await = Try(Await.result(createCustomProfileFieldAsync(fieldType, name, hint, fieldData), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a custom profile field asynchronously
   * [Create a custom profile field](/help/add-custom-profile-fields) in the user&#39;s organization.  &#x60;POST {{ api_url }}/v1/realm/profile_fields&#x60; 
   *
   * @param fieldType The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/add-custom-profile-fields) more details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account  
   * @param name The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user&#39;s profile.  (optional)
   * @param hint The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields.  (optional)
   * @param fieldData Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the &#x60;field_data&#x60; attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized.  (optional)
   * @return Future(JsonSuccessBase)
   */
  def createCustomProfileFieldAsync(fieldType: Integer, name: Option[String] = None, hint: Option[String] = None, fieldData: Option[Any] = None): Future[JsonSuccessBase] = {
      helper.createCustomProfileField(fieldType, name, hint, fieldData)
  }

  /**
   * Get all custom emoji
   * Get all the custom emoji in the user&#39;s organization.  &#x60;GET {{ api_url }}/v1/realm/emoji&#x60; 
   *
   * @return JsonSuccessBase
   */
  def getCustomEmoji(): Option[JsonSuccessBase] = {
    val await = Try(Await.result(getCustomEmojiAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all custom emoji asynchronously
   * Get all the custom emoji in the user&#39;s organization.  &#x60;GET {{ api_url }}/v1/realm/emoji&#x60; 
   *
   * @return Future(JsonSuccessBase)
   */
  def getCustomEmojiAsync(): Future[JsonSuccessBase] = {
      helper.getCustomEmoji()
  }

  /**
   * Get all custom profile fields
   * Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user&#39;s organization.  &#x60;GET {{ api_url }}/v1/realm/profile_fields&#x60; 
   *
   * @return JsonSuccessBase
   */
  def getCustomProfileFields(): Option[JsonSuccessBase] = {
    val await = Try(Await.result(getCustomProfileFieldsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all custom profile fields asynchronously
   * Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user&#39;s organization.  &#x60;GET {{ api_url }}/v1/realm/profile_fields&#x60; 
   *
   * @return Future(JsonSuccessBase)
   */
  def getCustomProfileFieldsAsync(): Future[JsonSuccessBase] = {
      helper.getCustomProfileFields()
  }

  /**
   * Get linkifiers
   * List all of an organization&#39;s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;GET {{ api_url }}/v1/realm/linkifiers&#x60;  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar &#x60;GET /realm/filters&#x60; endpoint was available with each entry in a &#x60;[pattern, url_format, id]&#x60; tuple format. 
   *
   * @return JsonSuccessBase
   */
  def getLinkifiers(): Option[JsonSuccessBase] = {
    val await = Try(Await.result(getLinkifiersAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get linkifiers asynchronously
   * List all of an organization&#39;s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;GET {{ api_url }}/v1/realm/linkifiers&#x60;  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar &#x60;GET /realm/filters&#x60; endpoint was available with each entry in a &#x60;[pattern, url_format, id]&#x60; tuple format. 
   *
   * @return Future(JsonSuccessBase)
   */
  def getLinkifiersAsync(): Future[JsonSuccessBase] = {
      helper.getLinkifiers()
  }

  /**
   * Get server settings
   * Fetch global settings for a Zulip server.  &#x60;GET {{ api_url }}/v1/server_settings&#x60;  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it&#39;s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
   *
   * @return JsonSuccessBase
   */
  def getServerSettings(): Option[JsonSuccessBase] = {
    val await = Try(Await.result(getServerSettingsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get server settings asynchronously
   * Fetch global settings for a Zulip server.  &#x60;GET {{ api_url }}/v1/server_settings&#x60;  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it&#39;s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
   *
   * @return Future(JsonSuccessBase)
   */
  def getServerSettingsAsync(): Future[JsonSuccessBase] = {
      helper.getServerSettings()
  }

  /**
   * Remove a code playground
   * Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  &#x60;DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}&#x60;  **Changes**: New in Zulip 4.0 (feature level 49). 
   *
   * @param playgroundId The ID of the playground that you want to remove.  
   * @return JsonSuccess
   */
  def removeCodePlayground(playgroundId: Integer): Option[JsonSuccess] = {
    val await = Try(Await.result(removeCodePlaygroundAsync(playgroundId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Remove a code playground asynchronously
   * Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  &#x60;DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}&#x60;  **Changes**: New in Zulip 4.0 (feature level 49). 
   *
   * @param playgroundId The ID of the playground that you want to remove.  
   * @return Future(JsonSuccess)
   */
  def removeCodePlaygroundAsync(playgroundId: Integer): Future[JsonSuccess] = {
      helper.removeCodePlayground(playgroundId)
  }

  /**
   * Remove a linkifier
   * Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;DELETE {{ api_url }}/v1/realm/filters/{filter_id}&#x60; 
   *
   * @param filterId The ID of the linkifier that you want to remove.  
   * @return JsonSuccess
   */
  def removeLinkifier(filterId: Integer): Option[JsonSuccess] = {
    val await = Try(Await.result(removeLinkifierAsync(filterId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Remove a linkifier asynchronously
   * Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;DELETE {{ api_url }}/v1/realm/filters/{filter_id}&#x60; 
   *
   * @param filterId The ID of the linkifier that you want to remove.  
   * @return Future(JsonSuccess)
   */
  def removeLinkifierAsync(filterId: Integer): Future[JsonSuccess] = {
      helper.removeLinkifier(filterId)
  }

  /**
   * Reorder custom profile fields
   * Reorder the custom profile fields in the user&#39;s organization.  &#x60;PATCH {{ api_url }}/v1/realm/profile_fields&#x60;  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
   *
   * @param order A list of the IDs of all the custom profile fields defined in this organization, in the desired new order.  
   * @return JsonSuccess
   */
  def reorderCustomProfileFields(order: List[Integer]): Option[JsonSuccess] = {
    val await = Try(Await.result(reorderCustomProfileFieldsAsync(order), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Reorder custom profile fields asynchronously
   * Reorder the custom profile fields in the user&#39;s organization.  &#x60;PATCH {{ api_url }}/v1/realm/profile_fields&#x60;  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
   *
   * @param order A list of the IDs of all the custom profile fields defined in this organization, in the desired new order.  
   * @return Future(JsonSuccess)
   */
  def reorderCustomProfileFieldsAsync(order: List[Integer]): Future[JsonSuccess] = {
      helper.reorderCustomProfileFields(order)
  }

  /**
   * Update a linkifier
   * Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;PATCH {{ api_url }}/v1/realm/filters/{filter_id}&#x60;  **Changes**: New in Zulip 4.0 (feature level 57). 
   *
   * @param filterId The ID of the linkifier that you want to update.  
   * @param pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier.  
   * @param urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;.  
   * @return JsonSuccess
   */
  def updateLinkifier(filterId: Integer, pattern: String, urlFormatString: String): Option[JsonSuccess] = {
    val await = Try(Await.result(updateLinkifierAsync(filterId, pattern, urlFormatString), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a linkifier asynchronously
   * Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;PATCH {{ api_url }}/v1/realm/filters/{filter_id}&#x60;  **Changes**: New in Zulip 4.0 (feature level 57). 
   *
   * @param filterId The ID of the linkifier that you want to update.  
   * @param pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier.  
   * @param urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;.  
   * @return Future(JsonSuccess)
   */
  def updateLinkifierAsync(filterId: Integer, pattern: String, urlFormatString: String): Future[JsonSuccess] = {
      helper.updateLinkifier(filterId, pattern, urlFormatString)
  }

  /**
   * Upload custom emoji
   * This endpoint is used to upload a custom emoji for use in the user&#39;s organization.  Access to this endpoint depends on the [organization&#39;s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  &#x60;POST {{ api_url }}/v1/realm/emoji/{emoji_name}&#x60; 
   *
   * @param emojiName The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (_) are treated the same as spaces (consistent with how the Zulip UI handles emoji).  
   * @param filename  (optional)
   * @return JsonSuccess
   */
  def uploadCustomEmoji(emojiName: String, filename: Option[File] = None): Option[JsonSuccess] = {
    val await = Try(Await.result(uploadCustomEmojiAsync(emojiName, filename), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Upload custom emoji asynchronously
   * This endpoint is used to upload a custom emoji for use in the user&#39;s organization.  Access to this endpoint depends on the [organization&#39;s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  &#x60;POST {{ api_url }}/v1/realm/emoji/{emoji_name}&#x60; 
   *
   * @param emojiName The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (_) are treated the same as spaces (consistent with how the Zulip UI handles emoji).  
   * @param filename  (optional)
   * @return Future(JsonSuccess)
   */
  def uploadCustomEmojiAsync(emojiName: String, filename: Option[File] = None): Future[JsonSuccess] = {
      helper.uploadCustomEmoji(emojiName, filename)
  }

}

class ServerAndOrganizationsApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def addCodePlayground(name: String,
    pygmentsLanguage: String,
    urlPrefix: String)(implicit reader: ClientResponseReader[JsonSuccessBase]): Future[JsonSuccessBase] = {
    // create path and map variables
    val path = (addFmt("/realm/playgrounds"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling ServerAndOrganizationsApi->addCodePlayground")

    if (pygmentsLanguage == null) throw new Exception("Missing required parameter 'pygmentsLanguage' when calling ServerAndOrganizationsApi->addCodePlayground")

    if (urlPrefix == null) throw new Exception("Missing required parameter 'urlPrefix' when calling ServerAndOrganizationsApi->addCodePlayground")

    queryParams += "name" -> name.toString
    queryParams += "pygments_language" -> pygmentsLanguage.toString
    queryParams += "url_prefix" -> urlPrefix.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def addLinkifier(pattern: String,
    urlFormatString: String)(implicit reader: ClientResponseReader[JsonSuccessBase]): Future[JsonSuccessBase] = {
    // create path and map variables
    val path = (addFmt("/realm/filters"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (pattern == null) throw new Exception("Missing required parameter 'pattern' when calling ServerAndOrganizationsApi->addLinkifier")

    if (urlFormatString == null) throw new Exception("Missing required parameter 'urlFormatString' when calling ServerAndOrganizationsApi->addLinkifier")

    queryParams += "pattern" -> pattern.toString
    queryParams += "url_format_string" -> urlFormatString.toString

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def createCustomProfileField(fieldType: Integer,
    name: Option[String] = None,
    hint: Option[String] = None,
    fieldData: Option[Any] = None
    )(implicit reader: ClientResponseReader[JsonSuccessBase]): Future[JsonSuccessBase] = {
    // create path and map variables
    val path = (addFmt("/realm/profile_fields"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    hint match {
      case Some(param) => queryParams += "hint" -> param.toString
      case _ => queryParams
    }
    queryParams += "field_type" -> fieldType.toString
    fieldData match {
      case Some(param) => queryParams += "field_data" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getCustomEmoji()(implicit reader: ClientResponseReader[JsonSuccessBase]): Future[JsonSuccessBase] = {
    // create path and map variables
    val path = (addFmt("/realm/emoji"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getCustomProfileFields()(implicit reader: ClientResponseReader[JsonSuccessBase]): Future[JsonSuccessBase] = {
    // create path and map variables
    val path = (addFmt("/realm/profile_fields"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getLinkifiers()(implicit reader: ClientResponseReader[JsonSuccessBase]): Future[JsonSuccessBase] = {
    // create path and map variables
    val path = (addFmt("/realm/linkifiers"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getServerSettings()(implicit reader: ClientResponseReader[JsonSuccessBase]): Future[JsonSuccessBase] = {
    // create path and map variables
    val path = (addFmt("/server_settings"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def removeCodePlayground(playgroundId: Integer)(implicit reader: ClientResponseReader[JsonSuccess]): Future[JsonSuccess] = {
    // create path and map variables
    val path = (addFmt("/realm/playgrounds/{playground_id}")
      replaceAll("\\{" + "playground_id" + "\\}", playgroundId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def removeLinkifier(filterId: Integer)(implicit reader: ClientResponseReader[JsonSuccess]): Future[JsonSuccess] = {
    // create path and map variables
    val path = (addFmt("/realm/filters/{filter_id}")
      replaceAll("\\{" + "filter_id" + "\\}", filterId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def reorderCustomProfileFields(order: List[Integer])(implicit reader: ClientResponseReader[JsonSuccess]): Future[JsonSuccess] = {
    // create path and map variables
    val path = (addFmt("/realm/profile_fields"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (order == null) throw new Exception("Missing required parameter 'order' when calling ServerAndOrganizationsApi->reorderCustomProfileFields")
    queryParams += "order" -> order.toString

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def updateLinkifier(filterId: Integer,
    pattern: String,
    urlFormatString: String)(implicit reader: ClientResponseReader[JsonSuccess]): Future[JsonSuccess] = {
    // create path and map variables
    val path = (addFmt("/realm/filters/{filter_id}")
      replaceAll("\\{" + "filter_id" + "\\}", filterId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (pattern == null) throw new Exception("Missing required parameter 'pattern' when calling ServerAndOrganizationsApi->updateLinkifier")

    if (urlFormatString == null) throw new Exception("Missing required parameter 'urlFormatString' when calling ServerAndOrganizationsApi->updateLinkifier")

    queryParams += "pattern" -> pattern.toString
    queryParams += "url_format_string" -> urlFormatString.toString

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def uploadCustomEmoji(emojiName: String,
    filename: Option[File] = None
    )(implicit reader: ClientResponseReader[JsonSuccess]): Future[JsonSuccess] = {
    // create path and map variables
    val path = (addFmt("/realm/emoji/{emoji_name}")
      replaceAll("\\{" + "emoji_name" + "\\}", emojiName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (emojiName == null) throw new Exception("Missing required parameter 'emojiName' when calling ServerAndOrganizationsApi->uploadCustomEmoji")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }


}
