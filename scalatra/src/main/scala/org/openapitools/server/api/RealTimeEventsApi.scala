/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: team@openapitools.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 */


package org.openapitools.server.api

import org.openapitools.server.model.BadEventQueueIdError
import org.openapitools.server.model.JsonSuccess
import org.openapitools.server.model.JsonSuccessBase
import org.openapitools.server.model.OneOfInvalidApiKeyErrorMissingArgumentErrorUserNotAuthorizedError
import org.openapitools.server.model.OneOfRateLimitedError
import org.openapitools.server.model.OneOfUserDeactivatedErrorRealmDeactivatedError

import java.io.File

import org.scalatra.ScalatraServlet
import org.scalatra.swagger._
import org.json4s._
import org.json4s.JsonDSL._
import org.scalatra.json.{ JValueResult, JacksonJsonSupport }
import org.scalatra.servlet.{ FileUploadSupport, MultipartConfig, SizeConstraintExceededException }

import scala.collection.JavaConverters._

class RealTimeEventsApi(implicit val swagger: Swagger) extends ScalatraServlet
  with FileUploadSupport
  with JacksonJsonSupport
  with SwaggerSupport {
  protected implicit val jsonFormats: Formats = DefaultFormats

  protected val applicationDescription: String = "RealTimeEventsApi"

  before() {
    contentType = formats("json")
    response.headers += ("Access-Control-Allow-Origin" -> "*")
  }
  

  val deleteQueueOperation = (apiOperation[JsonSuccess]("deleteQueue")
    summary "Delete an event queue"
    parameters(queryParam[String]("queueId").description(""))
  )

  delete("/events", operation(deleteQueueOperation)) {
            val queueId = params.getAs[String]("queueId")

    //println("queueId: " + queueId)
  }

  

  val getEventsOperation = (apiOperation[JsonSuccessBase]("getEvents")
    summary "Get events from an event queue"
    parameters(queryParam[String]("queueId").description(""), queryParam[Int]("lastEventId").description("").optional, queryParam[Boolean]("dontBlock").description("").optional.defaultValue(false))
  )

  get("/events", operation(getEventsOperation)) {
            val queueId = params.getAs[String]("queueId")

    //println("queueId: " + queueId)
            val lastEventId = params.getAs[Int]("lastEventId")

    //println("lastEventId: " + lastEventId)
            val dontBlock = params.getAs[Boolean]("dontBlock")

    //println("dontBlock: " + dontBlock)
  }

  

  val realTimePostOperation = (apiOperation[Unit]("realTimePost")
    summary ""
    parameters(queryParam[List[String]]("eventTypes").description("").optional.defaultValue(List.empty[String] ), queryParam[List[List[String]]]("narrow").description("").optional.defaultValue([]), queryParam[Boolean]("allPublicStreams").description("").optional.defaultValue(false))
  )

  post("/real-time", operation(realTimePostOperation)) {
        val eventTypesString = params.getAs[String]("eventTypes")
    val eventTypes = if("multi" == "default" || "multi" == "csv") {
      eventTypesString match {
        case Some(str) => str.split(",").toSeq
        case None => Seq()
      }
    } else
      Seq()

    //println("eventTypes: " + eventTypes)
        val narrowString = params.getAs[String]("narrow")
    val narrow = if("multi" == "default" || "multi" == "csv") {
      narrowString match {
        case Some(str) => str.split(",").toSeq
        case None => Seq()
      }
    } else
      Seq()

    //println("narrow: " + narrow)
            val allPublicStreams = params.getAs[Boolean]("allPublicStreams")

    //println("allPublicStreams: " + allPublicStreams)
  }

  

  val registerQueueOperation = (apiOperation[JsonSuccessBase]("registerQueue")
    summary "Register an event queue"
    parameters(queryParam[Boolean]("applyMarkdown").description("").optional.defaultValue(false), queryParam[Boolean]("clientGravatar").description("").optional.defaultValue(false), queryParam[Boolean]("slimPresence").description("").optional.defaultValue(false), queryParam[List[String]]("eventTypes").description("").optional.defaultValue(List.empty[String] ), queryParam[Boolean]("allPublicStreams").description("").optional.defaultValue(false), queryParam[Boolean]("includeSubscribers").description("").optional.defaultValue(false), queryParam[Any]("clientCapabilities").description("").optional, queryParam[List[String]]("fetchEventTypes").description("").optional.defaultValue(List.empty[String] ), queryParam[List[List[String]]]("narrow").description("").optional.defaultValue([]))
  )

  post("/register", operation(registerQueueOperation)) {
            val applyMarkdown = params.getAs[Boolean]("applyMarkdown")

    //println("applyMarkdown: " + applyMarkdown)
            val clientGravatar = params.getAs[Boolean]("clientGravatar")

    //println("clientGravatar: " + clientGravatar)
            val slimPresence = params.getAs[Boolean]("slimPresence")

    //println("slimPresence: " + slimPresence)
        val eventTypesString = params.getAs[String]("eventTypes")
    val eventTypes = if("multi" == "default" || "multi" == "csv") {
      eventTypesString match {
        case Some(str) => str.split(",").toSeq
        case None => Seq()
      }
    } else
      Seq()

    //println("eventTypes: " + eventTypes)
            val allPublicStreams = params.getAs[Boolean]("allPublicStreams")

    //println("allPublicStreams: " + allPublicStreams)
            val includeSubscribers = params.getAs[Boolean]("includeSubscribers")

    //println("includeSubscribers: " + includeSubscribers)
            val clientCapabilities = params.getAs[Any]("clientCapabilities")

    //println("clientCapabilities: " + clientCapabilities)
        val fetchEventTypesString = params.getAs[String]("fetchEventTypes")
    val fetchEventTypes = if("multi" == "default" || "multi" == "csv") {
      fetchEventTypesString match {
        case Some(str) => str.split(",").toSeq
        case None => Seq()
      }
    } else
      Seq()

    //println("fetchEventTypes: " + fetchEventTypes)
        val narrowString = params.getAs[String]("narrow")
    val narrow = if("multi" == "default" || "multi" == "csv") {
      narrowString match {
        case Some(str) => str.split(",").toSeq
        case None => Seq()
      }
    } else
      Seq()

    //println("narrow: " + narrow)
  }

  

  val restErrorHandlingOperation = (apiOperation[Unit]("restErrorHandling")
    summary "Error handling"
    parameters()
  )

  post("/rest-error-handling", operation(restErrorHandlingOperation)) {
  }

}
