/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: team@openapitools.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 */


package org.openapitools.server.api

import org.openapitools.server.model.AnyType
import org.openapitools.server.model.CodedError
import java.io.File
import org.openapitools.server.model.InvalidMessageError
import org.openapitools.server.model.JsonSuccess
import org.openapitools.server.model.JsonSuccessBase
import org.openapitools.server.model.OneOfobjectobject
import org.openapitools.server.model.OneOfstringinteger

import java.io.File

import org.scalatra.ScalatraServlet
import org.scalatra.swagger._
import org.json4s._
import org.json4s.JsonDSL._
import org.scalatra.json.{ JValueResult, JacksonJsonSupport }
import org.scalatra.servlet.{ FileUploadSupport, MultipartConfig, SizeConstraintExceededException }

import scala.collection.JavaConverters._

class MessagesApi(implicit val swagger: Swagger) extends ScalatraServlet
  with FileUploadSupport
  with JacksonJsonSupport
  with SwaggerSupport {
  protected implicit val jsonFormats: Formats = DefaultFormats

  protected val applicationDescription: String = "MessagesApi"

  before() {
    contentType = formats("json")
    response.headers += ("Access-Control-Allow-Origin" -> "*")
  }
  

  val addReactionOperation = (apiOperation[JsonSuccess]("addReaction")
    summary "Add an emoji reaction"
    parameters(pathParam[Int]("messageId").description(""), queryParam[String]("emojiName").description(""), queryParam[String]("emojiCode").description("").optional, queryParam[String]("reactionType").description("").optional)
  )

  post("/messages/:message_id/reactions", operation(addReactionOperation)) {
    val messageId = params.getOrElse("messageId", halt(400))
    //println("messageId: " + messageId)
            val emojiName = params.getAs[String]("emojiName")

    //println("emojiName: " + emojiName)
            val emojiCode = params.getAs[String]("emojiCode")

    //println("emojiCode: " + emojiCode)
            val reactionType = params.getAs[String]("reactionType")

    //println("reactionType: " + reactionType)
  }

  

  val checkMessagesMatchNarrowOperation = (apiOperation[AnyType]("checkMessagesMatchNarrow")
    summary "Check if messages match a narrow"
    parameters(queryParam[List[Int]]("msgIds").description("").defaultValue(List.empty[Int] ), queryParam[List[Any]]("narrow").description("").defaultValue(List.empty[Any] ))
  )

  get("/messages/matches_narrow", operation(checkMessagesMatchNarrowOperation)) {
        val msgIdsString = params.getAs[String]("msgIds")
    val msgIds = if("multi" == "default" || "multi" == "csv") {
      msgIdsString match {
        case Some(str) => str.split(",").toSeq
        case None => Seq()
      }
    } else
      Seq()

    //println("msgIds: " + msgIds)
        val narrowString = params.getAs[String]("narrow")
    val narrow = if("multi" == "default" || "multi" == "csv") {
      narrowString match {
        case Some(str) => str.split(",").toSeq
        case None => Seq()
      }
    } else
      Seq()

    //println("narrow: " + narrow)
  }

  

  val deleteMessageOperation = (apiOperation[JsonSuccess]("deleteMessage")
    summary "Delete a message"
    parameters(pathParam[Int]("messageId").description(""))
  )

  delete("/messages/:message_id", operation(deleteMessageOperation)) {
    val messageId = params.getOrElse("messageId", halt(400))
    //println("messageId: " + messageId)
  }

  

  val getFileTemporaryUrlOperation = (apiOperation[JsonSuccessBase]("getFileTemporaryUrl")
    summary "Get public temporary URL"
    parameters(pathParam[Int]("realmIdStr").description(""), pathParam[String]("filename").description(""))
  )

  get("/user_uploads/:realm_id_str/:filename", operation(getFileTemporaryUrlOperation)) {
    val realmIdStr = params.getOrElse("realmIdStr", halt(400))
    //println("realmIdStr: " + realmIdStr)
    val filename = params.getOrElse("filename", halt(400))
    //println("filename: " + filename)
  }

  

  val getMessageHistoryOperation = (apiOperation[JsonSuccessBase]("getMessageHistory")
    summary "Get a message's edit history"
    parameters(pathParam[Int]("messageId").description(""))
  )

  get("/messages/:message_id/history", operation(getMessageHistoryOperation)) {
    val messageId = params.getOrElse("messageId", halt(400))
    //println("messageId: " + messageId)
  }

  

  val getMessagesOperation = (apiOperation[JsonSuccessBase]("getMessages")
    summary "Get messages"
    parameters(queryParam[Int]("numBefore").description(""), queryParam[Int]("numAfter").description(""), queryParam[OneOfstringinteger]("anchor").description("").optional, queryParam[List[Any]]("narrow").description("").optional.defaultValue([]), queryParam[Boolean]("clientGravatar").description("").optional.defaultValue(false), queryParam[Boolean]("applyMarkdown").description("").optional.defaultValue(true), queryParam[Boolean]("useFirstUnreadAnchor").description("").optional.defaultValue(false))
  )

  get("/messages", operation(getMessagesOperation)) {
            val numBefore = params.getAs[Int]("numBefore")

    //println("numBefore: " + numBefore)
            val numAfter = params.getAs[Int]("numAfter")

    //println("numAfter: " + numAfter)
            val anchor = params.getAs[OneOfstringinteger]("anchor")

    //println("anchor: " + anchor)
        val narrowString = params.getAs[String]("narrow")
    val narrow = if("multi" == "default" || "multi" == "csv") {
      narrowString match {
        case Some(str) => str.split(",").toSeq
        case None => Seq()
      }
    } else
      Seq()

    //println("narrow: " + narrow)
            val clientGravatar = params.getAs[Boolean]("clientGravatar")

    //println("clientGravatar: " + clientGravatar)
            val applyMarkdown = params.getAs[Boolean]("applyMarkdown")

    //println("applyMarkdown: " + applyMarkdown)
            val useFirstUnreadAnchor = params.getAs[Boolean]("useFirstUnreadAnchor")

    //println("useFirstUnreadAnchor: " + useFirstUnreadAnchor)
  }

  

  val getRawMessageOperation = (apiOperation[JsonSuccessBase]("getRawMessage")
    summary "Get a message's raw Markdown"
    parameters(pathParam[Int]("messageId").description(""))
  )

  get("/messages/:message_id", operation(getRawMessageOperation)) {
    val messageId = params.getOrElse("messageId", halt(400))
    //println("messageId: " + messageId)
  }

  

  val markAllAsReadOperation = (apiOperation[JsonSuccess]("markAllAsRead")
    summary "Mark all messages as read"
    parameters()
  )

  post("/mark_all_as_read", operation(markAllAsReadOperation)) {
  }

  

  val markStreamAsReadOperation = (apiOperation[JsonSuccess]("markStreamAsRead")
    summary "Mark messages in a stream as read"
    parameters(queryParam[Int]("streamId").description(""))
  )

  post("/mark_stream_as_read", operation(markStreamAsReadOperation)) {
            val streamId = params.getAs[Int]("streamId")

    //println("streamId: " + streamId)
  }

  

  val markTopicAsReadOperation = (apiOperation[JsonSuccess]("markTopicAsRead")
    summary "Mark messages in a topic as read"
    parameters(queryParam[Int]("streamId").description(""), queryParam[String]("topicName").description(""))
  )

  post("/mark_topic_as_read", operation(markTopicAsReadOperation)) {
            val streamId = params.getAs[Int]("streamId")

    //println("streamId: " + streamId)
            val topicName = params.getAs[String]("topicName")

    //println("topicName: " + topicName)
  }

  

  val removeReactionOperation = (apiOperation[JsonSuccess]("removeReaction")
    summary "Remove an emoji reaction"
    parameters(pathParam[Int]("messageId").description(""), queryParam[String]("emojiName").description("").optional, queryParam[String]("emojiCode").description("").optional, queryParam[String]("reactionType").description("").optional)
  )

  delete("/messages/:message_id/reactions", operation(removeReactionOperation)) {
    val messageId = params.getOrElse("messageId", halt(400))
    //println("messageId: " + messageId)
            val emojiName = params.getAs[String]("emojiName")

    //println("emojiName: " + emojiName)
            val emojiCode = params.getAs[String]("emojiCode")

    //println("emojiCode: " + emojiCode)
            val reactionType = params.getAs[String]("reactionType")

    //println("reactionType: " + reactionType)
  }

  

  val renderMessageOperation = (apiOperation[JsonSuccessBase]("renderMessage")
    summary "Render message"
    parameters(queryParam[String]("content").description(""))
  )

  post("/messages/render", operation(renderMessageOperation)) {
            val content = params.getAs[String]("content")

    //println("content: " + content)
  }

  

  val sendMessageOperation = (apiOperation[JsonSuccessBase]("sendMessage")
    summary "Send a message"
    parameters(queryParam[String]("`type`").description(""), queryParam[List[Int]]("to").description("").defaultValue(List.empty[Int] ), queryParam[String]("content").description(""), queryParam[String]("topic").description("").optional, queryParam[String]("queueId").description("").optional, queryParam[String]("localId").description("").optional)
  )

  post("/messages", operation(sendMessageOperation)) {
            val `type` = params.getAs[String]("`type`")

    //println("`type`: " + `type`)
        val toString = params.getAs[String]("to")
    val to = if("multi" == "default" || "multi" == "csv") {
      toString match {
        case Some(str) => str.split(",").toSeq
        case None => Seq()
      }
    } else
      Seq()

    //println("to: " + to)
            val content = params.getAs[String]("content")

    //println("content: " + content)
            val topic = params.getAs[String]("topic")

    //println("topic: " + topic)
            val queueId = params.getAs[String]("queueId")

    //println("queueId: " + queueId)
            val localId = params.getAs[String]("localId")

    //println("localId: " + localId)
  }

  

  val updateMessageOperation = (apiOperation[JsonSuccess]("updateMessage")
    summary "Edit a message"
    parameters(pathParam[Int]("messageId").description(""), queryParam[String]("topic").description("").optional, queryParam[String]("propagateMode").description("").optional.defaultValue(change_one), queryParam[Boolean]("sendNotificationToOldThread").description("").optional.defaultValue(true), queryParam[Boolean]("sendNotificationToNewThread").description("").optional.defaultValue(true), queryParam[String]("content").description("").optional, queryParam[Int]("streamId").description("").optional)
  )

  patch("/messages/:message_id", operation(updateMessageOperation)) {
    val messageId = params.getOrElse("messageId", halt(400))
    //println("messageId: " + messageId)
            val topic = params.getAs[String]("topic")

    //println("topic: " + topic)
            val propagateMode = params.getAs[String]("propagateMode")

    //println("propagateMode: " + propagateMode)
            val sendNotificationToOldThread = params.getAs[Boolean]("sendNotificationToOldThread")

    //println("sendNotificationToOldThread: " + sendNotificationToOldThread)
            val sendNotificationToNewThread = params.getAs[Boolean]("sendNotificationToNewThread")

    //println("sendNotificationToNewThread: " + sendNotificationToNewThread)
            val content = params.getAs[String]("content")

    //println("content: " + content)
            val streamId = params.getAs[Int]("streamId")

    //println("streamId: " + streamId)
  }

  

  val updateMessageFlagsOperation = (apiOperation[JsonSuccessBase]("updateMessageFlags")
    summary "Update personal message flags"
    parameters(queryParam[List[Int]]("messages").description("").defaultValue(List.empty[Int] ), queryParam[String]("op").description(""), queryParam[String]("flag").description(""))
  )

  post("/messages/flags", operation(updateMessageFlagsOperation)) {
        val messagesString = params.getAs[String]("messages")
    val messages = if("multi" == "default" || "multi" == "csv") {
      messagesString match {
        case Some(str) => str.split(",").toSeq
        case None => Seq()
      }
    } else
      Seq()

    //println("messages: " + messages)
            val op = params.getAs[String]("op")

    //println("op: " + op)
            val flag = params.getAs[String]("flag")

    //println("flag: " + flag)
  }

  

  val uploadFileOperation = (apiOperation[JsonSuccessBase]("uploadFile")
    summary "Upload a file"
    parameters(formParam[File]("filename").description("").optional)
  )

  post("/user_uploads", operation(uploadFileOperation)) {
    val filename = fileParams("filename")
    //println("filename: " + filename)
  }

}
