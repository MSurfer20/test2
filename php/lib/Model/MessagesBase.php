<?php
/**
 * MessagesBase
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Zulip REST API
 *
 * Powerful open source group chat
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.2.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * MessagesBase Class Doc Comment
 *
 * @category Class
 * @description Object containing details of the message.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null
 */
class MessagesBase implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'MessagesBase';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'avatar_url' => 'string',
        'client' => 'string',
        'content' => 'string',
        'content_type' => 'string',
        'display_recipient' => 'OneOfStringArray',
        'id' => 'int',
        'is_me_message' => 'bool',
        'reactions' => '\OpenAPI\Client\Model\EmojiReaction[]',
        'recipient_id' => 'int',
        'sender_email' => 'string',
        'sender_full_name' => 'string',
        'sender_id' => 'int',
        'sender_realm_str' => 'string',
        'stream_id' => 'int',
        'subject' => 'string',
        'topic_links' => '\OpenAPI\Client\Model\MessagesBaseTopicLinks[]',
        'submessages' => 'string[]',
        'timestamp' => 'int',
        'type' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'avatar_url' => null,
        'client' => null,
        'content' => null,
        'content_type' => null,
        'display_recipient' => null,
        'id' => null,
        'is_me_message' => null,
        'reactions' => null,
        'recipient_id' => null,
        'sender_email' => null,
        'sender_full_name' => null,
        'sender_id' => null,
        'sender_realm_str' => null,
        'stream_id' => null,
        'subject' => null,
        'topic_links' => null,
        'submessages' => null,
        'timestamp' => null,
        'type' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'avatar_url' => 'avatar_url',
        'client' => 'client',
        'content' => 'content',
        'content_type' => 'content_type',
        'display_recipient' => 'display_recipient',
        'id' => 'id',
        'is_me_message' => 'is_me_message',
        'reactions' => 'reactions',
        'recipient_id' => 'recipient_id',
        'sender_email' => 'sender_email',
        'sender_full_name' => 'sender_full_name',
        'sender_id' => 'sender_id',
        'sender_realm_str' => 'sender_realm_str',
        'stream_id' => 'stream_id',
        'subject' => 'subject',
        'topic_links' => 'topic_links',
        'submessages' => 'submessages',
        'timestamp' => 'timestamp',
        'type' => 'type'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'avatar_url' => 'setAvatarUrl',
        'client' => 'setClient',
        'content' => 'setContent',
        'content_type' => 'setContentType',
        'display_recipient' => 'setDisplayRecipient',
        'id' => 'setId',
        'is_me_message' => 'setIsMeMessage',
        'reactions' => 'setReactions',
        'recipient_id' => 'setRecipientId',
        'sender_email' => 'setSenderEmail',
        'sender_full_name' => 'setSenderFullName',
        'sender_id' => 'setSenderId',
        'sender_realm_str' => 'setSenderRealmStr',
        'stream_id' => 'setStreamId',
        'subject' => 'setSubject',
        'topic_links' => 'setTopicLinks',
        'submessages' => 'setSubmessages',
        'timestamp' => 'setTimestamp',
        'type' => 'setType'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'avatar_url' => 'getAvatarUrl',
        'client' => 'getClient',
        'content' => 'getContent',
        'content_type' => 'getContentType',
        'display_recipient' => 'getDisplayRecipient',
        'id' => 'getId',
        'is_me_message' => 'getIsMeMessage',
        'reactions' => 'getReactions',
        'recipient_id' => 'getRecipientId',
        'sender_email' => 'getSenderEmail',
        'sender_full_name' => 'getSenderFullName',
        'sender_id' => 'getSenderId',
        'sender_realm_str' => 'getSenderRealmStr',
        'stream_id' => 'getStreamId',
        'subject' => 'getSubject',
        'topic_links' => 'getTopicLinks',
        'submessages' => 'getSubmessages',
        'timestamp' => 'getTimestamp',
        'type' => 'getType'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['avatar_url'] = $data['avatar_url'] ?? null;
        $this->container['client'] = $data['client'] ?? null;
        $this->container['content'] = $data['content'] ?? null;
        $this->container['content_type'] = $data['content_type'] ?? null;
        $this->container['display_recipient'] = $data['display_recipient'] ?? null;
        $this->container['id'] = $data['id'] ?? null;
        $this->container['is_me_message'] = $data['is_me_message'] ?? null;
        $this->container['reactions'] = $data['reactions'] ?? null;
        $this->container['recipient_id'] = $data['recipient_id'] ?? null;
        $this->container['sender_email'] = $data['sender_email'] ?? null;
        $this->container['sender_full_name'] = $data['sender_full_name'] ?? null;
        $this->container['sender_id'] = $data['sender_id'] ?? null;
        $this->container['sender_realm_str'] = $data['sender_realm_str'] ?? null;
        $this->container['stream_id'] = $data['stream_id'] ?? null;
        $this->container['subject'] = $data['subject'] ?? null;
        $this->container['topic_links'] = $data['topic_links'] ?? null;
        $this->container['submessages'] = $data['submessages'] ?? null;
        $this->container['timestamp'] = $data['timestamp'] ?? null;
        $this->container['type'] = $data['type'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets avatar_url
     *
     * @return string|null
     */
    public function getAvatarUrl()
    {
        return $this->container['avatar_url'];
    }

    /**
     * Sets avatar_url
     *
     * @param string|null $avatar_url The URL of the user's avatar.  Can be null only if client_gravatar was passed, which means that the user has not uploaded an avatar in Zulip, and the client should compute the gravatar URL by hashing the user's email address itself for this user.
     *
     * @return self
     */
    public function setAvatarUrl($avatar_url)
    {
        $this->container['avatar_url'] = $avatar_url;

        return $this;
    }

    /**
     * Gets client
     *
     * @return string|null
     */
    public function getClient()
    {
        return $this->container['client'];
    }

    /**
     * Sets client
     *
     * @param string|null $client A Zulip \"client\" string, describing what Zulip client sent the message.
     *
     * @return self
     */
    public function setClient($client)
    {
        $this->container['client'] = $client;

        return $this;
    }

    /**
     * Gets content
     *
     * @return string|null
     */
    public function getContent()
    {
        return $this->container['content'];
    }

    /**
     * Sets content
     *
     * @param string|null $content The content/body of the message.
     *
     * @return self
     */
    public function setContent($content)
    {
        $this->container['content'] = $content;

        return $this;
    }

    /**
     * Gets content_type
     *
     * @return string|null
     */
    public function getContentType()
    {
        return $this->container['content_type'];
    }

    /**
     * Sets content_type
     *
     * @param string|null $content_type The HTTP `content_type` for the message content.  This will be `text/html` or `text/x-markdown`, depending on whether `apply_markdown` was set.
     *
     * @return self
     */
    public function setContentType($content_type)
    {
        $this->container['content_type'] = $content_type;

        return $this;
    }

    /**
     * Gets display_recipient
     *
     * @return OneOfStringArray|null
     */
    public function getDisplayRecipient()
    {
        return $this->container['display_recipient'];
    }

    /**
     * Sets display_recipient
     *
     * @param OneOfStringArray|null $display_recipient Data on the recipient of the message; either the name of a stream or a dictionary containing basic data on the users who received the message.
     *
     * @return self
     */
    public function setDisplayRecipient($display_recipient)
    {
        $this->container['display_recipient'] = $display_recipient;

        return $this;
    }

    /**
     * Gets id
     *
     * @return int|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int|null $id The unique message ID.  Messages should always be displayed sorted by ID.
     *
     * @return self
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets is_me_message
     *
     * @return bool|null
     */
    public function getIsMeMessage()
    {
        return $this->container['is_me_message'];
    }

    /**
     * Sets is_me_message
     *
     * @param bool|null $is_me_message Whether the message is a [/me status message][status-messages]  [status-messages]: /help/format-your-message-using-markdown#status-messages
     *
     * @return self
     */
    public function setIsMeMessage($is_me_message)
    {
        $this->container['is_me_message'] = $is_me_message;

        return $this;
    }

    /**
     * Gets reactions
     *
     * @return \OpenAPI\Client\Model\EmojiReaction[]|null
     */
    public function getReactions()
    {
        return $this->container['reactions'];
    }

    /**
     * Sets reactions
     *
     * @param \OpenAPI\Client\Model\EmojiReaction[]|null $reactions Data on any reactions to the message.
     *
     * @return self
     */
    public function setReactions($reactions)
    {
        $this->container['reactions'] = $reactions;

        return $this;
    }

    /**
     * Gets recipient_id
     *
     * @return int|null
     */
    public function getRecipientId()
    {
        return $this->container['recipient_id'];
    }

    /**
     * Sets recipient_id
     *
     * @param int|null $recipient_id A unique ID for the set of users receiving the message (either a stream or group of users).  Useful primarily for hashing.
     *
     * @return self
     */
    public function setRecipientId($recipient_id)
    {
        $this->container['recipient_id'] = $recipient_id;

        return $this;
    }

    /**
     * Gets sender_email
     *
     * @return string|null
     */
    public function getSenderEmail()
    {
        return $this->container['sender_email'];
    }

    /**
     * Sets sender_email
     *
     * @param string|null $sender_email The Zulip display email address of the message's sender.
     *
     * @return self
     */
    public function setSenderEmail($sender_email)
    {
        $this->container['sender_email'] = $sender_email;

        return $this;
    }

    /**
     * Gets sender_full_name
     *
     * @return string|null
     */
    public function getSenderFullName()
    {
        return $this->container['sender_full_name'];
    }

    /**
     * Sets sender_full_name
     *
     * @param string|null $sender_full_name The full name of the message's sender.
     *
     * @return self
     */
    public function setSenderFullName($sender_full_name)
    {
        $this->container['sender_full_name'] = $sender_full_name;

        return $this;
    }

    /**
     * Gets sender_id
     *
     * @return int|null
     */
    public function getSenderId()
    {
        return $this->container['sender_id'];
    }

    /**
     * Sets sender_id
     *
     * @param int|null $sender_id The user ID of the message's sender.
     *
     * @return self
     */
    public function setSenderId($sender_id)
    {
        $this->container['sender_id'] = $sender_id;

        return $this;
    }

    /**
     * Gets sender_realm_str
     *
     * @return string|null
     */
    public function getSenderRealmStr()
    {
        return $this->container['sender_realm_str'];
    }

    /**
     * Sets sender_realm_str
     *
     * @param string|null $sender_realm_str A string identifier for the realm the sender is in.  Unique only within the context of a given Zulip server.  E.g. on `example.zulip.com`, this will be `example`.
     *
     * @return self
     */
    public function setSenderRealmStr($sender_realm_str)
    {
        $this->container['sender_realm_str'] = $sender_realm_str;

        return $this;
    }

    /**
     * Gets stream_id
     *
     * @return int|null
     */
    public function getStreamId()
    {
        return $this->container['stream_id'];
    }

    /**
     * Sets stream_id
     *
     * @param int|null $stream_id Only present for stream messages; the ID of the stream.
     *
     * @return self
     */
    public function setStreamId($stream_id)
    {
        $this->container['stream_id'] = $stream_id;

        return $this;
    }

    /**
     * Gets subject
     *
     * @return string|null
     */
    public function getSubject()
    {
        return $this->container['subject'];
    }

    /**
     * Sets subject
     *
     * @param string|null $subject The `topic` of the message.  Currently always `\"\"` for private messages, though this could change if Zulip adds support for topics in private message conversations.  The field name is a legacy holdover from when topics were called \"subjects\" and will eventually change.
     *
     * @return self
     */
    public function setSubject($subject)
    {
        $this->container['subject'] = $subject;

        return $this;
    }

    /**
     * Gets topic_links
     *
     * @return \OpenAPI\Client\Model\MessagesBaseTopicLinks[]|null
     */
    public function getTopicLinks()
    {
        return $this->container['topic_links'];
    }

    /**
     * Sets topic_links
     *
     * @param \OpenAPI\Client\Model\MessagesBaseTopicLinks[]|null $topic_links Data on any links to be included in the `topic` line (these are generated by [custom linkification filters](/help/add-a-custom-linkifier) that match content in the message's topic.)  **Changes**: This field contained a list of urls before   Zulip 4.0 (feature level 46).  New in Zulip 3.0 (feature level 1): Previously, this field was called `subject_links`; clients are recommended to rename `subject_links` to `topic_links` if present for compatibility with older Zulip servers.
     *
     * @return self
     */
    public function setTopicLinks($topic_links)
    {
        $this->container['topic_links'] = $topic_links;

        return $this;
    }

    /**
     * Gets submessages
     *
     * @return string[]|null
     */
    public function getSubmessages()
    {
        return $this->container['submessages'];
    }

    /**
     * Sets submessages
     *
     * @param string[]|null $submessages Data used for certain experimental Zulip integrations.
     *
     * @return self
     */
    public function setSubmessages($submessages)
    {
        $this->container['submessages'] = $submessages;

        return $this;
    }

    /**
     * Gets timestamp
     *
     * @return int|null
     */
    public function getTimestamp()
    {
        return $this->container['timestamp'];
    }

    /**
     * Sets timestamp
     *
     * @param int|null $timestamp The UNIX timestamp for when the message was sent, in UTC seconds.
     *
     * @return self
     */
    public function setTimestamp($timestamp)
    {
        $this->container['timestamp'] = $timestamp;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string|null
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string|null $type The type of the message: `stream` or `private`.
     *
     * @return self
     */
    public function setType($type)
    {
        $this->container['type'] = $type;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


