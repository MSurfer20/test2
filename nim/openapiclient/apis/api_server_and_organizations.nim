#
# Zulip REST API
# 
# Powerful open source group chat 
# The version of the OpenAPI document: 1.0.0
# 
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_json_success
import ../models/model_json_success_base
import ../models/model_object

const basepath = "https://example.zulipchat.com/api/v1"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      when name(stripGenericParams(T.typedesc).typedesc) == name(Table):
        (some(json.to(parseJson(response.body), T.typedesc)), response)
      else:
        (some(marshal.to[T](response.body)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc addCodePlayground*(httpClient: HttpClient, name: string, pygmentsLanguage: string, urlPrefix: string): (Option[JsonSuccessBase], Response) =
  ## Add a code playground
  let query_for_api_call = encodeQuery([
    ("name", $name), # The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language. 
    ("pygments_language", $pygmentsLanguage), # The name of the Pygments language lexer for that programming language. 
    ("url_prefix", $urlPrefix), # The url prefix for the playground. 
  ])

  let response = httpClient.post(basepath & "/realm/playgrounds" & "?" & query_for_api_call)
  constructResult[JsonSuccessBase](response)


proc addLinkifier*(httpClient: HttpClient, pattern: string, urlFormatString: string): (Option[JsonSuccessBase], Response) =
  ## Add a linkifier
  let query_for_api_call = encodeQuery([
    ("pattern", $pattern), # The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
    ("url_format_string", $urlFormatString), # The URL used for the link. If you used named groups for the `pattern`, you can insert their content here with `%(name_of_the_capturing_group)s`. 
  ])

  let response = httpClient.post(basepath & "/realm/filters" & "?" & query_for_api_call)
  constructResult[JsonSuccessBase](response)


proc createCustomProfileField*(httpClient: HttpClient, fieldType: int, name: string, hint: string, fieldData: object): (Option[JsonSuccessBase], Response) =
  ## Create a custom profile field
  let query_for_api_call = encodeQuery([
    ("name", $name), # The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user's profile. 
    ("hint", $hint), # The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
    ("field_type", $fieldType), # The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/add-custom-profile-fields) more details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
    ("field_data", $fieldData), # Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the `field_data` attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
  ])

  let response = httpClient.post(basepath & "/realm/profile_fields" & "?" & query_for_api_call)
  constructResult[JsonSuccessBase](response)


proc getCustomEmoji*(httpClient: HttpClient): (Option[JsonSuccessBase], Response) =
  ## Get all custom emoji

  let response = httpClient.get(basepath & "/realm/emoji")
  constructResult[JsonSuccessBase](response)


proc getCustomProfileFields*(httpClient: HttpClient): (Option[JsonSuccessBase], Response) =
  ## Get all custom profile fields

  let response = httpClient.get(basepath & "/realm/profile_fields")
  constructResult[JsonSuccessBase](response)


proc getLinkifiers*(httpClient: HttpClient): (Option[JsonSuccessBase], Response) =
  ## Get linkifiers

  let response = httpClient.get(basepath & "/realm/linkifiers")
  constructResult[JsonSuccessBase](response)


proc getServerSettings*(httpClient: HttpClient): (Option[JsonSuccessBase], Response) =
  ## Get server settings

  let response = httpClient.get(basepath & "/server_settings")
  constructResult[JsonSuccessBase](response)


proc removeCodePlayground*(httpClient: HttpClient, playgroundId: int): (Option[JsonSuccess], Response) =
  ## Remove a code playground

  let response = httpClient.delete(basepath & fmt"/realm/playgrounds/{playground_id}")
  constructResult[JsonSuccess](response)


proc removeLinkifier*(httpClient: HttpClient, filterId: int): (Option[JsonSuccess], Response) =
  ## Remove a linkifier

  let response = httpClient.delete(basepath & fmt"/realm/filters/{filter_id}")
  constructResult[JsonSuccess](response)


proc reorderCustomProfileFields*(httpClient: HttpClient, order: seq[int]): (Option[JsonSuccess], Response) =
  ## Reorder custom profile fields
  let query_for_api_call = encodeQuery([
    ("order", $order.join(",")), # A list of the IDs of all the custom profile fields defined in this organization, in the desired new order. 
  ])

  let response = httpClient.patch(basepath & "/realm/profile_fields" & "?" & query_for_api_call)
  constructResult[JsonSuccess](response)


proc updateLinkifier*(httpClient: HttpClient, filterId: int, pattern: string, urlFormatString: string): (Option[JsonSuccess], Response) =
  ## Update a linkifier
  let query_for_api_call = encodeQuery([
    ("pattern", $pattern), # The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
    ("url_format_string", $urlFormatString), # The URL used for the link. If you used named groups for the `pattern`, you can insert their content here with `%(name_of_the_capturing_group)s`. 
  ])

  let response = httpClient.patch(basepath & fmt"/realm/filters/{filter_id}" & "?" & query_for_api_call)
  constructResult[JsonSuccess](response)


proc uploadCustomEmoji*(httpClient: HttpClient, emojiName: string, filename: string): (Option[JsonSuccess], Response) =
  ## Upload custom emoji
  httpClient.headers["Content-Type"] = "multipart/form-data"
  let query_for_api_call = newMultipartData({
    "filename": $filename, # 
  })

  let response = httpClient.post(basepath & fmt"/realm/emoji/{emoji_name}", multipart=query_for_api_call)
  constructResult[JsonSuccess](response)

