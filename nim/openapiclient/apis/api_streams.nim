#
# Zulip REST API
# 
# Powerful open source group chat 
# The version of the OpenAPI document: 1.0.0
# 
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_coded_error
import ../models/model_json_error
import ../models/model_json_success
import ../models/model_json_success_base
import ../models/model_non_existing_stream_error
import ../models/model_object
import ../models/model_one_of&lt;object,object&gt;
import ../models/model_one_of&lt;string,integer&gt;

const basepath = "https://example.zulipchat.com/api/v1"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      when name(stripGenericParams(T.typedesc).typedesc) == name(Table):
        (some(json.to(parseJson(response.body), T.typedesc)), response)
      else:
        (some(marshal.to[T](response.body)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc archiveStream*(httpClient: HttpClient, streamId: int): (Option[JsonSuccess], Response) =
  ## Archive a stream

  let response = httpClient.delete(basepath & fmt"/streams/{stream_id}")
  constructResult[JsonSuccess](response)


proc createBigBlueButtonVideoCall*(httpClient: HttpClient): (Option[JsonSuccessBase], Response) =
  ## Create BigBlueButton video call

  let response = httpClient.get(basepath & "/calls/bigbluebutton/create")
  constructResult[JsonSuccessBase](response)


proc deleteTopic*(httpClient: HttpClient, streamId: int, topicName: string): (Option[JsonSuccess], Response) =
  ## Delete a topic
  let query_for_api_call = encodeQuery([
    ("topic_name", $topicName), # The name of the topic to delete. 
  ])

  let response = httpClient.post(basepath & fmt"/streams/{stream_id}/delete_topic" & "?" & query_for_api_call)
  constructResult[JsonSuccess](response)


proc getStreamId*(httpClient: HttpClient, stream: string): (Option[JsonSuccessBase], Response) =
  ## Get stream ID
  let query_for_api_call = encodeQuery([
    ("stream", $stream), # The name of the stream to access. 
  ])

  let response = httpClient.get(basepath & "/get_stream_id" & "?" & query_for_api_call)
  constructResult[JsonSuccessBase](response)


proc getStreamTopics*(httpClient: HttpClient, streamId: int): (Option[JsonSuccessBase], Response) =
  ## Get topics in a stream

  let response = httpClient.get(basepath & fmt"/users/me/{stream_id}/topics")
  constructResult[JsonSuccessBase](response)


proc getStreams*(httpClient: HttpClient, includePublic: bool, includeWebPublic: bool, includeSubscribed: bool, includeAllActive: bool, includeDefault: bool, includeOwnerSubscribed: bool): (Option[JsonSuccessBase], Response) =
  ## Get all streams
  let query_for_api_call = encodeQuery([
    ("include_public", $includePublic), # Include all public streams. 
    ("include_web_public", $includeWebPublic), # Include all web public streams. 
    ("include_subscribed", $includeSubscribed), # Include all streams that the user is subscribed to. 
    ("include_all_active", $includeAllActive), # Include all active streams. The user must have administrative privileges to use this parameter. 
    ("include_default", $includeDefault), # Include all default streams for the user's realm. 
    ("include_owner_subscribed", $includeOwnerSubscribed), # If the user is a bot, include all streams that the bot's owner is subscribed to. 
  ])

  let response = httpClient.get(basepath & "/streams" & "?" & query_for_api_call)
  constructResult[JsonSuccessBase](response)


proc getSubscribers*(httpClient: HttpClient, streamId: int): (Option[JsonSuccessBase], Response) =
  ## Get the subscribers of a stream

  let response = httpClient.get(basepath & fmt"/streams/{stream_id}/members")
  constructResult[JsonSuccessBase](response)


proc getSubscriptionStatus*(httpClient: HttpClient, userId: int, streamId: int): (Option[JsonSuccessBase], Response) =
  ## Get subscription status

  let response = httpClient.get(basepath & fmt"/users/{user_id}/subscriptions/{stream_id}")
  constructResult[JsonSuccessBase](response)


proc getSubscriptions*(httpClient: HttpClient, includeSubscribers: bool): (Option[JsonSuccessBase], Response) =
  ## Get subscribed streams
  let query_for_api_call = encodeQuery([
    ("include_subscribers", $includeSubscribers), # Whether each returned stream object should include a `subscribers` field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
  ])

  let response = httpClient.get(basepath & "/users/me/subscriptions" & "?" & query_for_api_call)
  constructResult[JsonSuccessBase](response)


proc muteTopic*(httpClient: HttpClient, topic: string, op: string, stream: string, streamId: int): (Option[JsonSuccess], Response) =
  ## Topic muting
  let query_for_api_call = encodeQuery([
    ("stream", $stream), # The name of the stream to access. 
    ("stream_id", $streamId), # The ID of the stream to access. 
    ("topic", $topic), # The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. 
    ("op", $op), # Whether to mute (`add`) or unmute (`remove`) the provided topic. 
  ])

  let response = httpClient.patch(basepath & "/users/me/subscriptions/muted_topics" & "?" & query_for_api_call)
  constructResult[JsonSuccess](response)


proc subscribe*(httpClient: HttpClient, subscriptions: seq[object], principals: seq[oneOf<string,integer>], authorizationErrorsFatal: bool, announce: bool, inviteOnly: bool, historyPublicToSubscribers: bool, streamPostPolicy: int, messageRetentionDays: oneOf<string,integer>): (Option[oneOf<object,object>], Response) =
  ## Subscribe to a stream
  let query_for_api_call = encodeQuery([
    ("subscriptions", $subscriptions.join(",")), # A list of dictionaries containing the key `name` and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key `description` with an appropriate value. 
    ("principals", $principals.join(",")), # A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the `subscriptions` parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
    ("authorization_errors_fatal", $authorizationErrorsFatal), # A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When `True`, an authorization error is reported as such. When set to `False`, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the `unauthorized` key. 
    ("announce", $announce), # If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream's creation. 
    ("invite_only", $inviteOnly), # As described above, this endpoint will create a new stream if passed a stream name that doesn't already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams. 
    ("history_public_to_subscribers", $historyPublicToSubscribers), # Whether the stream's message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
    ("stream_post_policy", $streamPostPolicy), # Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
    ("message_retention_days", $messageRetentionDays), # Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \"realm_default\" => Return to the organization-level setting. * \"forever\" => Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
  ])

  let response = httpClient.post(basepath & "/users/me/subscriptions" & "?" & query_for_api_call)
  constructResult[oneOf<object,object>](response)


proc unsubscribe*(httpClient: HttpClient, subscriptions: seq[string], principals: seq[oneOf<string,integer>]): (Option[JsonSuccessBase], Response) =
  ## Unsubscribe from a stream
  let query_for_api_call = encodeQuery([
    ("subscriptions", $subscriptions.join(",")), # A list of stream names to unsubscribe from. This parameter is called `streams` in our Python API. 
    ("principals", $principals.join(",")), # A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the `subscriptions` parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
  ])

  let response = httpClient.delete(basepath & "/users/me/subscriptions" & "?" & query_for_api_call)
  constructResult[JsonSuccessBase](response)


proc updateStream*(httpClient: HttpClient, streamId: int, description: string, newName: string, isPrivate: bool, isAnnouncementOnly: bool, streamPostPolicy: int, historyPublicToSubscribers: bool, messageRetentionDays: oneOf<string,integer>): (Option[JsonSuccess], Response) =
  ## Update a stream
  let query_for_api_call = encodeQuery([
    ("description", $description), # The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
    ("new_name", $newName), # The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
    ("is_private", $isPrivate), # Change whether the stream is a private stream. 
    ("is_announcement_only", $isAnnouncementOnly), # Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   `stream_post_policy` instead. 
    ("stream_post_policy", $streamPostPolicy), # Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
    ("history_public_to_subscribers", $historyPublicToSubscribers), # Whether the stream's message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
    ("message_retention_days", $messageRetentionDays), # Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \"realm_default\" => Return to the organization-level setting. * \"forever\" => Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
  ])

  let response = httpClient.patch(basepath & fmt"/streams/{stream_id}" & "?" & query_for_api_call)
  constructResult[JsonSuccess](response)


proc updateSubscriptionSettings*(httpClient: HttpClient, subscriptionData: seq[object]): (Option[JsonSuccessBase], Response) =
  ## Update subscription settings
  let query_for_api_call = encodeQuery([
    ("subscription_data", $subscriptionData.join(",")), # A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a `stream_id` key that identifies the stream, as well as the `property` being modified and its new `value`.  The possible values for each `property` and `value` pairs are:  * `color` (string): the hex value of the user's display color for the stream. * `is_muted` (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named `in_home_view` (with the   opposite value, `in_home_view=!is_muted`); for   backwards-compatibility, modern Zulip still accepts that value. * `pin_to_top` (boolean): whether to pin the stream at the top of the stream list. * `desktop_notifications` (boolean): whether to show desktop notifications     for all messages sent to the stream. * `audible_notifications` (boolean): whether to play a sound   notification for all messages sent to the stream. * `push_notifications` (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * `email_notifications` (boolean): whether to trigger an email     notification for all messages sent to the stream. 
  ])

  let response = httpClient.post(basepath & "/users/me/subscriptions/properties" & "?" & query_for_api_call)
  constructResult[JsonSuccessBase](response)


proc updateSubscriptions*(httpClient: HttpClient, delete: seq[string], add: seq[object]): (Option[JsonSuccessBase], Response) =
  ## Update subscriptions
  let query_for_api_call = encodeQuery([
    ("delete", $delete.join(",")), # A list of stream names to unsubscribe from. 
    ("add", $add.join(",")), # A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description. 
  ])

  let response = httpClient.patch(basepath & "/users/me/subscriptions" & "?" & query_for_api_call)
  constructResult[JsonSuccessBase](response)

