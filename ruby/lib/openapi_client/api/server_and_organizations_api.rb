=begin
#Zulip REST API

#Powerful open source group chat 

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 5.2.0

=end

require 'cgi'

module OpenapiClient
  class ServerAndOrganizationsApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Add a code playground
    # Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  `POST {{ api_url }}/v1/realm/playgrounds`  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
    # @param name [String] The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language. 
    # @param pygments_language [String] The name of the Pygments language lexer for that programming language. 
    # @param url_prefix [String] The url prefix for the playground. 
    # @param [Hash] opts the optional parameters
    # @return [JsonSuccessBase]
    def add_code_playground(name, pygments_language, url_prefix, opts = {})
      data, _status_code, _headers = add_code_playground_with_http_info(name, pygments_language, url_prefix, opts)
      data
    end

    # Add a code playground
    # Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  &#x60;POST {{ api_url }}/v1/realm/playgrounds&#x60;  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
    # @param name [String] The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language. 
    # @param pygments_language [String] The name of the Pygments language lexer for that programming language. 
    # @param url_prefix [String] The url prefix for the playground. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def add_code_playground_with_http_info(name, pygments_language, url_prefix, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.add_code_playground ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling ServerAndOrganizationsApi.add_code_playground"
      end
      # verify the required parameter 'pygments_language' is set
      if @api_client.config.client_side_validation && pygments_language.nil?
        fail ArgumentError, "Missing the required parameter 'pygments_language' when calling ServerAndOrganizationsApi.add_code_playground"
      end
      # verify the required parameter 'url_prefix' is set
      if @api_client.config.client_side_validation && url_prefix.nil?
        fail ArgumentError, "Missing the required parameter 'url_prefix' when calling ServerAndOrganizationsApi.add_code_playground"
      end
      # resource path
      local_var_path = '/realm/playgrounds'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'name'] = name
      query_params[:'pygments_language'] = pygments_language
      query_params[:'url_prefix'] = url_prefix

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccessBase'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.add_code_playground",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#add_code_playground\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a linkifier
    # Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `POST {{ api_url }}/v1/realm/filters` 
    # @param pattern [String] The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
    # @param url_format_string [String] The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
    # @param [Hash] opts the optional parameters
    # @return [JsonSuccessBase]
    def add_linkifier(pattern, url_format_string, opts = {})
      data, _status_code, _headers = add_linkifier_with_http_info(pattern, url_format_string, opts)
      data
    end

    # Add a linkifier
    # Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;POST {{ api_url }}/v1/realm/filters&#x60; 
    # @param pattern [String] The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
    # @param url_format_string [String] The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def add_linkifier_with_http_info(pattern, url_format_string, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.add_linkifier ...'
      end
      # verify the required parameter 'pattern' is set
      if @api_client.config.client_side_validation && pattern.nil?
        fail ArgumentError, "Missing the required parameter 'pattern' when calling ServerAndOrganizationsApi.add_linkifier"
      end
      # verify the required parameter 'url_format_string' is set
      if @api_client.config.client_side_validation && url_format_string.nil?
        fail ArgumentError, "Missing the required parameter 'url_format_string' when calling ServerAndOrganizationsApi.add_linkifier"
      end
      # resource path
      local_var_path = '/realm/filters'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pattern'] = pattern
      query_params[:'url_format_string'] = url_format_string

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccessBase'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.add_linkifier",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#add_linkifier\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a custom profile field
    # [Create a custom profile field](/help/add-custom-profile-fields) in the user's organization.  `POST {{ api_url }}/v1/realm/profile_fields` 
    # @param field_type [Integer] The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/add-custom-profile-fields) more details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :name The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user&#39;s profile. 
    # @option opts [String] :hint The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
    # @option opts [Object] :field_data Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the &#x60;field_data&#x60; attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
    # @return [JsonSuccessBase]
    def create_custom_profile_field(field_type, opts = {})
      data, _status_code, _headers = create_custom_profile_field_with_http_info(field_type, opts)
      data
    end

    # Create a custom profile field
    # [Create a custom profile field](/help/add-custom-profile-fields) in the user&#39;s organization.  &#x60;POST {{ api_url }}/v1/realm/profile_fields&#x60; 
    # @param field_type [Integer] The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/add-custom-profile-fields) more details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :name The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user&#39;s profile. 
    # @option opts [String] :hint The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
    # @option opts [Object] :field_data Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the &#x60;field_data&#x60; attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def create_custom_profile_field_with_http_info(field_type, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.create_custom_profile_field ...'
      end
      # verify the required parameter 'field_type' is set
      if @api_client.config.client_side_validation && field_type.nil?
        fail ArgumentError, "Missing the required parameter 'field_type' when calling ServerAndOrganizationsApi.create_custom_profile_field"
      end
      # resource path
      local_var_path = '/realm/profile_fields'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'field_type'] = field_type
      query_params[:'name'] = opts[:'name'] if !opts[:'name'].nil?
      query_params[:'hint'] = opts[:'hint'] if !opts[:'hint'].nil?
      query_params[:'field_data'] = opts[:'field_data'] if !opts[:'field_data'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccessBase'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.create_custom_profile_field",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#create_custom_profile_field\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get all custom emoji
    # Get all the custom emoji in the user's organization.  `GET {{ api_url }}/v1/realm/emoji` 
    # @param [Hash] opts the optional parameters
    # @return [JsonSuccessBase]
    def get_custom_emoji(opts = {})
      data, _status_code, _headers = get_custom_emoji_with_http_info(opts)
      data
    end

    # Get all custom emoji
    # Get all the custom emoji in the user&#39;s organization.  &#x60;GET {{ api_url }}/v1/realm/emoji&#x60; 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_custom_emoji_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.get_custom_emoji ...'
      end
      # resource path
      local_var_path = '/realm/emoji'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccessBase'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.get_custom_emoji",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#get_custom_emoji\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get all custom profile fields
    # Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user's organization.  `GET {{ api_url }}/v1/realm/profile_fields` 
    # @param [Hash] opts the optional parameters
    # @return [JsonSuccessBase]
    def get_custom_profile_fields(opts = {})
      data, _status_code, _headers = get_custom_profile_fields_with_http_info(opts)
      data
    end

    # Get all custom profile fields
    # Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user&#39;s organization.  &#x60;GET {{ api_url }}/v1/realm/profile_fields&#x60; 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_custom_profile_fields_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.get_custom_profile_fields ...'
      end
      # resource path
      local_var_path = '/realm/profile_fields'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccessBase'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.get_custom_profile_fields",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#get_custom_profile_fields\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get linkifiers
    # List all of an organization's configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `GET {{ api_url }}/v1/realm/linkifiers`  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar `GET /realm/filters` endpoint was available with each entry in a `[pattern, url_format, id]` tuple format. 
    # @param [Hash] opts the optional parameters
    # @return [JsonSuccessBase]
    def get_linkifiers(opts = {})
      data, _status_code, _headers = get_linkifiers_with_http_info(opts)
      data
    end

    # Get linkifiers
    # List all of an organization&#39;s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;GET {{ api_url }}/v1/realm/linkifiers&#x60;  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar &#x60;GET /realm/filters&#x60; endpoint was available with each entry in a &#x60;[pattern, url_format, id]&#x60; tuple format. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_linkifiers_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.get_linkifiers ...'
      end
      # resource path
      local_var_path = '/realm/linkifiers'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccessBase'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.get_linkifiers",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#get_linkifiers\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get server settings
    # Fetch global settings for a Zulip server.  `GET {{ api_url }}/v1/server_settings`  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it's running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
    # @param [Hash] opts the optional parameters
    # @return [JsonSuccessBase]
    def get_server_settings(opts = {})
      data, _status_code, _headers = get_server_settings_with_http_info(opts)
      data
    end

    # Get server settings
    # Fetch global settings for a Zulip server.  &#x60;GET {{ api_url }}/v1/server_settings&#x60;  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it&#39;s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JsonSuccessBase, Integer, Hash)>] JsonSuccessBase data, response status code and response headers
    def get_server_settings_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.get_server_settings ...'
      end
      # resource path
      local_var_path = '/server_settings'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccessBase'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.get_server_settings",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#get_server_settings\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Remove a code playground
    # Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  `DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}`  **Changes**: New in Zulip 4.0 (feature level 49). 
    # @param playground_id [Integer] The ID of the playground that you want to remove. 
    # @param [Hash] opts the optional parameters
    # @return [JsonSuccess]
    def remove_code_playground(playground_id, opts = {})
      data, _status_code, _headers = remove_code_playground_with_http_info(playground_id, opts)
      data
    end

    # Remove a code playground
    # Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  &#x60;DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}&#x60;  **Changes**: New in Zulip 4.0 (feature level 49). 
    # @param playground_id [Integer] The ID of the playground that you want to remove. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def remove_code_playground_with_http_info(playground_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.remove_code_playground ...'
      end
      # verify the required parameter 'playground_id' is set
      if @api_client.config.client_side_validation && playground_id.nil?
        fail ArgumentError, "Missing the required parameter 'playground_id' when calling ServerAndOrganizationsApi.remove_code_playground"
      end
      # resource path
      local_var_path = '/realm/playgrounds/{playground_id}'.sub('{' + 'playground_id' + '}', CGI.escape(playground_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccess'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.remove_code_playground",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#remove_code_playground\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Remove a linkifier
    # Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `DELETE {{ api_url }}/v1/realm/filters/{filter_id}` 
    # @param filter_id [Integer] The ID of the linkifier that you want to remove. 
    # @param [Hash] opts the optional parameters
    # @return [JsonSuccess]
    def remove_linkifier(filter_id, opts = {})
      data, _status_code, _headers = remove_linkifier_with_http_info(filter_id, opts)
      data
    end

    # Remove a linkifier
    # Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;DELETE {{ api_url }}/v1/realm/filters/{filter_id}&#x60; 
    # @param filter_id [Integer] The ID of the linkifier that you want to remove. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def remove_linkifier_with_http_info(filter_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.remove_linkifier ...'
      end
      # verify the required parameter 'filter_id' is set
      if @api_client.config.client_side_validation && filter_id.nil?
        fail ArgumentError, "Missing the required parameter 'filter_id' when calling ServerAndOrganizationsApi.remove_linkifier"
      end
      # resource path
      local_var_path = '/realm/filters/{filter_id}'.sub('{' + 'filter_id' + '}', CGI.escape(filter_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccess'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.remove_linkifier",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#remove_linkifier\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Reorder custom profile fields
    # Reorder the custom profile fields in the user's organization.  `PATCH {{ api_url }}/v1/realm/profile_fields`  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
    # @param order [Array<Integer>] A list of the IDs of all the custom profile fields defined in this organization, in the desired new order. 
    # @param [Hash] opts the optional parameters
    # @return [JsonSuccess]
    def reorder_custom_profile_fields(order, opts = {})
      data, _status_code, _headers = reorder_custom_profile_fields_with_http_info(order, opts)
      data
    end

    # Reorder custom profile fields
    # Reorder the custom profile fields in the user&#39;s organization.  &#x60;PATCH {{ api_url }}/v1/realm/profile_fields&#x60;  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
    # @param order [Array<Integer>] A list of the IDs of all the custom profile fields defined in this organization, in the desired new order. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def reorder_custom_profile_fields_with_http_info(order, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.reorder_custom_profile_fields ...'
      end
      # verify the required parameter 'order' is set
      if @api_client.config.client_side_validation && order.nil?
        fail ArgumentError, "Missing the required parameter 'order' when calling ServerAndOrganizationsApi.reorder_custom_profile_fields"
      end
      # resource path
      local_var_path = '/realm/profile_fields'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'order'] = @api_client.build_collection_param(order, :multi)

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccess'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.reorder_custom_profile_fields",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#reorder_custom_profile_fields\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a linkifier
    # Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `PATCH {{ api_url }}/v1/realm/filters/{filter_id}`  **Changes**: New in Zulip 4.0 (feature level 57). 
    # @param filter_id [Integer] The ID of the linkifier that you want to update. 
    # @param pattern [String] The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
    # @param url_format_string [String] The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
    # @param [Hash] opts the optional parameters
    # @return [JsonSuccess]
    def update_linkifier(filter_id, pattern, url_format_string, opts = {})
      data, _status_code, _headers = update_linkifier_with_http_info(filter_id, pattern, url_format_string, opts)
      data
    end

    # Update a linkifier
    # Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;PATCH {{ api_url }}/v1/realm/filters/{filter_id}&#x60;  **Changes**: New in Zulip 4.0 (feature level 57). 
    # @param filter_id [Integer] The ID of the linkifier that you want to update. 
    # @param pattern [String] The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
    # @param url_format_string [String] The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def update_linkifier_with_http_info(filter_id, pattern, url_format_string, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.update_linkifier ...'
      end
      # verify the required parameter 'filter_id' is set
      if @api_client.config.client_side_validation && filter_id.nil?
        fail ArgumentError, "Missing the required parameter 'filter_id' when calling ServerAndOrganizationsApi.update_linkifier"
      end
      # verify the required parameter 'pattern' is set
      if @api_client.config.client_side_validation && pattern.nil?
        fail ArgumentError, "Missing the required parameter 'pattern' when calling ServerAndOrganizationsApi.update_linkifier"
      end
      # verify the required parameter 'url_format_string' is set
      if @api_client.config.client_side_validation && url_format_string.nil?
        fail ArgumentError, "Missing the required parameter 'url_format_string' when calling ServerAndOrganizationsApi.update_linkifier"
      end
      # resource path
      local_var_path = '/realm/filters/{filter_id}'.sub('{' + 'filter_id' + '}', CGI.escape(filter_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'pattern'] = pattern
      query_params[:'url_format_string'] = url_format_string

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccess'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.update_linkifier",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#update_linkifier\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upload custom emoji
    # This endpoint is used to upload a custom emoji for use in the user's organization.  Access to this endpoint depends on the [organization's configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  `POST {{ api_url }}/v1/realm/emoji/{emoji_name}` 
    # @param emoji_name [String] The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (_) are treated the same as spaces (consistent with how the Zulip UI handles emoji). 
    # @param [Hash] opts the optional parameters
    # @option opts [File] :filename 
    # @return [JsonSuccess]
    def upload_custom_emoji(emoji_name, opts = {})
      data, _status_code, _headers = upload_custom_emoji_with_http_info(emoji_name, opts)
      data
    end

    # Upload custom emoji
    # This endpoint is used to upload a custom emoji for use in the user&#39;s organization.  Access to this endpoint depends on the [organization&#39;s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  &#x60;POST {{ api_url }}/v1/realm/emoji/{emoji_name}&#x60; 
    # @param emoji_name [String] The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (_) are treated the same as spaces (consistent with how the Zulip UI handles emoji). 
    # @param [Hash] opts the optional parameters
    # @option opts [File] :filename 
    # @return [Array<(JsonSuccess, Integer, Hash)>] JsonSuccess data, response status code and response headers
    def upload_custom_emoji_with_http_info(emoji_name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ServerAndOrganizationsApi.upload_custom_emoji ...'
      end
      # verify the required parameter 'emoji_name' is set
      if @api_client.config.client_side_validation && emoji_name.nil?
        fail ArgumentError, "Missing the required parameter 'emoji_name' when calling ServerAndOrganizationsApi.upload_custom_emoji"
      end
      # resource path
      local_var_path = '/realm/emoji/{emoji_name}'.sub('{' + 'emoji_name' + '}', CGI.escape(emoji_name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['filename'] = opts[:'filename'] if !opts[:'filename'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JsonSuccess'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"ServerAndOrganizationsApi.upload_custom_emoji",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ServerAndOrganizationsApi#upload_custom_emoji\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
