/**
* Zulip REST API
* Powerful open source group chat 
*
* The version of the OpenAPI document: 1.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "StreamsApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string StreamsApi::base = "/api/v1";

StreamsApi::StreamsApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : router(rtr)
{
}

void StreamsApi::init() {
    setupRoutes();
}

void StreamsApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Delete(*router, base + "/streams/:stream_id", Routes::bind(&StreamsApi::archive_stream_handler, this));
    Routes::Get(*router, base + "/calls/bigbluebutton/create", Routes::bind(&StreamsApi::create_big_blue_button_video_call_handler, this));
    Routes::Post(*router, base + "/streams/:stream_id/delete_topic", Routes::bind(&StreamsApi::delete_topic_handler, this));
    Routes::Get(*router, base + "/get_stream_id", Routes::bind(&StreamsApi::get_stream_id_handler, this));
    Routes::Get(*router, base + "/users/me/:stream_id/topics", Routes::bind(&StreamsApi::get_stream_topics_handler, this));
    Routes::Get(*router, base + "/streams", Routes::bind(&StreamsApi::get_streams_handler, this));
    Routes::Get(*router, base + "/streams/:stream_id/members", Routes::bind(&StreamsApi::get_subscribers_handler, this));
    Routes::Get(*router, base + "/users/:user_id/subscriptions/:stream_id", Routes::bind(&StreamsApi::get_subscription_status_handler, this));
    Routes::Get(*router, base + "/users/me/subscriptions", Routes::bind(&StreamsApi::get_subscriptions_handler, this));
    Routes::Patch(*router, base + "/users/me/subscriptions/muted_topics", Routes::bind(&StreamsApi::mute_topic_handler, this));
    Routes::Post(*router, base + "/users/me/subscriptions", Routes::bind(&StreamsApi::subscribe_handler, this));
    Routes::Delete(*router, base + "/users/me/subscriptions", Routes::bind(&StreamsApi::unsubscribe_handler, this));
    Routes::Patch(*router, base + "/streams/:stream_id", Routes::bind(&StreamsApi::update_stream_handler, this));
    Routes::Post(*router, base + "/users/me/subscriptions/properties", Routes::bind(&StreamsApi::update_subscription_settings_handler, this));
    Routes::Patch(*router, base + "/users/me/subscriptions", Routes::bind(&StreamsApi::update_subscriptions_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&StreamsApi::streams_api_default_handler, this));
}

std::pair<Pistache::Http::Code, std::string> StreamsApi::handleParsingException(const std::exception& ex) const noexcept
{
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what())
    }
}

std::pair<Pistache::Http::Code, std::string> StreamsApi::handleOperationException(const std::exception& ex) const noexcept
{
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void StreamsApi::archive_stream_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto streamId = request.param(":streamId").as<int32_t>();
    
    try {
        this->archive_stream(streamId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::create_big_blue_button_video_call_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    try {


    try {
        this->create_big_blue_button_video_call(response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::delete_topic_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto streamId = request.param(":streamId").as<int32_t>();
    
    // Getting the query params
    auto topicNameQuery = request.query().get("topic_name");
    Pistache::Optional<std::string> topicName;
    if(!topicNameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(topicNameQuery.get(), valueQuery_instance)){
            topicName = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->delete_topic(streamId, topicName, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::get_stream_id_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto streamQuery = request.query().get("stream");
    Pistache::Optional<std::string> stream;
    if(!streamQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(streamQuery.get(), valueQuery_instance)){
            stream = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->get_stream_id(stream, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::get_stream_topics_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto streamId = request.param(":streamId").as<int32_t>();
    
    try {
        this->get_stream_topics(streamId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::get_streams_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto includePublicQuery = request.query().get("include_public");
    Pistache::Optional<bool> includePublic;
    if(!includePublicQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(includePublicQuery.get(), valueQuery_instance)){
            includePublic = Pistache::Some(valueQuery_instance);
        }
    }
    auto includeWebPublicQuery = request.query().get("include_web_public");
    Pistache::Optional<bool> includeWebPublic;
    if(!includeWebPublicQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(includeWebPublicQuery.get(), valueQuery_instance)){
            includeWebPublic = Pistache::Some(valueQuery_instance);
        }
    }
    auto includeSubscribedQuery = request.query().get("include_subscribed");
    Pistache::Optional<bool> includeSubscribed;
    if(!includeSubscribedQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(includeSubscribedQuery.get(), valueQuery_instance)){
            includeSubscribed = Pistache::Some(valueQuery_instance);
        }
    }
    auto includeAllActiveQuery = request.query().get("include_all_active");
    Pistache::Optional<bool> includeAllActive;
    if(!includeAllActiveQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(includeAllActiveQuery.get(), valueQuery_instance)){
            includeAllActive = Pistache::Some(valueQuery_instance);
        }
    }
    auto includeDefaultQuery = request.query().get("include_default");
    Pistache::Optional<bool> includeDefault;
    if(!includeDefaultQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(includeDefaultQuery.get(), valueQuery_instance)){
            includeDefault = Pistache::Some(valueQuery_instance);
        }
    }
    auto includeOwnerSubscribedQuery = request.query().get("include_owner_subscribed");
    Pistache::Optional<bool> includeOwnerSubscribed;
    if(!includeOwnerSubscribedQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(includeOwnerSubscribedQuery.get(), valueQuery_instance)){
            includeOwnerSubscribed = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->get_streams(includePublic, includeWebPublic, includeSubscribed, includeAllActive, includeDefault, includeOwnerSubscribed, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::get_subscribers_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto streamId = request.param(":streamId").as<int32_t>();
    
    try {
        this->get_subscribers(streamId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::get_subscription_status_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto userId = request.param(":userId").as<int32_t>();
    auto streamId = request.param(":streamId").as<int32_t>();
    
    try {
        this->get_subscription_status(userId, streamId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::get_subscriptions_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto includeSubscribersQuery = request.query().get("include_subscribers");
    Pistache::Optional<bool> includeSubscribers;
    if(!includeSubscribersQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(includeSubscribersQuery.get(), valueQuery_instance)){
            includeSubscribers = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->get_subscriptions(includeSubscribers, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::mute_topic_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto streamQuery = request.query().get("stream");
    Pistache::Optional<std::string> stream;
    if(!streamQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(streamQuery.get(), valueQuery_instance)){
            stream = Pistache::Some(valueQuery_instance);
        }
    }
    auto streamIdQuery = request.query().get("stream_id");
    Pistache::Optional<int32_t> streamId;
    if(!streamIdQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(streamIdQuery.get(), valueQuery_instance)){
            streamId = Pistache::Some(valueQuery_instance);
        }
    }
    auto topicQuery = request.query().get("topic");
    Pistache::Optional<std::string> topic;
    if(!topicQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(topicQuery.get(), valueQuery_instance)){
            topic = Pistache::Some(valueQuery_instance);
        }
    }
    auto opQuery = request.query().get("op");
    Pistache::Optional<std::string> op;
    if(!opQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(opQuery.get(), valueQuery_instance)){
            op = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->mute_topic(topic, op, stream, streamId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::subscribe_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto subscriptionsQuery = request.query().get("subscriptions");
    Pistache::Optional<std::vector<Object>> subscriptions;
    if(!subscriptionsQuery.isEmpty()){
        std::vector<Object> valueQuery_instance;
        if(fromStringValue(subscriptionsQuery.get(), valueQuery_instance)){
            subscriptions = Pistache::Some(valueQuery_instance);
        }
    }
    auto principalsQuery = request.query().get("principals");
    Pistache::Optional<std::vector<OneOfstringinteger>> principals;
    if(!principalsQuery.isEmpty()){
        std::vector<OneOfstringinteger> valueQuery_instance;
        if(fromStringValue(principalsQuery.get(), valueQuery_instance)){
            principals = Pistache::Some(valueQuery_instance);
        }
    }
    auto authorizationErrorsFatalQuery = request.query().get("authorization_errors_fatal");
    Pistache::Optional<bool> authorizationErrorsFatal;
    if(!authorizationErrorsFatalQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(authorizationErrorsFatalQuery.get(), valueQuery_instance)){
            authorizationErrorsFatal = Pistache::Some(valueQuery_instance);
        }
    }
    auto announceQuery = request.query().get("announce");
    Pistache::Optional<bool> announce;
    if(!announceQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(announceQuery.get(), valueQuery_instance)){
            announce = Pistache::Some(valueQuery_instance);
        }
    }
    auto inviteOnlyQuery = request.query().get("invite_only");
    Pistache::Optional<bool> inviteOnly;
    if(!inviteOnlyQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(inviteOnlyQuery.get(), valueQuery_instance)){
            inviteOnly = Pistache::Some(valueQuery_instance);
        }
    }
    auto historyPublicToSubscribersQuery = request.query().get("history_public_to_subscribers");
    Pistache::Optional<bool> historyPublicToSubscribers;
    if(!historyPublicToSubscribersQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(historyPublicToSubscribersQuery.get(), valueQuery_instance)){
            historyPublicToSubscribers = Pistache::Some(valueQuery_instance);
        }
    }
    auto streamPostPolicyQuery = request.query().get("stream_post_policy");
    Pistache::Optional<int32_t> streamPostPolicy;
    if(!streamPostPolicyQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(streamPostPolicyQuery.get(), valueQuery_instance)){
            streamPostPolicy = Pistache::Some(valueQuery_instance);
        }
    }
    auto messageRetentionDaysQuery = request.query().get("message_retention_days");
    Pistache::Optional<OneOfstringinteger> messageRetentionDays;
    if(!messageRetentionDaysQuery.isEmpty()){
        OneOfstringinteger valueQuery_instance;
        if(fromStringValue(messageRetentionDaysQuery.get(), valueQuery_instance)){
            messageRetentionDays = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->subscribe(subscriptions, principals, authorizationErrorsFatal, announce, inviteOnly, historyPublicToSubscribers, streamPostPolicy, messageRetentionDays, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::unsubscribe_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto subscriptionsQuery = request.query().get("subscriptions");
    Pistache::Optional<std::vector<std::string>> subscriptions;
    if(!subscriptionsQuery.isEmpty()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(subscriptionsQuery.get(), valueQuery_instance)){
            subscriptions = Pistache::Some(valueQuery_instance);
        }
    }
    auto principalsQuery = request.query().get("principals");
    Pistache::Optional<std::vector<OneOfstringinteger>> principals;
    if(!principalsQuery.isEmpty()){
        std::vector<OneOfstringinteger> valueQuery_instance;
        if(fromStringValue(principalsQuery.get(), valueQuery_instance)){
            principals = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->unsubscribe(subscriptions, principals, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::update_stream_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto streamId = request.param(":streamId").as<int32_t>();
    
    // Getting the query params
    auto descriptionQuery = request.query().get("description");
    Pistache::Optional<std::string> description;
    if(!descriptionQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(descriptionQuery.get(), valueQuery_instance)){
            description = Pistache::Some(valueQuery_instance);
        }
    }
    auto newNameQuery = request.query().get("new_name");
    Pistache::Optional<std::string> newName;
    if(!newNameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(newNameQuery.get(), valueQuery_instance)){
            newName = Pistache::Some(valueQuery_instance);
        }
    }
    auto isPrivateQuery = request.query().get("is_private");
    Pistache::Optional<bool> isPrivate;
    if(!isPrivateQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(isPrivateQuery.get(), valueQuery_instance)){
            isPrivate = Pistache::Some(valueQuery_instance);
        }
    }
    auto isAnnouncementOnlyQuery = request.query().get("is_announcement_only");
    Pistache::Optional<bool> isAnnouncementOnly;
    if(!isAnnouncementOnlyQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(isAnnouncementOnlyQuery.get(), valueQuery_instance)){
            isAnnouncementOnly = Pistache::Some(valueQuery_instance);
        }
    }
    auto streamPostPolicyQuery = request.query().get("stream_post_policy");
    Pistache::Optional<int32_t> streamPostPolicy;
    if(!streamPostPolicyQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(streamPostPolicyQuery.get(), valueQuery_instance)){
            streamPostPolicy = Pistache::Some(valueQuery_instance);
        }
    }
    auto historyPublicToSubscribersQuery = request.query().get("history_public_to_subscribers");
    Pistache::Optional<bool> historyPublicToSubscribers;
    if(!historyPublicToSubscribersQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(historyPublicToSubscribersQuery.get(), valueQuery_instance)){
            historyPublicToSubscribers = Pistache::Some(valueQuery_instance);
        }
    }
    auto messageRetentionDaysQuery = request.query().get("message_retention_days");
    Pistache::Optional<OneOfstringinteger> messageRetentionDays;
    if(!messageRetentionDaysQuery.isEmpty()){
        OneOfstringinteger valueQuery_instance;
        if(fromStringValue(messageRetentionDaysQuery.get(), valueQuery_instance)){
            messageRetentionDays = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->update_stream(streamId, description, newName, isPrivate, isAnnouncementOnly, streamPostPolicy, historyPublicToSubscribers, messageRetentionDays, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::update_subscription_settings_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto subscriptionDataQuery = request.query().get("subscription_data");
    Pistache::Optional<std::vector<Object>> subscriptionData;
    if(!subscriptionDataQuery.isEmpty()){
        std::vector<Object> valueQuery_instance;
        if(fromStringValue(subscriptionDataQuery.get(), valueQuery_instance)){
            subscriptionData = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->update_subscription_settings(subscriptionData, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void StreamsApi::update_subscriptions_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto r_deleteQuery = request.query().get("delete");
    Pistache::Optional<std::vector<std::string>> r_delete;
    if(!r_deleteQuery.isEmpty()){
        std::vector<std::string> valueQuery_instance;
        if(fromStringValue(r_deleteQuery.get(), valueQuery_instance)){
            r_delete = Pistache::Some(valueQuery_instance);
        }
    }
    auto addQuery = request.query().get("add");
    Pistache::Optional<std::vector<Object>> add;
    if(!addQuery.isEmpty()){
        std::vector<Object> valueQuery_instance;
        if(fromStringValue(addQuery.get(), valueQuery_instance)){
            add = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->update_subscriptions(r_delete, add, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}

void StreamsApi::streams_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

