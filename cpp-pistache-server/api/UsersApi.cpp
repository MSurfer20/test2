/**
* Zulip REST API
* Powerful open source group chat 
*
* The version of the OpenAPI document: 1.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "UsersApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string UsersApi::base = "/api/v1";

UsersApi::UsersApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : router(rtr)
{
}

void UsersApi::init() {
    setupRoutes();
}

void UsersApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/users", Routes::bind(&UsersApi::create_user_handler, this));
    Routes::Post(*router, base + "/user_groups/create", Routes::bind(&UsersApi::create_user_group_handler, this));
    Routes::Delete(*router, base + "/users/me", Routes::bind(&UsersApi::deactivate_own_user_handler, this));
    Routes::Delete(*router, base + "/users/:user_id", Routes::bind(&UsersApi::deactivate_user_handler, this));
    Routes::Get(*router, base + "/attachments", Routes::bind(&UsersApi::get_attachments_handler, this));
    Routes::Get(*router, base + "/users/me", Routes::bind(&UsersApi::get_own_user_handler, this));
    Routes::Get(*router, base + "/users/:user_id", Routes::bind(&UsersApi::get_user_handler, this));
    Routes::Get(*router, base + "/users/:email", Routes::bind(&UsersApi::get_user_by_email_handler, this));
    Routes::Get(*router, base + "/user_groups", Routes::bind(&UsersApi::get_user_groups_handler, this));
    Routes::Get(*router, base + "/users/:user_id_or_email/presence", Routes::bind(&UsersApi::get_user_presence_handler, this));
    Routes::Get(*router, base + "/users", Routes::bind(&UsersApi::get_users_handler, this));
    Routes::Post(*router, base + "/users/me/muted_users/:muted_user_id", Routes::bind(&UsersApi::mute_user_handler, this));
    Routes::Post(*router, base + "/users/:user_id/reactivate", Routes::bind(&UsersApi::reactivate_user_handler, this));
    Routes::Delete(*router, base + "/user_groups/:user_group_id", Routes::bind(&UsersApi::remove_user_group_handler, this));
    Routes::Post(*router, base + "/typing", Routes::bind(&UsersApi::set_typing_status_handler, this));
    Routes::Delete(*router, base + "/users/me/muted_users/:muted_user_id", Routes::bind(&UsersApi::unmute_user_handler, this));
    Routes::Patch(*router, base + "/settings", Routes::bind(&UsersApi::update_settings_handler, this));
    Routes::Post(*router, base + "/users/me/status", Routes::bind(&UsersApi::update_status_handler, this));
    Routes::Patch(*router, base + "/users/:user_id", Routes::bind(&UsersApi::update_user_handler, this));
    Routes::Patch(*router, base + "/user_groups/:user_group_id", Routes::bind(&UsersApi::update_user_group_handler, this));
    Routes::Post(*router, base + "/user_groups/:user_group_id/members", Routes::bind(&UsersApi::update_user_group_members_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&UsersApi::users_api_default_handler, this));
}

std::pair<Pistache::Http::Code, std::string> UsersApi::handleParsingException(const std::exception& ex) const noexcept
{
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what())
    }
}

std::pair<Pistache::Http::Code, std::string> UsersApi::handleOperationException(const std::exception& ex) const noexcept
{
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void UsersApi::create_user_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto emailQuery = request.query().get("email");
    Pistache::Optional<std::string> email;
    if(!emailQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(emailQuery.get(), valueQuery_instance)){
            email = Pistache::Some(valueQuery_instance);
        }
    }
    auto passwordQuery = request.query().get("password");
    Pistache::Optional<std::string> password;
    if(!passwordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(passwordQuery.get(), valueQuery_instance)){
            password = Pistache::Some(valueQuery_instance);
        }
    }
    auto fullNameQuery = request.query().get("full_name");
    Pistache::Optional<std::string> fullName;
    if(!fullNameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(fullNameQuery.get(), valueQuery_instance)){
            fullName = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->create_user(email, password, fullName, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::create_user_group_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto nameQuery = request.query().get("name");
    Pistache::Optional<std::string> name;
    if(!nameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(nameQuery.get(), valueQuery_instance)){
            name = Pistache::Some(valueQuery_instance);
        }
    }
    auto descriptionQuery = request.query().get("description");
    Pistache::Optional<std::string> description;
    if(!descriptionQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(descriptionQuery.get(), valueQuery_instance)){
            description = Pistache::Some(valueQuery_instance);
        }
    }
    auto membersQuery = request.query().get("members");
    Pistache::Optional<std::vector<int32_t>> members;
    if(!membersQuery.isEmpty()){
        std::vector<int32_t> valueQuery_instance;
        if(fromStringValue(membersQuery.get(), valueQuery_instance)){
            members = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->create_user_group(name, description, members, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::deactivate_own_user_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    try {


    try {
        this->deactivate_own_user(response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::deactivate_user_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto userId = request.param(":userId").as<int32_t>();
    
    try {
        this->deactivate_user(userId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::get_attachments_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    try {


    try {
        this->get_attachments(response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::get_own_user_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    try {


    try {
        this->get_own_user(response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::get_user_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto userId = request.param(":userId").as<int32_t>();
    
    // Getting the query params
    auto clientGravatarQuery = request.query().get("client_gravatar");
    Pistache::Optional<bool> clientGravatar;
    if(!clientGravatarQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(clientGravatarQuery.get(), valueQuery_instance)){
            clientGravatar = Pistache::Some(valueQuery_instance);
        }
    }
    auto includeCustomProfileFieldsQuery = request.query().get("include_custom_profile_fields");
    Pistache::Optional<bool> includeCustomProfileFields;
    if(!includeCustomProfileFieldsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(includeCustomProfileFieldsQuery.get(), valueQuery_instance)){
            includeCustomProfileFields = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->get_user(userId, clientGravatar, includeCustomProfileFields, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::get_user_by_email_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto email = request.param(":email").as<std::string>();
    
    // Getting the query params
    auto clientGravatarQuery = request.query().get("client_gravatar");
    Pistache::Optional<bool> clientGravatar;
    if(!clientGravatarQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(clientGravatarQuery.get(), valueQuery_instance)){
            clientGravatar = Pistache::Some(valueQuery_instance);
        }
    }
    auto includeCustomProfileFieldsQuery = request.query().get("include_custom_profile_fields");
    Pistache::Optional<bool> includeCustomProfileFields;
    if(!includeCustomProfileFieldsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(includeCustomProfileFieldsQuery.get(), valueQuery_instance)){
            includeCustomProfileFields = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->get_user_by_email(email, clientGravatar, includeCustomProfileFields, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::get_user_groups_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    try {


    try {
        this->get_user_groups(response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::get_user_presence_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto userIdOrEmail = request.param(":userIdOrEmail").as<std::string>();
    
    try {
        this->get_user_presence(userIdOrEmail, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::get_users_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto clientGravatarQuery = request.query().get("client_gravatar");
    Pistache::Optional<bool> clientGravatar;
    if(!clientGravatarQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(clientGravatarQuery.get(), valueQuery_instance)){
            clientGravatar = Pistache::Some(valueQuery_instance);
        }
    }
    auto includeCustomProfileFieldsQuery = request.query().get("include_custom_profile_fields");
    Pistache::Optional<bool> includeCustomProfileFields;
    if(!includeCustomProfileFieldsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(includeCustomProfileFieldsQuery.get(), valueQuery_instance)){
            includeCustomProfileFields = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->get_users(clientGravatar, includeCustomProfileFields, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::mute_user_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto mutedUserId = request.param(":mutedUserId").as<int32_t>();
    
    try {
        this->mute_user(mutedUserId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::reactivate_user_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto userId = request.param(":userId").as<int32_t>();
    
    try {
        this->reactivate_user(userId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::remove_user_group_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto userGroupId = request.param(":userGroupId").as<int32_t>();
    
    try {
        this->remove_user_group(userGroupId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::set_typing_status_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto typeQuery = request.query().get("type");
    Pistache::Optional<std::string> type;
    if(!typeQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(typeQuery.get(), valueQuery_instance)){
            type = Pistache::Some(valueQuery_instance);
        }
    }
    auto opQuery = request.query().get("op");
    Pistache::Optional<std::string> op;
    if(!opQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(opQuery.get(), valueQuery_instance)){
            op = Pistache::Some(valueQuery_instance);
        }
    }
    auto toQuery = request.query().get("to");
    Pistache::Optional<std::vector<int32_t>> to;
    if(!toQuery.isEmpty()){
        std::vector<int32_t> valueQuery_instance;
        if(fromStringValue(toQuery.get(), valueQuery_instance)){
            to = Pistache::Some(valueQuery_instance);
        }
    }
    auto topicQuery = request.query().get("topic");
    Pistache::Optional<std::string> topic;
    if(!topicQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(topicQuery.get(), valueQuery_instance)){
            topic = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->set_typing_status(op, to, type, topic, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::unmute_user_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto mutedUserId = request.param(":mutedUserId").as<int32_t>();
    
    try {
        this->unmute_user(mutedUserId, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::update_settings_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto fullNameQuery = request.query().get("full_name");
    Pistache::Optional<std::string> fullName;
    if(!fullNameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(fullNameQuery.get(), valueQuery_instance)){
            fullName = Pistache::Some(valueQuery_instance);
        }
    }
    auto emailQuery = request.query().get("email");
    Pistache::Optional<std::string> email;
    if(!emailQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(emailQuery.get(), valueQuery_instance)){
            email = Pistache::Some(valueQuery_instance);
        }
    }
    auto oldPasswordQuery = request.query().get("old_password");
    Pistache::Optional<std::string> oldPassword;
    if(!oldPasswordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(oldPasswordQuery.get(), valueQuery_instance)){
            oldPassword = Pistache::Some(valueQuery_instance);
        }
    }
    auto newPasswordQuery = request.query().get("new_password");
    Pistache::Optional<std::string> newPassword;
    if(!newPasswordQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(newPasswordQuery.get(), valueQuery_instance)){
            newPassword = Pistache::Some(valueQuery_instance);
        }
    }
    auto twentyFourHourTimeQuery = request.query().get("twenty_four_hour_time");
    Pistache::Optional<bool> twentyFourHourTime;
    if(!twentyFourHourTimeQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(twentyFourHourTimeQuery.get(), valueQuery_instance)){
            twentyFourHourTime = Pistache::Some(valueQuery_instance);
        }
    }
    auto denseModeQuery = request.query().get("dense_mode");
    Pistache::Optional<bool> denseMode;
    if(!denseModeQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(denseModeQuery.get(), valueQuery_instance)){
            denseMode = Pistache::Some(valueQuery_instance);
        }
    }
    auto starredMessageCountsQuery = request.query().get("starred_message_counts");
    Pistache::Optional<bool> starredMessageCounts;
    if(!starredMessageCountsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(starredMessageCountsQuery.get(), valueQuery_instance)){
            starredMessageCounts = Pistache::Some(valueQuery_instance);
        }
    }
    auto fluidLayoutWidthQuery = request.query().get("fluid_layout_width");
    Pistache::Optional<bool> fluidLayoutWidth;
    if(!fluidLayoutWidthQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(fluidLayoutWidthQuery.get(), valueQuery_instance)){
            fluidLayoutWidth = Pistache::Some(valueQuery_instance);
        }
    }
    auto highContrastModeQuery = request.query().get("high_contrast_mode");
    Pistache::Optional<bool> highContrastMode;
    if(!highContrastModeQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(highContrastModeQuery.get(), valueQuery_instance)){
            highContrastMode = Pistache::Some(valueQuery_instance);
        }
    }
    auto colorSchemeQuery = request.query().get("color_scheme");
    Pistache::Optional<int32_t> colorScheme;
    if(!colorSchemeQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(colorSchemeQuery.get(), valueQuery_instance)){
            colorScheme = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableDraftsSynchronizationQuery = request.query().get("enable_drafts_synchronization");
    Pistache::Optional<bool> enableDraftsSynchronization;
    if(!enableDraftsSynchronizationQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableDraftsSynchronizationQuery.get(), valueQuery_instance)){
            enableDraftsSynchronization = Pistache::Some(valueQuery_instance);
        }
    }
    auto translateEmoticonsQuery = request.query().get("translate_emoticons");
    Pistache::Optional<bool> translateEmoticons;
    if(!translateEmoticonsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(translateEmoticonsQuery.get(), valueQuery_instance)){
            translateEmoticons = Pistache::Some(valueQuery_instance);
        }
    }
    auto defaultLanguageQuery = request.query().get("default_language");
    Pistache::Optional<std::string> defaultLanguage;
    if(!defaultLanguageQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(defaultLanguageQuery.get(), valueQuery_instance)){
            defaultLanguage = Pistache::Some(valueQuery_instance);
        }
    }
    auto defaultViewQuery = request.query().get("default_view");
    Pistache::Optional<std::string> defaultView;
    if(!defaultViewQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(defaultViewQuery.get(), valueQuery_instance)){
            defaultView = Pistache::Some(valueQuery_instance);
        }
    }
    auto leftSideUserlistQuery = request.query().get("left_side_userlist");
    Pistache::Optional<bool> leftSideUserlist;
    if(!leftSideUserlistQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(leftSideUserlistQuery.get(), valueQuery_instance)){
            leftSideUserlist = Pistache::Some(valueQuery_instance);
        }
    }
    auto emojisetQuery = request.query().get("emojiset");
    Pistache::Optional<std::string> emojiset;
    if(!emojisetQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(emojisetQuery.get(), valueQuery_instance)){
            emojiset = Pistache::Some(valueQuery_instance);
        }
    }
    auto demoteInactiveStreamsQuery = request.query().get("demote_inactive_streams");
    Pistache::Optional<int32_t> demoteInactiveStreams;
    if(!demoteInactiveStreamsQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(demoteInactiveStreamsQuery.get(), valueQuery_instance)){
            demoteInactiveStreams = Pistache::Some(valueQuery_instance);
        }
    }
    auto timezoneQuery = request.query().get("timezone");
    Pistache::Optional<std::string> timezone;
    if(!timezoneQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(timezoneQuery.get(), valueQuery_instance)){
            timezone = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableStreamDesktopNotificationsQuery = request.query().get("enable_stream_desktop_notifications");
    Pistache::Optional<bool> enableStreamDesktopNotifications;
    if(!enableStreamDesktopNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableStreamDesktopNotificationsQuery.get(), valueQuery_instance)){
            enableStreamDesktopNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableStreamEmailNotificationsQuery = request.query().get("enable_stream_email_notifications");
    Pistache::Optional<bool> enableStreamEmailNotifications;
    if(!enableStreamEmailNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableStreamEmailNotificationsQuery.get(), valueQuery_instance)){
            enableStreamEmailNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableStreamPushNotificationsQuery = request.query().get("enable_stream_push_notifications");
    Pistache::Optional<bool> enableStreamPushNotifications;
    if(!enableStreamPushNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableStreamPushNotificationsQuery.get(), valueQuery_instance)){
            enableStreamPushNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableStreamAudibleNotificationsQuery = request.query().get("enable_stream_audible_notifications");
    Pistache::Optional<bool> enableStreamAudibleNotifications;
    if(!enableStreamAudibleNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableStreamAudibleNotificationsQuery.get(), valueQuery_instance)){
            enableStreamAudibleNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto notificationSoundQuery = request.query().get("notification_sound");
    Pistache::Optional<std::string> notificationSound;
    if(!notificationSoundQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(notificationSoundQuery.get(), valueQuery_instance)){
            notificationSound = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableDesktopNotificationsQuery = request.query().get("enable_desktop_notifications");
    Pistache::Optional<bool> enableDesktopNotifications;
    if(!enableDesktopNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableDesktopNotificationsQuery.get(), valueQuery_instance)){
            enableDesktopNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableSoundsQuery = request.query().get("enable_sounds");
    Pistache::Optional<bool> enableSounds;
    if(!enableSoundsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableSoundsQuery.get(), valueQuery_instance)){
            enableSounds = Pistache::Some(valueQuery_instance);
        }
    }
    auto emailNotificationsBatchingPeriodSecondsQuery = request.query().get("email_notifications_batching_period_seconds");
    Pistache::Optional<int32_t> emailNotificationsBatchingPeriodSeconds;
    if(!emailNotificationsBatchingPeriodSecondsQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(emailNotificationsBatchingPeriodSecondsQuery.get(), valueQuery_instance)){
            emailNotificationsBatchingPeriodSeconds = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableOfflineEmailNotificationsQuery = request.query().get("enable_offline_email_notifications");
    Pistache::Optional<bool> enableOfflineEmailNotifications;
    if(!enableOfflineEmailNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableOfflineEmailNotificationsQuery.get(), valueQuery_instance)){
            enableOfflineEmailNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableOfflinePushNotificationsQuery = request.query().get("enable_offline_push_notifications");
    Pistache::Optional<bool> enableOfflinePushNotifications;
    if(!enableOfflinePushNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableOfflinePushNotificationsQuery.get(), valueQuery_instance)){
            enableOfflinePushNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableOnlinePushNotificationsQuery = request.query().get("enable_online_push_notifications");
    Pistache::Optional<bool> enableOnlinePushNotifications;
    if(!enableOnlinePushNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableOnlinePushNotificationsQuery.get(), valueQuery_instance)){
            enableOnlinePushNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableDigestEmailsQuery = request.query().get("enable_digest_emails");
    Pistache::Optional<bool> enableDigestEmails;
    if(!enableDigestEmailsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableDigestEmailsQuery.get(), valueQuery_instance)){
            enableDigestEmails = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableMarketingEmailsQuery = request.query().get("enable_marketing_emails");
    Pistache::Optional<bool> enableMarketingEmails;
    if(!enableMarketingEmailsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableMarketingEmailsQuery.get(), valueQuery_instance)){
            enableMarketingEmails = Pistache::Some(valueQuery_instance);
        }
    }
    auto enableLoginEmailsQuery = request.query().get("enable_login_emails");
    Pistache::Optional<bool> enableLoginEmails;
    if(!enableLoginEmailsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enableLoginEmailsQuery.get(), valueQuery_instance)){
            enableLoginEmails = Pistache::Some(valueQuery_instance);
        }
    }
    auto messageContentInEmailNotificationsQuery = request.query().get("message_content_in_email_notifications");
    Pistache::Optional<bool> messageContentInEmailNotifications;
    if(!messageContentInEmailNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(messageContentInEmailNotificationsQuery.get(), valueQuery_instance)){
            messageContentInEmailNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto pmContentInDesktopNotificationsQuery = request.query().get("pm_content_in_desktop_notifications");
    Pistache::Optional<bool> pmContentInDesktopNotifications;
    if(!pmContentInDesktopNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(pmContentInDesktopNotificationsQuery.get(), valueQuery_instance)){
            pmContentInDesktopNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto wildcardMentionsNotifyQuery = request.query().get("wildcard_mentions_notify");
    Pistache::Optional<bool> wildcardMentionsNotify;
    if(!wildcardMentionsNotifyQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(wildcardMentionsNotifyQuery.get(), valueQuery_instance)){
            wildcardMentionsNotify = Pistache::Some(valueQuery_instance);
        }
    }
    auto desktopIconCountDisplayQuery = request.query().get("desktop_icon_count_display");
    Pistache::Optional<int32_t> desktopIconCountDisplay;
    if(!desktopIconCountDisplayQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(desktopIconCountDisplayQuery.get(), valueQuery_instance)){
            desktopIconCountDisplay = Pistache::Some(valueQuery_instance);
        }
    }
    auto realmNameInNotificationsQuery = request.query().get("realm_name_in_notifications");
    Pistache::Optional<bool> realmNameInNotifications;
    if(!realmNameInNotificationsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(realmNameInNotificationsQuery.get(), valueQuery_instance)){
            realmNameInNotifications = Pistache::Some(valueQuery_instance);
        }
    }
    auto presenceEnabledQuery = request.query().get("presence_enabled");
    Pistache::Optional<bool> presenceEnabled;
    if(!presenceEnabledQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(presenceEnabledQuery.get(), valueQuery_instance)){
            presenceEnabled = Pistache::Some(valueQuery_instance);
        }
    }
    auto enterSendsQuery = request.query().get("enter_sends");
    Pistache::Optional<bool> enterSends;
    if(!enterSendsQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(enterSendsQuery.get(), valueQuery_instance)){
            enterSends = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->update_settings(fullName, email, oldPassword, newPassword, twentyFourHourTime, denseMode, starredMessageCounts, fluidLayoutWidth, highContrastMode, colorScheme, enableDraftsSynchronization, translateEmoticons, defaultLanguage, defaultView, leftSideUserlist, emojiset, demoteInactiveStreams, timezone, enableStreamDesktopNotifications, enableStreamEmailNotifications, enableStreamPushNotifications, enableStreamAudibleNotifications, notificationSound, enableDesktopNotifications, enableSounds, emailNotificationsBatchingPeriodSeconds, enableOfflineEmailNotifications, enableOfflinePushNotifications, enableOnlinePushNotifications, enableDigestEmails, enableMarketingEmails, enableLoginEmails, messageContentInEmailNotifications, pmContentInDesktopNotifications, wildcardMentionsNotify, desktopIconCountDisplay, realmNameInNotifications, presenceEnabled, enterSends, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::update_status_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {


    // Getting the query params
    auto statusTextQuery = request.query().get("status_text");
    Pistache::Optional<std::string> statusText;
    if(!statusTextQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(statusTextQuery.get(), valueQuery_instance)){
            statusText = Pistache::Some(valueQuery_instance);
        }
    }
    auto awayQuery = request.query().get("away");
    Pistache::Optional<bool> away;
    if(!awayQuery.isEmpty()){
        bool valueQuery_instance;
        if(fromStringValue(awayQuery.get(), valueQuery_instance)){
            away = Pistache::Some(valueQuery_instance);
        }
    }
    auto emojiNameQuery = request.query().get("emoji_name");
    Pistache::Optional<std::string> emojiName;
    if(!emojiNameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(emojiNameQuery.get(), valueQuery_instance)){
            emojiName = Pistache::Some(valueQuery_instance);
        }
    }
    auto emojiCodeQuery = request.query().get("emoji_code");
    Pistache::Optional<std::string> emojiCode;
    if(!emojiCodeQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(emojiCodeQuery.get(), valueQuery_instance)){
            emojiCode = Pistache::Some(valueQuery_instance);
        }
    }
    auto reactionTypeQuery = request.query().get("reaction_type");
    Pistache::Optional<std::string> reactionType;
    if(!reactionTypeQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(reactionTypeQuery.get(), valueQuery_instance)){
            reactionType = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->update_status(statusText, away, emojiName, emojiCode, reactionType, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::update_user_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto userId = request.param(":userId").as<int32_t>();
    
    // Getting the query params
    auto fullNameQuery = request.query().get("full_name");
    Pistache::Optional<std::string> fullName;
    if(!fullNameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(fullNameQuery.get(), valueQuery_instance)){
            fullName = Pistache::Some(valueQuery_instance);
        }
    }
    auto roleQuery = request.query().get("role");
    Pistache::Optional<int32_t> role;
    if(!roleQuery.isEmpty()){
        int32_t valueQuery_instance;
        if(fromStringValue(roleQuery.get(), valueQuery_instance)){
            role = Pistache::Some(valueQuery_instance);
        }
    }
    auto profileDataQuery = request.query().get("profile_data");
    Pistache::Optional<std::vector<Object>> profileData;
    if(!profileDataQuery.isEmpty()){
        std::vector<Object> valueQuery_instance;
        if(fromStringValue(profileDataQuery.get(), valueQuery_instance)){
            profileData = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->update_user(userId, fullName, role, profileData, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::update_user_group_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto userGroupId = request.param(":userGroupId").as<int32_t>();
    
    // Getting the query params
    auto nameQuery = request.query().get("name");
    Pistache::Optional<std::string> name;
    if(!nameQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(nameQuery.get(), valueQuery_instance)){
            name = Pistache::Some(valueQuery_instance);
        }
    }
    auto descriptionQuery = request.query().get("description");
    Pistache::Optional<std::string> description;
    if(!descriptionQuery.isEmpty()){
        std::string valueQuery_instance;
        if(fromStringValue(descriptionQuery.get(), valueQuery_instance)){
            description = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->update_user_group(userGroupId, name, description, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}
void UsersApi::update_user_group_members_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    try {

    // Getting the path params
    auto userGroupId = request.param(":userGroupId").as<int32_t>();
    
    // Getting the query params
    auto r_deleteQuery = request.query().get("delete");
    Pistache::Optional<std::vector<int32_t>> r_delete;
    if(!r_deleteQuery.isEmpty()){
        std::vector<int32_t> valueQuery_instance;
        if(fromStringValue(r_deleteQuery.get(), valueQuery_instance)){
            r_delete = Pistache::Some(valueQuery_instance);
        }
    }
    auto addQuery = request.query().get("add");
    Pistache::Optional<std::vector<int32_t>> add;
    if(!addQuery.isEmpty()){
        std::vector<int32_t> valueQuery_instance;
        if(fromStringValue(addQuery.get(), valueQuery_instance)){
            add = Pistache::Some(valueQuery_instance);
        }
    }
    
    try {
        this->update_user_group_members(userGroupId, r_delete, add, response);
    } catch (Pistache::Http::HttpError &e) {
        response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
        return;
    } catch (std::exception &e) {
        const std::pair<Pistache::Http::Code, std::string> errorInfo = this->handleOperationException(e);
        response.send(errorInfo.first, errorInfo.second);
        return;
    }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

}

void UsersApi::users_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

