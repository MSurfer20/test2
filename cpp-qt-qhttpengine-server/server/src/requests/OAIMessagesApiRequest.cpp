/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QVariantMap>
#include <QDebug>

#include "OAIHelpers.h"
#include "OAIMessagesApiRequest.h"

namespace OpenAPI {

OAIMessagesApiRequest::OAIMessagesApiRequest(QHttpEngine::Socket *s, QSharedPointer<OAIMessagesApiHandler> hdl) : QObject(s), socket(s), handler(hdl) {
    auto headers = s->headers();
    for(auto itr = headers.begin(); itr != headers.end(); itr++) {
        requestHeaders.insert(QString(itr.key()), QString(itr.value()));
    }
}

OAIMessagesApiRequest::~OAIMessagesApiRequest(){
    disconnect(this, nullptr, nullptr, nullptr);
    qDebug() << "OAIMessagesApiRequest::~OAIMessagesApiRequest()";
}

QMap<QString, QString>
OAIMessagesApiRequest::getRequestHeaders() const {
    return requestHeaders;
}

void OAIMessagesApiRequest::setResponseHeaders(const QMultiMap<QString, QString>& headers){
    for(auto itr = headers.begin(); itr != headers.end(); ++itr) {
        responseHeaders.insert(itr.key(), itr.value());
    }
}


QHttpEngine::Socket* OAIMessagesApiRequest::getRawSocket(){
    return socket;
}


void OAIMessagesApiRequest::addReactionRequest(const QString& message_idstr){
    qDebug() << "/api/v1/messages/{message_id}/reactions";
    connect(this, &OAIMessagesApiRequest::addReaction, handler.data(), &OAIMessagesApiHandler::addReaction);

    
    QString emoji_name;
    if(socket->queryString().keys().contains("emoji_name")){
        fromStringValue(socket->queryString().value("emoji_name"), emoji_name);
    }
    
    QString emoji_code;
    if(socket->queryString().keys().contains("emoji_code")){
        fromStringValue(socket->queryString().value("emoji_code"), emoji_code);
    }
    
    QString reaction_type;
    if(socket->queryString().keys().contains("reaction_type")){
        fromStringValue(socket->queryString().value("reaction_type"), reaction_type);
    }
    
    qint32 message_id;
    fromStringValue(message_idstr, message_id);
    

    emit addReaction(message_id, emoji_name, emoji_code, reaction_type);
}


void OAIMessagesApiRequest::checkMessagesMatchNarrowRequest(){
    qDebug() << "/api/v1/messages/matches_narrow";
    connect(this, &OAIMessagesApiRequest::checkMessagesMatchNarrow, handler.data(), &OAIMessagesApiHandler::checkMessagesMatchNarrow);

    
    QList<qint32> msg_ids;
    if(socket->queryString().keys().contains("msg_ids")){
        fromStringValue(socket->queryString().values("msg_ids"), msg_ids);
    }
    
    QList<OAIObject> narrow;
    if(socket->queryString().keys().contains("narrow")){
        fromStringValue(socket->queryString().values("narrow"), narrow);
    }
    


    emit checkMessagesMatchNarrow(msg_ids, narrow);
}


void OAIMessagesApiRequest::deleteMessageRequest(const QString& message_idstr){
    qDebug() << "/api/v1/messages/{message_id}";
    connect(this, &OAIMessagesApiRequest::deleteMessage, handler.data(), &OAIMessagesApiHandler::deleteMessage);

    
    qint32 message_id;
    fromStringValue(message_idstr, message_id);
    

    emit deleteMessage(message_id);
}


void OAIMessagesApiRequest::getFileTemporaryUrlRequest(const QString& realm_id_strstr, const QString& filenamestr){
    qDebug() << "/api/v1/user_uploads/{realm_id_str}/{filename}";
    connect(this, &OAIMessagesApiRequest::getFileTemporaryUrl, handler.data(), &OAIMessagesApiHandler::getFileTemporaryUrl);

    
    qint32 realm_id_str;
    fromStringValue(realm_id_strstr, realm_id_str);
        QString filename;
    fromStringValue(filenamestr, filename);
    

    emit getFileTemporaryUrl(realm_id_str, filename);
}


void OAIMessagesApiRequest::getMessageHistoryRequest(const QString& message_idstr){
    qDebug() << "/api/v1/messages/{message_id}/history";
    connect(this, &OAIMessagesApiRequest::getMessageHistory, handler.data(), &OAIMessagesApiHandler::getMessageHistory);

    
    qint32 message_id;
    fromStringValue(message_idstr, message_id);
    

    emit getMessageHistory(message_id);
}


void OAIMessagesApiRequest::getMessagesRequest(){
    qDebug() << "/api/v1/messages";
    connect(this, &OAIMessagesApiRequest::getMessages, handler.data(), &OAIMessagesApiHandler::getMessages);

    
    OAIOneOfstringinteger anchor;
    if(socket->queryString().keys().contains("anchor")){
        fromStringValue(socket->queryString().value("anchor"), anchor);
    }
    
    qint32 num_before;
    if(socket->queryString().keys().contains("num_before")){
        fromStringValue(socket->queryString().value("num_before"), num_before);
    }
    
    qint32 num_after;
    if(socket->queryString().keys().contains("num_after")){
        fromStringValue(socket->queryString().value("num_after"), num_after);
    }
    
    QList<OAIObject> narrow;
    if(socket->queryString().keys().contains("narrow")){
        fromStringValue(socket->queryString().values("narrow"), narrow);
    }
    
    bool client_gravatar;
    if(socket->queryString().keys().contains("client_gravatar")){
        fromStringValue(socket->queryString().value("client_gravatar"), client_gravatar);
    }
    
    bool apply_markdown;
    if(socket->queryString().keys().contains("apply_markdown")){
        fromStringValue(socket->queryString().value("apply_markdown"), apply_markdown);
    }
    
    bool use_first_unread_anchor;
    if(socket->queryString().keys().contains("use_first_unread_anchor")){
        fromStringValue(socket->queryString().value("use_first_unread_anchor"), use_first_unread_anchor);
    }
    


    emit getMessages(num_before, num_after, anchor, narrow, client_gravatar, apply_markdown, use_first_unread_anchor);
}


void OAIMessagesApiRequest::getRawMessageRequest(const QString& message_idstr){
    qDebug() << "/api/v1/messages/{message_id}";
    connect(this, &OAIMessagesApiRequest::getRawMessage, handler.data(), &OAIMessagesApiHandler::getRawMessage);

    
    qint32 message_id;
    fromStringValue(message_idstr, message_id);
    

    emit getRawMessage(message_id);
}


void OAIMessagesApiRequest::markAllAsReadRequest(){
    qDebug() << "/api/v1/mark_all_as_read";
    connect(this, &OAIMessagesApiRequest::markAllAsRead, handler.data(), &OAIMessagesApiHandler::markAllAsRead);

    


    emit markAllAsRead();
}


void OAIMessagesApiRequest::markStreamAsReadRequest(){
    qDebug() << "/api/v1/mark_stream_as_read";
    connect(this, &OAIMessagesApiRequest::markStreamAsRead, handler.data(), &OAIMessagesApiHandler::markStreamAsRead);

    
    qint32 stream_id;
    if(socket->queryString().keys().contains("stream_id")){
        fromStringValue(socket->queryString().value("stream_id"), stream_id);
    }
    


    emit markStreamAsRead(stream_id);
}


void OAIMessagesApiRequest::markTopicAsReadRequest(){
    qDebug() << "/api/v1/mark_topic_as_read";
    connect(this, &OAIMessagesApiRequest::markTopicAsRead, handler.data(), &OAIMessagesApiHandler::markTopicAsRead);

    
    qint32 stream_id;
    if(socket->queryString().keys().contains("stream_id")){
        fromStringValue(socket->queryString().value("stream_id"), stream_id);
    }
    
    QString topic_name;
    if(socket->queryString().keys().contains("topic_name")){
        fromStringValue(socket->queryString().value("topic_name"), topic_name);
    }
    


    emit markTopicAsRead(stream_id, topic_name);
}


void OAIMessagesApiRequest::removeReactionRequest(const QString& message_idstr){
    qDebug() << "/api/v1/messages/{message_id}/reactions";
    connect(this, &OAIMessagesApiRequest::removeReaction, handler.data(), &OAIMessagesApiHandler::removeReaction);

    
    QString emoji_name;
    if(socket->queryString().keys().contains("emoji_name")){
        fromStringValue(socket->queryString().value("emoji_name"), emoji_name);
    }
    
    QString emoji_code;
    if(socket->queryString().keys().contains("emoji_code")){
        fromStringValue(socket->queryString().value("emoji_code"), emoji_code);
    }
    
    QString reaction_type;
    if(socket->queryString().keys().contains("reaction_type")){
        fromStringValue(socket->queryString().value("reaction_type"), reaction_type);
    }
    
    qint32 message_id;
    fromStringValue(message_idstr, message_id);
    

    emit removeReaction(message_id, emoji_name, emoji_code, reaction_type);
}


void OAIMessagesApiRequest::renderMessageRequest(){
    qDebug() << "/api/v1/messages/render";
    connect(this, &OAIMessagesApiRequest::renderMessage, handler.data(), &OAIMessagesApiHandler::renderMessage);

    
    QString content;
    if(socket->queryString().keys().contains("content")){
        fromStringValue(socket->queryString().value("content"), content);
    }
    


    emit renderMessage(content);
}


void OAIMessagesApiRequest::sendMessageRequest(){
    qDebug() << "/api/v1/messages";
    connect(this, &OAIMessagesApiRequest::sendMessage, handler.data(), &OAIMessagesApiHandler::sendMessage);

    
    QString type;
    if(socket->queryString().keys().contains("type")){
        fromStringValue(socket->queryString().value("type"), type);
    }
    
    QList<qint32> to;
    if(socket->queryString().keys().contains("to")){
        fromStringValue(socket->queryString().values("to"), to);
    }
    
    QString content;
    if(socket->queryString().keys().contains("content")){
        fromStringValue(socket->queryString().value("content"), content);
    }
    
    QString topic;
    if(socket->queryString().keys().contains("topic")){
        fromStringValue(socket->queryString().value("topic"), topic);
    }
    
    QString queue_id;
    if(socket->queryString().keys().contains("queue_id")){
        fromStringValue(socket->queryString().value("queue_id"), queue_id);
    }
    
    QString local_id;
    if(socket->queryString().keys().contains("local_id")){
        fromStringValue(socket->queryString().value("local_id"), local_id);
    }
    


    emit sendMessage(type, to, content, topic, queue_id, local_id);
}


void OAIMessagesApiRequest::updateMessageRequest(const QString& message_idstr){
    qDebug() << "/api/v1/messages/{message_id}";
    connect(this, &OAIMessagesApiRequest::updateMessage, handler.data(), &OAIMessagesApiHandler::updateMessage);

    
    QString topic;
    if(socket->queryString().keys().contains("topic")){
        fromStringValue(socket->queryString().value("topic"), topic);
    }
    
    QString propagate_mode;
    if(socket->queryString().keys().contains("propagate_mode")){
        fromStringValue(socket->queryString().value("propagate_mode"), propagate_mode);
    }
    
    bool send_notification_to_old_thread;
    if(socket->queryString().keys().contains("send_notification_to_old_thread")){
        fromStringValue(socket->queryString().value("send_notification_to_old_thread"), send_notification_to_old_thread);
    }
    
    bool send_notification_to_new_thread;
    if(socket->queryString().keys().contains("send_notification_to_new_thread")){
        fromStringValue(socket->queryString().value("send_notification_to_new_thread"), send_notification_to_new_thread);
    }
    
    QString content;
    if(socket->queryString().keys().contains("content")){
        fromStringValue(socket->queryString().value("content"), content);
    }
    
    qint32 stream_id;
    if(socket->queryString().keys().contains("stream_id")){
        fromStringValue(socket->queryString().value("stream_id"), stream_id);
    }
    
    qint32 message_id;
    fromStringValue(message_idstr, message_id);
    

    emit updateMessage(message_id, topic, propagate_mode, send_notification_to_old_thread, send_notification_to_new_thread, content, stream_id);
}


void OAIMessagesApiRequest::updateMessageFlagsRequest(){
    qDebug() << "/api/v1/messages/flags";
    connect(this, &OAIMessagesApiRequest::updateMessageFlags, handler.data(), &OAIMessagesApiHandler::updateMessageFlags);

    
    QList<qint32> messages;
    if(socket->queryString().keys().contains("messages")){
        fromStringValue(socket->queryString().values("messages"), messages);
    }
    
    QString op;
    if(socket->queryString().keys().contains("op")){
        fromStringValue(socket->queryString().value("op"), op);
    }
    
    QString flag;
    if(socket->queryString().keys().contains("flag")){
        fromStringValue(socket->queryString().value("flag"), flag);
    }
    


    emit updateMessageFlags(messages, op, flag);
}


void OAIMessagesApiRequest::uploadFileRequest(){
    qDebug() << "/api/v1/user_uploads";
    connect(this, &OAIMessagesApiRequest::uploadFile, handler.data(), &OAIMessagesApiHandler::uploadFile);

    

    OAIHttpFileElement filename;

    emit uploadFile(filename);
}



void OAIMessagesApiRequest::addReactionResponse(const OAIJsonSuccess& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::checkMessagesMatchNarrowResponse(const OAIAnyType& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::deleteMessageResponse(const OAIJsonSuccess& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::getFileTemporaryUrlResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::getMessageHistoryResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::getMessagesResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::getRawMessageResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::markAllAsReadResponse(const OAIJsonSuccess& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::markStreamAsReadResponse(const OAIJsonSuccess& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::markTopicAsReadResponse(const OAIJsonSuccess& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::removeReactionResponse(const OAIJsonSuccess& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::renderMessageResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::sendMessageResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::updateMessageResponse(const OAIJsonSuccess& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::updateMessageFlagsResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::uploadFileResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIMessagesApiRequest::addReactionError(const OAIJsonSuccess& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::checkMessagesMatchNarrowError(const OAIAnyType& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::deleteMessageError(const OAIJsonSuccess& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::getFileTemporaryUrlError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::getMessageHistoryError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::getMessagesError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::getRawMessageError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::markAllAsReadError(const OAIJsonSuccess& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::markStreamAsReadError(const OAIJsonSuccess& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::markTopicAsReadError(const OAIJsonSuccess& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::removeReactionError(const OAIJsonSuccess& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::renderMessageError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::sendMessageError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::updateMessageError(const OAIJsonSuccess& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::updateMessageFlagsError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIMessagesApiRequest::uploadFileError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIMessagesApiRequest::sendCustomResponse(QByteArray & res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type); // TODO
    socket->write(res);
    if(socket->isOpen()){
        socket->close();
    }    
}

void OAIMessagesApiRequest::sendCustomResponse(QIODevice *res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type);  // TODO
    socket->write(res->readAll());
    if(socket->isOpen()){
        socket->close();
    }
}

}
