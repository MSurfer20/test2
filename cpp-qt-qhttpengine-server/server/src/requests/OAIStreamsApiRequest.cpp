/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QVariantMap>
#include <QDebug>

#include "OAIHelpers.h"
#include "OAIStreamsApiRequest.h"

namespace OpenAPI {

OAIStreamsApiRequest::OAIStreamsApiRequest(QHttpEngine::Socket *s, QSharedPointer<OAIStreamsApiHandler> hdl) : QObject(s), socket(s), handler(hdl) {
    auto headers = s->headers();
    for(auto itr = headers.begin(); itr != headers.end(); itr++) {
        requestHeaders.insert(QString(itr.key()), QString(itr.value()));
    }
}

OAIStreamsApiRequest::~OAIStreamsApiRequest(){
    disconnect(this, nullptr, nullptr, nullptr);
    qDebug() << "OAIStreamsApiRequest::~OAIStreamsApiRequest()";
}

QMap<QString, QString>
OAIStreamsApiRequest::getRequestHeaders() const {
    return requestHeaders;
}

void OAIStreamsApiRequest::setResponseHeaders(const QMultiMap<QString, QString>& headers){
    for(auto itr = headers.begin(); itr != headers.end(); ++itr) {
        responseHeaders.insert(itr.key(), itr.value());
    }
}


QHttpEngine::Socket* OAIStreamsApiRequest::getRawSocket(){
    return socket;
}


void OAIStreamsApiRequest::archiveStreamRequest(const QString& stream_idstr){
    qDebug() << "/api/v1/streams/{stream_id}";
    connect(this, &OAIStreamsApiRequest::archiveStream, handler.data(), &OAIStreamsApiHandler::archiveStream);

    
    qint32 stream_id;
    fromStringValue(stream_idstr, stream_id);
    

    emit archiveStream(stream_id);
}


void OAIStreamsApiRequest::createBigBlueButtonVideoCallRequest(){
    qDebug() << "/api/v1/calls/bigbluebutton/create";
    connect(this, &OAIStreamsApiRequest::createBigBlueButtonVideoCall, handler.data(), &OAIStreamsApiHandler::createBigBlueButtonVideoCall);

    


    emit createBigBlueButtonVideoCall();
}


void OAIStreamsApiRequest::getStreamIdRequest(){
    qDebug() << "/api/v1/get_stream_id";
    connect(this, &OAIStreamsApiRequest::getStreamId, handler.data(), &OAIStreamsApiHandler::getStreamId);

    
    QString stream;
    if(socket->queryString().keys().contains("stream")){
        fromStringValue(socket->queryString().value("stream"), stream);
    }
    


    emit getStreamId(stream);
}


void OAIStreamsApiRequest::getStreamTopicsRequest(const QString& stream_idstr){
    qDebug() << "/api/v1/users/me/{stream_id}/topics";
    connect(this, &OAIStreamsApiRequest::getStreamTopics, handler.data(), &OAIStreamsApiHandler::getStreamTopics);

    
    qint32 stream_id;
    fromStringValue(stream_idstr, stream_id);
    

    emit getStreamTopics(stream_id);
}


void OAIStreamsApiRequest::getStreamsRequest(){
    qDebug() << "/api/v1/streams";
    connect(this, &OAIStreamsApiRequest::getStreams, handler.data(), &OAIStreamsApiHandler::getStreams);

    
    bool include_public;
    if(socket->queryString().keys().contains("include_public")){
        fromStringValue(socket->queryString().value("include_public"), include_public);
    }
    
    bool include_web_public;
    if(socket->queryString().keys().contains("include_web_public")){
        fromStringValue(socket->queryString().value("include_web_public"), include_web_public);
    }
    
    bool include_subscribed;
    if(socket->queryString().keys().contains("include_subscribed")){
        fromStringValue(socket->queryString().value("include_subscribed"), include_subscribed);
    }
    
    bool include_all_active;
    if(socket->queryString().keys().contains("include_all_active")){
        fromStringValue(socket->queryString().value("include_all_active"), include_all_active);
    }
    
    bool include_default;
    if(socket->queryString().keys().contains("include_default")){
        fromStringValue(socket->queryString().value("include_default"), include_default);
    }
    
    bool include_owner_subscribed;
    if(socket->queryString().keys().contains("include_owner_subscribed")){
        fromStringValue(socket->queryString().value("include_owner_subscribed"), include_owner_subscribed);
    }
    


    emit getStreams(include_public, include_web_public, include_subscribed, include_all_active, include_default, include_owner_subscribed);
}


void OAIStreamsApiRequest::getSubscriptionStatusRequest(const QString& user_idstr, const QString& stream_idstr){
    qDebug() << "/api/v1/users/{user_id}/subscriptions/{stream_id}";
    connect(this, &OAIStreamsApiRequest::getSubscriptionStatus, handler.data(), &OAIStreamsApiHandler::getSubscriptionStatus);

    
    qint32 user_id;
    fromStringValue(user_idstr, user_id);
        qint32 stream_id;
    fromStringValue(stream_idstr, stream_id);
    

    emit getSubscriptionStatus(user_id, stream_id);
}


void OAIStreamsApiRequest::getSubscriptionsRequest(){
    qDebug() << "/api/v1/users/me/subscriptions";
    connect(this, &OAIStreamsApiRequest::getSubscriptions, handler.data(), &OAIStreamsApiHandler::getSubscriptions);

    
    bool include_subscribers;
    if(socket->queryString().keys().contains("include_subscribers")){
        fromStringValue(socket->queryString().value("include_subscribers"), include_subscribers);
    }
    


    emit getSubscriptions(include_subscribers);
}


void OAIStreamsApiRequest::muteTopicRequest(){
    qDebug() << "/api/v1/users/me/subscriptions/muted_topics";
    connect(this, &OAIStreamsApiRequest::muteTopic, handler.data(), &OAIStreamsApiHandler::muteTopic);

    
    QString stream;
    if(socket->queryString().keys().contains("stream")){
        fromStringValue(socket->queryString().value("stream"), stream);
    }
    
    qint32 stream_id;
    if(socket->queryString().keys().contains("stream_id")){
        fromStringValue(socket->queryString().value("stream_id"), stream_id);
    }
    
    QString topic;
    if(socket->queryString().keys().contains("topic")){
        fromStringValue(socket->queryString().value("topic"), topic);
    }
    
    QString op;
    if(socket->queryString().keys().contains("op")){
        fromStringValue(socket->queryString().value("op"), op);
    }
    


    emit muteTopic(topic, op, stream, stream_id);
}


void OAIStreamsApiRequest::subscribeRequest(){
    qDebug() << "/api/v1/users/me/subscriptions";
    connect(this, &OAIStreamsApiRequest::subscribe, handler.data(), &OAIStreamsApiHandler::subscribe);

    
    QList<OAIObject> subscriptions;
    if(socket->queryString().keys().contains("subscriptions")){
        fromStringValue(socket->queryString().values("subscriptions"), subscriptions);
    }
    
    QList<OAIOneOfstringinteger> principals;
    if(socket->queryString().keys().contains("principals")){
        fromStringValue(socket->queryString().values("principals"), principals);
    }
    
    bool authorization_errors_fatal;
    if(socket->queryString().keys().contains("authorization_errors_fatal")){
        fromStringValue(socket->queryString().value("authorization_errors_fatal"), authorization_errors_fatal);
    }
    
    bool announce;
    if(socket->queryString().keys().contains("announce")){
        fromStringValue(socket->queryString().value("announce"), announce);
    }
    
    bool invite_only;
    if(socket->queryString().keys().contains("invite_only")){
        fromStringValue(socket->queryString().value("invite_only"), invite_only);
    }
    
    bool history_public_to_subscribers;
    if(socket->queryString().keys().contains("history_public_to_subscribers")){
        fromStringValue(socket->queryString().value("history_public_to_subscribers"), history_public_to_subscribers);
    }
    
    qint32 stream_post_policy;
    if(socket->queryString().keys().contains("stream_post_policy")){
        fromStringValue(socket->queryString().value("stream_post_policy"), stream_post_policy);
    }
    
    OAIOneOfstringinteger message_retention_days;
    if(socket->queryString().keys().contains("message_retention_days")){
        fromStringValue(socket->queryString().value("message_retention_days"), message_retention_days);
    }
    


    emit subscribe(subscriptions, principals, authorization_errors_fatal, announce, invite_only, history_public_to_subscribers, stream_post_policy, message_retention_days);
}


void OAIStreamsApiRequest::unsubscribeRequest(){
    qDebug() << "/api/v1/users/me/subscriptions";
    connect(this, &OAIStreamsApiRequest::unsubscribe, handler.data(), &OAIStreamsApiHandler::unsubscribe);

    
    QList<QString> subscriptions;
    if(socket->queryString().keys().contains("subscriptions")){
        fromStringValue(socket->queryString().values("subscriptions"), subscriptions);
    }
    
    QList<OAIOneOfstringinteger> principals;
    if(socket->queryString().keys().contains("principals")){
        fromStringValue(socket->queryString().values("principals"), principals);
    }
    


    emit unsubscribe(subscriptions, principals);
}


void OAIStreamsApiRequest::updateStreamRequest(const QString& stream_idstr){
    qDebug() << "/api/v1/streams/{stream_id}";
    connect(this, &OAIStreamsApiRequest::updateStream, handler.data(), &OAIStreamsApiHandler::updateStream);

    
    QString description;
    if(socket->queryString().keys().contains("description")){
        fromStringValue(socket->queryString().value("description"), description);
    }
    
    QString new_name;
    if(socket->queryString().keys().contains("new_name")){
        fromStringValue(socket->queryString().value("new_name"), new_name);
    }
    
    bool is_private;
    if(socket->queryString().keys().contains("is_private")){
        fromStringValue(socket->queryString().value("is_private"), is_private);
    }
    
    bool is_announcement_only;
    if(socket->queryString().keys().contains("is_announcement_only")){
        fromStringValue(socket->queryString().value("is_announcement_only"), is_announcement_only);
    }
    
    qint32 stream_post_policy;
    if(socket->queryString().keys().contains("stream_post_policy")){
        fromStringValue(socket->queryString().value("stream_post_policy"), stream_post_policy);
    }
    
    bool history_public_to_subscribers;
    if(socket->queryString().keys().contains("history_public_to_subscribers")){
        fromStringValue(socket->queryString().value("history_public_to_subscribers"), history_public_to_subscribers);
    }
    
    OAIOneOfstringinteger message_retention_days;
    if(socket->queryString().keys().contains("message_retention_days")){
        fromStringValue(socket->queryString().value("message_retention_days"), message_retention_days);
    }
    
    qint32 stream_id;
    fromStringValue(stream_idstr, stream_id);
    

    emit updateStream(stream_id, description, new_name, is_private, is_announcement_only, stream_post_policy, history_public_to_subscribers, message_retention_days);
}


void OAIStreamsApiRequest::updateSubscriptionSettingsRequest(){
    qDebug() << "/api/v1/users/me/subscriptions/properties";
    connect(this, &OAIStreamsApiRequest::updateSubscriptionSettings, handler.data(), &OAIStreamsApiHandler::updateSubscriptionSettings);

    
    QList<OAIObject> subscription_data;
    if(socket->queryString().keys().contains("subscription_data")){
        fromStringValue(socket->queryString().values("subscription_data"), subscription_data);
    }
    


    emit updateSubscriptionSettings(subscription_data);
}


void OAIStreamsApiRequest::updateSubscriptionsRequest(){
    qDebug() << "/api/v1/users/me/subscriptions";
    connect(this, &OAIStreamsApiRequest::updateSubscriptions, handler.data(), &OAIStreamsApiHandler::updateSubscriptions);

    
    QList<QString> r_delete;
    if(socket->queryString().keys().contains("r_delete")){
        fromStringValue(socket->queryString().values("r_delete"), r_delete);
    }
    
    QList<OAIObject> add;
    if(socket->queryString().keys().contains("add")){
        fromStringValue(socket->queryString().values("add"), add);
    }
    


    emit updateSubscriptions(r_delete, add);
}



void OAIStreamsApiRequest::archiveStreamResponse(const OAIJsonSuccess& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::createBigBlueButtonVideoCallResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::getStreamIdResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::getStreamTopicsResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::getStreamsResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::getSubscriptionStatusResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::getSubscriptionsResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::muteTopicResponse(const OAIJsonSuccess& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::subscribeResponse(const OAIOneOfobjectobject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::unsubscribeResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::updateStreamResponse(const OAIJsonSuccess& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::updateSubscriptionSettingsResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::updateSubscriptionsResponse(const OAIJsonSuccessBase& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIStreamsApiRequest::archiveStreamError(const OAIJsonSuccess& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::createBigBlueButtonVideoCallError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::getStreamIdError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::getStreamTopicsError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::getStreamsError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::getSubscriptionStatusError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::getSubscriptionsError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::muteTopicError(const OAIJsonSuccess& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::subscribeError(const OAIOneOfobjectobject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::unsubscribeError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::updateStreamError(const OAIJsonSuccess& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::updateSubscriptionSettingsError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIStreamsApiRequest::updateSubscriptionsError(const OAIJsonSuccessBase& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIStreamsApiRequest::sendCustomResponse(QByteArray & res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type); // TODO
    socket->write(res);
    if(socket->isOpen()){
        socket->close();
    }    
}

void OAIStreamsApiRequest::sendCustomResponse(QIODevice *res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type);  // TODO
    socket->write(res->readAll());
    if(socket->isOpen()){
        socket->close();
    }
}

}
