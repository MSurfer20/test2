// @flow
/* eslint-disable no-use-before-define */
/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://example.zulipchat.com/api/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type AddSubscriptionsResponse = {
    /**
     * 
     * @type {AnyType}
     * @memberof AddSubscriptionsResponse
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof AddSubscriptionsResponse
     */
    msg: AnyType;
    /**
     * A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that were subscribed to as a result of the query. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AddSubscriptionsResponse
     */
    subscribed?: { [key: string]: Array<string>; };
    /**
     * A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that the user/bot is already subscribed to. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AddSubscriptionsResponse
     */
    already_subscribed?: { [key: string]: Array<string>; };
    /**
     * A list of names of streams that the requesting user/bot was not authorized to subscribe to.  Only present if `authorization_errors_fatal=false`. 
     * @type {Array<string>}
     * @memberof AddSubscriptionsResponse
     */
    unauthorized?: Array<string>;
}


/**
 * 
 * @export
 */
export type AddSubscriptionsResponseAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof AddSubscriptionsResponseAllOf
     */
    result?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof AddSubscriptionsResponseAllOf
     */
    msg?: AnyType;
    /**
     * A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that were subscribed to as a result of the query. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AddSubscriptionsResponseAllOf
     */
    subscribed?: { [key: string]: Array<string>; };
    /**
     * A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that the user/bot is already subscribed to. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AddSubscriptionsResponseAllOf
     */
    already_subscribed?: { [key: string]: Array<string>; };
    /**
     * A list of names of streams that the requesting user/bot was not authorized to subscribe to.  Only present if `authorization_errors_fatal=false`. 
     * @type {Array<string>}
     * @memberof AddSubscriptionsResponseAllOf
     */
    unauthorized?: Array<string>;
}


/**
 * 
 * @export
 */
export type ApiKeyResponse = {
    /**
     * 
     * @type {AnyType}
     * @memberof ApiKeyResponse
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof ApiKeyResponse
     */
    msg: AnyType;
    /**
     * The API key that can be used to authenticate as the requested user. 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    api_key: string;
    /**
     * The email address of the user who owns the API key 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    email: string;
}


/**
 * 
 * @export
 */
export type ApiKeyResponseAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof ApiKeyResponseAllOf
     */
    result?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof ApiKeyResponseAllOf
     */
    msg?: AnyType;
    /**
     * The API key that can be used to authenticate as the requested user. 
     * @type {string}
     * @memberof ApiKeyResponseAllOf
     */
    api_key: string;
    /**
     * The email address of the user who owns the API key 
     * @type {string}
     * @memberof ApiKeyResponseAllOf
     */
    email: string;
}


/**
 * Dictionary containing details of a file uploaded by a user. 
 * @export
 */
export type Attachments = {
    /**
     * The unique ID for the attachment. 
     * @type {number}
     * @memberof Attachments
     */
    id?: number;
    /**
     * Name of the uploaded file. 
     * @type {string}
     * @memberof Attachments
     */
    name?: string;
    /**
     * A representation of the path of the file within the repository of user-uploaded files.  If the `path_id` of a file is `{realm_id}/ab/cdef/temp_file.py`, its URL will be: `{server_url}/user_uploads/{realm_id}/ab/cdef/temp_file.py`. 
     * @type {string}
     * @memberof Attachments
     */
    path_id?: string;
    /**
     * Size of the file in bytes. 
     * @type {number}
     * @memberof Attachments
     */
    size?: number;
    /**
     * Time when the attachment was uploaded as a UNIX timestamp multiplied by 1000 (matching the format of getTime() in JavaScript).  **Changes**: Changed in Zulip 2.2 (feature level 22).  This field was previously a floating point number. 
     * @type {number}
     * @memberof Attachments
     */
    create_time?: number;
    /**
     * Contains basic details on any Zulip messages that have been sent referencing this [uploaded file](/api/upload-file). This includes messages sent by any user in the Zulip organization who sent a message containing a link to the uploaded file. 
     * @type {Array<AttachmentsMessages>}
     * @memberof Attachments
     */
    messages?: Array<AttachmentsMessages>;
}


/**
 * 
 * @export
 */
export type AttachmentsMessages = {
    /**
     * Time when the message was sent as a UNIX timestamp multiplied by 1000 (matching the format of getTime() in JavaScript).  **Changes**: Changed in Zulip 2.2 (feature level 22).  This field was previously strangely called `name` and was a floating point number. 
     * @type {number}
     * @memberof AttachmentsMessages
     */
    date_sent?: number;
    /**
     * The unique message ID.  Messages should always be displayed sorted by ID. 
     * @type {number}
     * @memberof AttachmentsMessages
     */
    id?: number;
}


/**
 * 
 * @export
 */
export type BadEventQueueIdError = {
    /**
     * 
     * @type {AnyType}
     * @memberof BadEventQueueIdError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BadEventQueueIdError
     */
    msg: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BadEventQueueIdError
     */
    code?: AnyType;
    /**
     * The string that identifies the invalid event queue. 
     * @type {string}
     * @memberof BadEventQueueIdError
     */
    queue_id?: string;
}


/**
 * 
 * @export
 */
export type BadEventQueueIdErrorAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof BadEventQueueIdErrorAllOf
     */
    result?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BadEventQueueIdErrorAllOf
     */
    msg?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BadEventQueueIdErrorAllOf
     */
    code?: AnyType;
    /**
     * The string that identifies the invalid event queue. 
     * @type {string}
     * @memberof BadEventQueueIdErrorAllOf
     */
    queue_id?: string;
}


/**
 * 
 * @export
 */
export type BasicBot = {
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBot
     */
    user_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBot
     */
    full_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBot
     */
    api_key?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBot
     */
    default_sending_stream?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBot
     */
    default_events_register_stream?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBot
     */
    default_all_public_streams?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBot
     */
    avatar_url?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBot
     */
    owner_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBot
     */
    services?: AnyType;
}


/**
 * 
 * @export
 */
export type BasicBotAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBotAllOf
     */
    user_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBotAllOf
     */
    full_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBotAllOf
     */
    api_key?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBotAllOf
     */
    default_sending_stream?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBotAllOf
     */
    default_events_register_stream?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBotAllOf
     */
    default_all_public_streams?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBotAllOf
     */
    avatar_url?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBotAllOf
     */
    owner_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicBotAllOf
     */
    services?: AnyType;
}


/**
 * 
 * @export
 */
export type BasicBotBase = {
    /**
     * The user id of the bot. 
     * @type {number}
     * @memberof BasicBotBase
     */
    user_id?: number;
    /**
     * The full name of the bot. 
     * @type {string}
     * @memberof BasicBotBase
     */
    full_name?: string;
    /**
     * The API key of the bot which it uses to make API requests. 
     * @type {string}
     * @memberof BasicBotBase
     */
    api_key?: string;
    /**
     * The default sending stream of the bot. Null if the bot doesn\'t have a default sending stream. 
     * @type {string}
     * @memberof BasicBotBase
     */
    default_sending_stream?: string;
    /**
     * The default stream for which the bot receives events/register data. Null if the bot doesn\'t have such a default stream. 
     * @type {string}
     * @memberof BasicBotBase
     */
    default_events_register_stream?: string;
    /**
     * Whether the bot can send messages to all streams by default. 
     * @type {boolean}
     * @memberof BasicBotBase
     */
    default_all_public_streams?: boolean;
    /**
     * The URL of the bot\'s avatar. 
     * @type {string}
     * @memberof BasicBotBase
     */
    avatar_url?: string;
    /**
     * The user id of the bot\'s owner.  Null if the bot has no owner. 
     * @type {number}
     * @memberof BasicBotBase
     */
    owner_id?: number;
    /**
     * The \"Services\" array contains extra configuration fields only relevant for Outgoing webhook bots and Embedded bots.  It is always a single-element array.  We consider this part of the Zulip API to be unstable; it is used only for UI elements for administering bots and is likely to change. 
     * @type {Array<Object>}
     * @memberof BasicBotBase
     */
    services?: Array<Object>;
}


/**
 * 
 * @export
 */
export type BasicStream = {
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    stream_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    description?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    date_created?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    invite_only?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    rendered_description?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    is_web_public?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    stream_post_policy?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    message_retention_days?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    history_public_to_subscribers?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    first_message_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStream
     */
    is_announcement_only?: AnyType;
}


/**
 * 
 * @export
 */
export type BasicStreamAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    stream_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    description?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    date_created?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    invite_only?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    rendered_description?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    is_web_public?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    stream_post_policy?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    message_retention_days?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    history_public_to_subscribers?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    first_message_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BasicStreamAllOf
     */
    is_announcement_only?: AnyType;
}


/**
 * Object containing basic details about the stream. 
 * @export
 */
export type BasicStreamBase = {
    /**
     * The unique ID of the stream. 
     * @type {number}
     * @memberof BasicStreamBase
     */
    stream_id?: number;
    /**
     * The name of the stream. 
     * @type {string}
     * @memberof BasicStreamBase
     */
    name?: string;
    /**
     * The short description of the stream in text/markdown format, intended to be used to prepopulate UI for editing a stream\'s description. 
     * @type {string}
     * @memberof BasicStreamBase
     */
    description?: string;
    /**
     * The UNIX timestamp for when the stream was created, in UTC seconds.  **Changes**: New in Zulip 4.0 (feature level 30). 
     * @type {number}
     * @memberof BasicStreamBase
     */
    date_created?: number;
    /**
     * Specifies whether the stream is private or not. Only people who have been invited can access a private stream. 
     * @type {boolean}
     * @memberof BasicStreamBase
     */
    invite_only?: boolean;
    /**
     * The short description of the stream rendered as HTML, intended to be used when displaying the stream description in a UI.  One should use the standard Zulip rendered_markdown CSS when displaying this content so that emoji, LaTeX, and other syntax work correctly.  And any client-side security logic for user-generated message content should be applied when displaying this HTML as though it were the body of a Zulip message. 
     * @type {string}
     * @memberof BasicStreamBase
     */
    rendered_description?: string;
    /**
     * Whether the stream has been configured to allow unauthenticated access to its message history from the web. 
     * @type {boolean}
     * @memberof BasicStreamBase
     */
    is_web_public?: boolean;
    /**
     * Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
     * @type {number}
     * @memberof BasicStreamBase
     */
    stream_post_policy?: number;
    /**
     * Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  There are two special values:  * `null`, the default, means the stream will inherit the organization   level setting. * `-1` encodes retaining messages in this stream forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
     * @type {number}
     * @memberof BasicStreamBase
     */
    message_retention_days?: number;
    /**
     * Whether the history of the stream is public to its subscribers.  Currently always true for public streams (i.e. invite_only=False implies history_public_to_subscribers=True), but clients should not make that assumption, as we may change that behavior in the future. 
     * @type {boolean}
     * @memberof BasicStreamBase
     */
    history_public_to_subscribers?: boolean;
    /**
     * The id of the first message in the stream.  Intended to help clients determine whether they need to display UI like the \"more topics\" widget that would suggest the stream has older history that can be accessed.  Null is used for streams with no message history. 
     * @type {number}
     * @memberof BasicStreamBase
     */
    first_message_id?: number;
    /**
     * Whether the given stream is announcement only or not.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use `stream_post_policy` instead. 
     * @type {boolean}
     * @memberof BasicStreamBase
     */
    is_announcement_only?: boolean;
}


/**
 * 
 * @export
 */
export type Bot = {
    /**
     * 
     * @type {AnyType}
     * @memberof Bot
     */
    user_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Bot
     */
    full_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Bot
     */
    api_key?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Bot
     */
    default_sending_stream?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Bot
     */
    default_events_register_stream?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Bot
     */
    default_all_public_streams?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Bot
     */
    avatar_url?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Bot
     */
    owner_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Bot
     */
    services?: AnyType;
    /**
     * The email of the bot. 
     * @type {string}
     * @memberof Bot
     */
    email?: string;
    /**
     * An integer describing the type of bot: * `1` for a `Generic` bot. * `2` for an `Incoming webhook` bot. * `3` for an `Outgoing webhook` bot. * `4` for an `Embedded` bot. 
     * @type {number}
     * @memberof Bot
     */
    bot_type?: number;
    /**
     * A boolean describing whether the user account has been deactivated. 
     * @type {boolean}
     * @memberof Bot
     */
    is_active?: boolean;
}


/**
 * Object containing details of a bot. 
 * @export
 */
export type BotAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof BotAllOf
     */
    user_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BotAllOf
     */
    full_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BotAllOf
     */
    api_key?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BotAllOf
     */
    default_sending_stream?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BotAllOf
     */
    default_events_register_stream?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BotAllOf
     */
    default_all_public_streams?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BotAllOf
     */
    avatar_url?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BotAllOf
     */
    owner_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof BotAllOf
     */
    services?: AnyType;
    /**
     * The email of the bot. 
     * @type {string}
     * @memberof BotAllOf
     */
    email?: string;
    /**
     * An integer describing the type of bot: * `1` for a `Generic` bot. * `2` for an `Incoming webhook` bot. * `3` for an `Outgoing webhook` bot. * `4` for an `Embedded` bot. 
     * @type {number}
     * @memberof BotAllOf
     */
    bot_type?: number;
    /**
     * A boolean describing whether the user account has been deactivated. 
     * @type {boolean}
     * @memberof BotAllOf
     */
    is_active?: boolean;
}


/**
 * 
 * @export
 */
export type CodedError = {
    /**
     * 
     * @type {AnyType}
     * @memberof CodedError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof CodedError
     */
    msg: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof CodedError
     */
    code?: AnyType;
}


/**
 * 
 * @export
 */
export type CodedErrorAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof CodedErrorAllOf
     */
    result?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof CodedErrorAllOf
     */
    msg?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof CodedErrorAllOf
     */
    code?: AnyType;
}


/**
 * 
 * @export
 */
export type CodedErrorBase = {
    /**
     * 
     * @type {AnyType}
     * @memberof CodedErrorBase
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof CodedErrorBase
     */
    msg: AnyType;
    /**
     * A string that identifies the error. 
     * @type {string}
     * @memberof CodedErrorBase
     */
    code?: string;
}


/**
 * 
 * @export
 */
export type CodedErrorBaseAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof CodedErrorBaseAllOf
     */
    result?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof CodedErrorBaseAllOf
     */
    msg?: AnyType;
    /**
     * A string that identifies the error. 
     * @type {string}
     * @memberof CodedErrorBaseAllOf
     */
    code?: string;
}


/**
 * Dictionary containing the details of a custom profile field configured for this organization. 
 * @export
 */
export type CustomProfileField = {
    /**
     * The ID of the custom profile field.  This will be referenced in custom the profile fields section of user objects. 
     * @type {number}
     * @memberof CustomProfileField
     */
    id?: number;
    /**
     * An integer indicating the type of the custom profile field, which determines how it is configured and displayed to users.  See the [Add custom profile fields](/help/add-custom-profile-fields) article for details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
     * @type {number}
     * @memberof CustomProfileField
     */
    type?: number;
    /**
     * Custom profile fields are displayed in both settings UI and UI showing users\' profiles in increasing `order`. 
     * @type {number}
     * @memberof CustomProfileField
     */
    order?: number;
    /**
     * The name of the custom profile field. 
     * @type {string}
     * @memberof CustomProfileField
     */
    name?: string;
    /**
     * The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
     * @type {string}
     * @memberof CustomProfileField
     */
    hint?: string;
    /**
     * Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the `field_data` attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
     * @type {string}
     * @memberof CustomProfileField
     */
    field_data?: string;
}


/**
 * Dictionary containing details of a default stream group. 
 * @export
 */
export type DefaultStreamGroup = {
    /**
     * Name of the default stream group. 
     * @type {string}
     * @memberof DefaultStreamGroup
     */
    name?: string;
    /**
     * Description of the default stream group. 
     * @type {string}
     * @memberof DefaultStreamGroup
     */
    description?: string;
    /**
     * id of the default stream group. 
     * @type {number}
     * @memberof DefaultStreamGroup
     */
    id?: number;
    /**
     * Array containing details about the streams in the default stream group. 
     * @type {Array<BasicStream>}
     * @memberof DefaultStreamGroup
     */
    streams?: Array<BasicStream>;
}


/**
 * 
 * @export
 */
export type EmojiReaction = {
    /**
     * 
     * @type {AnyType}
     * @memberof EmojiReaction
     */
    emoji_code?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof EmojiReaction
     */
    emoji_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof EmojiReaction
     */
    reaction_type?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof EmojiReaction
     */
    user_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof EmojiReaction
     */
    user?: AnyType;
}


/**
 * 
 * @export
 */
export type EmojiReactionAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof EmojiReactionAllOf
     */
    emoji_code?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof EmojiReactionAllOf
     */
    emoji_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof EmojiReactionAllOf
     */
    reaction_type?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof EmojiReactionAllOf
     */
    user_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof EmojiReactionAllOf
     */
    user?: AnyType;
}


/**
 * 
 * @export
 */
export type EmojiReactionBase = {
    /**
     * A unique identifier, defining the specific emoji codepoint requested, within the namespace of the `reaction_type`.  For example, for `unicode_emoji`, this will be an encoding of the Unicode codepoint. 
     * @type {string}
     * @memberof EmojiReactionBase
     */
    emoji_code?: string;
    /**
     * Name of the emoji. 
     * @type {string}
     * @memberof EmojiReactionBase
     */
    emoji_name?: string;
    /**
     * One of the following values:  * `unicode_emoji`: Unicode emoji (`emoji_code` will be its Unicode   codepoint). * `realm_emoji`: [Custom emoji](/help/add-custom-emoji).   (`emoji_code` will be its ID). * `zulip_extra_emoji`: Special emoji included with Zulip.  Exists to   namespace the `zulip` emoji. 
     * @type {string}
     * @memberof EmojiReactionBase
     */
    reaction_type?: string;
    /**
     * The ID of the user who added the reaction.  **Changes**: New in Zulip 3.0 (feature level 2). The `user` object is deprecated and will be removed in the future. 
     * @type {number}
     * @memberof EmojiReactionBase
     */
    user_id?: number;
    /**
     * 
     * @type {EmojiReactionBaseUser}
     * @memberof EmojiReactionBase
     */
    user?: EmojiReactionBaseUser;
}


/**
 * Dictionary with data on the user who added the reaction, including the user ID as the `id` field.  **Note**: In the [events API](/api/get-events), this `user` dictionary confusing had the user ID in a field called `user_id` instead.  We recommend ignoring fields other than the user ID.  **Deprecated** and to be removed in a future release once core clients have migrated to use the `user_id` field. 
 * @export
 */
export type EmojiReactionBaseUser = {
    /**
     * ID of the user. 
     * @type {number}
     * @memberof EmojiReactionBaseUser
     */
    id?: number;
    /**
     * Email of the user. 
     * @type {string}
     * @memberof EmojiReactionBaseUser
     */
    email?: string;
    /**
     * Full name of the user. 
     * @type {string}
     * @memberof EmojiReactionBaseUser
     */
    full_name?: string;
    /**
     * Whether the user is a mirror dummy. 
     * @type {boolean}
     * @memberof EmojiReactionBaseUser
     */
    is_mirror_dummy?: boolean;
}


/**
 * 
 * @export
 */
export type GetMessages = {
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    avatar_url?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    client?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    content?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    content_type?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    display_recipient?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    is_me_message?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    reactions?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    recipient_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    sender_email?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    sender_full_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    sender_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    sender_realm_str?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    stream_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    subject?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    topic_links?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    submessages?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    timestamp?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessages
     */
    type?: AnyType;
    /**
     * The user\'s [message flags][message-flags] for the message.  [message-flags]: /api/update-message-flags#available-flags 
     * @type {Array<string>}
     * @memberof GetMessages
     */
    flags?: Array<string>;
    /**
     * The UNIX timestamp for when the message was last edited, in UTC seconds. 
     * @type {number}
     * @memberof GetMessages
     */
    last_edit_timestamp?: number;
    /**
     * Only present if keyword search was included among the narrow parameters. HTML content of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords. 
     * @type {string}
     * @memberof GetMessages
     */
    match_content?: string;
    /**
     * Only present if keyword search was included among the narrow parameters. HTML-escaped topic of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords. 
     * @type {string}
     * @memberof GetMessages
     */
    match_subject?: string;
}


/**
 * 
 * @export
 */
export type GetMessagesAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    avatar_url?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    client?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    content?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    content_type?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    display_recipient?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    is_me_message?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    reactions?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    recipient_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    sender_email?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    sender_full_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    sender_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    sender_realm_str?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    stream_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    subject?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    topic_links?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    submessages?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    timestamp?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof GetMessagesAllOf
     */
    type?: AnyType;
    /**
     * The user\'s [message flags][message-flags] for the message.  [message-flags]: /api/update-message-flags#available-flags 
     * @type {Array<string>}
     * @memberof GetMessagesAllOf
     */
    flags?: Array<string>;
    /**
     * The UNIX timestamp for when the message was last edited, in UTC seconds. 
     * @type {number}
     * @memberof GetMessagesAllOf
     */
    last_edit_timestamp?: number;
    /**
     * Only present if keyword search was included among the narrow parameters. HTML content of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords. 
     * @type {string}
     * @memberof GetMessagesAllOf
     */
    match_content?: string;
    /**
     * Only present if keyword search was included among the narrow parameters. HTML-escaped topic of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords. 
     * @type {string}
     * @memberof GetMessagesAllOf
     */
    match_subject?: string;
}


/**
 * Dictionary containing details of a single hotspot. 
 * @export
 */
export type Hotspot = {
    /**
     * The delay after which the user should be shown the hotspot. 
     * @type {number}
     * @memberof Hotspot
     */
    delay?: number;
    /**
     * The name of the hotspot. 
     * @type {string}
     * @memberof Hotspot
     */
    name?: string;
    /**
     * The title of the hotspot, as will be displayed to the user. 
     * @type {string}
     * @memberof Hotspot
     */
    title?: string;
    /**
     * The description of the hotspot, as will be displayed to the user. 
     * @type {string}
     * @memberof Hotspot
     */
    description?: string;
}


/**
 * This is an example of the JSON payload that the Zulip server will `POST` to your server 
 * @export
 */
export type InlineResponse200 = {
    /**
     * Email of the bot user. 
     * @type {string}
     * @memberof InlineResponse200
     */
    bot_email?: string;
    /**
     * The full name of the bot user. 
     * @type {string}
     * @memberof InlineResponse200
     */
    bot_full_name?: string;
    /**
     * The message content, in raw Markdown format (not rendered to HTML). 
     * @type {string}
     * @memberof InlineResponse200
     */
    data?: string;
    /**
     * What aspect of the message triggered the outgoing webhook notification. Possible values include `private_message` and `mention`. 
     * @type {string}
     * @memberof InlineResponse200
     */
    trigger?: string;
    /**
     * A string of alphanumeric characters that can be used to authenticate the webhook request (each bot user uses a fixed token). You can get the token used by a given outgoing webhook bot in the `zuliprc` file downloaded when creating the bot. 
     * @type {string}
     * @memberof InlineResponse200
     */
    token?: string;
    /**
     * A dict containing details on the message that triggered the outgoing webhook, in the format used by [`GET /messages`](/api/get-messages). 
     * @type {MessagesBase & Object}
     * @memberof InlineResponse200
     */
    message?: MessagesBase & Object;
}


/**
 * 
 * @export
 */
export type InvalidApiKeyError = {
    /**
     * 
     * @type {AnyType}
     * @memberof InvalidApiKeyError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof InvalidApiKeyError
     */
    msg: AnyType;
}


/**
 * 
 * @export
 */
export type InvalidMessageError = {
    /**
     * 
     * @type {AnyType}
     * @memberof InvalidMessageError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof InvalidMessageError
     */
    msg: AnyType;
    /**
     * The raw content of the message. 
     * @type {string}
     * @memberof InvalidMessageError
     */
    raw_content?: string;
}


/**
 * 
 * @export
 */
export type InvalidMessageErrorAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof InvalidMessageErrorAllOf
     */
    result?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof InvalidMessageErrorAllOf
     */
    msg?: AnyType;
    /**
     * The raw content of the message. 
     * @type {string}
     * @memberof InvalidMessageErrorAllOf
     */
    raw_content?: string;
}


/**
 * 
 * @export
 */
export type JsonError = {
    /**
     * 
     * @type {AnyType}
     * @memberof JsonError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof JsonError
     */
    msg: AnyType;
}



            export type JsonErrorBaseResultEnum = 'error';
/**
 * 
 * @export
 */
export type JsonErrorBase = {
    /**
     * 
     * @type {string}
     * @memberof JsonErrorBase
     */
    result: JsonErrorBaseResultEnum;
    /**
     * 
     * @type {string}
     * @memberof JsonErrorBase
     */
    msg: string;
}



            export type JsonErrorBaseAllOfResultEnum = 'error';
/**
 * 
 * @export
 */
export type JsonErrorBaseAllOf = {
    /**
     * 
     * @type {string}
     * @memberof JsonErrorBaseAllOf
     */
    result: JsonErrorBaseAllOfResultEnum;
    /**
     * 
     * @type {string}
     * @memberof JsonErrorBaseAllOf
     */
    msg: string;
}


/**
 * 
 * @export
 */
export type JsonResponseBase = {
    /**
     * 
     * @type {string}
     * @memberof JsonResponseBase
     */
    result?: string;
}


/**
 * 
 * @export
 */
export type JsonSuccess = {
    /**
     * 
     * @type {AnyType}
     * @memberof JsonSuccess
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof JsonSuccess
     */
    msg: AnyType;
}


/**
 * 
 * @export
 */
export type JsonSuccessAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof JsonSuccessAllOf
     */
    result?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof JsonSuccessAllOf
     */
    msg?: AnyType;
}



            export type JsonSuccessBaseResultEnum = 'success';
/**
 * 
 * @export
 */
export type JsonSuccessBase = {
    /**
     * 
     * @type {string}
     * @memberof JsonSuccessBase
     */
    result: JsonSuccessBaseResultEnum;
    /**
     * 
     * @type {string}
     * @memberof JsonSuccessBase
     */
    msg: string;
}



            export type JsonSuccessBaseAllOfResultEnum = 'success';
/**
 * 
 * @export
 */
export type JsonSuccessBaseAllOf = {
    /**
     * 
     * @type {string}
     * @memberof JsonSuccessBaseAllOf
     */
    result: JsonSuccessBaseAllOfResultEnum;
    /**
     * 
     * @type {string}
     * @memberof JsonSuccessBaseAllOf
     */
    msg: string;
}


/**
 * 
 * @export
 */
export type Messages = {
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    avatar_url?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    client?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    content?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    content_type?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    display_recipient?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    is_me_message?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    reactions?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    recipient_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    sender_email?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    sender_full_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    sender_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    sender_realm_str?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    stream_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    subject?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    topic_links?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    submessages?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    timestamp?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof Messages
     */
    type?: AnyType;
}


/**
 * 
 * @export
 */
export type MessagesAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    avatar_url?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    client?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    content?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    content_type?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    display_recipient?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    is_me_message?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    reactions?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    recipient_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    sender_email?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    sender_full_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    sender_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    sender_realm_str?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    stream_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    subject?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    topic_links?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    submessages?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    timestamp?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MessagesAllOf
     */
    type?: AnyType;
}


/**
 * Object containing details of the message. 
 * @export
 */
export type MessagesBase = {
    /**
     * The URL of the user\'s avatar.  Can be null only if client_gravatar was passed, which means that the user has not uploaded an avatar in Zulip, and the client should compute the gravatar URL by hashing the user\'s email address itself for this user. 
     * @type {string}
     * @memberof MessagesBase
     */
    avatar_url?: string;
    /**
     * A Zulip \"client\" string, describing what Zulip client sent the message. 
     * @type {string}
     * @memberof MessagesBase
     */
    client?: string;
    /**
     * The content/body of the message. 
     * @type {string}
     * @memberof MessagesBase
     */
    content?: string;
    /**
     * The HTTP `content_type` for the message content.  This will be `text/html` or `text/x-markdown`, depending on whether `apply_markdown` was set. 
     * @type {string}
     * @memberof MessagesBase
     */
    content_type?: string;
    /**
     * Data on the recipient of the message; either the name of a stream or a dictionary containing basic data on the users who received the message. 
     * @type {string | Array<Object>}
     * @memberof MessagesBase
     */
    display_recipient?: string | Array<Object>;
    /**
     * The unique message ID.  Messages should always be displayed sorted by ID. 
     * @type {number}
     * @memberof MessagesBase
     */
    id?: number;
    /**
     * Whether the message is a [/me status message][status-messages]  [status-messages]: /help/format-your-message-using-markdown#status-messages 
     * @type {boolean}
     * @memberof MessagesBase
     */
    is_me_message?: boolean;
    /**
     * Data on any reactions to the message. 
     * @type {Array<EmojiReaction>}
     * @memberof MessagesBase
     */
    reactions?: Array<EmojiReaction>;
    /**
     * A unique ID for the set of users receiving the message (either a stream or group of users).  Useful primarily for hashing. 
     * @type {number}
     * @memberof MessagesBase
     */
    recipient_id?: number;
    /**
     * The Zulip display email address of the message\'s sender. 
     * @type {string}
     * @memberof MessagesBase
     */
    sender_email?: string;
    /**
     * The full name of the message\'s sender. 
     * @type {string}
     * @memberof MessagesBase
     */
    sender_full_name?: string;
    /**
     * The user ID of the message\'s sender. 
     * @type {number}
     * @memberof MessagesBase
     */
    sender_id?: number;
    /**
     * A string identifier for the realm the sender is in.  Unique only within the context of a given Zulip server.  E.g. on `example.zulip.com`, this will be `example`. 
     * @type {string}
     * @memberof MessagesBase
     */
    sender_realm_str?: string;
    /**
     * Only present for stream messages; the ID of the stream. 
     * @type {number}
     * @memberof MessagesBase
     */
    stream_id?: number;
    /**
     * The `topic` of the message.  Currently always `\"\"` for private messages, though this could change if Zulip adds support for topics in private message conversations.  The field name is a legacy holdover from when topics were called \"subjects\" and will eventually change. 
     * @type {string}
     * @memberof MessagesBase
     */
    subject?: string;
    /**
     * Data on any links to be included in the `topic` line (these are generated by [custom linkification filters](/help/add-a-custom-linkifier) that match content in the message\'s topic.)  **Changes**: This field contained a list of urls before   Zulip 4.0 (feature level 46).  New in Zulip 3.0 (feature level 1): Previously, this field was called `subject_links`; clients are recommended to rename `subject_links` to `topic_links` if present for compatibility with older Zulip servers. 
     * @type {Array<MessagesBaseTopicLinks>}
     * @memberof MessagesBase
     */
    topic_links?: Array<MessagesBaseTopicLinks>;
    /**
     * Data used for certain experimental Zulip integrations. 
     * @type {Array<string>}
     * @memberof MessagesBase
     */
    submessages?: Array<string>;
    /**
     * The UNIX timestamp for when the message was sent, in UTC seconds. 
     * @type {number}
     * @memberof MessagesBase
     */
    timestamp?: number;
    /**
     * The type of the message: `stream` or `private`. 
     * @type {string}
     * @memberof MessagesBase
     */
    type?: string;
}


/**
 * 
 * @export
 */
export type MessagesBaseTopicLinks = {
    /**
     * The original link text present in the topic. 
     * @type {string}
     * @memberof MessagesBaseTopicLinks
     */
    text?: string;
    /**
     * The expanded target url which the link points to. 
     * @type {string}
     * @memberof MessagesBaseTopicLinks
     */
    url?: string;
}


/**
 * 
 * @export
 */
export type MissingArgumentError = {
    /**
     * 
     * @type {AnyType}
     * @memberof MissingArgumentError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MissingArgumentError
     */
    msg: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MissingArgumentError
     */
    code?: AnyType;
    /**
     * It contains the information about the missing parameter. 
     * @type {string}
     * @memberof MissingArgumentError
     */
    var_name?: string;
}


/**
 * ## Missing request parameter(s)  A typical failed JSON response for when a required request parameter is not supplied 
 * @export
 */
export type MissingArgumentErrorAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof MissingArgumentErrorAllOf
     */
    result?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MissingArgumentErrorAllOf
     */
    msg?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof MissingArgumentErrorAllOf
     */
    code?: AnyType;
    /**
     * It contains the information about the missing parameter. 
     * @type {string}
     * @memberof MissingArgumentErrorAllOf
     */
    var_name?: string;
}


/**
 * 
 * @export
 */
export type NonExistingStreamError = {
    /**
     * 
     * @type {AnyType}
     * @memberof NonExistingStreamError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof NonExistingStreamError
     */
    msg: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof NonExistingStreamError
     */
    code?: AnyType;
    /**
     * The name of the stream that could not be found. 
     * @type {string}
     * @memberof NonExistingStreamError
     */
    stream?: string;
}


/**
 * 
 * @export
 */
export type NonExistingStreamErrorAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof NonExistingStreamErrorAllOf
     */
    result?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof NonExistingStreamErrorAllOf
     */
    msg?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof NonExistingStreamErrorAllOf
     */
    code?: AnyType;
    /**
     * The name of the stream that could not be found. 
     * @type {string}
     * @memberof NonExistingStreamErrorAllOf
     */
    stream?: string;
}



            export type PresenceStatusEnum = 'idle' | 'active';
/**
 * `{client_name}`: Object containing the details of the user\'s presence on a particular platform with the client\'s platform name being the object key. 
 * @export
 */
export type Presence = {
    /**
     * The client\'s platform name. 
     * @type {string}
     * @memberof Presence
     */
    client?: string;
    /**
     * The status of the user on this client. It is either `idle` or `active`. 
     * @type {string}
     * @memberof Presence
     */
    status?: PresenceStatusEnum;
    /**
     * The UNIX timestamp of when this client sent the user\'s presence to the server with the precision of a second. 
     * @type {number}
     * @memberof Presence
     */
    timestamp?: number;
    /**
     * Whether the client is capable of showing mobile/push notifications to the user. 
     * @type {boolean}
     * @memberof Presence
     */
    pushable?: boolean;
}


/**
 * 
 * @export
 */
export type RateLimitedError = {
    /**
     * 
     * @type {AnyType}
     * @memberof RateLimitedError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof RateLimitedError
     */
    msg: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof RateLimitedError
     */
    code?: AnyType;
}


/**
 * 
 * @export
 */
export type RealmDeactivatedError = {
    /**
     * 
     * @type {AnyType}
     * @memberof RealmDeactivatedError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof RealmDeactivatedError
     */
    msg: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof RealmDeactivatedError
     */
    code?: AnyType;
}


/**
 * Object containing details of the newly added domain. 
 * @export
 */
export type RealmDomain = {
    /**
     * The new allowed domain. 
     * @type {string}
     * @memberof RealmDomain
     */
    domain?: string;
    /**
     * Whether subdomains are allowed for this domain. 
     * @type {boolean}
     * @memberof RealmDomain
     */
    allow_subdomains?: boolean;
}


/**
 * `{emoji_id}`: Object containing details about the emoji with  the specified ID. It has the following properties: 
 * @export
 */
export type RealmEmoji = {
    /**
     * The ID for this emoji, same as the object\'s key. 
     * @type {string}
     * @memberof RealmEmoji
     */
    id?: string;
    /**
     * The user-friendly name for this emoji. Users in the organization can use this emoji by writing this name between colons (`:name  :`). 
     * @type {string}
     * @memberof RealmEmoji
     */
    name?: string;
    /**
     * The path relative to the organization\'s URL where the emoji\'s image can be found. 
     * @type {string}
     * @memberof RealmEmoji
     */
    source_url?: string;
    /**
     * Whether the emoji has been deactivated or not. 
     * @type {boolean}
     * @memberof RealmEmoji
     */
    deactivated?: boolean;
    /**
     * The user ID of the user who uploaded the custom emoji. Will be null if the uploader is unknown.  **Changes**: New in Zulip 3.0 (feature level 7).  Previously was accessible via and `author` object with an `id` field. 
     * @type {number}
     * @memberof RealmEmoji
     */
    author_id?: number;
}


/**
 * Object containing details about a realm export. 
 * @export
 */
export type RealmExport = {
    /**
     * The id of the export. 
     * @type {number}
     * @memberof RealmExport
     */
    id?: number;
    /**
     * The id of the user who did the export. 
     * @type {number}
     * @memberof RealmExport
     */
    acting_user_id?: number;
    /**
     * The UNIX timestamp of when the export was made. 
     * @type {number}
     * @memberof RealmExport
     */
    export_time?: number;
    /**
     * The timestamp of when the export was deleted. Null if it wasn\'t. 
     * @type {number}
     * @memberof RealmExport
     */
    deleted_timestamp?: number;
    /**
     * The timestamp of when the export failed. Null if it didn\'t. 
     * @type {number}
     * @memberof RealmExport
     */
    failed_timestamp?: number;
    /**
     * The URL of the export. `null` if there\'s no URL. 
     * @type {string}
     * @memberof RealmExport
     */
    export_url?: string;
    /**
     * Whether the export is pending or not. 
     * @type {boolean}
     * @memberof RealmExport
     */
    pending?: boolean;
}


/**
 * Object containing details about a realm playground. 
 * @export
 */
export type RealmPlayground = {
    /**
     * The unique ID for the realm playground. 
     * @type {number}
     * @memberof RealmPlayground
     */
    id?: number;
    /**
     * The user-visible display name of the playground.  Clients should display this in UI for picking which playground to open a code block in, to differentiate between multiple configured playground options for a given pygments language.  **Changes**: New in Zulip 4.0 (feature level 49). 
     * @type {string}
     * @memberof RealmPlayground
     */
    name?: string;
    /**
     * The name of the Pygments language lexer for that programming language. 
     * @type {string}
     * @memberof RealmPlayground
     */
    pygments_language?: string;
    /**
     * The url prefix for the playground. 
     * @type {string}
     * @memberof RealmPlayground
     */
    url_prefix?: string;
}



            export type SubscriptionsRoleEnum = 20 | 50;
/**
 * 
 * @export
 */
export type Subscriptions = {
    /**
     * The unique ID of a stream. 
     * @type {number}
     * @memberof Subscriptions
     */
    stream_id?: number;
    /**
     * The name of a stream. 
     * @type {string}
     * @memberof Subscriptions
     */
    name?: string;
    /**
     * The short description of a stream in text/markdown format, intended to be used to prepopulate UI for editing a stream\'s description. 
     * @type {string}
     * @memberof Subscriptions
     */
    description?: string;
    /**
     * A short description of a stream rendered as HTML, intended to be used when displaying the stream description in a UI.  One should use the standard Zulip rendered_markdown CSS when displaying this content so that emoji, LaTeX, and other syntax work correctly.  And any client-side security logic for user-generated message content should be applied when displaying this HTML as though it were the body of a Zulip message. 
     * @type {string}
     * @memberof Subscriptions
     */
    rendered_description?: string;
    /**
     * The UNIX timestamp for when the stream was created, in UTC seconds.  **Changes**: New in Zulip 4.0 (feature level 30). 
     * @type {number}
     * @memberof Subscriptions
     */
    date_created?: number;
    /**
     * Specifies whether the stream is private or not. Only people who have been invited can access a private stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    invite_only?: boolean;
    /**
     * A list of user IDs of users who are also subscribed to a given stream. Included only if `include_subscribers` is `true`. 
     * @type {Array<number>}
     * @memberof Subscriptions
     */
    subscribers?: Array<number>;
    /**
     * A boolean specifying whether desktop notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_desktop_notifications, for this stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    desktop_notifications?: boolean;
    /**
     * A boolean specifying whether email notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_email_notifications, for this stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    email_notifications?: boolean;
    /**
     * A boolean specifying whether wildcard mentions trigger notifications as though they were personal mentions in this stream.  A null value means the value of this setting should be inherited from the user-level default setting, wildcard_mentions_notify, for this stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    wildcard_mentions_notify?: boolean;
    /**
     * A boolean specifying whether push notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_push_notifications, for this stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    push_notifications?: boolean;
    /**
     * A boolean specifying whether audible notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_audible_notifications, for this stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    audible_notifications?: boolean;
    /**
     * A boolean specifying whether the given stream has been pinned to the top. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    pin_to_top?: boolean;
    /**
     * Email address of the given stream, used for [sending emails to the stream](/help/message-a-stream-by-email). 
     * @type {string}
     * @memberof Subscriptions
     */
    email_address?: string;
    /**
     * Whether the user has muted the stream. Muted streams do not count towards your total unread count and do not show up in `All messages` view (previously known as `Home` view).  **Changes**: Prior to Zulip 2.1, this feature was represented by the more confusingly named `in_home_view` (with the opposite value, `in_home_view=!is_muted`). 
     * @type {boolean}
     * @memberof Subscriptions
     */
    is_muted?: boolean;
    /**
     * Legacy property for if the given stream is muted, with inverted meeting.  **Deprecated**; clients should use is_muted where available. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    in_home_view?: boolean;
    /**
     * Whether only organization administrators can post to the stream.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use `stream_post_policy` instead. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    is_announcement_only?: boolean;
    /**
     * Whether the stream has been configured to allow unauthenticated access to its message history from the web. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    is_web_public?: boolean;
    /**
     * The user\'s role within the stream (distinct from the user\'s [organization-level role](/help/roles-and-permissions)). Valid values are:  * 20 => Stream administrator. * 50 => Subscriber.  **Changes**: New in Zulip 4.0 (feature level 31). 
     * @type {number}
     * @memberof Subscriptions
     */
    role?: SubscriptionsRoleEnum;
    /**
     * The user\'s personal color for the stream. 
     * @type {string}
     * @memberof Subscriptions
     */
    color?: string;
    /**
     * Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
     * @type {number}
     * @memberof Subscriptions
     */
    stream_post_policy?: number;
    /**
     * Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  There are two special values:  * `null`, the default, means the stream will inherit the organization   level setting. * `-1` encodes retaining messages in this stream forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
     * @type {number}
     * @memberof Subscriptions
     */
    message_retention_days?: number;
    /**
     * Whether the history of the stream is public to its subscribers.  Currently always true for public streams (i.e. invite_only=False implies history_public_to_subscribers=True), but clients should not make that assumption, as we may change that behavior in the future. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    history_public_to_subscribers?: boolean;
    /**
     * The id of the first message in the stream.  Intended to help clients determine whether they need to display UI like the \"more topics\" widget that would suggest the stream has older history that can be accessed.  Null is used for streams with no message history. 
     * @type {number}
     * @memberof Subscriptions
     */
    first_message_id?: number;
    /**
     * The average number of messages sent to the stream in recent weeks, rounded to the nearest integer.  Null means the stream was recently created and there is insufficient data to estimate the average traffic. 
     * @type {number}
     * @memberof Subscriptions
     */
    stream_weekly_traffic?: number;
}


/**
 * 
 * @export
 */
export type User = {
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    email?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    is_bot?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    avatar_url?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    avatar_version?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    full_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    is_admin?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    is_owner?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    is_billing_admin?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    role?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    bot_type?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    user_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    bot_owner_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    is_active?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    is_guest?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    timezone?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    date_joined?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    delivery_email?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof User
     */
    profile_data?: AnyType;
}


/**
 * 
 * @export
 */
export type UserAllOf = {
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    email?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    is_bot?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    avatar_url?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    avatar_version?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    full_name?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    is_admin?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    is_owner?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    is_billing_admin?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    role?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    bot_type?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    user_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    bot_owner_id?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    is_active?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    is_guest?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    timezone?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    date_joined?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    delivery_email?: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserAllOf
     */
    profile_data?: AnyType;
}



            export type UserBaseRoleEnum = 100 | 200 | 300 | 400 | 600;
/**
 * A dictionary containing basic data on a given Zulip user. 
 * @export
 */
export type UserBase = {
    /**
     * The Zulip API email address of the user or bot.  If you do not have permission to view the email address of the target user, this will be a fake email address that is usable for the Zulip API but nothing else. 
     * @type {string}
     * @memberof UserBase
     */
    email?: string;
    /**
     * A boolean specifying whether the user is a bot or full account. 
     * @type {boolean}
     * @memberof UserBase
     */
    is_bot?: boolean;
    /**
     * URL for the user\'s avatar.  Will be `null` if the `client_gravatar` query parameter was set to `True` and the user\'s avatar is hosted by the Gravatar provider (i.e. the user has never uploaded an avatar).  **Changes**: In Zulip 3.0 (feature level 18), if the client has the `user_avatar_url_field_optional` capability, this will be missing at the server\'s sole discretion. 
     * @type {string}
     * @memberof UserBase
     */
    avatar_url?: string;
    /**
     * Version for the user\'s avatar.  Used for cache-busting requests for the user\'s avatar.  Clients generally shouldn\'t need to use this; most avatar URLs sent by Zulip will already end with `?v={avatar_version}`. 
     * @type {number}
     * @memberof UserBase
     */
    avatar_version?: number;
    /**
     * Full name of the user or bot, used for all display purposes. 
     * @type {string}
     * @memberof UserBase
     */
    full_name?: string;
    /**
     * A boolean specifying whether the user is an organization administrator. 
     * @type {boolean}
     * @memberof UserBase
     */
    is_admin?: boolean;
    /**
     * A boolean specifying whether the user is an organization owner. If true, is_admin will also be true.  **Changes**: New in Zulip 3.0 (feature level 8). 
     * @type {boolean}
     * @memberof UserBase
     */
    is_owner?: boolean;
    /**
     * A boolean specifying whether the user is a billing administrator.  **Changes**: New in Zulip 5.0 (feature level 73). 
     * @type {boolean}
     * @memberof UserBase
     */
    is_billing_admin?: boolean;
    /**
     * [Organization-level role](/help/roles-and-permissions)) of the user. Poosible values are:  * Organization owner => 100 * Organization administrator => 200 * Organization moderator => 300 * Member => 400 * Guest => 600  **Changes**: New in Zulip 4.0 (feature level 59). 
     * @type {number}
     * @memberof UserBase
     */
    role?: UserBaseRoleEnum;
    /**
     * An integer describing the type of bot: * `null` if the user isn\'t a bot. * `1` for a `Generic` bot. * `2` for an `Incoming webhook` bot. * `3` for an `Outgoing webhook` bot. * `4` for an `Embedded` bot. 
     * @type {number}
     * @memberof UserBase
     */
    bot_type?: number;
    /**
     * The unique ID of the user. 
     * @type {number}
     * @memberof UserBase
     */
    user_id?: number;
    /**
     * If the user is a bot (i.e. `is_bot` is `True`), `bot_owner` is the user ID of the bot\'s owner (usually, whoever created the bot).  Will be null for legacy bots that do not have an owner.  **Changes**: New in Zulip 3.0 (feature level 1).  In previous versions, there was a `bot_owner` field containing the email address of the bot\'s owner. 
     * @type {number}
     * @memberof UserBase
     */
    bot_owner_id?: number;
    /**
     * A boolean specifying whether the user account has been deactivated. 
     * @type {boolean}
     * @memberof UserBase
     */
    is_active?: boolean;
    /**
     * A boolean specifying whether the user is a guest user. 
     * @type {boolean}
     * @memberof UserBase
     */
    is_guest?: boolean;
    /**
     * The time zone of the user. 
     * @type {string}
     * @memberof UserBase
     */
    timezone?: string;
    /**
     * The time the user account was created. 
     * @type {string}
     * @memberof UserBase
     */
    date_joined?: string;
    /**
     * The user\'s real email address.  This field is present only if [email address visibility](/help/restrict-visibility-of-email-addresses) is limited and you are an administrator with access to real email addresses under the configured policy. 
     * @type {string}
     * @memberof UserBase
     */
    delivery_email?: string;
    /**
     * A dictionary containing custom profile field data for the user. Each entry maps the integer ID of a custom profile field in the organization to a dictionary containing the user\'s data for that field.  Generally the data includes just a single `value` key; for those custom profile fields supporting Markdown, a `rendered_value` key will also be present. 
     * @type {{ [key: string]: Object; }}
     * @memberof UserBase
     */
    profile_data?: { [key: string]: Object; };
}


/**
 * 
 * @export
 */
export type UserDeactivatedError = {
    /**
     * 
     * @type {AnyType}
     * @memberof UserDeactivatedError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserDeactivatedError
     */
    msg: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserDeactivatedError
     */
    code?: AnyType;
}


/**
 * Object containing the user group\'s attributes. 
 * @export
 */
export type UserGroup = {
    /**
     * The name of the user group. 
     * @type {string}
     * @memberof UserGroup
     */
    name?: string;
    /**
     * The description of the user group. 
     * @type {string}
     * @memberof UserGroup
     */
    description?: string;
    /**
     * Array containing the id of the users who are members of this user group. 
     * @type {Array<number>}
     * @memberof UserGroup
     */
    members?: Array<number>;
    /**
     * The ID of the user group. 
     * @type {number}
     * @memberof UserGroup
     */
    id?: number;
}


/**
 * 
 * @export
 */
export type UserNotAuthorizedError = {
    /**
     * 
     * @type {AnyType}
     * @memberof UserNotAuthorizedError
     */
    result: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserNotAuthorizedError
     */
    msg: AnyType;
    /**
     * 
     * @type {AnyType}
     * @memberof UserNotAuthorizedError
     */
    code?: AnyType;
}




/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For easy testing of mobile apps and other clients and against Zulip development servers, we support fetching a Zulip API key for any user on the development server without authentication (so that they can implement analogues of the one-click login process available for Zulip development servers on the web).  **Note:** This endpoint is only available on Zulip development servers; for obvious security reasons it will always return an error in a Zulip production server.  `POST {{ api_url }}/v1/dev_fetch_api_key` 
         * @summary Fetch an API key (development only)
         * @throws {RequiredError}
         */
        devFetchApiKey(username: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling devFetchApiKey.');
            }
            const localVarPath = `/dev_fetch_api_key`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (username !== undefined) {
                localVarQueryParameter['username'] = ((username:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint is used by clients such as the Zulip mobile and terminal apps to implement password-based authentication.  Given the user\'s Zulip login credentials, it returns a Zulip API key that the client can use to make requests requests as the user.  This endpoint is only useful for Zulip servers/organizations with EmailAuthBackend or LDAPAuthBackend enabled.  The Zulip mobile apps also support SSO/social authentication (GitHub auth, Google auth, SAML, etc.) that does not use this endpoint.  Instead, the mobile apps reuse the web login flow passing the `mobile_flow_otp` in a webview, and the credentials are returned to the app (encrypted) via a redirect to a `zulip://` URL.  !!! warn \"\"     **Note:** If you signed up using passwordless authentication and     never had a password, you can [reset your password](/help/change-your-password).      See the [API keys](/api/api-keys) documentation for     more details on how to download API key manually.  In a [Zulip development environment](https://zulip.readthedocs.io/en/latest/development/overview.html), see also [the unauthenticated variant](/api/dev-fetch-api-key). 
         * @summary Fetch an API key (production)
         * @throws {RequiredError}
         */
        fetchApiKey(username: string, password: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling fetchApiKey.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling fetchApiKey.');
            }
            const localVarPath = `/fetch_api_key`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (username !== undefined) {
                localVarQueryParameter['username'] = ((username:any):string);
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = ((password:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type AuthenticationApiType = { 
    devFetchApiKey(username: string, options?: RequestOptions): Promise<ApiKeyResponse>,

    fetchApiKey(username: string, password: string, options?: RequestOptions): Promise<ApiKeyResponse>,
}

/**
 * AuthenticationApi - factory function to inject configuration 
 * @export
 */
export const AuthenticationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): AuthenticationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * For easy testing of mobile apps and other clients and against Zulip development servers, we support fetching a Zulip API key for any user on the development server without authentication (so that they can implement analogues of the one-click login process available for Zulip development servers on the web).  **Note:** This endpoint is only available on Zulip development servers; for obvious security reasons it will always return an error in a Zulip production server.  `POST {{ api_url }}/v1/dev_fetch_api_key` 
         * @summary Fetch an API key (development only)
         * @throws {RequiredError}
         */
        devFetchApiKey(username: string, options?: RequestOptions = {}): Promise<ApiKeyResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).devFetchApiKey(username, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This API endpoint is used by clients such as the Zulip mobile and terminal apps to implement password-based authentication.  Given the user\'s Zulip login credentials, it returns a Zulip API key that the client can use to make requests requests as the user.  This endpoint is only useful for Zulip servers/organizations with EmailAuthBackend or LDAPAuthBackend enabled.  The Zulip mobile apps also support SSO/social authentication (GitHub auth, Google auth, SAML, etc.) that does not use this endpoint.  Instead, the mobile apps reuse the web login flow passing the `mobile_flow_otp` in a webview, and the credentials are returned to the app (encrypted) via a redirect to a `zulip://` URL.  !!! warn \"\"     **Note:** If you signed up using passwordless authentication and     never had a password, you can [reset your password](/help/change-your-password).      See the [API keys](/api/api-keys) documentation for     more details on how to download API key manually.  In a [Zulip development environment](https://zulip.readthedocs.io/en/latest/development/overview.html), see also [the unauthenticated variant](/api/dev-fetch-api-key). 
         * @summary Fetch an API key (production)
         * @throws {RequiredError}
         */
        fetchApiKey(username: string, password: string, options?: RequestOptions = {}): Promise<ApiKeyResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).fetchApiKey(username, password, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * MessagesApi - fetch parameter creator
 * @export
 */
export const MessagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an [emoji reaction](/help/emoji-reactions) to a message.  `POST {{ api_url }}/v1/messages/{message_id}/reactions` 
         * @summary Add an emoji reaction
         * @throws {RequiredError}
         */
        addReaction(messageId: number, emojiName: string, emojiCode?: string, reactionType?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling addReaction.');
            }
            // verify required parameter 'emojiName' is not null or undefined
            if (emojiName === null || emojiName === undefined) {
                throw new RequiredError('emojiName','Required parameter emojiName was null or undefined when calling addReaction.');
            }
            const localVarPath = `/messages/{message_id}/reactions`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (emojiName !== undefined) {
                localVarQueryParameter['emoji_name'] = ((emojiName:any):string);
            }

            if (emojiCode !== undefined) {
                localVarQueryParameter['emoji_code'] = ((emojiCode:any):string);
            }

            if (reactionType !== undefined) {
                localVarQueryParameter['reaction_type'] = ((reactionType:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check whether a set of messages match a [narrow](/api/construct-narrow).  `GET {{ api_url }}/v1/messages/matches_narrow`  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the `match_subject` and `match_content` objects is designed to match those of `GET /messages`, so that a client can splice these fields into a `message` object received from `GET /events` and end up with an extended message object identical to how a `GET /messages` for the current narrow would have returned the message. 
         * @summary Check if messages match a narrow
         * @throws {RequiredError}
         */
        checkMessagesMatchNarrow(msgIds: Array<number>, narrow: Array<Object>, options: RequestOptions): FetchArgs {
            // verify required parameter 'msgIds' is not null or undefined
            if (msgIds === null || msgIds === undefined) {
                throw new RequiredError('msgIds','Required parameter msgIds was null or undefined when calling checkMessagesMatchNarrow.');
            }
            // verify required parameter 'narrow' is not null or undefined
            if (narrow === null || narrow === undefined) {
                throw new RequiredError('narrow','Required parameter narrow was null or undefined when calling checkMessagesMatchNarrow.');
            }
            const localVarPath = `/messages/matches_narrow`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (msgIds) {
                localVarQueryParameter['msg_ids'] = msgIds;
            }

            if (narrow) {
                localVarQueryParameter['narrow'] = narrow;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a message.  `DELETE {{ api_url }}/v1/messages/{msg_id}`  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
         * @summary Delete a message
         * @throws {RequiredError}
         */
        deleteMessage(messageId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling deleteMessage.');
            }
            const localVarPath = `/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a temporary URL for access to the file that doesn\'t require authentication. 
         * @summary Get public temporary URL
         * @throws {RequiredError}
         */
        getFileTemporaryUrl(realmIdStr: number, filename: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'realmIdStr' is not null or undefined
            if (realmIdStr === null || realmIdStr === undefined) {
                throw new RequiredError('realmIdStr','Required parameter realmIdStr was null or undefined when calling getFileTemporaryUrl.');
            }
            // verify required parameter 'filename' is not null or undefined
            if (filename === null || filename === undefined) {
                throw new RequiredError('filename','Required parameter filename was null or undefined when calling getFileTemporaryUrl.');
            }
            const localVarPath = `/user_uploads/{realm_id_str}/{filename}`
                .replace(`{${"realm_id_str"}}`, encodeURIComponent(String(realmIdStr)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the message edit history of a previously edited message.  `GET {{ api_url }}/v1/messages/{message_id}/history`  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
         * @summary Get a message\'s edit history
         * @throws {RequiredError}
         */
        getMessageHistory(messageId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling getMessageHistory.');
            }
            const localVarPath = `/messages/{message_id}/history`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch message history from a Zulip server.  `GET {{ api_url }}/v1/messages`  This `GET /api/v1/messages` endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip\'s powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user\'s message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an `anchor` message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the `num_before` and `num_after` limits.  We recommend using `num_before <= 1000` and `num_after <= 1000` to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
         * @summary Get messages
         * @throws {RequiredError}
         */
        getMessages(numBefore: number, numAfter: number, anchor?: string | number, narrow?: Array<Object>, clientGravatar?: boolean, applyMarkdown?: boolean, useFirstUnreadAnchor?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'numBefore' is not null or undefined
            if (numBefore === null || numBefore === undefined) {
                throw new RequiredError('numBefore','Required parameter numBefore was null or undefined when calling getMessages.');
            }
            // verify required parameter 'numAfter' is not null or undefined
            if (numAfter === null || numAfter === undefined) {
                throw new RequiredError('numAfter','Required parameter numAfter was null or undefined when calling getMessages.');
            }
            const localVarPath = `/messages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (anchor !== undefined) {
                localVarQueryParameter['anchor'] = ((anchor:any):string);
            }

            if (numBefore !== undefined) {
                localVarQueryParameter['num_before'] = ((numBefore:any):string);
            }

            if (numAfter !== undefined) {
                localVarQueryParameter['num_after'] = ((numAfter:any):string);
            }

            if (narrow) {
                localVarQueryParameter['narrow'] = narrow;
            }

            if (clientGravatar !== undefined) {
                localVarQueryParameter['client_gravatar'] = ((clientGravatar:any):string);
            }

            if (applyMarkdown !== undefined) {
                localVarQueryParameter['apply_markdown'] = ((applyMarkdown:any):string);
            }

            if (useFirstUnreadAnchor !== undefined) {
                localVarQueryParameter['use_first_unread_anchor'] = ((useFirstUnreadAnchor:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the raw content of a message.  `GET {{ api_url }}/v1/messages/{msg_id}`  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message\'s raw Markdown (e.g. for pre-filling a message-editing UI). 
         * @summary Get a message\'s raw Markdown
         * @throws {RequiredError}
         */
        getRawMessage(messageId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling getRawMessage.');
            }
            const localVarPath = `/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks all of the current user\'s unread messages as read.  `POST {{ api_url }}/v1/mark_all_as_read` 
         * @summary Mark all messages as read
         * @throws {RequiredError}
         */
        markAllAsRead(options: RequestOptions): FetchArgs {
            const localVarPath = `/mark_all_as_read`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all the unread messages in a stream as read. 
         * @summary Mark messages in a stream as read
         * @throws {RequiredError}
         */
        markStreamAsRead(streamId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling markStreamAsRead.');
            }
            const localVarPath = `/mark_stream_as_read`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = ((streamId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all the unread messages in a topic as read. 
         * @summary Mark messages in a topic as read
         * @throws {RequiredError}
         */
        markTopicAsRead(streamId: number, topicName: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling markTopicAsRead.');
            }
            // verify required parameter 'topicName' is not null or undefined
            if (topicName === null || topicName === undefined) {
                throw new RequiredError('topicName','Required parameter topicName was null or undefined when calling markTopicAsRead.');
            }
            const localVarPath = `/mark_topic_as_read`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = ((streamId:any):string);
            }

            if (topicName !== undefined) {
                localVarQueryParameter['topic_name'] = ((topicName:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an [emoji reaction](/help/emoji-reactions) from a message.  `DELETE {{ api_url }}/v1/messages/{message_id}/reactions` 
         * @summary Remove an emoji reaction
         * @throws {RequiredError}
         */
        removeReaction(messageId: number, emojiName?: string, emojiCode?: string, reactionType?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling removeReaction.');
            }
            const localVarPath = `/messages/{message_id}/reactions`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (emojiName !== undefined) {
                localVarQueryParameter['emoji_name'] = ((emojiName:any):string);
            }

            if (emojiCode !== undefined) {
                localVarQueryParameter['emoji_code'] = ((emojiCode:any):string);
            }

            if (reactionType !== undefined) {
                localVarQueryParameter['reaction_type'] = ((reactionType:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Render a message to HTML.  `POST {{ api_url }}/v1/messages/render` 
         * @summary Render message
         * @throws {RequiredError}
         */
        renderMessage(content: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling renderMessage.');
            }
            const localVarPath = `/messages/render`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (content !== undefined) {
                localVarQueryParameter['content'] = ((content:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a stream or a private message.  `POST {{ api_url }}/v1/messages` 
         * @summary Send a message
         * @throws {RequiredError}
         */
        sendMessage(type: 'private' | 'stream', to: Array<number>, content: string, topic?: string, queueId?: string, localId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling sendMessage.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling sendMessage.');
            }
            // verify required parameter 'content' is not null or undefined
            if (content === null || content === undefined) {
                throw new RequiredError('content','Required parameter content was null or undefined when calling sendMessage.');
            }
            const localVarPath = `/messages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (type !== undefined) {
                localVarQueryParameter['type'] = ((type:any):string);
            }

            if (to) {
                localVarQueryParameter['to'] = to;
            }

            if (content !== undefined) {
                localVarQueryParameter['content'] = ((content:any):string);
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = ((topic:any):string);
            }

            if (queueId !== undefined) {
                localVarQueryParameter['queue_id'] = ((queueId:any):string);
            }

            if (localId !== undefined) {
                localVarQueryParameter['local_id'] = ((localId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit/update the content or topic of a message.  `PATCH {{ api_url }}/v1/messages/{msg_id}`  `{msg_id}` in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to ` {original_topic}`.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
         * @summary Edit a message
         * @throws {RequiredError}
         */
        updateMessage(messageId: number, topic?: string, propagateMode?: 'change_one' | 'change_later' | 'change_all', sendNotificationToOldThread?: boolean, sendNotificationToNewThread?: boolean, content?: string, streamId?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling updateMessage.');
            }
            const localVarPath = `/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = ((topic:any):string);
            }

            if (propagateMode !== undefined) {
                localVarQueryParameter['propagate_mode'] = ((propagateMode:any):string);
            }

            if (sendNotificationToOldThread !== undefined) {
                localVarQueryParameter['send_notification_to_old_thread'] = ((sendNotificationToOldThread:any):string);
            }

            if (sendNotificationToNewThread !== undefined) {
                localVarQueryParameter['send_notification_to_new_thread'] = ((sendNotificationToNewThread:any):string);
            }

            if (content !== undefined) {
                localVarQueryParameter['content'] = ((content:any):string);
            }

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = ((streamId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or remove personal message flags like `read` and `starred` on a collection of message IDs.  `POST {{ api_url }}/v1/messages/flags`  For updating the `read` flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
         * @summary Update personal message flags
         * @throws {RequiredError}
         */
        updateMessageFlags(messages: Array<number>, op: 'add' | 'remove', flag: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'messages' is not null or undefined
            if (messages === null || messages === undefined) {
                throw new RequiredError('messages','Required parameter messages was null or undefined when calling updateMessageFlags.');
            }
            // verify required parameter 'op' is not null or undefined
            if (op === null || op === undefined) {
                throw new RequiredError('op','Required parameter op was null or undefined when calling updateMessageFlags.');
            }
            // verify required parameter 'flag' is not null or undefined
            if (flag === null || flag === undefined) {
                throw new RequiredError('flag','Required parameter flag was null or undefined when calling updateMessageFlags.');
            }
            const localVarPath = `/messages/flags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (messages) {
                localVarQueryParameter['messages'] = messages;
            }

            if (op !== undefined) {
                localVarQueryParameter['op'] = ((op:any):string);
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = ((flag:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a single file and get the corresponding URI.  `POST {{ api_url }}/v1/user_uploads`  Initially, only you will be able to access the link.  To share the uploaded file, you\'ll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
         * @summary Upload a file
         * @throws {RequiredError}
         */
        uploadFile(filename?: any, options: RequestOptions): FetchArgs {
            const localVarPath = `/user_uploads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (filename !== undefined) {
                localVarFormParams.set('filename', ((filename:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MessagesApiType = { 
    addReaction(messageId: number, emojiName: string, emojiCode?: string, reactionType?: string, options?: RequestOptions): Promise<JsonSuccess>,

    checkMessagesMatchNarrow(msgIds: Array<number>, narrow: Array<Object>, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    deleteMessage(messageId: number, options?: RequestOptions): Promise<JsonSuccess>,

    getFileTemporaryUrl(realmIdStr: number, filename: string, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getMessageHistory(messageId: number, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getMessages(numBefore: number, numAfter: number, anchor?: string | number, narrow?: Array<Object>, clientGravatar?: boolean, applyMarkdown?: boolean, useFirstUnreadAnchor?: boolean, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getRawMessage(messageId: number, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    markAllAsRead(options?: RequestOptions): Promise<JsonSuccess>,

    markStreamAsRead(streamId: number, options?: RequestOptions): Promise<JsonSuccess>,

    markTopicAsRead(streamId: number, topicName: string, options?: RequestOptions): Promise<JsonSuccess>,

    removeReaction(messageId: number, emojiName?: string, emojiCode?: string, reactionType?: string, options?: RequestOptions): Promise<JsonSuccess>,

    renderMessage(content: string, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    sendMessage(type: 'private' | 'stream', to: Array<number>, content: string, topic?: string, queueId?: string, localId?: string, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    updateMessage(messageId: number, topic?: string, propagateMode?: 'change_one' | 'change_later' | 'change_all', sendNotificationToOldThread?: boolean, sendNotificationToNewThread?: boolean, content?: string, streamId?: number, options?: RequestOptions): Promise<JsonSuccess>,

    updateMessageFlags(messages: Array<number>, op: 'add' | 'remove', flag: string, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    uploadFile(filename?: any, options?: RequestOptions): Promise<JsonSuccessBase & Object>,
}

/**
 * MessagesApi - factory function to inject configuration 
 * @export
 */
export const MessagesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MessagesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Add an [emoji reaction](/help/emoji-reactions) to a message.  `POST {{ api_url }}/v1/messages/{message_id}/reactions` 
         * @summary Add an emoji reaction
         * @throws {RequiredError}
         */
        addReaction(messageId: number, emojiName: string, emojiCode?: string, reactionType?: string, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).addReaction(messageId, emojiName, emojiCode, reactionType, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Check whether a set of messages match a [narrow](/api/construct-narrow).  `GET {{ api_url }}/v1/messages/matches_narrow`  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the `match_subject` and `match_content` objects is designed to match those of `GET /messages`, so that a client can splice these fields into a `message` object received from `GET /events` and end up with an extended message object identical to how a `GET /messages` for the current narrow would have returned the message. 
         * @summary Check if messages match a narrow
         * @throws {RequiredError}
         */
        checkMessagesMatchNarrow(msgIds: Array<number>, narrow: Array<Object>, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).checkMessagesMatchNarrow(msgIds, narrow, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Permanently delete a message.  `DELETE {{ api_url }}/v1/messages/{msg_id}`  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
         * @summary Delete a message
         * @throws {RequiredError}
         */
        deleteMessage(messageId: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).deleteMessage(messageId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get a temporary URL for access to the file that doesn\'t require authentication. 
         * @summary Get public temporary URL
         * @throws {RequiredError}
         */
        getFileTemporaryUrl(realmIdStr: number, filename: string, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).getFileTemporaryUrl(realmIdStr, filename, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Fetch the message edit history of a previously edited message.  `GET {{ api_url }}/v1/messages/{message_id}/history`  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
         * @summary Get a message\'s edit history
         * @throws {RequiredError}
         */
        getMessageHistory(messageId: number, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).getMessageHistory(messageId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Fetch message history from a Zulip server.  `GET {{ api_url }}/v1/messages`  This `GET /api/v1/messages` endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip\'s powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user\'s message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an `anchor` message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the `num_before` and `num_after` limits.  We recommend using `num_before <= 1000` and `num_after <= 1000` to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
         * @summary Get messages
         * @throws {RequiredError}
         */
        getMessages(numBefore: number, numAfter: number, anchor?: string | number, narrow?: Array<Object>, clientGravatar?: boolean, applyMarkdown?: boolean, useFirstUnreadAnchor?: boolean, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).getMessages(numBefore, numAfter, anchor, narrow, clientGravatar, applyMarkdown, useFirstUnreadAnchor, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get the raw content of a message.  `GET {{ api_url }}/v1/messages/{msg_id}`  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message\'s raw Markdown (e.g. for pre-filling a message-editing UI). 
         * @summary Get a message\'s raw Markdown
         * @throws {RequiredError}
         */
        getRawMessage(messageId: number, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).getRawMessage(messageId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Marks all of the current user\'s unread messages as read.  `POST {{ api_url }}/v1/mark_all_as_read` 
         * @summary Mark all messages as read
         * @throws {RequiredError}
         */
        markAllAsRead(options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).markAllAsRead(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Mark all the unread messages in a stream as read. 
         * @summary Mark messages in a stream as read
         * @throws {RequiredError}
         */
        markStreamAsRead(streamId: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).markStreamAsRead(streamId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Mark all the unread messages in a topic as read. 
         * @summary Mark messages in a topic as read
         * @throws {RequiredError}
         */
        markTopicAsRead(streamId: number, topicName: string, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).markTopicAsRead(streamId, topicName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Remove an [emoji reaction](/help/emoji-reactions) from a message.  `DELETE {{ api_url }}/v1/messages/{message_id}/reactions` 
         * @summary Remove an emoji reaction
         * @throws {RequiredError}
         */
        removeReaction(messageId: number, emojiName?: string, emojiCode?: string, reactionType?: string, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).removeReaction(messageId, emojiName, emojiCode, reactionType, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Render a message to HTML.  `POST {{ api_url }}/v1/messages/render` 
         * @summary Render message
         * @throws {RequiredError}
         */
        renderMessage(content: string, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).renderMessage(content, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Send a stream or a private message.  `POST {{ api_url }}/v1/messages` 
         * @summary Send a message
         * @throws {RequiredError}
         */
        sendMessage(type: 'private' | 'stream', to: Array<number>, content: string, topic?: string, queueId?: string, localId?: string, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).sendMessage(type, to, content, topic, queueId, localId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Edit/update the content or topic of a message.  `PATCH {{ api_url }}/v1/messages/{msg_id}`  `{msg_id}` in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to ` {original_topic}`.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
         * @summary Edit a message
         * @throws {RequiredError}
         */
        updateMessage(messageId: number, topic?: string, propagateMode?: 'change_one' | 'change_later' | 'change_all', sendNotificationToOldThread?: boolean, sendNotificationToNewThread?: boolean, content?: string, streamId?: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).updateMessage(messageId, topic, propagateMode, sendNotificationToOldThread, sendNotificationToNewThread, content, streamId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Add or remove personal message flags like `read` and `starred` on a collection of message IDs.  `POST {{ api_url }}/v1/messages/flags`  For updating the `read` flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
         * @summary Update personal message flags
         * @throws {RequiredError}
         */
        updateMessageFlags(messages: Array<number>, op: 'add' | 'remove', flag: string, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).updateMessageFlags(messages, op, flag, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Upload a single file and get the corresponding URI.  `POST {{ api_url }}/v1/user_uploads`  Initially, only you will be able to access the link.  To share the uploaded file, you\'ll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
         * @summary Upload a file
         * @throws {RequiredError}
         */
        uploadFile(filename?: any, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).uploadFile(filename, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * RealTimeEventsApi - fetch parameter creator
 * @export
 */
export const RealTimeEventsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a previously registered queue.  `DELETE {{ api_url }}/v1/events` 
         * @summary Delete an event queue
         * @throws {RequiredError}
         */
        deleteQueue(queueId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'queueId' is not null or undefined
            if (queueId === null || queueId === undefined) {
                throw new RequiredError('queueId','Required parameter queueId was null or undefined when calling deleteQueue.');
            }
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (queueId !== undefined) {
                localVarQueryParameter['queue_id'] = ((queueId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * `GET {{ api_url }}/v1/events`  This endpoint allows you to receive new events from [a registered event queue](/api/register-queue).  Long-lived clients should use the `event_queue_longpoll_timeout_seconds` property returned by `POST /register` as the client-side HTTP request timeout for calls to this endpoint.  It is guaranteed to be higher than heartbeat frequency and should be respected by clients to avoid breaking when heartbeat frequency increases. 
         * @summary Get events from an event queue
         * @throws {RequiredError}
         */
        getEvents(queueId: string, lastEventId?: number, dontBlock?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'queueId' is not null or undefined
            if (queueId === null || queueId === undefined) {
                throw new RequiredError('queueId','Required parameter queueId was null or undefined when calling getEvents.');
            }
            const localVarPath = `/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (queueId !== undefined) {
                localVarQueryParameter['queue_id'] = ((queueId:any):string);
            }

            if (lastEventId !== undefined) {
                localVarQueryParameter['last_event_id'] = ((lastEventId:any):string);
            }

            if (dontBlock !== undefined) {
                localVarQueryParameter['dont_block'] = ((dontBlock:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (Ignored) 
         * @throws {RequiredError}
         */
        realTimePost(eventTypes?: Array<string>, narrow?: Array<Array<string>>, allPublicStreams?: boolean, options: RequestOptions): FetchArgs {
            const localVarPath = `/real-time`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (eventTypes) {
                localVarQueryParameter['event_types'] = eventTypes;
            }

            if (narrow) {
                localVarQueryParameter['narrow'] = narrow;
            }

            if (allPublicStreams !== undefined) {
                localVarQueryParameter['all_public_streams'] = ((allPublicStreams:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * `POST {{ api_url }}/v1/register`  This powerful endpoint can be used to register a Zulip \"event queue\" (subscribed to certain types of \"events\", or updates to the messages and other Zulip data the current user has access to), as well as to fetch the current state of that data.  (`register` also powers the `call_on_each_event` Python API, and is intended primarily for complex applications for which the more convenient `call_on_each_event` API is insufficient).  This endpoint returns a `queue_id` and a `last_event_id`; these can be used in subsequent calls to the [\"events\" endpoint](/api/get-events) to request events from the Zulip server using long-polling.  The server will queue events for up to 10 minutes of inactivity. After 10 minutes, your event queue will be garbage-collected.  The server will send `heartbeat` events every minute, which makes it easy to implement a robust client that does not miss events unless the client loses network connectivity with the Zulip server for 10 minutes or longer.  Once the server garbage-collects your event queue, the server will [return an error](/api/get-events#bad_event_queue_id-errors) with a code of `BAD_EVENT_QUEUE_ID` if you try to fetch events from the event queue.  Your software will need to handle that error condition by re-initializing itself (e.g. this is what triggers your browser reloading the Zulip web app when your laptop comes back online after being offline for more than 10 minutes).  When prototyping with this API, we recommend first calling `register` with no `event_types` parameter to see all the available data from all supported event types.  Before using your client in production, you should set appropriate `event_types` and `fetch_event_types` filters so that your client only requests the data it needs.  A few minutes doing this often saves 90% of the total bandwidth and other resources consumed by a client using this API.  See the [events system developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/events-system.html) if you need deeper details about how the Zulip event queue system works, avoids clients needing to worry about large classes of potentially messy races, etc. 
         * @summary Register an event queue
         * @throws {RequiredError}
         */
        registerQueue(applyMarkdown?: boolean, clientGravatar?: boolean, slimPresence?: boolean, eventTypes?: Array<string>, allPublicStreams?: boolean, includeSubscribers?: boolean, clientCapabilities?: Object, fetchEventTypes?: Array<string>, narrow?: Array<Array<string>>, options: RequestOptions): FetchArgs {
            const localVarPath = `/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (applyMarkdown !== undefined) {
                localVarQueryParameter['apply_markdown'] = ((applyMarkdown:any):string);
            }

            if (clientGravatar !== undefined) {
                localVarQueryParameter['client_gravatar'] = ((clientGravatar:any):string);
            }

            if (slimPresence !== undefined) {
                localVarQueryParameter['slim_presence'] = ((slimPresence:any):string);
            }

            if (eventTypes) {
                localVarQueryParameter['event_types'] = eventTypes;
            }

            if (allPublicStreams !== undefined) {
                localVarQueryParameter['all_public_streams'] = ((allPublicStreams:any):string);
            }

            if (includeSubscribers !== undefined) {
                localVarQueryParameter['include_subscribers'] = ((includeSubscribers:any):string);
            }

            if (clientCapabilities !== undefined) {
                localVarQueryParameter['client_capabilities'] = ((clientCapabilities:any):string);
            }

            if (fetchEventTypes) {
                localVarQueryParameter['fetch_event_types'] = fetchEventTypes;
            }

            if (narrow) {
                localVarQueryParameter['narrow'] = narrow;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Common error to many endpoints 
         * @summary Error handling
         * @throws {RequiredError}
         */
        restErrorHandling(options: RequestOptions): FetchArgs {
            const localVarPath = `/rest-error-handling`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type RealTimeEventsApiType = { 
    deleteQueue(queueId: string, options?: RequestOptions): Promise<JsonSuccess>,

    getEvents(queueId: string, lastEventId?: number, dontBlock?: boolean, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    realTimePost(eventTypes?: Array<string>, narrow?: Array<Array<string>>, allPublicStreams?: boolean, options?: RequestOptions): Promise<Response>,

    registerQueue(applyMarkdown?: boolean, clientGravatar?: boolean, slimPresence?: boolean, eventTypes?: Array<string>, allPublicStreams?: boolean, includeSubscribers?: boolean, clientCapabilities?: Object, fetchEventTypes?: Array<string>, narrow?: Array<Array<string>>, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    restErrorHandling(options?: RequestOptions): Promise<Response>,
}

/**
 * RealTimeEventsApi - factory function to inject configuration 
 * @export
 */
export const RealTimeEventsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): RealTimeEventsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Delete a previously registered queue.  `DELETE {{ api_url }}/v1/events` 
         * @summary Delete an event queue
         * @throws {RequiredError}
         */
        deleteQueue(queueId: string, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = RealTimeEventsApiFetchParamCreator(configuration).deleteQueue(queueId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * `GET {{ api_url }}/v1/events`  This endpoint allows you to receive new events from [a registered event queue](/api/register-queue).  Long-lived clients should use the `event_queue_longpoll_timeout_seconds` property returned by `POST /register` as the client-side HTTP request timeout for calls to this endpoint.  It is guaranteed to be higher than heartbeat frequency and should be respected by clients to avoid breaking when heartbeat frequency increases. 
         * @summary Get events from an event queue
         * @throws {RequiredError}
         */
        getEvents(queueId: string, lastEventId?: number, dontBlock?: boolean, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = RealTimeEventsApiFetchParamCreator(configuration).getEvents(queueId, lastEventId, dontBlock, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * (Ignored) 
         * @throws {RequiredError}
         */
        realTimePost(eventTypes?: Array<string>, narrow?: Array<Array<string>>, allPublicStreams?: boolean, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = RealTimeEventsApiFetchParamCreator(configuration).realTimePost(eventTypes, narrow, allPublicStreams, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * `POST {{ api_url }}/v1/register`  This powerful endpoint can be used to register a Zulip \"event queue\" (subscribed to certain types of \"events\", or updates to the messages and other Zulip data the current user has access to), as well as to fetch the current state of that data.  (`register` also powers the `call_on_each_event` Python API, and is intended primarily for complex applications for which the more convenient `call_on_each_event` API is insufficient).  This endpoint returns a `queue_id` and a `last_event_id`; these can be used in subsequent calls to the [\"events\" endpoint](/api/get-events) to request events from the Zulip server using long-polling.  The server will queue events for up to 10 minutes of inactivity. After 10 minutes, your event queue will be garbage-collected.  The server will send `heartbeat` events every minute, which makes it easy to implement a robust client that does not miss events unless the client loses network connectivity with the Zulip server for 10 minutes or longer.  Once the server garbage-collects your event queue, the server will [return an error](/api/get-events#bad_event_queue_id-errors) with a code of `BAD_EVENT_QUEUE_ID` if you try to fetch events from the event queue.  Your software will need to handle that error condition by re-initializing itself (e.g. this is what triggers your browser reloading the Zulip web app when your laptop comes back online after being offline for more than 10 minutes).  When prototyping with this API, we recommend first calling `register` with no `event_types` parameter to see all the available data from all supported event types.  Before using your client in production, you should set appropriate `event_types` and `fetch_event_types` filters so that your client only requests the data it needs.  A few minutes doing this often saves 90% of the total bandwidth and other resources consumed by a client using this API.  See the [events system developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/events-system.html) if you need deeper details about how the Zulip event queue system works, avoids clients needing to worry about large classes of potentially messy races, etc. 
         * @summary Register an event queue
         * @throws {RequiredError}
         */
        registerQueue(applyMarkdown?: boolean, clientGravatar?: boolean, slimPresence?: boolean, eventTypes?: Array<string>, allPublicStreams?: boolean, includeSubscribers?: boolean, clientCapabilities?: Object, fetchEventTypes?: Array<string>, narrow?: Array<Array<string>>, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = RealTimeEventsApiFetchParamCreator(configuration).registerQueue(applyMarkdown, clientGravatar, slimPresence, eventTypes, allPublicStreams, includeSubscribers, clientCapabilities, fetchEventTypes, narrow, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Common error to many endpoints 
         * @summary Error handling
         * @throws {RequiredError}
         */
        restErrorHandling(options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = RealTimeEventsApiFetchParamCreator(configuration).restErrorHandling(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ServerAndOrganizationsApi - fetch parameter creator
 * @export
 */
export const ServerAndOrganizationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  `POST {{ api_url }}/v1/realm/playgrounds`  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
         * @summary Add a code playground
         * @throws {RequiredError}
         */
        addCodePlayground(name: string, pygmentsLanguage: string, urlPrefix: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling addCodePlayground.');
            }
            // verify required parameter 'pygmentsLanguage' is not null or undefined
            if (pygmentsLanguage === null || pygmentsLanguage === undefined) {
                throw new RequiredError('pygmentsLanguage','Required parameter pygmentsLanguage was null or undefined when calling addCodePlayground.');
            }
            // verify required parameter 'urlPrefix' is not null or undefined
            if (urlPrefix === null || urlPrefix === undefined) {
                throw new RequiredError('urlPrefix','Required parameter urlPrefix was null or undefined when calling addCodePlayground.');
            }
            const localVarPath = `/realm/playgrounds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (pygmentsLanguage !== undefined) {
                localVarQueryParameter['pygments_language'] = ((pygmentsLanguage:any):string);
            }

            if (urlPrefix !== undefined) {
                localVarQueryParameter['url_prefix'] = ((urlPrefix:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `POST {{ api_url }}/v1/realm/filters` 
         * @summary Add a linkifier
         * @throws {RequiredError}
         */
        addLinkifier(pattern: string, urlFormatString: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'pattern' is not null or undefined
            if (pattern === null || pattern === undefined) {
                throw new RequiredError('pattern','Required parameter pattern was null or undefined when calling addLinkifier.');
            }
            // verify required parameter 'urlFormatString' is not null or undefined
            if (urlFormatString === null || urlFormatString === undefined) {
                throw new RequiredError('urlFormatString','Required parameter urlFormatString was null or undefined when calling addLinkifier.');
            }
            const localVarPath = `/realm/filters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pattern !== undefined) {
                localVarQueryParameter['pattern'] = ((pattern:any):string);
            }

            if (urlFormatString !== undefined) {
                localVarQueryParameter['url_format_string'] = ((urlFormatString:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [Create a custom profile field](/help/add-custom-profile-fields) in the user\'s organization.  `POST {{ api_url }}/v1/realm/profile_fields` 
         * @summary Create a custom profile field
         * @throws {RequiredError}
         */
        createCustomProfileField(fieldType: number, name?: string, hint?: string, fieldData?: Object, options: RequestOptions): FetchArgs {
            // verify required parameter 'fieldType' is not null or undefined
            if (fieldType === null || fieldType === undefined) {
                throw new RequiredError('fieldType','Required parameter fieldType was null or undefined when calling createCustomProfileField.');
            }
            const localVarPath = `/realm/profile_fields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (hint !== undefined) {
                localVarQueryParameter['hint'] = ((hint:any):string);
            }

            if (fieldType !== undefined) {
                localVarQueryParameter['field_type'] = ((fieldType:any):string);
            }

            if (fieldData !== undefined) {
                localVarQueryParameter['field_data'] = ((fieldData:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the custom emoji in the user\'s organization.  `GET {{ api_url }}/v1/realm/emoji` 
         * @summary Get all custom emoji
         * @throws {RequiredError}
         */
        getCustomEmoji(options: RequestOptions): FetchArgs {
            const localVarPath = `/realm/emoji`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user\'s organization.  `GET {{ api_url }}/v1/realm/profile_fields` 
         * @summary Get all custom profile fields
         * @throws {RequiredError}
         */
        getCustomProfileFields(options: RequestOptions): FetchArgs {
            const localVarPath = `/realm/profile_fields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of an organization\'s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `GET {{ api_url }}/v1/realm/linkifiers`  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar `GET /realm/filters` endpoint was available with each entry in a `[pattern, url_format, id]` tuple format. 
         * @summary Get linkifiers
         * @throws {RequiredError}
         */
        getLinkifiers(options: RequestOptions): FetchArgs {
            const localVarPath = `/realm/linkifiers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch global settings for a Zulip server.  `GET {{ api_url }}/v1/server_settings`  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it\'s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
         * @summary Get server settings
         * @throws {RequiredError}
         */
        getServerSettings(options: RequestOptions): FetchArgs {
            const localVarPath = `/server_settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  `DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}`  **Changes**: New in Zulip 4.0 (feature level 49). 
         * @summary Remove a code playground
         * @throws {RequiredError}
         */
        removeCodePlayground(playgroundId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'playgroundId' is not null or undefined
            if (playgroundId === null || playgroundId === undefined) {
                throw new RequiredError('playgroundId','Required parameter playgroundId was null or undefined when calling removeCodePlayground.');
            }
            const localVarPath = `/realm/playgrounds/{playground_id}`
                .replace(`{${"playground_id"}}`, encodeURIComponent(String(playgroundId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `DELETE {{ api_url }}/v1/realm/filters/{filter_id}` 
         * @summary Remove a linkifier
         * @throws {RequiredError}
         */
        removeLinkifier(filterId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'filterId' is not null or undefined
            if (filterId === null || filterId === undefined) {
                throw new RequiredError('filterId','Required parameter filterId was null or undefined when calling removeLinkifier.');
            }
            const localVarPath = `/realm/filters/{filter_id}`
                .replace(`{${"filter_id"}}`, encodeURIComponent(String(filterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reorder the custom profile fields in the user\'s organization.  `PATCH {{ api_url }}/v1/realm/profile_fields`  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
         * @summary Reorder custom profile fields
         * @throws {RequiredError}
         */
        reorderCustomProfileFields(order: Array<number>, options: RequestOptions): FetchArgs {
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order','Required parameter order was null or undefined when calling reorderCustomProfileFields.');
            }
            const localVarPath = `/realm/profile_fields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (order) {
                localVarQueryParameter['order'] = order;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `PATCH {{ api_url }}/v1/realm/filters/{filter_id}`  **Changes**: New in Zulip 4.0 (feature level 57). 
         * @summary Update a linkifier
         * @throws {RequiredError}
         */
        updateLinkifier(filterId: number, pattern: string, urlFormatString: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'filterId' is not null or undefined
            if (filterId === null || filterId === undefined) {
                throw new RequiredError('filterId','Required parameter filterId was null or undefined when calling updateLinkifier.');
            }
            // verify required parameter 'pattern' is not null or undefined
            if (pattern === null || pattern === undefined) {
                throw new RequiredError('pattern','Required parameter pattern was null or undefined when calling updateLinkifier.');
            }
            // verify required parameter 'urlFormatString' is not null or undefined
            if (urlFormatString === null || urlFormatString === undefined) {
                throw new RequiredError('urlFormatString','Required parameter urlFormatString was null or undefined when calling updateLinkifier.');
            }
            const localVarPath = `/realm/filters/{filter_id}`
                .replace(`{${"filter_id"}}`, encodeURIComponent(String(filterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (pattern !== undefined) {
                localVarQueryParameter['pattern'] = ((pattern:any):string);
            }

            if (urlFormatString !== undefined) {
                localVarQueryParameter['url_format_string'] = ((urlFormatString:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to upload a custom emoji for use in the user\'s organization.  Access to this endpoint depends on the [organization\'s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  `POST {{ api_url }}/v1/realm/emoji/{emoji_name}` 
         * @summary Upload custom emoji
         * @throws {RequiredError}
         */
        uploadCustomEmoji(emojiName: string, filename?: any, options: RequestOptions): FetchArgs {
            // verify required parameter 'emojiName' is not null or undefined
            if (emojiName === null || emojiName === undefined) {
                throw new RequiredError('emojiName','Required parameter emojiName was null or undefined when calling uploadCustomEmoji.');
            }
            const localVarPath = `/realm/emoji/{emoji_name}`
                .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            if (filename !== undefined) {
                localVarFormParams.set('filename', ((filename:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ServerAndOrganizationsApiType = { 
    addCodePlayground(name: string, pygmentsLanguage: string, urlPrefix: string, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    addLinkifier(pattern: string, urlFormatString: string, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    createCustomProfileField(fieldType: number, name?: string, hint?: string, fieldData?: Object, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getCustomEmoji(options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getCustomProfileFields(options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getLinkifiers(options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getServerSettings(options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    removeCodePlayground(playgroundId: number, options?: RequestOptions): Promise<JsonSuccess>,

    removeLinkifier(filterId: number, options?: RequestOptions): Promise<JsonSuccess>,

    reorderCustomProfileFields(order: Array<number>, options?: RequestOptions): Promise<JsonSuccess>,

    updateLinkifier(filterId: number, pattern: string, urlFormatString: string, options?: RequestOptions): Promise<JsonSuccess>,

    uploadCustomEmoji(emojiName: string, filename?: any, options?: RequestOptions): Promise<JsonSuccess>,
}

/**
 * ServerAndOrganizationsApi - factory function to inject configuration 
 * @export
 */
export const ServerAndOrganizationsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ServerAndOrganizationsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  `POST {{ api_url }}/v1/realm/playgrounds`  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
         * @summary Add a code playground
         * @throws {RequiredError}
         */
        addCodePlayground(name: string, pygmentsLanguage: string, urlPrefix: string, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).addCodePlayground(name, pygmentsLanguage, urlPrefix, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `POST {{ api_url }}/v1/realm/filters` 
         * @summary Add a linkifier
         * @throws {RequiredError}
         */
        addLinkifier(pattern: string, urlFormatString: string, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).addLinkifier(pattern, urlFormatString, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * [Create a custom profile field](/help/add-custom-profile-fields) in the user\'s organization.  `POST {{ api_url }}/v1/realm/profile_fields` 
         * @summary Create a custom profile field
         * @throws {RequiredError}
         */
        createCustomProfileField(fieldType: number, name?: string, hint?: string, fieldData?: Object, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).createCustomProfileField(fieldType, name, hint, fieldData, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all the custom emoji in the user\'s organization.  `GET {{ api_url }}/v1/realm/emoji` 
         * @summary Get all custom emoji
         * @throws {RequiredError}
         */
        getCustomEmoji(options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).getCustomEmoji(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user\'s organization.  `GET {{ api_url }}/v1/realm/profile_fields` 
         * @summary Get all custom profile fields
         * @throws {RequiredError}
         */
        getCustomProfileFields(options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).getCustomProfileFields(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * List all of an organization\'s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `GET {{ api_url }}/v1/realm/linkifiers`  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar `GET /realm/filters` endpoint was available with each entry in a `[pattern, url_format, id]` tuple format. 
         * @summary Get linkifiers
         * @throws {RequiredError}
         */
        getLinkifiers(options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).getLinkifiers(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Fetch global settings for a Zulip server.  `GET {{ api_url }}/v1/server_settings`  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it\'s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
         * @summary Get server settings
         * @throws {RequiredError}
         */
        getServerSettings(options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).getServerSettings(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  `DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}`  **Changes**: New in Zulip 4.0 (feature level 49). 
         * @summary Remove a code playground
         * @throws {RequiredError}
         */
        removeCodePlayground(playgroundId: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).removeCodePlayground(playgroundId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `DELETE {{ api_url }}/v1/realm/filters/{filter_id}` 
         * @summary Remove a linkifier
         * @throws {RequiredError}
         */
        removeLinkifier(filterId: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).removeLinkifier(filterId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Reorder the custom profile fields in the user\'s organization.  `PATCH {{ api_url }}/v1/realm/profile_fields`  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
         * @summary Reorder custom profile fields
         * @throws {RequiredError}
         */
        reorderCustomProfileFields(order: Array<number>, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).reorderCustomProfileFields(order, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `PATCH {{ api_url }}/v1/realm/filters/{filter_id}`  **Changes**: New in Zulip 4.0 (feature level 57). 
         * @summary Update a linkifier
         * @throws {RequiredError}
         */
        updateLinkifier(filterId: number, pattern: string, urlFormatString: string, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).updateLinkifier(filterId, pattern, urlFormatString, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This endpoint is used to upload a custom emoji for use in the user\'s organization.  Access to this endpoint depends on the [organization\'s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  `POST {{ api_url }}/v1/realm/emoji/{emoji_name}` 
         * @summary Upload custom emoji
         * @throws {RequiredError}
         */
        uploadCustomEmoji(emojiName: string, filename?: any, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = ServerAndOrganizationsApiFetchParamCreator(configuration).uploadCustomEmoji(emojiName, filename, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * StreamsApi - fetch parameter creator
 * @export
 */
export const StreamsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
         * @summary Archive a stream
         * @throws {RequiredError}
         */
        archiveStream(streamId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling archiveStream.');
            }
            const localVarPath = `/streams/{stream_id}`
                .replace(`{${"stream_id"}}`, encodeURIComponent(String(streamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
         * @summary Create BigBlueButton video call
         * @throws {RequiredError}
         */
        createBigBlueButtonVideoCall(options: RequestOptions): FetchArgs {
            const localVarPath = `/calls/bigbluebutton/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
         * @summary Get stream ID
         * @throws {RequiredError}
         */
        getStreamId(stream: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'stream' is not null or undefined
            if (stream === null || stream === undefined) {
                throw new RequiredError('stream','Required parameter stream was null or undefined when calling getStreamId.');
            }
            const localVarPath = `/get_stream_id`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = ((stream:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
         * @summary Get topics in a stream
         * @throws {RequiredError}
         */
        getStreamTopics(streamId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling getStreamTopics.');
            }
            const localVarPath = `/users/me/{stream_id}/topics`
                .replace(`{${"stream_id"}}`, encodeURIComponent(String(streamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
         * @summary Get all streams
         * @throws {RequiredError}
         */
        getStreams(includePublic?: boolean, includeWebPublic?: boolean, includeSubscribed?: boolean, includeAllActive?: boolean, includeDefault?: boolean, includeOwnerSubscribed?: boolean, options: RequestOptions): FetchArgs {
            const localVarPath = `/streams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (includePublic !== undefined) {
                localVarQueryParameter['include_public'] = ((includePublic:any):string);
            }

            if (includeWebPublic !== undefined) {
                localVarQueryParameter['include_web_public'] = ((includeWebPublic:any):string);
            }

            if (includeSubscribed !== undefined) {
                localVarQueryParameter['include_subscribed'] = ((includeSubscribed:any):string);
            }

            if (includeAllActive !== undefined) {
                localVarQueryParameter['include_all_active'] = ((includeAllActive:any):string);
            }

            if (includeDefault !== undefined) {
                localVarQueryParameter['include_default'] = ((includeDefault:any):string);
            }

            if (includeOwnerSubscribed !== undefined) {
                localVarQueryParameter['include_owner_subscribed'] = ((includeOwnerSubscribed:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
         * @summary Get subscription status
         * @throws {RequiredError}
         */
        getSubscriptionStatus(userId: number, streamId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getSubscriptionStatus.');
            }
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling getSubscriptionStatus.');
            }
            const localVarPath = `/users/{user_id}/subscriptions/{stream_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"stream_id"}}`, encodeURIComponent(String(streamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
         * @summary Get subscribed streams
         * @throws {RequiredError}
         */
        getSubscriptions(includeSubscribers?: boolean, options: RequestOptions): FetchArgs {
            const localVarPath = `/users/me/subscriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (includeSubscribers !== undefined) {
                localVarQueryParameter['include_subscribers'] = ((includeSubscribers:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user\'s unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
         * @summary Topic muting
         * @throws {RequiredError}
         */
        muteTopic(topic: string, op: 'add' | 'remove', stream?: string, streamId?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling muteTopic.');
            }
            // verify required parameter 'op' is not null or undefined
            if (op === null || op === undefined) {
                throw new RequiredError('op','Required parameter op was null or undefined when calling muteTopic.');
            }
            const localVarPath = `/users/me/subscriptions/muted_topics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = ((stream:any):string);
            }

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = ((streamId:any):string);
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = ((topic:any):string);
            }

            if (op !== undefined) {
                localVarQueryParameter['op'] = ((op:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
         * @summary Subscribe to a stream
         * @throws {RequiredError}
         */
        subscribe(subscriptions: Array<Object>, principals?: Array<string | number>, authorizationErrorsFatal?: boolean, announce?: boolean, inviteOnly?: boolean, historyPublicToSubscribers?: boolean, streamPostPolicy?: number, messageRetentionDays?: string | number, options: RequestOptions): FetchArgs {
            // verify required parameter 'subscriptions' is not null or undefined
            if (subscriptions === null || subscriptions === undefined) {
                throw new RequiredError('subscriptions','Required parameter subscriptions was null or undefined when calling subscribe.');
            }
            const localVarPath = `/users/me/subscriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (subscriptions) {
                localVarQueryParameter['subscriptions'] = subscriptions;
            }

            if (principals) {
                localVarQueryParameter['principals'] = principals;
            }

            if (authorizationErrorsFatal !== undefined) {
                localVarQueryParameter['authorization_errors_fatal'] = ((authorizationErrorsFatal:any):string);
            }

            if (announce !== undefined) {
                localVarQueryParameter['announce'] = ((announce:any):string);
            }

            if (inviteOnly !== undefined) {
                localVarQueryParameter['invite_only'] = ((inviteOnly:any):string);
            }

            if (historyPublicToSubscribers !== undefined) {
                localVarQueryParameter['history_public_to_subscribers'] = ((historyPublicToSubscribers:any):string);
            }

            if (streamPostPolicy !== undefined) {
                localVarQueryParameter['stream_post_policy'] = ((streamPostPolicy:any):string);
            }

            if (messageRetentionDays !== undefined) {
                localVarQueryParameter['message_retention_days'] = ((messageRetentionDays:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
         * @summary Unsubscribe from a stream
         * @throws {RequiredError}
         */
        unsubscribe(subscriptions: Array<string>, principals?: Array<string | number>, options: RequestOptions): FetchArgs {
            // verify required parameter 'subscriptions' is not null or undefined
            if (subscriptions === null || subscriptions === undefined) {
                throw new RequiredError('subscriptions','Required parameter subscriptions was null or undefined when calling unsubscribe.');
            }
            const localVarPath = `/users/me/subscriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (subscriptions) {
                localVarQueryParameter['subscriptions'] = subscriptions;
            }

            if (principals) {
                localVarQueryParameter['principals'] = principals;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
         * @summary Update a stream
         * @throws {RequiredError}
         */
        updateStream(streamId: number, description?: string, newName?: string, isPrivate?: boolean, isAnnouncementOnly?: boolean, streamPostPolicy?: number, historyPublicToSubscribers?: boolean, messageRetentionDays?: string | number, options: RequestOptions): FetchArgs {
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling updateStream.');
            }
            const localVarPath = `/streams/{stream_id}`
                .replace(`{${"stream_id"}}`, encodeURIComponent(String(streamId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (description !== undefined) {
                localVarQueryParameter['description'] = ((description:any):string);
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = ((newName:any):string);
            }

            if (isPrivate !== undefined) {
                localVarQueryParameter['is_private'] = ((isPrivate:any):string);
            }

            if (isAnnouncementOnly !== undefined) {
                localVarQueryParameter['is_announcement_only'] = ((isAnnouncementOnly:any):string);
            }

            if (streamPostPolicy !== undefined) {
                localVarQueryParameter['stream_post_policy'] = ((streamPostPolicy:any):string);
            }

            if (historyPublicToSubscribers !== undefined) {
                localVarQueryParameter['history_public_to_subscribers'] = ((historyPublicToSubscribers:any):string);
            }

            if (messageRetentionDays !== undefined) {
                localVarQueryParameter['message_retention_days'] = ((messageRetentionDays:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to update the user\'s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
         * @summary Update subscription settings
         * @throws {RequiredError}
         */
        updateSubscriptionSettings(subscriptionData: Array<Object>, options: RequestOptions): FetchArgs {
            // verify required parameter 'subscriptionData' is not null or undefined
            if (subscriptionData === null || subscriptionData === undefined) {
                throw new RequiredError('subscriptionData','Required parameter subscriptionData was null or undefined when calling updateSubscriptionSettings.');
            }
            const localVarPath = `/users/me/subscriptions/properties`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (subscriptionData) {
                localVarQueryParameter['subscription_data'] = subscriptionData;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update which streams you are are subscribed to. 
         * @summary Update subscriptions
         * @throws {RequiredError}
         */
        updateSubscriptions(_delete?: Array<string>, add?: Array<Object>, options: RequestOptions): FetchArgs {
            const localVarPath = `/users/me/subscriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (_delete) {
                localVarQueryParameter['delete'] = _delete;
            }

            if (add) {
                localVarQueryParameter['add'] = add;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type StreamsApiType = { 
    archiveStream(streamId: number, options?: RequestOptions): Promise<JsonSuccess>,

    createBigBlueButtonVideoCall(options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getStreamId(stream: string, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getStreamTopics(streamId: number, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getStreams(includePublic?: boolean, includeWebPublic?: boolean, includeSubscribed?: boolean, includeAllActive?: boolean, includeDefault?: boolean, includeOwnerSubscribed?: boolean, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getSubscriptionStatus(userId: number, streamId: number, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getSubscriptions(includeSubscribers?: boolean, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    muteTopic(topic: string, op: 'add' | 'remove', stream?: string, streamId?: number, options?: RequestOptions): Promise<JsonSuccess>,

    subscribe(subscriptions: Array<Object>, principals?: Array<string | number>, authorizationErrorsFatal?: boolean, announce?: boolean, inviteOnly?: boolean, historyPublicToSubscribers?: boolean, streamPostPolicy?: number, messageRetentionDays?: string | number, options?: RequestOptions): Promise<AddSubscriptionsResponse>,

    unsubscribe(subscriptions: Array<string>, principals?: Array<string | number>, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    updateStream(streamId: number, description?: string, newName?: string, isPrivate?: boolean, isAnnouncementOnly?: boolean, streamPostPolicy?: number, historyPublicToSubscribers?: boolean, messageRetentionDays?: string | number, options?: RequestOptions): Promise<JsonSuccess>,

    updateSubscriptionSettings(subscriptionData: Array<Object>, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    updateSubscriptions(_delete?: Array<string>, add?: Array<Object>, options?: RequestOptions): Promise<JsonSuccessBase & Object>,
}

/**
 * StreamsApi - factory function to inject configuration 
 * @export
 */
export const StreamsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): StreamsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
         * @summary Archive a stream
         * @throws {RequiredError}
         */
        archiveStream(streamId: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).archiveStream(streamId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
         * @summary Create BigBlueButton video call
         * @throws {RequiredError}
         */
        createBigBlueButtonVideoCall(options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).createBigBlueButtonVideoCall(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
         * @summary Get stream ID
         * @throws {RequiredError}
         */
        getStreamId(stream: string, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).getStreamId(stream, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
         * @summary Get topics in a stream
         * @throws {RequiredError}
         */
        getStreamTopics(streamId: number, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).getStreamTopics(streamId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
         * @summary Get all streams
         * @throws {RequiredError}
         */
        getStreams(includePublic?: boolean, includeWebPublic?: boolean, includeSubscribed?: boolean, includeAllActive?: boolean, includeDefault?: boolean, includeOwnerSubscribed?: boolean, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).getStreams(includePublic, includeWebPublic, includeSubscribed, includeAllActive, includeDefault, includeOwnerSubscribed, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
         * @summary Get subscription status
         * @throws {RequiredError}
         */
        getSubscriptionStatus(userId: number, streamId: number, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).getSubscriptionStatus(userId, streamId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
         * @summary Get subscribed streams
         * @throws {RequiredError}
         */
        getSubscriptions(includeSubscribers?: boolean, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).getSubscriptions(includeSubscribers, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user\'s unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
         * @summary Topic muting
         * @throws {RequiredError}
         */
        muteTopic(topic: string, op: 'add' | 'remove', stream?: string, streamId?: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).muteTopic(topic, op, stream, streamId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
         * @summary Subscribe to a stream
         * @throws {RequiredError}
         */
        subscribe(subscriptions: Array<Object>, principals?: Array<string | number>, authorizationErrorsFatal?: boolean, announce?: boolean, inviteOnly?: boolean, historyPublicToSubscribers?: boolean, streamPostPolicy?: number, messageRetentionDays?: string | number, options?: RequestOptions = {}): Promise<AddSubscriptionsResponse> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).subscribe(subscriptions, principals, authorizationErrorsFatal, announce, inviteOnly, historyPublicToSubscribers, streamPostPolicy, messageRetentionDays, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
         * @summary Unsubscribe from a stream
         * @throws {RequiredError}
         */
        unsubscribe(subscriptions: Array<string>, principals?: Array<string | number>, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).unsubscribe(subscriptions, principals, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
         * @summary Update a stream
         * @throws {RequiredError}
         */
        updateStream(streamId: number, description?: string, newName?: string, isPrivate?: boolean, isAnnouncementOnly?: boolean, streamPostPolicy?: number, historyPublicToSubscribers?: boolean, messageRetentionDays?: string | number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).updateStream(streamId, description, newName, isPrivate, isAnnouncementOnly, streamPostPolicy, historyPublicToSubscribers, messageRetentionDays, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This endpoint is used to update the user\'s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
         * @summary Update subscription settings
         * @throws {RequiredError}
         */
        updateSubscriptionSettings(subscriptionData: Array<Object>, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).updateSubscriptionSettings(subscriptionData, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Update which streams you are are subscribed to. 
         * @summary Update subscriptions
         * @throws {RequiredError}
         */
        updateSubscriptions(_delete?: Array<string>, add?: Array<Object>, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = StreamsApiFetchParamCreator(configuration).updateSubscriptions(_delete, add, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
         * @summary Create a user
         * @throws {RequiredError}
         */
        createUser(email: string, password: string, fullName: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling createUser.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling createUser.');
            }
            // verify required parameter 'fullName' is not null or undefined
            if (fullName === null || fullName === undefined) {
                throw new RequiredError('fullName','Required parameter fullName was null or undefined when calling createUser.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (email !== undefined) {
                localVarQueryParameter['email'] = ((email:any):string);
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = ((password:any):string);
            }

            if (fullName !== undefined) {
                localVarQueryParameter['full_name'] = ((fullName:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
         * @summary Create a user group
         * @throws {RequiredError}
         */
        createUserGroup(name: string, description: string, members: Array<number>, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createUserGroup.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling createUserGroup.');
            }
            // verify required parameter 'members' is not null or undefined
            if (members === null || members === undefined) {
                throw new RequiredError('members','Required parameter members was null or undefined when calling createUserGroup.');
            }
            const localVarPath = `/user_groups/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = ((description:any):string);
            }

            if (members) {
                localVarQueryParameter['members'] = members;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates the user\'s account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
         * @summary Deactivate own user
         * @throws {RequiredError}
         */
        deactivateOwnUser(options: RequestOptions): FetchArgs {
            const localVarPath = `/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
         * @summary Deactivate a user
         * @throws {RequiredError}
         */
        deactivateUser(userId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deactivateUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
         * @summary Get attachments
         * @throws {RequiredError}
         */
        getAttachments(options: RequestOptions): FetchArgs {
            const localVarPath = `/attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
         * @summary Get own user
         * @throws {RequiredError}
         */
        getOwnUser(options: RequestOptions): FetchArgs {
            const localVarPath = `/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
         * @summary Get a user
         * @throws {RequiredError}
         */
        getUser(userId: number, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (clientGravatar !== undefined) {
                localVarQueryParameter['client_gravatar'] = ((clientGravatar:any):string);
            }

            if (includeCustomProfileFields !== undefined) {
                localVarQueryParameter['include_custom_profile_fields'] = ((includeCustomProfileFields:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
         * @summary Get a user by email
         * @throws {RequiredError}
         */
        getUserByEmail(email: string, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling getUserByEmail.');
            }
            const localVarPath = `/users/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (clientGravatar !== undefined) {
                localVarQueryParameter['client_gravatar'] = ((clientGravatar:any):string);
            }

            if (includeCustomProfileFields !== undefined) {
                localVarQueryParameter['include_custom_profile_fields'] = ((includeCustomProfileFields:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
         * @summary Get user groups
         * @throws {RequiredError}
         */
        getUserGroups(options: RequestOptions): FetchArgs {
            const localVarPath = `/user_groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user\'s presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip\'s developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
         * @summary Get user presence
         * @throws {RequiredError}
         */
        getUserPresence(userIdOrEmail: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userIdOrEmail' is not null or undefined
            if (userIdOrEmail === null || userIdOrEmail === undefined) {
                throw new RequiredError('userIdOrEmail','Required parameter userIdOrEmail was null or undefined when calling getUserPresence.');
            }
            const localVarPath = `/users/{user_id_or_email}/presence`
                .replace(`{${"user_id_or_email"}}`, encodeURIComponent(String(userIdOrEmail)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
         * @summary Get all users
         * @throws {RequiredError}
         */
        getUsers(clientGravatar?: boolean, includeCustomProfileFields?: boolean, options: RequestOptions): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (clientGravatar !== undefined) {
                localVarQueryParameter['client_gravatar'] = ((clientGravatar:any):string);
            }

            if (includeCustomProfileFields !== undefined) {
                localVarQueryParameter['include_custom_profile_fields'] = ((includeCustomProfileFields:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you\'ve muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user\'s name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
         * @summary Mute a user
         * @throws {RequiredError}
         */
        muteUser(mutedUserId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'mutedUserId' is not null or undefined
            if (mutedUserId === null || mutedUserId === undefined) {
                throw new RequiredError('mutedUserId','Required parameter mutedUserId was null or undefined when calling muteUser.');
            }
            const localVarPath = `/users/me/muted_users/{muted_user_id}`
                .replace(`{${"muted_user_id"}}`, encodeURIComponent(String(mutedUserId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
         * @summary Reactivate a user
         * @throws {RequiredError}
         */
        reactivateUser(userId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling reactivateUser.');
            }
            const localVarPath = `/users/{user_id}/reactivate`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
         * @summary Delete a user group
         * @throws {RequiredError}
         */
        removeUserGroup(userGroupId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'userGroupId' is not null or undefined
            if (userGroupId === null || userGroupId === undefined) {
                throw new RequiredError('userGroupId','Required parameter userGroupId was null or undefined when calling removeUserGroup.');
            }
            const localVarPath = `/user_groups/{user_group_id}`
                .replace(`{${"user_group_id"}}`, encodeURIComponent(String(userGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip\'s typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip\'s typing notifications protocol. 
         * @summary Set \"typing\" status
         * @throws {RequiredError}
         */
        setTypingStatus(op: 'start' | 'stop', to: Array<number>, type?: 'private' | 'stream', topic?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'op' is not null or undefined
            if (op === null || op === undefined) {
                throw new RequiredError('op','Required parameter op was null or undefined when calling setTypingStatus.');
            }
            // verify required parameter 'to' is not null or undefined
            if (to === null || to === undefined) {
                throw new RequiredError('to','Required parameter to was null or undefined when calling setTypingStatus.');
            }
            const localVarPath = `/typing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (type !== undefined) {
                localVarQueryParameter['type'] = ((type:any):string);
            }

            if (op !== undefined) {
                localVarQueryParameter['op'] = ((op:any):string);
            }

            if (to) {
                localVarQueryParameter['to'] = to;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = ((topic:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
         * @summary Unmute a user
         * @throws {RequiredError}
         */
        unmuteUser(mutedUserId: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'mutedUserId' is not null or undefined
            if (mutedUserId === null || mutedUserId === undefined) {
                throw new RequiredError('mutedUserId','Required parameter mutedUserId was null or undefined when calling unmuteUser.');
            }
            const localVarPath = `/users/me/muted_users/{muted_user_id}`
                .replace(`{${"muted_user_id"}}`, encodeURIComponent(String(mutedUserId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to edit the current user\'s user interface settings.  `PATCH {{ api_url }}/v1/settings/display` 
         * @summary Update display settings
         * @throws {RequiredError}
         */
        updateDisplaySettings(twentyFourHourTime?: boolean, denseMode?: boolean, starredMessageCounts?: boolean, fluidLayoutWidth?: boolean, highContrastMode?: boolean, colorScheme?: 1 | 2 | 3, translateEmoticons?: boolean, defaultLanguage?: string, defaultView?: string, leftSideUserlist?: boolean, emojiset?: string, demoteInactiveStreams?: 1 | 2 | 3, timezone?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/settings/display`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (twentyFourHourTime !== undefined) {
                localVarQueryParameter['twenty_four_hour_time'] = ((twentyFourHourTime:any):string);
            }

            if (denseMode !== undefined) {
                localVarQueryParameter['dense_mode'] = ((denseMode:any):string);
            }

            if (starredMessageCounts !== undefined) {
                localVarQueryParameter['starred_message_counts'] = ((starredMessageCounts:any):string);
            }

            if (fluidLayoutWidth !== undefined) {
                localVarQueryParameter['fluid_layout_width'] = ((fluidLayoutWidth:any):string);
            }

            if (highContrastMode !== undefined) {
                localVarQueryParameter['high_contrast_mode'] = ((highContrastMode:any):string);
            }

            if (colorScheme !== undefined) {
                localVarQueryParameter['color_scheme'] = ((colorScheme:any):string);
            }

            if (translateEmoticons !== undefined) {
                localVarQueryParameter['translate_emoticons'] = ((translateEmoticons:any):string);
            }

            if (defaultLanguage !== undefined) {
                localVarQueryParameter['default_language'] = ((defaultLanguage:any):string);
            }

            if (defaultView !== undefined) {
                localVarQueryParameter['default_view'] = ((defaultView:any):string);
            }

            if (leftSideUserlist !== undefined) {
                localVarQueryParameter['left_side_userlist'] = ((leftSideUserlist:any):string);
            }

            if (emojiset !== undefined) {
                localVarQueryParameter['emojiset'] = ((emojiset:any):string);
            }

            if (demoteInactiveStreams !== undefined) {
                localVarQueryParameter['demote_inactive_streams'] = ((demoteInactiveStreams:any):string);
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = ((timezone:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to edit the user\'s global notification settings. See [this endpoint](/api/update-subscription-settings) for per-stream notification settings.  `PATCH {{ api_url }}/v1/settings/notifications` 
         * @summary Update notification settings
         * @throws {RequiredError}
         */
        updateNotificationSettings(enableStreamDesktopNotifications?: boolean, enableStreamEmailNotifications?: boolean, enableStreamPushNotifications?: boolean, enableStreamAudibleNotifications?: boolean, notificationSound?: string, enableDesktopNotifications?: boolean, enableSounds?: boolean, enableOfflineEmailNotifications?: boolean, enableOfflinePushNotifications?: boolean, enableOnlinePushNotifications?: boolean, enableDigestEmails?: boolean, enableMarketingEmails?: boolean, enableLoginEmails?: boolean, messageContentInEmailNotifications?: boolean, pmContentInDesktopNotifications?: boolean, wildcardMentionsNotify?: boolean, desktopIconCountDisplay?: 1 | 2 | 3, realmNameInNotifications?: boolean, presenceEnabled?: boolean, options: RequestOptions): FetchArgs {
            const localVarPath = `/settings/notifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (enableStreamDesktopNotifications !== undefined) {
                localVarQueryParameter['enable_stream_desktop_notifications'] = ((enableStreamDesktopNotifications:any):string);
            }

            if (enableStreamEmailNotifications !== undefined) {
                localVarQueryParameter['enable_stream_email_notifications'] = ((enableStreamEmailNotifications:any):string);
            }

            if (enableStreamPushNotifications !== undefined) {
                localVarQueryParameter['enable_stream_push_notifications'] = ((enableStreamPushNotifications:any):string);
            }

            if (enableStreamAudibleNotifications !== undefined) {
                localVarQueryParameter['enable_stream_audible_notifications'] = ((enableStreamAudibleNotifications:any):string);
            }

            if (notificationSound !== undefined) {
                localVarQueryParameter['notification_sound'] = ((notificationSound:any):string);
            }

            if (enableDesktopNotifications !== undefined) {
                localVarQueryParameter['enable_desktop_notifications'] = ((enableDesktopNotifications:any):string);
            }

            if (enableSounds !== undefined) {
                localVarQueryParameter['enable_sounds'] = ((enableSounds:any):string);
            }

            if (enableOfflineEmailNotifications !== undefined) {
                localVarQueryParameter['enable_offline_email_notifications'] = ((enableOfflineEmailNotifications:any):string);
            }

            if (enableOfflinePushNotifications !== undefined) {
                localVarQueryParameter['enable_offline_push_notifications'] = ((enableOfflinePushNotifications:any):string);
            }

            if (enableOnlinePushNotifications !== undefined) {
                localVarQueryParameter['enable_online_push_notifications'] = ((enableOnlinePushNotifications:any):string);
            }

            if (enableDigestEmails !== undefined) {
                localVarQueryParameter['enable_digest_emails'] = ((enableDigestEmails:any):string);
            }

            if (enableMarketingEmails !== undefined) {
                localVarQueryParameter['enable_marketing_emails'] = ((enableMarketingEmails:any):string);
            }

            if (enableLoginEmails !== undefined) {
                localVarQueryParameter['enable_login_emails'] = ((enableLoginEmails:any):string);
            }

            if (messageContentInEmailNotifications !== undefined) {
                localVarQueryParameter['message_content_in_email_notifications'] = ((messageContentInEmailNotifications:any):string);
            }

            if (pmContentInDesktopNotifications !== undefined) {
                localVarQueryParameter['pm_content_in_desktop_notifications'] = ((pmContentInDesktopNotifications:any):string);
            }

            if (wildcardMentionsNotify !== undefined) {
                localVarQueryParameter['wildcard_mentions_notify'] = ((wildcardMentionsNotify:any):string);
            }

            if (desktopIconCountDisplay !== undefined) {
                localVarQueryParameter['desktop_icon_count_display'] = ((desktopIconCountDisplay:any):string);
            }

            if (realmNameInNotifications !== undefined) {
                localVarQueryParameter['realm_name_in_notifications'] = ((realmNameInNotifications:any):string);
            }

            if (presenceEnabled !== undefined) {
                localVarQueryParameter['presence_enabled'] = ((presenceEnabled:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user\'s account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
         * @summary Update a user
         * @throws {RequiredError}
         */
        updateUser(userId: number, fullName?: string, role?: number, profileData?: Array<Object>, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (fullName !== undefined) {
                localVarQueryParameter['full_name'] = ((fullName:any):string);
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = ((role:any):string);
            }

            if (profileData) {
                localVarQueryParameter['profile_data'] = profileData;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
         * @summary Update a user group
         * @throws {RequiredError}
         */
        updateUserGroup(userGroupId: number, name: string, description: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userGroupId' is not null or undefined
            if (userGroupId === null || userGroupId === undefined) {
                throw new RequiredError('userGroupId','Required parameter userGroupId was null or undefined when calling updateUserGroup.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateUserGroup.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling updateUserGroup.');
            }
            const localVarPath = `/user_groups/{user_group_id}`
                .replace(`{${"user_group_id"}}`, encodeURIComponent(String(userGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (name !== undefined) {
                localVarQueryParameter['name'] = ((name:any):string);
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = ((description:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
         * @summary Update user group members
         * @throws {RequiredError}
         */
        updateUserGroupMembers(userGroupId: number, _delete?: Array<number>, add?: Array<number>, options: RequestOptions): FetchArgs {
            // verify required parameter 'userGroupId' is not null or undefined
            if (userGroupId === null || userGroupId === undefined) {
                throw new RequiredError('userGroupId','Required parameter userGroupId was null or undefined when calling updateUserGroupMembers.');
            }
            const localVarPath = `/user_groups/{user_group_id}/members`
                .replace(`{${"user_group_id"}}`, encodeURIComponent(String(userGroupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (_delete) {
                localVarQueryParameter['delete'] = _delete;
            }

            if (add) {
                localVarQueryParameter['add'] = add;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UsersApiType = { 
    createUser(email: string, password: string, fullName: string, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    createUserGroup(name: string, description: string, members: Array<number>, options?: RequestOptions): Promise<JsonSuccess>,

    deactivateOwnUser(options?: RequestOptions): Promise<JsonSuccess>,

    deactivateUser(userId: number, options?: RequestOptions): Promise<JsonSuccess>,

    getAttachments(options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getOwnUser(options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getUser(userId: number, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getUserByEmail(email: string, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getUserGroups(options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getUserPresence(userIdOrEmail: string, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    getUsers(clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    muteUser(mutedUserId: number, options?: RequestOptions): Promise<JsonSuccess>,

    reactivateUser(userId: number, options?: RequestOptions): Promise<JsonSuccess>,

    removeUserGroup(userGroupId: number, options?: RequestOptions): Promise<JsonSuccess>,

    setTypingStatus(op: 'start' | 'stop', to: Array<number>, type?: 'private' | 'stream', topic?: string, options?: RequestOptions): Promise<JsonSuccess>,

    unmuteUser(mutedUserId: number, options?: RequestOptions): Promise<JsonSuccess>,

    updateDisplaySettings(twentyFourHourTime?: boolean, denseMode?: boolean, starredMessageCounts?: boolean, fluidLayoutWidth?: boolean, highContrastMode?: boolean, colorScheme?: 1 | 2 | 3, translateEmoticons?: boolean, defaultLanguage?: string, defaultView?: string, leftSideUserlist?: boolean, emojiset?: string, demoteInactiveStreams?: 1 | 2 | 3, timezone?: string, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    updateNotificationSettings(enableStreamDesktopNotifications?: boolean, enableStreamEmailNotifications?: boolean, enableStreamPushNotifications?: boolean, enableStreamAudibleNotifications?: boolean, notificationSound?: string, enableDesktopNotifications?: boolean, enableSounds?: boolean, enableOfflineEmailNotifications?: boolean, enableOfflinePushNotifications?: boolean, enableOnlinePushNotifications?: boolean, enableDigestEmails?: boolean, enableMarketingEmails?: boolean, enableLoginEmails?: boolean, messageContentInEmailNotifications?: boolean, pmContentInDesktopNotifications?: boolean, wildcardMentionsNotify?: boolean, desktopIconCountDisplay?: 1 | 2 | 3, realmNameInNotifications?: boolean, presenceEnabled?: boolean, options?: RequestOptions): Promise<JsonSuccessBase & Object>,

    updateUser(userId: number, fullName?: string, role?: number, profileData?: Array<Object>, options?: RequestOptions): Promise<JsonSuccess>,

    updateUserGroup(userGroupId: number, name: string, description: string, options?: RequestOptions): Promise<JsonSuccess>,

    updateUserGroupMembers(userGroupId: number, _delete?: Array<number>, add?: Array<number>, options?: RequestOptions): Promise<JsonSuccess>,
}

/**
 * UsersApi - factory function to inject configuration 
 * @export
 */
export const UsersApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UsersApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
         * @summary Create a user
         * @throws {RequiredError}
         */
        createUser(email: string, password: string, fullName: string, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(email, password, fullName, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
         * @summary Create a user group
         * @throws {RequiredError}
         */
        createUserGroup(name: string, description: string, members: Array<number>, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUserGroup(name, description, members, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Deactivates the user\'s account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
         * @summary Deactivate own user
         * @throws {RequiredError}
         */
        deactivateOwnUser(options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deactivateOwnUser(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
         * @summary Deactivate a user
         * @throws {RequiredError}
         */
        deactivateUser(userId: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deactivateUser(userId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
         * @summary Get attachments
         * @throws {RequiredError}
         */
        getAttachments(options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getAttachments(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
         * @summary Get own user
         * @throws {RequiredError}
         */
        getOwnUser(options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getOwnUser(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
         * @summary Get a user
         * @throws {RequiredError}
         */
        getUser(userId: number, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUser(userId, clientGravatar, includeCustomProfileFields, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
         * @summary Get a user by email
         * @throws {RequiredError}
         */
        getUserByEmail(email: string, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserByEmail(email, clientGravatar, includeCustomProfileFields, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
         * @summary Get user groups
         * @throws {RequiredError}
         */
        getUserGroups(options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserGroups(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user\'s presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip\'s developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
         * @summary Get user presence
         * @throws {RequiredError}
         */
        getUserPresence(userIdOrEmail: string, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserPresence(userIdOrEmail, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
         * @summary Get all users
         * @throws {RequiredError}
         */
        getUsers(clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsers(clientGravatar, includeCustomProfileFields, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you\'ve muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user\'s name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
         * @summary Mute a user
         * @throws {RequiredError}
         */
        muteUser(mutedUserId: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).muteUser(mutedUserId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
         * @summary Reactivate a user
         * @throws {RequiredError}
         */
        reactivateUser(userId: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).reactivateUser(userId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
         * @summary Delete a user group
         * @throws {RequiredError}
         */
        removeUserGroup(userGroupId: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).removeUserGroup(userGroupId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip\'s typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip\'s typing notifications protocol. 
         * @summary Set \"typing\" status
         * @throws {RequiredError}
         */
        setTypingStatus(op: 'start' | 'stop', to: Array<number>, type?: 'private' | 'stream', topic?: string, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).setTypingStatus(op, to, type, topic, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
         * @summary Unmute a user
         * @throws {RequiredError}
         */
        unmuteUser(mutedUserId: number, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).unmuteUser(mutedUserId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This endpoint is used to edit the current user\'s user interface settings.  `PATCH {{ api_url }}/v1/settings/display` 
         * @summary Update display settings
         * @throws {RequiredError}
         */
        updateDisplaySettings(twentyFourHourTime?: boolean, denseMode?: boolean, starredMessageCounts?: boolean, fluidLayoutWidth?: boolean, highContrastMode?: boolean, colorScheme?: 1 | 2 | 3, translateEmoticons?: boolean, defaultLanguage?: string, defaultView?: string, leftSideUserlist?: boolean, emojiset?: string, demoteInactiveStreams?: 1 | 2 | 3, timezone?: string, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateDisplaySettings(twentyFourHourTime, denseMode, starredMessageCounts, fluidLayoutWidth, highContrastMode, colorScheme, translateEmoticons, defaultLanguage, defaultView, leftSideUserlist, emojiset, demoteInactiveStreams, timezone, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * This endpoint is used to edit the user\'s global notification settings. See [this endpoint](/api/update-subscription-settings) for per-stream notification settings.  `PATCH {{ api_url }}/v1/settings/notifications` 
         * @summary Update notification settings
         * @throws {RequiredError}
         */
        updateNotificationSettings(enableStreamDesktopNotifications?: boolean, enableStreamEmailNotifications?: boolean, enableStreamPushNotifications?: boolean, enableStreamAudibleNotifications?: boolean, notificationSound?: string, enableDesktopNotifications?: boolean, enableSounds?: boolean, enableOfflineEmailNotifications?: boolean, enableOfflinePushNotifications?: boolean, enableOnlinePushNotifications?: boolean, enableDigestEmails?: boolean, enableMarketingEmails?: boolean, enableLoginEmails?: boolean, messageContentInEmailNotifications?: boolean, pmContentInDesktopNotifications?: boolean, wildcardMentionsNotify?: boolean, desktopIconCountDisplay?: 1 | 2 | 3, realmNameInNotifications?: boolean, presenceEnabled?: boolean, options?: RequestOptions = {}): Promise<JsonSuccessBase & Object> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateNotificationSettings(enableStreamDesktopNotifications, enableStreamEmailNotifications, enableStreamPushNotifications, enableStreamAudibleNotifications, notificationSound, enableDesktopNotifications, enableSounds, enableOfflineEmailNotifications, enableOfflinePushNotifications, enableOnlinePushNotifications, enableDigestEmails, enableMarketingEmails, enableLoginEmails, messageContentInEmailNotifications, pmContentInDesktopNotifications, wildcardMentionsNotify, desktopIconCountDisplay, realmNameInNotifications, presenceEnabled, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user\'s account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
         * @summary Update a user
         * @throws {RequiredError}
         */
        updateUser(userId: number, fullName?: string, role?: number, profileData?: Array<Object>, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(userId, fullName, role, profileData, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
         * @summary Update a user group
         * @throws {RequiredError}
         */
        updateUserGroup(userGroupId: number, name: string, description: string, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUserGroup(userGroupId, name, description, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
         * @summary Update user group members
         * @throws {RequiredError}
         */
        updateUserGroupMembers(userGroupId: number, _delete?: Array<number>, add?: Array<number>, options?: RequestOptions = {}): Promise<JsonSuccess> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUserGroupMembers(userGroupId, _delete, add, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * WebhooksApi - fetch parameter creator
 * @export
 */
export const WebhooksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Outgoing webhooks allows to build or set up Zulip integrations which are notified when certain types of messages are sent in Zulip. 
         * @summary Outgoing webhooks
         * @throws {RequiredError}
         */
        zulipOutgoingWebhooks(options: RequestOptions): FetchArgs {
            const localVarPath = `/zulip-outgoing-webhook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type WebhooksApiType = { 
    zulipOutgoingWebhooks(options?: RequestOptions): Promise<InlineResponse200>,
}

/**
 * WebhooksApi - factory function to inject configuration 
 * @export
 */
export const WebhooksApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): WebhooksApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Outgoing webhooks allows to build or set up Zulip integrations which are notified when certain types of messages are sent in Zulip. 
         * @summary Outgoing webhooks
         * @throws {RequiredError}
         */
        zulipOutgoingWebhooks(options?: RequestOptions = {}): Promise<InlineResponse200> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).zulipOutgoingWebhooks(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    AuthenticationApi: AuthenticationApiType,

    MessagesApi: MessagesApiType,

    RealTimeEventsApi: RealTimeEventsApiType,

    ServerAndOrganizationsApi: ServerAndOrganizationsApiType,

    StreamsApi: StreamsApiType,

    UsersApi: UsersApiType,

    WebhooksApi: WebhooksApiType,
 }
