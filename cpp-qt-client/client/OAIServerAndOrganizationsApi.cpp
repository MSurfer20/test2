/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIServerAndOrganizationsApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace OpenAPI {

OAIServerAndOrganizationsApi::OAIServerAndOrganizationsApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      isResponseCompressionEnabled(false),
      isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIServerAndOrganizationsApi::~OAIServerAndOrganizationsApi() {
}

void OAIServerAndOrganizationsApi::initializeServerConfigs(){
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    QList<OAIServerConfiguration> serverConf = QList<OAIServerConfiguration>();
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://{subdomain}.zulipchat.com/api/v1"),
    "No description provided",
    QMap<QString, OAIServerVariable>{ 
    {"subdomain", OAIServerVariable("No description provided","example",
    QSet<QString>{ {"example"} })}, }));
    
    defaultConf.append(OAIServerConfiguration(
    QUrl("{server}/api/v1"),
    "No description provided",
    QMap<QString, OAIServerVariable>{ 
    {"server", OAIServerVariable("No description provided","https://",
    QSet<QString>{ {"https://"} })}, }));
    
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://chat.zulip.org/api/v1"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    defaultConf.append(OAIServerConfiguration(
    QUrl("http://localhost:9991/api/v1"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("addCodePlayground", defaultConf);
    _serverIndices.insert("addCodePlayground", 0);
    _serverConfigs.insert("addLinkifier", defaultConf);
    _serverIndices.insert("addLinkifier", 0);
    _serverConfigs.insert("createCustomProfileField", defaultConf);
    _serverIndices.insert("createCustomProfileField", 0);
    _serverConfigs.insert("getCustomEmoji", defaultConf);
    _serverIndices.insert("getCustomEmoji", 0);
    _serverConfigs.insert("getCustomProfileFields", defaultConf);
    _serverIndices.insert("getCustomProfileFields", 0);
    _serverConfigs.insert("getLinkifiers", defaultConf);
    _serverIndices.insert("getLinkifiers", 0);
    _serverConfigs.insert("getServerSettings", defaultConf);
    _serverIndices.insert("getServerSettings", 0);
    _serverConfigs.insert("removeCodePlayground", defaultConf);
    _serverIndices.insert("removeCodePlayground", 0);
    _serverConfigs.insert("removeLinkifier", defaultConf);
    _serverIndices.insert("removeLinkifier", 0);
    _serverConfigs.insert("reorderCustomProfileFields", defaultConf);
    _serverIndices.insert("reorderCustomProfileFields", 0);
    _serverConfigs.insert("updateLinkifier", defaultConf);
    _serverIndices.insert("updateLinkifier", 0);
    _serverConfigs.insert("uploadCustomEmoji", defaultConf);
    _serverIndices.insert("uploadCustomEmoji", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIServerAndOrganizationsApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value){
    auto it = _serverConfigs.find(operation);
    if(it != _serverConfigs.end() && serverIndex < it.value().size() ){
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIServerAndOrganizationsApi::setServerIndex(const QString &operation, int serverIndex){
    if(_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size() )
        _serverIndices[operation] = serverIndex;
}

void OAIServerAndOrganizationsApi::setApiKey(const QString &apiKeyName, const QString &apiKey){
    _apiKeys.insert(apiKeyName,apiKey);
}

void OAIServerAndOrganizationsApi::setBearerToken(const QString &token){
    _bearerToken = token;
}

void OAIServerAndOrganizationsApi::setUsername(const QString &username) {
    _username = username;
}

void OAIServerAndOrganizationsApi::setPassword(const QString &password) {
    _password = password;
}


void OAIServerAndOrganizationsApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIServerAndOrganizationsApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIServerAndOrganizationsApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIServerAndOrganizationsApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables){
    if(_serverConfigs.contains(operation)){
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    }else{
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIServerAndOrganizationsApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables){
    for(auto e : _serverIndices.keys()){
        setServerIndex(e, addServerConfiguration(e, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIServerAndOrganizationsApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables){
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIServerAndOrganizationsApi::addHeaders(const QString &key, const QString &value) {
    defaultHeaders.insert(key, value);
}

void OAIServerAndOrganizationsApi::enableRequestCompression() {
    isRequestCompressionEnabled = true;
}

void OAIServerAndOrganizationsApi::enableResponseCompression() {
    isResponseCompressionEnabled = true;
}

void OAIServerAndOrganizationsApi::abortRequests(){
    emit abortRequestsSignal();
}

QString OAIServerAndOrganizationsApi::getParamStylePrefix(QString style){
    if(style == "matrix"){
        return ";";
    }else if(style == "label"){
        return ".";
    }else if(style == "form"){
        return "&";
    }else if(style == "simple"){
        return "";
    }else if(style == "spaceDelimited"){
        return "&";
    }else if(style == "pipeDelimited"){
        return "&";
    }else{
        return "none";
    }
}

QString OAIServerAndOrganizationsApi::getParamStyleSuffix(QString style){
    if(style == "matrix"){
        return "=";
    }else if(style == "label"){
        return "";
    }else if(style == "form"){
        return "=";
    }else if(style == "simple"){
        return "";
    }else if(style == "spaceDelimited"){
        return "=";
    }else if(style == "pipeDelimited"){
        return "=";
    }else{
        return "none";
    }
}

QString OAIServerAndOrganizationsApi::getParamStyleDelimiter(QString style, QString name, bool isExplode){

    if(style == "matrix"){
        return (isExplode) ? ";" + name + "=" : ",";

    }else if(style == "label"){
        return (isExplode) ? "." : ",";

    }else if(style == "form"){
        return (isExplode) ? "&" + name + "=" : ",";

    }else if(style == "simple"){
        return ",";
    }else if(style == "spaceDelimited"){
        return (isExplode) ? "&" + name + "=" : " ";

    }else if(style == "pipeDelimited"){
        return (isExplode) ? "&" + name + "=" : "|";

    }else if(style == "deepObject"){
        return (isExplode) ? "&" : "none";

    }else {
        return "none";
    }
}

void OAIServerAndOrganizationsApi::addCodePlayground(const QString &name, const QString &pygments_language, const QString &url_prefix) {
    QString fullPath = QString(_serverConfigs["addCodePlayground"][_serverIndices.value("addCodePlayground")].URL()+"/realm/playgrounds");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name)));
    }
    
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "pygments_language", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("pygments_language")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(pygments_language)));
    }
    
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "url_prefix", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("url_prefix")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(url_prefix)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::addCodePlaygroundCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::addCodePlaygroundCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccessBase output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit addCodePlaygroundSignal(output);
        emit addCodePlaygroundSignalFull(worker, output);
    } else {
        emit addCodePlaygroundSignalE(output, error_type, error_str);
        emit addCodePlaygroundSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::addLinkifier(const QString &pattern, const QString &url_format_string) {
    QString fullPath = QString(_serverConfigs["addLinkifier"][_serverIndices.value("addLinkifier")].URL()+"/realm/filters");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "pattern", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("pattern")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(pattern)));
    }
    
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "url_format_string", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("url_format_string")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(url_format_string)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::addLinkifierCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::addLinkifierCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccessBase output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit addLinkifierSignal(output);
        emit addLinkifierSignalFull(worker, output);
    } else {
        emit addLinkifierSignalE(output, error_type, error_str);
        emit addLinkifierSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::createCustomProfileField(const qint32 &field_type, const ::OpenAPI::OptionalParam<QString> &name, const ::OpenAPI::OptionalParam<QString> &hint, const ::OpenAPI::OptionalParam<OAIObject> &field_data) {
    QString fullPath = QString(_serverConfigs["createCustomProfileField"][_serverIndices.value("createCustomProfileField")].URL()+"/realm/profile_fields");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if(name.hasValue())
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(name.value())));
    }
    if(hint.hasValue())
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "hint", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("hint")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(hint.value())));
    }
    
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "field_type", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("field_type")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(field_type)));
    }
    if(field_data.hasValue())
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "field_data", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");
        QString paramString = (queryStyle == "form" && true) ? "" : (queryStyle == "form" && !(true)) ? "field_data"+querySuffix : "";
        QJsonObject parameter = field_data.value().asJsonObject();
        qint32 count = 0;
        foreach(const QString& key, parameter.keys()) {
            if (count > 0) {
                queryDelimiter =  ((queryStyle == "form" || queryStyle == "deepObject") && true) ? "&" : getParamStyleDelimiter(queryStyle, key, true);
                paramString.append(queryDelimiter);
            }
            QString assignOperator;
            if (queryStyle == "form")
                assignOperator = (true) ? "=" : ",";
            else if (queryStyle == "deepObject")
                assignOperator = (true) ? "=" : "none";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("field_data").append("[").append(key).append("]"))+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("field_data").append("[").append(key).append("]"))+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("field_data").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("field_data").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("field_data").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.append(paramString);
            }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::createCustomProfileFieldCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::createCustomProfileFieldCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccessBase output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit createCustomProfileFieldSignal(output);
        emit createCustomProfileFieldSignalFull(worker, output);
    } else {
        emit createCustomProfileFieldSignalE(output, error_type, error_str);
        emit createCustomProfileFieldSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::getCustomEmoji() {
    QString fullPath = QString(_serverConfigs["getCustomEmoji"][_serverIndices.value("getCustomEmoji")].URL()+"/realm/emoji");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::getCustomEmojiCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::getCustomEmojiCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccessBase output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getCustomEmojiSignal(output);
        emit getCustomEmojiSignalFull(worker, output);
    } else {
        emit getCustomEmojiSignalE(output, error_type, error_str);
        emit getCustomEmojiSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::getCustomProfileFields() {
    QString fullPath = QString(_serverConfigs["getCustomProfileFields"][_serverIndices.value("getCustomProfileFields")].URL()+"/realm/profile_fields");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::getCustomProfileFieldsCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::getCustomProfileFieldsCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccessBase output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getCustomProfileFieldsSignal(output);
        emit getCustomProfileFieldsSignalFull(worker, output);
    } else {
        emit getCustomProfileFieldsSignalE(output, error_type, error_str);
        emit getCustomProfileFieldsSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::getLinkifiers() {
    QString fullPath = QString(_serverConfigs["getLinkifiers"][_serverIndices.value("getLinkifiers")].URL()+"/realm/linkifiers");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::getLinkifiersCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::getLinkifiersCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccessBase output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getLinkifiersSignal(output);
        emit getLinkifiersSignalFull(worker, output);
    } else {
        emit getLinkifiersSignalE(output, error_type, error_str);
        emit getLinkifiersSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::getServerSettings() {
    QString fullPath = QString(_serverConfigs["getServerSettings"][_serverIndices.value("getServerSettings")].URL()+"/server_settings");
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::getServerSettingsCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::getServerSettingsCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccessBase output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit getServerSettingsSignal(output);
        emit getServerSettingsSignalFull(worker, output);
    } else {
        emit getServerSettingsSignalE(output, error_type, error_str);
        emit getServerSettingsSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::removeCodePlayground(const qint32 &playground_id) {
    QString fullPath = QString(_serverConfigs["removeCodePlayground"][_serverIndices.value("removeCodePlayground")].URL()+"/realm/playgrounds/{playground_id}");
    
    
    {
        QString playground_idPathParam("{");
        playground_idPathParam.append("playground_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if(pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "playground_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"playground_id"+pathSuffix : pathPrefix;
        fullPath.replace(playground_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(playground_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::removeCodePlaygroundCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::removeCodePlaygroundCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccess output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit removeCodePlaygroundSignal(output);
        emit removeCodePlaygroundSignalFull(worker, output);
    } else {
        emit removeCodePlaygroundSignalE(output, error_type, error_str);
        emit removeCodePlaygroundSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::removeLinkifier(const qint32 &filter_id) {
    QString fullPath = QString(_serverConfigs["removeLinkifier"][_serverIndices.value("removeLinkifier")].URL()+"/realm/filters/{filter_id}");
    
    
    {
        QString filter_idPathParam("{");
        filter_idPathParam.append("filter_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if(pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "filter_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"filter_id"+pathSuffix : pathPrefix;
        fullPath.replace(filter_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(filter_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::removeLinkifierCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::removeLinkifierCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccess output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit removeLinkifierSignal(output);
        emit removeLinkifierSignalFull(worker, output);
    } else {
        emit removeLinkifierSignalE(output, error_type, error_str);
        emit removeLinkifierSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::reorderCustomProfileFields(const QList<qint32> &order) {
    QString fullPath = QString(_serverConfigs["reorderCustomProfileFields"][_serverIndices.value("reorderCustomProfileFields")].URL()+"/realm/profile_fields");
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "order", true);
        if(order.size() > 0) {
            if (QString("multi").indexOf("multi") == 0) {
                foreach (qint32 t, order) {
                    if (fullPath.indexOf("?") > 0)
                        fullPath.append(queryPrefix);
                    else
                        fullPath.append("?");
                    fullPath.append("order=").append(::OpenAPI::toStringValue(t));
                }
            } else if (QString("multi").indexOf("ssv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("order").append(querySuffix);
                qint32 count = 0;
                foreach (qint32 t, order) {
                    if (count > 0) {
                        fullPath.append((true)? queryDelimiter : QUrl::toPercentEncoding(queryDelimiter));
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("tsv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("order").append(querySuffix);
                qint32 count = 0;
                foreach (qint32 t, order) {
                    if (count > 0) {
                        fullPath.append("\t");
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("csv") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("order").append(querySuffix);
                qint32 count = 0;
                foreach (qint32 t, order) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("pipes") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("order").append(querySuffix);
                qint32 count = 0;
                foreach (qint32 t, order) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            } else if (QString("multi").indexOf("deepObject") == 0) {
                if (fullPath.indexOf("?") > 0)
                    fullPath.append("&");
                else
                    fullPath.append("?").append(queryPrefix).append("order").append(querySuffix);
                qint32 count = 0;
                foreach (qint32 t, order) {
                    if (count > 0) {
                        fullPath.append(queryDelimiter);
                    }
                    fullPath.append(::OpenAPI::toStringValue(t));
                    count++;
                }
            }
        }
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::reorderCustomProfileFieldsCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::reorderCustomProfileFieldsCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccess output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit reorderCustomProfileFieldsSignal(output);
        emit reorderCustomProfileFieldsSignalFull(worker, output);
    } else {
        emit reorderCustomProfileFieldsSignalE(output, error_type, error_str);
        emit reorderCustomProfileFieldsSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::updateLinkifier(const qint32 &filter_id, const QString &pattern, const QString &url_format_string) {
    QString fullPath = QString(_serverConfigs["updateLinkifier"][_serverIndices.value("updateLinkifier")].URL()+"/realm/filters/{filter_id}");
    
    
    {
        QString filter_idPathParam("{");
        filter_idPathParam.append("filter_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if(pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "filter_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"filter_id"+pathSuffix : pathPrefix;
        fullPath.replace(filter_idPathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(filter_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "pattern", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("pattern")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(pattern)));
    }
    
    {
        queryStyle = "form";
        if(queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "url_format_string", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("url_format_string")).append(querySuffix).append(QUrl::toPercentEncoding(::OpenAPI::toStringValue(url_format_string)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");


    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::updateLinkifierCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::updateLinkifierCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccess output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit updateLinkifierSignal(output);
        emit updateLinkifierSignalFull(worker, output);
    } else {
        emit updateLinkifierSignalE(output, error_type, error_str);
        emit updateLinkifierSignalEFull(worker, error_type, error_str);
    }
}

void OAIServerAndOrganizationsApi::uploadCustomEmoji(const QString &emoji_name, const ::OpenAPI::OptionalParam<OAIHttpFileElement> &filename) {
    QString fullPath = QString(_serverConfigs["uploadCustomEmoji"][_serverIndices.value("uploadCustomEmoji")].URL()+"/realm/emoji/{emoji_name}");
    
    
    {
        QString emoji_namePathParam("{");
        emoji_namePathParam.append("emoji_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if(pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_name"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_namePathParam, paramString+QUrl::toPercentEncoding(::OpenAPI::toStringValue(emoji_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    if(filename.hasValue())
    {
        input.add_file("filename", filename.value().local_filename, filename.value().request_filename, filename.value().mime_type);
    }

    foreach (QString key, this->defaultHeaders.keys()) { input.headers.insert(key, this->defaultHeaders.value(key)); }

    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIServerAndOrganizationsApi::uploadCustomEmojiCallback);
    connect(this, &OAIServerAndOrganizationsApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, [this](){
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            emit allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIServerAndOrganizationsApi::uploadCustomEmojiCallback(OAIHttpRequestWorker *worker) {
    QString msg;
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type == QNetworkReply::NoError) {
        msg = QString("Success! %1 bytes").arg(worker->response.length());
    } else {
        msg = "Error: " + worker->error_str;
        error_str = QString("%1, %2").arg(worker->error_str).arg(QString(worker->response));
    }
    OAIJsonSuccess output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        emit uploadCustomEmojiSignal(output);
        emit uploadCustomEmojiSignalFull(worker, output);
    } else {
        emit uploadCustomEmojiSignalE(output, error_type, error_str);
        emit uploadCustomEmojiSignalEFull(worker, error_type, error_str);
    }
}

} // namespace OpenAPI
