// tslint:disable
/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    CodedError,
    CodedErrorFromJSON,
    CodedErrorToJSON,
    InvalidMessageError,
    InvalidMessageErrorFromJSON,
    InvalidMessageErrorToJSON,
    JsonSuccess,
    JsonSuccessFromJSON,
    JsonSuccessToJSON,
    JsonSuccessBase,
    JsonSuccessBaseFromJSON,
    JsonSuccessBaseToJSON,
    NonExistingStreamError,
    NonExistingStreamErrorFromJSON,
    NonExistingStreamErrorToJSON,
} from '../models';

export interface AddReactionRequest {
    messageId: number;
    emojiName: string;
    emojiCode?: string;
    reactionType?: string;
}

export interface CheckMessagesMatchNarrowRequest {
    msgIds: Array<number>;
    narrow: Array<object>;
}

export interface DeleteMessageRequest {
    messageId: number;
}

export interface GetFileTemporaryUrlRequest {
    realmIdStr: number;
    filename: string;
}

export interface GetMessageHistoryRequest {
    messageId: number;
}

export interface GetMessagesRequest {
    numBefore: number;
    numAfter: number;
    anchor?: string | number;
    narrow?: Array<object>;
    clientGravatar?: boolean;
    applyMarkdown?: boolean;
    useFirstUnreadAnchor?: boolean;
}

export interface GetRawMessageRequest {
    messageId: number;
}

export interface MarkStreamAsReadRequest {
    streamId: number;
}

export interface MarkTopicAsReadRequest {
    streamId: number;
    topicName: string;
}

export interface RemoveReactionRequest {
    messageId: number;
    emojiName?: string;
    emojiCode?: string;
    reactionType?: string;
}

export interface RenderMessageRequest {
    content: string;
}

export interface SendMessageRequest {
    type: SendMessageTypeEnum;
    to: Array<number>;
    content: string;
    topic?: string;
    queueId?: string;
    localId?: string;
}

export interface UpdateMessageRequest {
    messageId: number;
    topic?: string;
    propagateMode?: UpdateMessagePropagateModeEnum;
    sendNotificationToOldThread?: boolean;
    sendNotificationToNewThread?: boolean;
    content?: string;
    streamId?: number;
}

export interface UpdateMessageFlagsRequest {
    messages: Array<number>;
    op: UpdateMessageFlagsOpEnum;
    flag: string;
}

export interface UploadFileRequest {
    filename?: Blob;
}


/**
 * Add an [emoji reaction](/help/emoji-reactions) to a message.  `POST {{ api_url }}/v1/messages/{message_id}/reactions` 
 * Add an emoji reaction
 */
function addReactionRaw<T>(requestParameters: AddReactionRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
        throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling addReaction.');
    }

    if (requestParameters.emojiName === null || requestParameters.emojiName === undefined) {
        throw new runtime.RequiredError('emojiName','Required parameter requestParameters.emojiName was null or undefined when calling addReaction.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.emojiName !== undefined) {
        queryParameters['emoji_name'] = requestParameters.emojiName;
    }


    if (requestParameters.emojiCode !== undefined) {
        queryParameters['emoji_code'] = requestParameters.emojiCode;
    }


    if (requestParameters.reactionType !== undefined) {
        queryParameters['reaction_type'] = requestParameters.reactionType;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/{message_id}/reactions`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Add an [emoji reaction](/help/emoji-reactions) to a message.  `POST {{ api_url }}/v1/messages/{message_id}/reactions` 
* Add an emoji reaction
*/
export function addReaction<T>(requestParameters: AddReactionRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return addReactionRaw(requestParameters, requestConfig);
}

/**
 * Check whether a set of messages match a [narrow](/api/construct-narrow).  `GET {{ api_url }}/v1/messages/matches_narrow`  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the `match_subject` and `match_content` objects is designed to match those of `GET /messages`, so that a client can splice these fields into a `message` object received from `GET /events` and end up with an extended message object identical to how a `GET /messages` for the current narrow would have returned the message. 
 * Check if messages match a narrow
 */
function checkMessagesMatchNarrowRaw<T>(requestParameters: CheckMessagesMatchNarrowRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.msgIds === null || requestParameters.msgIds === undefined) {
        throw new runtime.RequiredError('msgIds','Required parameter requestParameters.msgIds was null or undefined when calling checkMessagesMatchNarrow.');
    }

    if (requestParameters.narrow === null || requestParameters.narrow === undefined) {
        throw new runtime.RequiredError('narrow','Required parameter requestParameters.narrow was null or undefined when calling checkMessagesMatchNarrow.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.msgIds) {
        queryParameters['msg_ids'] = requestParameters.msgIds;
    }


    if (requestParameters.narrow) {
        queryParameters['narrow'] = requestParameters.narrow;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/matches_narrow`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Check whether a set of messages match a [narrow](/api/construct-narrow).  `GET {{ api_url }}/v1/messages/matches_narrow`  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the `match_subject` and `match_content` objects is designed to match those of `GET /messages`, so that a client can splice these fields into a `message` object received from `GET /events` and end up with an extended message object identical to how a `GET /messages` for the current narrow would have returned the message. 
* Check if messages match a narrow
*/
export function checkMessagesMatchNarrow<T>(requestParameters: CheckMessagesMatchNarrowRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return checkMessagesMatchNarrowRaw(requestParameters, requestConfig);
}

/**
 * Permanently delete a message.  `DELETE {{ api_url }}/v1/messages/{msg_id}`  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
 * Delete a message
 */
function deleteMessageRaw<T>(requestParameters: DeleteMessageRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
        throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling deleteMessage.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/{message_id}`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Permanently delete a message.  `DELETE {{ api_url }}/v1/messages/{msg_id}`  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
* Delete a message
*/
export function deleteMessage<T>(requestParameters: DeleteMessageRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return deleteMessageRaw(requestParameters, requestConfig);
}

/**
 * Get a temporary URL for access to the file that doesn\'t require authentication. 
 * Get public temporary URL
 */
function getFileTemporaryUrlRaw<T>(requestParameters: GetFileTemporaryUrlRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.realmIdStr === null || requestParameters.realmIdStr === undefined) {
        throw new runtime.RequiredError('realmIdStr','Required parameter requestParameters.realmIdStr was null or undefined when calling getFileTemporaryUrl.');
    }

    if (requestParameters.filename === null || requestParameters.filename === undefined) {
        throw new runtime.RequiredError('filename','Required parameter requestParameters.filename was null or undefined when calling getFileTemporaryUrl.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_uploads/{realm_id_str}/{filename}`.replace(`{${"realm_id_str"}}`, encodeURIComponent(String(requestParameters.realmIdStr))).replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters.filename))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Get a temporary URL for access to the file that doesn\'t require authentication. 
* Get public temporary URL
*/
export function getFileTemporaryUrl<T>(requestParameters: GetFileTemporaryUrlRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getFileTemporaryUrlRaw(requestParameters, requestConfig);
}

/**
 * Fetch the message edit history of a previously edited message.  `GET {{ api_url }}/v1/messages/{message_id}/history`  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
 * Get a message\'s edit history
 */
function getMessageHistoryRaw<T>(requestParameters: GetMessageHistoryRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
        throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling getMessageHistory.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/{message_id}/history`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Fetch the message edit history of a previously edited message.  `GET {{ api_url }}/v1/messages/{message_id}/history`  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
* Get a message\'s edit history
*/
export function getMessageHistory<T>(requestParameters: GetMessageHistoryRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getMessageHistoryRaw(requestParameters, requestConfig);
}

/**
 * Fetch message history from a Zulip server.  `GET {{ api_url }}/v1/messages`  This `GET /api/v1/messages` endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip\'s powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user\'s message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an `anchor` message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the `num_before` and `num_after` limits.  We recommend using `num_before <= 1000` and `num_after <= 1000` to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
 * Get messages
 */
function getMessagesRaw<T>(requestParameters: GetMessagesRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.numBefore === null || requestParameters.numBefore === undefined) {
        throw new runtime.RequiredError('numBefore','Required parameter requestParameters.numBefore was null or undefined when calling getMessages.');
    }

    if (requestParameters.numAfter === null || requestParameters.numAfter === undefined) {
        throw new runtime.RequiredError('numAfter','Required parameter requestParameters.numAfter was null or undefined when calling getMessages.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.anchor !== undefined) {
        queryParameters['anchor'] = requestParameters.anchor;
    }


    if (requestParameters.numBefore !== undefined) {
        queryParameters['num_before'] = requestParameters.numBefore;
    }


    if (requestParameters.numAfter !== undefined) {
        queryParameters['num_after'] = requestParameters.numAfter;
    }


    if (requestParameters.narrow) {
        queryParameters['narrow'] = requestParameters.narrow;
    }


    if (requestParameters.clientGravatar !== undefined) {
        queryParameters['client_gravatar'] = requestParameters.clientGravatar;
    }


    if (requestParameters.applyMarkdown !== undefined) {
        queryParameters['apply_markdown'] = requestParameters.applyMarkdown;
    }


    if (requestParameters.useFirstUnreadAnchor !== undefined) {
        queryParameters['use_first_unread_anchor'] = requestParameters.useFirstUnreadAnchor;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Fetch message history from a Zulip server.  `GET {{ api_url }}/v1/messages`  This `GET /api/v1/messages` endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip\'s powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user\'s message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an `anchor` message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the `num_before` and `num_after` limits.  We recommend using `num_before <= 1000` and `num_after <= 1000` to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
* Get messages
*/
export function getMessages<T>(requestParameters: GetMessagesRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getMessagesRaw(requestParameters, requestConfig);
}

/**
 * Get the raw content of a message.  `GET {{ api_url }}/v1/messages/{msg_id}`  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message\'s raw Markdown (e.g. for pre-filling a message-editing UI). 
 * Get a message\'s raw Markdown
 */
function getRawMessageRaw<T>(requestParameters: GetRawMessageRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
        throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling getRawMessage.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/{message_id}`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Get the raw content of a message.  `GET {{ api_url }}/v1/messages/{msg_id}`  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message\'s raw Markdown (e.g. for pre-filling a message-editing UI). 
* Get a message\'s raw Markdown
*/
export function getRawMessage<T>(requestParameters: GetRawMessageRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getRawMessageRaw(requestParameters, requestConfig);
}

/**
 * Marks all of the current user\'s unread messages as read.  `POST {{ api_url }}/v1/mark_all_as_read` 
 * Mark all messages as read
 */
function markAllAsReadRaw<T>( requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mark_all_as_read`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Marks all of the current user\'s unread messages as read.  `POST {{ api_url }}/v1/mark_all_as_read` 
* Mark all messages as read
*/
export function markAllAsRead<T>( requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return markAllAsReadRaw( requestConfig);
}

/**
 * Mark all the unread messages in a stream as read. 
 * Mark messages in a stream as read
 */
function markStreamAsReadRaw<T>(requestParameters: MarkStreamAsReadRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.streamId === null || requestParameters.streamId === undefined) {
        throw new runtime.RequiredError('streamId','Required parameter requestParameters.streamId was null or undefined when calling markStreamAsRead.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.streamId !== undefined) {
        queryParameters['stream_id'] = requestParameters.streamId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mark_stream_as_read`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Mark all the unread messages in a stream as read. 
* Mark messages in a stream as read
*/
export function markStreamAsRead<T>(requestParameters: MarkStreamAsReadRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return markStreamAsReadRaw(requestParameters, requestConfig);
}

/**
 * Mark all the unread messages in a topic as read. 
 * Mark messages in a topic as read
 */
function markTopicAsReadRaw<T>(requestParameters: MarkTopicAsReadRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.streamId === null || requestParameters.streamId === undefined) {
        throw new runtime.RequiredError('streamId','Required parameter requestParameters.streamId was null or undefined when calling markTopicAsRead.');
    }

    if (requestParameters.topicName === null || requestParameters.topicName === undefined) {
        throw new runtime.RequiredError('topicName','Required parameter requestParameters.topicName was null or undefined when calling markTopicAsRead.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.streamId !== undefined) {
        queryParameters['stream_id'] = requestParameters.streamId;
    }


    if (requestParameters.topicName !== undefined) {
        queryParameters['topic_name'] = requestParameters.topicName;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/mark_topic_as_read`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Mark all the unread messages in a topic as read. 
* Mark messages in a topic as read
*/
export function markTopicAsRead<T>(requestParameters: MarkTopicAsReadRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return markTopicAsReadRaw(requestParameters, requestConfig);
}

/**
 * Remove an [emoji reaction](/help/emoji-reactions) from a message.  `DELETE {{ api_url }}/v1/messages/{message_id}/reactions` 
 * Remove an emoji reaction
 */
function removeReactionRaw<T>(requestParameters: RemoveReactionRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
        throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling removeReaction.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.emojiName !== undefined) {
        queryParameters['emoji_name'] = requestParameters.emojiName;
    }


    if (requestParameters.emojiCode !== undefined) {
        queryParameters['emoji_code'] = requestParameters.emojiCode;
    }


    if (requestParameters.reactionType !== undefined) {
        queryParameters['reaction_type'] = requestParameters.reactionType;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/{message_id}/reactions`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Remove an [emoji reaction](/help/emoji-reactions) from a message.  `DELETE {{ api_url }}/v1/messages/{message_id}/reactions` 
* Remove an emoji reaction
*/
export function removeReaction<T>(requestParameters: RemoveReactionRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return removeReactionRaw(requestParameters, requestConfig);
}

/**
 * Render a message to HTML.  `POST {{ api_url }}/v1/messages/render` 
 * Render message
 */
function renderMessageRaw<T>(requestParameters: RenderMessageRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.content === null || requestParameters.content === undefined) {
        throw new runtime.RequiredError('content','Required parameter requestParameters.content was null or undefined when calling renderMessage.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.content !== undefined) {
        queryParameters['content'] = requestParameters.content;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/render`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Render a message to HTML.  `POST {{ api_url }}/v1/messages/render` 
* Render message
*/
export function renderMessage<T>(requestParameters: RenderMessageRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return renderMessageRaw(requestParameters, requestConfig);
}

/**
 * Send a stream or a private message.  `POST {{ api_url }}/v1/messages` 
 * Send a message
 */
function sendMessageRaw<T>(requestParameters: SendMessageRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.type === null || requestParameters.type === undefined) {
        throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling sendMessage.');
    }

    if (requestParameters.to === null || requestParameters.to === undefined) {
        throw new runtime.RequiredError('to','Required parameter requestParameters.to was null or undefined when calling sendMessage.');
    }

    if (requestParameters.content === null || requestParameters.content === undefined) {
        throw new runtime.RequiredError('content','Required parameter requestParameters.content was null or undefined when calling sendMessage.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.type !== undefined) {
        queryParameters['type'] = requestParameters.type;
    }


    if (requestParameters.to) {
        queryParameters['to'] = requestParameters.to;
    }


    if (requestParameters.content !== undefined) {
        queryParameters['content'] = requestParameters.content;
    }


    if (requestParameters.topic !== undefined) {
        queryParameters['topic'] = requestParameters.topic;
    }


    if (requestParameters.queueId !== undefined) {
        queryParameters['queue_id'] = requestParameters.queueId;
    }


    if (requestParameters.localId !== undefined) {
        queryParameters['local_id'] = requestParameters.localId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Send a stream or a private message.  `POST {{ api_url }}/v1/messages` 
* Send a message
*/
export function sendMessage<T>(requestParameters: SendMessageRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return sendMessageRaw(requestParameters, requestConfig);
}

/**
 * Edit/update the content or topic of a message.  `PATCH {{ api_url }}/v1/messages/{msg_id}`  `{msg_id}` in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to `✔ {original_topic}`.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
 * Edit a message
 */
function updateMessageRaw<T>(requestParameters: UpdateMessageRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
        throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling updateMessage.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.topic !== undefined) {
        queryParameters['topic'] = requestParameters.topic;
    }


    if (requestParameters.propagateMode !== undefined) {
        queryParameters['propagate_mode'] = requestParameters.propagateMode;
    }


    if (requestParameters.sendNotificationToOldThread !== undefined) {
        queryParameters['send_notification_to_old_thread'] = requestParameters.sendNotificationToOldThread;
    }


    if (requestParameters.sendNotificationToNewThread !== undefined) {
        queryParameters['send_notification_to_new_thread'] = requestParameters.sendNotificationToNewThread;
    }


    if (requestParameters.content !== undefined) {
        queryParameters['content'] = requestParameters.content;
    }


    if (requestParameters.streamId !== undefined) {
        queryParameters['stream_id'] = requestParameters.streamId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/{message_id}`.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Edit/update the content or topic of a message.  `PATCH {{ api_url }}/v1/messages/{msg_id}`  `{msg_id}` in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to `✔ {original_topic}`.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
* Edit a message
*/
export function updateMessage<T>(requestParameters: UpdateMessageRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return updateMessageRaw(requestParameters, requestConfig);
}

/**
 * Add or remove personal message flags like `read` and `starred` on a collection of message IDs.  `POST {{ api_url }}/v1/messages/flags`  For updating the `read` flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
 * Update personal message flags
 */
function updateMessageFlagsRaw<T>(requestParameters: UpdateMessageFlagsRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.messages === null || requestParameters.messages === undefined) {
        throw new runtime.RequiredError('messages','Required parameter requestParameters.messages was null or undefined when calling updateMessageFlags.');
    }

    if (requestParameters.op === null || requestParameters.op === undefined) {
        throw new runtime.RequiredError('op','Required parameter requestParameters.op was null or undefined when calling updateMessageFlags.');
    }

    if (requestParameters.flag === null || requestParameters.flag === undefined) {
        throw new runtime.RequiredError('flag','Required parameter requestParameters.flag was null or undefined when calling updateMessageFlags.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.messages) {
        queryParameters['messages'] = requestParameters.messages;
    }


    if (requestParameters.op !== undefined) {
        queryParameters['op'] = requestParameters.op;
    }


    if (requestParameters.flag !== undefined) {
        queryParameters['flag'] = requestParameters.flag;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/flags`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Add or remove personal message flags like `read` and `starred` on a collection of message IDs.  `POST {{ api_url }}/v1/messages/flags`  For updating the `read` flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
* Update personal message flags
*/
export function updateMessageFlags<T>(requestParameters: UpdateMessageFlagsRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return updateMessageFlagsRaw(requestParameters, requestConfig);
}

/**
 * Upload a single file and get the corresponding URI.  `POST {{ api_url }}/v1/user_uploads`  Initially, only you will be able to access the link.  To share the uploaded file, you\'ll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
 * Upload a file
 */
function uploadFileRaw<T>(requestParameters: UploadFileRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const formData = new FormData();
    if (requestParameters.filename !== undefined) {
        formData.append('filename', requestParameters.filename as any);
    }

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_uploads`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: formData,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Upload a single file and get the corresponding URI.  `POST {{ api_url }}/v1/user_uploads`  Initially, only you will be able to access the link.  To share the uploaded file, you\'ll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
* Upload a file
*/
export function uploadFile<T>(requestParameters: UploadFileRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return uploadFileRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum SendMessageTypeEnum {
    Private = 'private',
    Stream = 'stream'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateMessagePropagateModeEnum {
    One = 'change_one',
    Later = 'change_later',
    All = 'change_all'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateMessageFlagsOpEnum {
    Add = 'add',
    Remove = 'remove'
}
