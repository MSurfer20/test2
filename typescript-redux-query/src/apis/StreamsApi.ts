// tslint:disable
/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    AddSubscriptionsResponse,
    AddSubscriptionsResponseFromJSON,
    AddSubscriptionsResponseToJSON,
    CodedError,
    CodedErrorFromJSON,
    CodedErrorToJSON,
    JsonError,
    JsonErrorFromJSON,
    JsonErrorToJSON,
    JsonSuccess,
    JsonSuccessFromJSON,
    JsonSuccessToJSON,
    JsonSuccessBase,
    JsonSuccessBaseFromJSON,
    JsonSuccessBaseToJSON,
    NonExistingStreamError,
    NonExistingStreamErrorFromJSON,
    NonExistingStreamErrorToJSON,
} from '../models';

export interface ArchiveStreamRequest {
    streamId: number;
}

export interface GetStreamIdRequest {
    stream: string;
}

export interface GetStreamTopicsRequest {
    streamId: number;
}

export interface GetStreamsRequest {
    includePublic?: boolean;
    includeWebPublic?: boolean;
    includeSubscribed?: boolean;
    includeAllActive?: boolean;
    includeDefault?: boolean;
    includeOwnerSubscribed?: boolean;
}

export interface GetSubscriptionStatusRequest {
    userId: number;
    streamId: number;
}

export interface GetSubscriptionsRequest {
    includeSubscribers?: boolean;
}

export interface MuteTopicRequest {
    topic: string;
    op: MuteTopicOpEnum;
    stream?: string;
    streamId?: number;
}

export interface SubscribeRequest {
    subscriptions: Array<object>;
    principals?: Array<string | number>;
    authorizationErrorsFatal?: boolean;
    announce?: boolean;
    inviteOnly?: boolean;
    historyPublicToSubscribers?: boolean;
    streamPostPolicy?: number;
    messageRetentionDays?: string | number;
}

export interface UnsubscribeRequest {
    subscriptions: Array<string>;
    principals?: Array<string | number>;
}

export interface UpdateStreamRequest {
    streamId: number;
    description?: string;
    newName?: string;
    isPrivate?: boolean;
    isAnnouncementOnly?: boolean;
    streamPostPolicy?: number;
    historyPublicToSubscribers?: boolean;
    messageRetentionDays?: string | number;
}

export interface UpdateSubscriptionSettingsRequest {
    subscriptionData: Array<object>;
}

export interface UpdateSubscriptionsRequest {
    _delete?: Array<string>;
    add?: Array<object>;
}


/**
 * [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
 * Archive a stream
 */
function archiveStreamRaw<T>(requestParameters: ArchiveStreamRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.streamId === null || requestParameters.streamId === undefined) {
        throw new runtime.RequiredError('streamId','Required parameter requestParameters.streamId was null or undefined when calling archiveStream.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/streams/{stream_id}`.replace(`{${"stream_id"}}`, encodeURIComponent(String(requestParameters.streamId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
* Archive a stream
*/
export function archiveStream<T>(requestParameters: ArchiveStreamRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return archiveStreamRaw(requestParameters, requestConfig);
}

/**
 * Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
 * Create BigBlueButton video call
 */
function createBigBlueButtonVideoCallRaw<T>( requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/calls/bigbluebutton/create`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
* Create BigBlueButton video call
*/
export function createBigBlueButtonVideoCall<T>( requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return createBigBlueButtonVideoCallRaw( requestConfig);
}

/**
 * Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
 * Get stream ID
 */
function getStreamIdRaw<T>(requestParameters: GetStreamIdRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.stream === null || requestParameters.stream === undefined) {
        throw new runtime.RequiredError('stream','Required parameter requestParameters.stream was null or undefined when calling getStreamId.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.stream !== undefined) {
        queryParameters['stream'] = requestParameters.stream;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/get_stream_id`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
* Get stream ID
*/
export function getStreamId<T>(requestParameters: GetStreamIdRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getStreamIdRaw(requestParameters, requestConfig);
}

/**
 * Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
 * Get topics in a stream
 */
function getStreamTopicsRaw<T>(requestParameters: GetStreamTopicsRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.streamId === null || requestParameters.streamId === undefined) {
        throw new runtime.RequiredError('streamId','Required parameter requestParameters.streamId was null or undefined when calling getStreamTopics.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me/{stream_id}/topics`.replace(`{${"stream_id"}}`, encodeURIComponent(String(requestParameters.streamId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
* Get topics in a stream
*/
export function getStreamTopics<T>(requestParameters: GetStreamTopicsRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getStreamTopicsRaw(requestParameters, requestConfig);
}

/**
 * Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
 * Get all streams
 */
function getStreamsRaw<T>(requestParameters: GetStreamsRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.includePublic !== undefined) {
        queryParameters['include_public'] = requestParameters.includePublic;
    }


    if (requestParameters.includeWebPublic !== undefined) {
        queryParameters['include_web_public'] = requestParameters.includeWebPublic;
    }


    if (requestParameters.includeSubscribed !== undefined) {
        queryParameters['include_subscribed'] = requestParameters.includeSubscribed;
    }


    if (requestParameters.includeAllActive !== undefined) {
        queryParameters['include_all_active'] = requestParameters.includeAllActive;
    }


    if (requestParameters.includeDefault !== undefined) {
        queryParameters['include_default'] = requestParameters.includeDefault;
    }


    if (requestParameters.includeOwnerSubscribed !== undefined) {
        queryParameters['include_owner_subscribed'] = requestParameters.includeOwnerSubscribed;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/streams`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
* Get all streams
*/
export function getStreams<T>(requestParameters: GetStreamsRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getStreamsRaw(requestParameters, requestConfig);
}

/**
 * Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
 * Get subscription status
 */
function getSubscriptionStatusRaw<T>(requestParameters: GetSubscriptionStatusRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.userId === null || requestParameters.userId === undefined) {
        throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getSubscriptionStatus.');
    }

    if (requestParameters.streamId === null || requestParameters.streamId === undefined) {
        throw new runtime.RequiredError('streamId','Required parameter requestParameters.streamId was null or undefined when calling getSubscriptionStatus.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/{user_id}/subscriptions/{stream_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"stream_id"}}`, encodeURIComponent(String(requestParameters.streamId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
* Get subscription status
*/
export function getSubscriptionStatus<T>(requestParameters: GetSubscriptionStatusRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getSubscriptionStatusRaw(requestParameters, requestConfig);
}

/**
 * Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
 * Get subscribed streams
 */
function getSubscriptionsRaw<T>(requestParameters: GetSubscriptionsRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.includeSubscribers !== undefined) {
        queryParameters['include_subscribers'] = requestParameters.includeSubscribers;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me/subscriptions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
* Get subscribed streams
*/
export function getSubscriptions<T>(requestParameters: GetSubscriptionsRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getSubscriptionsRaw(requestParameters, requestConfig);
}

/**
 * This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user\'s unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
 * Topic muting
 */
function muteTopicRaw<T>(requestParameters: MuteTopicRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.topic === null || requestParameters.topic === undefined) {
        throw new runtime.RequiredError('topic','Required parameter requestParameters.topic was null or undefined when calling muteTopic.');
    }

    if (requestParameters.op === null || requestParameters.op === undefined) {
        throw new runtime.RequiredError('op','Required parameter requestParameters.op was null or undefined when calling muteTopic.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.stream !== undefined) {
        queryParameters['stream'] = requestParameters.stream;
    }


    if (requestParameters.streamId !== undefined) {
        queryParameters['stream_id'] = requestParameters.streamId;
    }


    if (requestParameters.topic !== undefined) {
        queryParameters['topic'] = requestParameters.topic;
    }


    if (requestParameters.op !== undefined) {
        queryParameters['op'] = requestParameters.op;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me/subscriptions/muted_topics`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user\'s unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
* Topic muting
*/
export function muteTopic<T>(requestParameters: MuteTopicRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return muteTopicRaw(requestParameters, requestConfig);
}

/**
 * Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
 * Subscribe to a stream
 */
function subscribeRaw<T>(requestParameters: SubscribeRequest, requestConfig: runtime.TypedQueryConfig<T, AddSubscriptionsResponse> = {}): QueryConfig<T> {
    if (requestParameters.subscriptions === null || requestParameters.subscriptions === undefined) {
        throw new runtime.RequiredError('subscriptions','Required parameter requestParameters.subscriptions was null or undefined when calling subscribe.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.subscriptions) {
        queryParameters['subscriptions'] = requestParameters.subscriptions;
    }


    if (requestParameters.principals) {
        queryParameters['principals'] = requestParameters.principals;
    }


    if (requestParameters.authorizationErrorsFatal !== undefined) {
        queryParameters['authorization_errors_fatal'] = requestParameters.authorizationErrorsFatal;
    }


    if (requestParameters.announce !== undefined) {
        queryParameters['announce'] = requestParameters.announce;
    }


    if (requestParameters.inviteOnly !== undefined) {
        queryParameters['invite_only'] = requestParameters.inviteOnly;
    }


    if (requestParameters.historyPublicToSubscribers !== undefined) {
        queryParameters['history_public_to_subscribers'] = requestParameters.historyPublicToSubscribers;
    }


    if (requestParameters.streamPostPolicy !== undefined) {
        queryParameters['stream_post_policy'] = requestParameters.streamPostPolicy;
    }


    if (requestParameters.messageRetentionDays !== undefined) {
        queryParameters['message_retention_days'] = requestParameters.messageRetentionDays;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me/subscriptions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AddSubscriptionsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
* Subscribe to a stream
*/
export function subscribe<T>(requestParameters: SubscribeRequest, requestConfig?: runtime.TypedQueryConfig<T, AddSubscriptionsResponse>): QueryConfig<T> {
    return subscribeRaw(requestParameters, requestConfig);
}

/**
 * Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
 * Unsubscribe from a stream
 */
function unsubscribeRaw<T>(requestParameters: UnsubscribeRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.subscriptions === null || requestParameters.subscriptions === undefined) {
        throw new runtime.RequiredError('subscriptions','Required parameter requestParameters.subscriptions was null or undefined when calling unsubscribe.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.subscriptions) {
        queryParameters['subscriptions'] = requestParameters.subscriptions;
    }


    if (requestParameters.principals) {
        queryParameters['principals'] = requestParameters.principals;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me/subscriptions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
* Unsubscribe from a stream
*/
export function unsubscribe<T>(requestParameters: UnsubscribeRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return unsubscribeRaw(requestParameters, requestConfig);
}

/**
 * Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
 * Update a stream
 */
function updateStreamRaw<T>(requestParameters: UpdateStreamRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.streamId === null || requestParameters.streamId === undefined) {
        throw new runtime.RequiredError('streamId','Required parameter requestParameters.streamId was null or undefined when calling updateStream.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.description !== undefined) {
        queryParameters['description'] = requestParameters.description;
    }


    if (requestParameters.newName !== undefined) {
        queryParameters['new_name'] = requestParameters.newName;
    }


    if (requestParameters.isPrivate !== undefined) {
        queryParameters['is_private'] = requestParameters.isPrivate;
    }


    if (requestParameters.isAnnouncementOnly !== undefined) {
        queryParameters['is_announcement_only'] = requestParameters.isAnnouncementOnly;
    }


    if (requestParameters.streamPostPolicy !== undefined) {
        queryParameters['stream_post_policy'] = requestParameters.streamPostPolicy;
    }


    if (requestParameters.historyPublicToSubscribers !== undefined) {
        queryParameters['history_public_to_subscribers'] = requestParameters.historyPublicToSubscribers;
    }


    if (requestParameters.messageRetentionDays !== undefined) {
        queryParameters['message_retention_days'] = requestParameters.messageRetentionDays;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/streams/{stream_id}`.replace(`{${"stream_id"}}`, encodeURIComponent(String(requestParameters.streamId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
* Update a stream
*/
export function updateStream<T>(requestParameters: UpdateStreamRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return updateStreamRaw(requestParameters, requestConfig);
}

/**
 * This endpoint is used to update the user\'s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
 * Update subscription settings
 */
function updateSubscriptionSettingsRaw<T>(requestParameters: UpdateSubscriptionSettingsRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.subscriptionData === null || requestParameters.subscriptionData === undefined) {
        throw new runtime.RequiredError('subscriptionData','Required parameter requestParameters.subscriptionData was null or undefined when calling updateSubscriptionSettings.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.subscriptionData) {
        queryParameters['subscription_data'] = requestParameters.subscriptionData;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me/subscriptions/properties`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* This endpoint is used to update the user\'s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
* Update subscription settings
*/
export function updateSubscriptionSettings<T>(requestParameters: UpdateSubscriptionSettingsRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return updateSubscriptionSettingsRaw(requestParameters, requestConfig);
}

/**
 * Update which streams you are are subscribed to. 
 * Update subscriptions
 */
function updateSubscriptionsRaw<T>(requestParameters: UpdateSubscriptionsRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters._delete) {
        queryParameters['delete'] = requestParameters._delete;
    }


    if (requestParameters.add) {
        queryParameters['add'] = requestParameters.add;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me/subscriptions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Update which streams you are are subscribed to. 
* Update subscriptions
*/
export function updateSubscriptions<T>(requestParameters: UpdateSubscriptionsRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return updateSubscriptionsRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum MuteTopicOpEnum {
    Add = 'add',
    Remove = 'remove'
}
