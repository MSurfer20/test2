// tslint:disable
/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    CodedError,
    CodedErrorFromJSON,
    CodedErrorToJSON,
    JsonError,
    JsonErrorFromJSON,
    JsonErrorToJSON,
    JsonSuccess,
    JsonSuccessFromJSON,
    JsonSuccessToJSON,
    JsonSuccessBase,
    JsonSuccessBaseFromJSON,
    JsonSuccessBaseToJSON,
} from '../models';

export interface CreateUserRequest {
    email: string;
    password: string;
    fullName: string;
}

export interface CreateUserGroupRequest {
    name: string;
    description: string;
    members: Array<number>;
}

export interface DeactivateUserRequest {
    userId: number;
}

export interface GetUserRequest {
    userId: number;
    clientGravatar?: boolean;
    includeCustomProfileFields?: boolean;
}

export interface GetUserByEmailRequest {
    email: string;
    clientGravatar?: boolean;
    includeCustomProfileFields?: boolean;
}

export interface GetUserPresenceRequest {
    userIdOrEmail: string;
}

export interface GetUsersRequest {
    clientGravatar?: boolean;
    includeCustomProfileFields?: boolean;
}

export interface MuteUserRequest {
    mutedUserId: number;
}

export interface ReactivateUserRequest {
    userId: number;
}

export interface RemoveUserGroupRequest {
    userGroupId: number;
}

export interface SetTypingStatusRequest {
    op: SetTypingStatusOpEnum;
    to: Array<number>;
    type?: SetTypingStatusTypeEnum;
    topic?: string;
}

export interface UnmuteUserRequest {
    mutedUserId: number;
}

export interface UpdateDisplaySettingsRequest {
    twentyFourHourTime?: boolean;
    denseMode?: boolean;
    starredMessageCounts?: boolean;
    fluidLayoutWidth?: boolean;
    highContrastMode?: boolean;
    colorScheme?: UpdateDisplaySettingsColorSchemeEnum;
    translateEmoticons?: boolean;
    defaultLanguage?: string;
    defaultView?: string;
    leftSideUserlist?: boolean;
    emojiset?: string;
    demoteInactiveStreams?: UpdateDisplaySettingsDemoteInactiveStreamsEnum;
    timezone?: string;
}

export interface UpdateNotificationSettingsRequest {
    enableStreamDesktopNotifications?: boolean;
    enableStreamEmailNotifications?: boolean;
    enableStreamPushNotifications?: boolean;
    enableStreamAudibleNotifications?: boolean;
    notificationSound?: string;
    enableDesktopNotifications?: boolean;
    enableSounds?: boolean;
    enableOfflineEmailNotifications?: boolean;
    enableOfflinePushNotifications?: boolean;
    enableOnlinePushNotifications?: boolean;
    enableDigestEmails?: boolean;
    enableMarketingEmails?: boolean;
    enableLoginEmails?: boolean;
    messageContentInEmailNotifications?: boolean;
    pmContentInDesktopNotifications?: boolean;
    wildcardMentionsNotify?: boolean;
    desktopIconCountDisplay?: UpdateNotificationSettingsDesktopIconCountDisplayEnum;
    realmNameInNotifications?: boolean;
    presenceEnabled?: boolean;
}

export interface UpdateUserRequest {
    userId: number;
    fullName?: string;
    role?: number;
    profileData?: Array<object>;
}

export interface UpdateUserGroupRequest {
    userGroupId: number;
    name: string;
    description: string;
}

export interface UpdateUserGroupMembersRequest {
    userGroupId: number;
    _delete?: Array<number>;
    add?: Array<number>;
}


/**
 * {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
 * Create a user
 */
function createUserRaw<T>(requestParameters: CreateUserRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.email === null || requestParameters.email === undefined) {
        throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling createUser.');
    }

    if (requestParameters.password === null || requestParameters.password === undefined) {
        throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling createUser.');
    }

    if (requestParameters.fullName === null || requestParameters.fullName === undefined) {
        throw new runtime.RequiredError('fullName','Required parameter requestParameters.fullName was null or undefined when calling createUser.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.email !== undefined) {
        queryParameters['email'] = requestParameters.email;
    }


    if (requestParameters.password !== undefined) {
        queryParameters['password'] = requestParameters.password;
    }


    if (requestParameters.fullName !== undefined) {
        queryParameters['full_name'] = requestParameters.fullName;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
* Create a user
*/
export function createUser<T>(requestParameters: CreateUserRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return createUserRaw(requestParameters, requestConfig);
}

/**
 * Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
 * Create a user group
 */
function createUserGroupRaw<T>(requestParameters: CreateUserGroupRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
        throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createUserGroup.');
    }

    if (requestParameters.description === null || requestParameters.description === undefined) {
        throw new runtime.RequiredError('description','Required parameter requestParameters.description was null or undefined when calling createUserGroup.');
    }

    if (requestParameters.members === null || requestParameters.members === undefined) {
        throw new runtime.RequiredError('members','Required parameter requestParameters.members was null or undefined when calling createUserGroup.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.name !== undefined) {
        queryParameters['name'] = requestParameters.name;
    }


    if (requestParameters.description !== undefined) {
        queryParameters['description'] = requestParameters.description;
    }


    if (requestParameters.members) {
        queryParameters['members'] = requestParameters.members;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_groups/create`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
* Create a user group
*/
export function createUserGroup<T>(requestParameters: CreateUserGroupRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return createUserGroupRaw(requestParameters, requestConfig);
}

/**
 * Deactivates the user\'s account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
 * Deactivate own user
 */
function deactivateOwnUserRaw<T>( requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Deactivates the user\'s account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
* Deactivate own user
*/
export function deactivateOwnUser<T>( requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return deactivateOwnUserRaw( requestConfig);
}

/**
 * [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
 * Deactivate a user
 */
function deactivateUserRaw<T>(requestParameters: DeactivateUserRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.userId === null || requestParameters.userId === undefined) {
        throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deactivateUser.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
* Deactivate a user
*/
export function deactivateUser<T>(requestParameters: DeactivateUserRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return deactivateUserRaw(requestParameters, requestConfig);
}

/**
 * Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
 * Get attachments
 */
function getAttachmentsRaw<T>( requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/attachments`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
* Get attachments
*/
export function getAttachments<T>( requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getAttachmentsRaw( requestConfig);
}

/**
 * Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
 * Get own user
 */
function getOwnUserRaw<T>( requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
* Get own user
*/
export function getOwnUser<T>( requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getOwnUserRaw( requestConfig);
}

/**
 * Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
 * Get a user
 */
function getUserRaw<T>(requestParameters: GetUserRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.userId === null || requestParameters.userId === undefined) {
        throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getUser.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.clientGravatar !== undefined) {
        queryParameters['client_gravatar'] = requestParameters.clientGravatar;
    }


    if (requestParameters.includeCustomProfileFields !== undefined) {
        queryParameters['include_custom_profile_fields'] = requestParameters.includeCustomProfileFields;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
* Get a user
*/
export function getUser<T>(requestParameters: GetUserRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getUserRaw(requestParameters, requestConfig);
}

/**
 * Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
 * Get a user by email
 */
function getUserByEmailRaw<T>(requestParameters: GetUserByEmailRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.email === null || requestParameters.email === undefined) {
        throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling getUserByEmail.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.clientGravatar !== undefined) {
        queryParameters['client_gravatar'] = requestParameters.clientGravatar;
    }


    if (requestParameters.includeCustomProfileFields !== undefined) {
        queryParameters['include_custom_profile_fields'] = requestParameters.includeCustomProfileFields;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/{email}`.replace(`{${"email"}}`, encodeURIComponent(String(requestParameters.email))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
* Get a user by email
*/
export function getUserByEmail<T>(requestParameters: GetUserByEmailRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getUserByEmailRaw(requestParameters, requestConfig);
}

/**
 * {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
 * Get user groups
 */
function getUserGroupsRaw<T>( requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_groups`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
* Get user groups
*/
export function getUserGroups<T>( requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getUserGroupsRaw( requestConfig);
}

/**
 * Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user\'s presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip\'s developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
 * Get user presence
 */
function getUserPresenceRaw<T>(requestParameters: GetUserPresenceRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    if (requestParameters.userIdOrEmail === null || requestParameters.userIdOrEmail === undefined) {
        throw new runtime.RequiredError('userIdOrEmail','Required parameter requestParameters.userIdOrEmail was null or undefined when calling getUserPresence.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/{user_id_or_email}/presence`.replace(`{${"user_id_or_email"}}`, encodeURIComponent(String(requestParameters.userIdOrEmail))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user\'s presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip\'s developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
* Get user presence
*/
export function getUserPresence<T>(requestParameters: GetUserPresenceRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getUserPresenceRaw(requestParameters, requestConfig);
}

/**
 * Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
 * Get all users
 */
function getUsersRaw<T>(requestParameters: GetUsersRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.clientGravatar !== undefined) {
        queryParameters['client_gravatar'] = requestParameters.clientGravatar;
    }


    if (requestParameters.includeCustomProfileFields !== undefined) {
        queryParameters['include_custom_profile_fields'] = requestParameters.includeCustomProfileFields;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
* Get all users
*/
export function getUsers<T>(requestParameters: GetUsersRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return getUsersRaw(requestParameters, requestConfig);
}

/**
 * This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you\'ve muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user\'s name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
 * Mute a user
 */
function muteUserRaw<T>(requestParameters: MuteUserRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.mutedUserId === null || requestParameters.mutedUserId === undefined) {
        throw new runtime.RequiredError('mutedUserId','Required parameter requestParameters.mutedUserId was null or undefined when calling muteUser.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me/muted_users/{muted_user_id}`.replace(`{${"muted_user_id"}}`, encodeURIComponent(String(requestParameters.mutedUserId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you\'ve muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user\'s name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
* Mute a user
*/
export function muteUser<T>(requestParameters: MuteUserRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return muteUserRaw(requestParameters, requestConfig);
}

/**
 * [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
 * Reactivate a user
 */
function reactivateUserRaw<T>(requestParameters: ReactivateUserRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.userId === null || requestParameters.userId === undefined) {
        throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling reactivateUser.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/{user_id}/reactivate`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
* Reactivate a user
*/
export function reactivateUser<T>(requestParameters: ReactivateUserRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return reactivateUserRaw(requestParameters, requestConfig);
}

/**
 * Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
 * Delete a user group
 */
function removeUserGroupRaw<T>(requestParameters: RemoveUserGroupRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.userGroupId === null || requestParameters.userGroupId === undefined) {
        throw new runtime.RequiredError('userGroupId','Required parameter requestParameters.userGroupId was null or undefined when calling removeUserGroup.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_groups/{user_group_id}`.replace(`{${"user_group_id"}}`, encodeURIComponent(String(requestParameters.userGroupId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
* Delete a user group
*/
export function removeUserGroup<T>(requestParameters: RemoveUserGroupRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return removeUserGroupRaw(requestParameters, requestConfig);
}

/**
 * Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip\'s typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip\'s typing notifications protocol. 
 * Set \"typing\" status
 */
function setTypingStatusRaw<T>(requestParameters: SetTypingStatusRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.op === null || requestParameters.op === undefined) {
        throw new runtime.RequiredError('op','Required parameter requestParameters.op was null or undefined when calling setTypingStatus.');
    }

    if (requestParameters.to === null || requestParameters.to === undefined) {
        throw new runtime.RequiredError('to','Required parameter requestParameters.to was null or undefined when calling setTypingStatus.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.type !== undefined) {
        queryParameters['type'] = requestParameters.type;
    }


    if (requestParameters.op !== undefined) {
        queryParameters['op'] = requestParameters.op;
    }


    if (requestParameters.to) {
        queryParameters['to'] = requestParameters.to;
    }


    if (requestParameters.topic !== undefined) {
        queryParameters['topic'] = requestParameters.topic;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/typing`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip\'s typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip\'s typing notifications protocol. 
* Set \"typing\" status
*/
export function setTypingStatus<T>(requestParameters: SetTypingStatusRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return setTypingStatusRaw(requestParameters, requestConfig);
}

/**
 * This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
 * Unmute a user
 */
function unmuteUserRaw<T>(requestParameters: UnmuteUserRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.mutedUserId === null || requestParameters.mutedUserId === undefined) {
        throw new runtime.RequiredError('mutedUserId','Required parameter requestParameters.mutedUserId was null or undefined when calling unmuteUser.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/me/muted_users/{muted_user_id}`.replace(`{${"muted_user_id"}}`, encodeURIComponent(String(requestParameters.mutedUserId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
* Unmute a user
*/
export function unmuteUser<T>(requestParameters: UnmuteUserRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return unmuteUserRaw(requestParameters, requestConfig);
}

/**
 * This endpoint is used to edit the current user\'s user interface settings.  `PATCH {{ api_url }}/v1/settings/display` 
 * Update display settings
 */
function updateDisplaySettingsRaw<T>(requestParameters: UpdateDisplaySettingsRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.twentyFourHourTime !== undefined) {
        queryParameters['twenty_four_hour_time'] = requestParameters.twentyFourHourTime;
    }


    if (requestParameters.denseMode !== undefined) {
        queryParameters['dense_mode'] = requestParameters.denseMode;
    }


    if (requestParameters.starredMessageCounts !== undefined) {
        queryParameters['starred_message_counts'] = requestParameters.starredMessageCounts;
    }


    if (requestParameters.fluidLayoutWidth !== undefined) {
        queryParameters['fluid_layout_width'] = requestParameters.fluidLayoutWidth;
    }


    if (requestParameters.highContrastMode !== undefined) {
        queryParameters['high_contrast_mode'] = requestParameters.highContrastMode;
    }


    if (requestParameters.colorScheme !== undefined) {
        queryParameters['color_scheme'] = requestParameters.colorScheme;
    }


    if (requestParameters.translateEmoticons !== undefined) {
        queryParameters['translate_emoticons'] = requestParameters.translateEmoticons;
    }


    if (requestParameters.defaultLanguage !== undefined) {
        queryParameters['default_language'] = requestParameters.defaultLanguage;
    }


    if (requestParameters.defaultView !== undefined) {
        queryParameters['default_view'] = requestParameters.defaultView;
    }


    if (requestParameters.leftSideUserlist !== undefined) {
        queryParameters['left_side_userlist'] = requestParameters.leftSideUserlist;
    }


    if (requestParameters.emojiset !== undefined) {
        queryParameters['emojiset'] = requestParameters.emojiset;
    }


    if (requestParameters.demoteInactiveStreams !== undefined) {
        queryParameters['demote_inactive_streams'] = requestParameters.demoteInactiveStreams;
    }


    if (requestParameters.timezone !== undefined) {
        queryParameters['timezone'] = requestParameters.timezone;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/settings/display`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* This endpoint is used to edit the current user\'s user interface settings.  `PATCH {{ api_url }}/v1/settings/display` 
* Update display settings
*/
export function updateDisplaySettings<T>(requestParameters: UpdateDisplaySettingsRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return updateDisplaySettingsRaw(requestParameters, requestConfig);
}

/**
 * This endpoint is used to edit the user\'s global notification settings. See [this endpoint](/api/update-subscription-settings) for per-stream notification settings.  `PATCH {{ api_url }}/v1/settings/notifications` 
 * Update notification settings
 */
function updateNotificationSettingsRaw<T>(requestParameters: UpdateNotificationSettingsRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccessBase & object> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.enableStreamDesktopNotifications !== undefined) {
        queryParameters['enable_stream_desktop_notifications'] = requestParameters.enableStreamDesktopNotifications;
    }


    if (requestParameters.enableStreamEmailNotifications !== undefined) {
        queryParameters['enable_stream_email_notifications'] = requestParameters.enableStreamEmailNotifications;
    }


    if (requestParameters.enableStreamPushNotifications !== undefined) {
        queryParameters['enable_stream_push_notifications'] = requestParameters.enableStreamPushNotifications;
    }


    if (requestParameters.enableStreamAudibleNotifications !== undefined) {
        queryParameters['enable_stream_audible_notifications'] = requestParameters.enableStreamAudibleNotifications;
    }


    if (requestParameters.notificationSound !== undefined) {
        queryParameters['notification_sound'] = requestParameters.notificationSound;
    }


    if (requestParameters.enableDesktopNotifications !== undefined) {
        queryParameters['enable_desktop_notifications'] = requestParameters.enableDesktopNotifications;
    }


    if (requestParameters.enableSounds !== undefined) {
        queryParameters['enable_sounds'] = requestParameters.enableSounds;
    }


    if (requestParameters.enableOfflineEmailNotifications !== undefined) {
        queryParameters['enable_offline_email_notifications'] = requestParameters.enableOfflineEmailNotifications;
    }


    if (requestParameters.enableOfflinePushNotifications !== undefined) {
        queryParameters['enable_offline_push_notifications'] = requestParameters.enableOfflinePushNotifications;
    }


    if (requestParameters.enableOnlinePushNotifications !== undefined) {
        queryParameters['enable_online_push_notifications'] = requestParameters.enableOnlinePushNotifications;
    }


    if (requestParameters.enableDigestEmails !== undefined) {
        queryParameters['enable_digest_emails'] = requestParameters.enableDigestEmails;
    }


    if (requestParameters.enableMarketingEmails !== undefined) {
        queryParameters['enable_marketing_emails'] = requestParameters.enableMarketingEmails;
    }


    if (requestParameters.enableLoginEmails !== undefined) {
        queryParameters['enable_login_emails'] = requestParameters.enableLoginEmails;
    }


    if (requestParameters.messageContentInEmailNotifications !== undefined) {
        queryParameters['message_content_in_email_notifications'] = requestParameters.messageContentInEmailNotifications;
    }


    if (requestParameters.pmContentInDesktopNotifications !== undefined) {
        queryParameters['pm_content_in_desktop_notifications'] = requestParameters.pmContentInDesktopNotifications;
    }


    if (requestParameters.wildcardMentionsNotify !== undefined) {
        queryParameters['wildcard_mentions_notify'] = requestParameters.wildcardMentionsNotify;
    }


    if (requestParameters.desktopIconCountDisplay !== undefined) {
        queryParameters['desktop_icon_count_display'] = requestParameters.desktopIconCountDisplay;
    }


    if (requestParameters.realmNameInNotifications !== undefined) {
        queryParameters['realm_name_in_notifications'] = requestParameters.realmNameInNotifications;
    }


    if (requestParameters.presenceEnabled !== undefined) {
        queryParameters['presence_enabled'] = requestParameters.presenceEnabled;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/settings/notifications`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessBase &amp; objectFromJSON(body), text);
    }

    return config;
}

/**
* This endpoint is used to edit the user\'s global notification settings. See [this endpoint](/api/update-subscription-settings) for per-stream notification settings.  `PATCH {{ api_url }}/v1/settings/notifications` 
* Update notification settings
*/
export function updateNotificationSettings<T>(requestParameters: UpdateNotificationSettingsRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccessBase & object>): QueryConfig<T> {
    return updateNotificationSettingsRaw(requestParameters, requestConfig);
}

/**
 * Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user\'s account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
 * Update a user
 */
function updateUserRaw<T>(requestParameters: UpdateUserRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.userId === null || requestParameters.userId === undefined) {
        throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling updateUser.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.fullName !== undefined) {
        queryParameters['full_name'] = requestParameters.fullName;
    }


    if (requestParameters.role !== undefined) {
        queryParameters['role'] = requestParameters.role;
    }


    if (requestParameters.profileData) {
        queryParameters['profile_data'] = requestParameters.profileData;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user\'s account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
* Update a user
*/
export function updateUser<T>(requestParameters: UpdateUserRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return updateUserRaw(requestParameters, requestConfig);
}

/**
 * Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
 * Update a user group
 */
function updateUserGroupRaw<T>(requestParameters: UpdateUserGroupRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.userGroupId === null || requestParameters.userGroupId === undefined) {
        throw new runtime.RequiredError('userGroupId','Required parameter requestParameters.userGroupId was null or undefined when calling updateUserGroup.');
    }

    if (requestParameters.name === null || requestParameters.name === undefined) {
        throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updateUserGroup.');
    }

    if (requestParameters.description === null || requestParameters.description === undefined) {
        throw new runtime.RequiredError('description','Required parameter requestParameters.description was null or undefined when calling updateUserGroup.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.name !== undefined) {
        queryParameters['name'] = requestParameters.name;
    }


    if (requestParameters.description !== undefined) {
        queryParameters['description'] = requestParameters.description;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_groups/{user_group_id}`.replace(`{${"user_group_id"}}`, encodeURIComponent(String(requestParameters.userGroupId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
* Update a user group
*/
export function updateUserGroup<T>(requestParameters: UpdateUserGroupRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return updateUserGroupRaw(requestParameters, requestConfig);
}

/**
 * Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
 * Update user group members
 */
function updateUserGroupMembersRaw<T>(requestParameters: UpdateUserGroupMembersRequest, requestConfig: runtime.TypedQueryConfig<T, JsonSuccess> = {}): QueryConfig<T> {
    if (requestParameters.userGroupId === null || requestParameters.userGroupId === undefined) {
        throw new runtime.RequiredError('userGroupId','Required parameter requestParameters.userGroupId was null or undefined when calling updateUserGroupMembers.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters._delete) {
        queryParameters['delete'] = requestParameters._delete;
    }


    if (requestParameters.add) {
        queryParameters['add'] = requestParameters.add;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_groups/{user_group_id}/members`.replace(`{${"user_group_id"}}`, encodeURIComponent(String(requestParameters.userGroupId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(JsonSuccessFromJSON(body), text);
    }

    return config;
}

/**
* Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
* Update user group members
*/
export function updateUserGroupMembers<T>(requestParameters: UpdateUserGroupMembersRequest, requestConfig?: runtime.TypedQueryConfig<T, JsonSuccess>): QueryConfig<T> {
    return updateUserGroupMembersRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum SetTypingStatusOpEnum {
    Start = 'start',
    Stop = 'stop'
}
/**
    * @export
    * @enum {string}
    */
export enum SetTypingStatusTypeEnum {
    Private = 'private',
    Stream = 'stream'
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateDisplaySettingsColorSchemeEnum {
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateDisplaySettingsDemoteInactiveStreamsEnum {
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3
}
/**
    * @export
    * @enum {string}
    */
export enum UpdateNotificationSettingsDesktopIconCountDisplayEnum {
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3
}
