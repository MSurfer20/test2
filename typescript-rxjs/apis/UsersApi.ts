// tslint:disable
/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Observable } from 'rxjs';
import { BaseAPI, HttpQuery, throwIfNullOrUndefined, encodeURI, OperationOpts, RawAjaxResponse } from '../runtime';
import {
    CodedError,
    JsonError,
    JsonSuccess,
    JsonSuccessBase,
} from '../models';

export interface CreateUserRequest {
    email: string;
    password: string;
    fullName: string;
}

export interface CreateUserGroupRequest {
    name: string;
    description: string;
    members: Array<number>;
}

export interface DeactivateUserRequest {
    userId: number;
}

export interface GetUserRequest {
    userId: number;
    clientGravatar?: boolean;
    includeCustomProfileFields?: boolean;
}

export interface GetUserByEmailRequest {
    email: string;
    clientGravatar?: boolean;
    includeCustomProfileFields?: boolean;
}

export interface GetUserPresenceRequest {
    userIdOrEmail: string;
}

export interface GetUsersRequest {
    clientGravatar?: boolean;
    includeCustomProfileFields?: boolean;
}

export interface MuteUserRequest {
    mutedUserId: number;
}

export interface ReactivateUserRequest {
    userId: number;
}

export interface RemoveUserGroupRequest {
    userGroupId: number;
}

export interface SetTypingStatusRequest {
    op: SetTypingStatusOpEnum;
    to: Array<number>;
    type?: SetTypingStatusTypeEnum;
    topic?: string;
}

export interface UnmuteUserRequest {
    mutedUserId: number;
}

export interface UpdateDisplaySettingsRequest {
    twentyFourHourTime?: boolean;
    denseMode?: boolean;
    starredMessageCounts?: boolean;
    fluidLayoutWidth?: boolean;
    highContrastMode?: boolean;
    colorScheme?: UpdateDisplaySettingsColorSchemeEnum;
    translateEmoticons?: boolean;
    defaultLanguage?: string;
    defaultView?: string;
    leftSideUserlist?: boolean;
    emojiset?: string;
    demoteInactiveStreams?: UpdateDisplaySettingsDemoteInactiveStreamsEnum;
    timezone?: string;
}

export interface UpdateNotificationSettingsRequest {
    enableStreamDesktopNotifications?: boolean;
    enableStreamEmailNotifications?: boolean;
    enableStreamPushNotifications?: boolean;
    enableStreamAudibleNotifications?: boolean;
    notificationSound?: string;
    enableDesktopNotifications?: boolean;
    enableSounds?: boolean;
    enableOfflineEmailNotifications?: boolean;
    enableOfflinePushNotifications?: boolean;
    enableOnlinePushNotifications?: boolean;
    enableDigestEmails?: boolean;
    enableMarketingEmails?: boolean;
    enableLoginEmails?: boolean;
    messageContentInEmailNotifications?: boolean;
    pmContentInDesktopNotifications?: boolean;
    wildcardMentionsNotify?: boolean;
    desktopIconCountDisplay?: UpdateNotificationSettingsDesktopIconCountDisplayEnum;
    realmNameInNotifications?: boolean;
    presenceEnabled?: boolean;
}

export interface UpdateUserRequest {
    userId: number;
    fullName?: string;
    role?: number;
    profileData?: Array<object>;
}

export interface UpdateUserGroupRequest {
    userGroupId: number;
    name: string;
    description: string;
}

export interface UpdateUserGroupMembersRequest {
    userGroupId: number;
    _delete?: Array<number>;
    add?: Array<number>;
}

/**
 * no description
 */
export class UsersApi extends BaseAPI {

    /**
     * {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
     * Create a user
     */
    createUser({ email, password, fullName }: CreateUserRequest): Observable<JsonSuccessBase & object>
    createUser({ email, password, fullName }: CreateUserRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccessBase & object>>
    createUser({ email, password, fullName }: CreateUserRequest, opts?: OperationOpts): Observable<JsonSuccessBase & object | RawAjaxResponse<JsonSuccessBase & object>> {
        throwIfNullOrUndefined(email, 'email', 'createUser');
        throwIfNullOrUndefined(password, 'password', 'createUser');
        throwIfNullOrUndefined(fullName, 'fullName', 'createUser');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'email': email,
            'password': password,
            'full_name': fullName,
        };

        return this.request<JsonSuccessBase & object>({
            url: '/users',
            method: 'POST',
            query,
        }, opts?.responseOpts);
    };

    /**
     * Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
     * Create a user group
     */
    createUserGroup({ name, description, members }: CreateUserGroupRequest): Observable<JsonSuccess>
    createUserGroup({ name, description, members }: CreateUserGroupRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    createUserGroup({ name, description, members }: CreateUserGroupRequest, opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        throwIfNullOrUndefined(name, 'name', 'createUserGroup');
        throwIfNullOrUndefined(description, 'description', 'createUserGroup');
        throwIfNullOrUndefined(members, 'members', 'createUserGroup');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'name': name,
            'description': description,
            'members': members,
        };

        return this.request<JsonSuccess>({
            url: '/user_groups/create',
            method: 'POST',
            query,
        }, opts?.responseOpts);
    };

    /**
     * Deactivates the user\'s account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
     * Deactivate own user
     */
    deactivateOwnUser(): Observable<JsonSuccess>
    deactivateOwnUser(opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    deactivateOwnUser(opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        return this.request<JsonSuccess>({
            url: '/users/me',
            method: 'DELETE',
        }, opts?.responseOpts);
    };

    /**
     * [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
     * Deactivate a user
     */
    deactivateUser({ userId }: DeactivateUserRequest): Observable<JsonSuccess>
    deactivateUser({ userId }: DeactivateUserRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    deactivateUser({ userId }: DeactivateUserRequest, opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        throwIfNullOrUndefined(userId, 'userId', 'deactivateUser');

        return this.request<JsonSuccess>({
            url: '/users/{user_id}'.replace('{user_id}', encodeURI(userId)),
            method: 'DELETE',
        }, opts?.responseOpts);
    };

    /**
     * Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
     * Get attachments
     */
    getAttachments(): Observable<JsonSuccessBase & object>
    getAttachments(opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccessBase & object>>
    getAttachments(opts?: OperationOpts): Observable<JsonSuccessBase & object | RawAjaxResponse<JsonSuccessBase & object>> {
        return this.request<JsonSuccessBase & object>({
            url: '/attachments',
            method: 'GET',
        }, opts?.responseOpts);
    };

    /**
     * Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
     * Get own user
     */
    getOwnUser(): Observable<JsonSuccessBase & object>
    getOwnUser(opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccessBase & object>>
    getOwnUser(opts?: OperationOpts): Observable<JsonSuccessBase & object | RawAjaxResponse<JsonSuccessBase & object>> {
        return this.request<JsonSuccessBase & object>({
            url: '/users/me',
            method: 'GET',
        }, opts?.responseOpts);
    };

    /**
     * Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
     * Get a user
     */
    getUser({ userId, clientGravatar, includeCustomProfileFields }: GetUserRequest): Observable<JsonSuccessBase & object>
    getUser({ userId, clientGravatar, includeCustomProfileFields }: GetUserRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccessBase & object>>
    getUser({ userId, clientGravatar, includeCustomProfileFields }: GetUserRequest, opts?: OperationOpts): Observable<JsonSuccessBase & object | RawAjaxResponse<JsonSuccessBase & object>> {
        throwIfNullOrUndefined(userId, 'userId', 'getUser');

        const query: HttpQuery = {};

        if (clientGravatar != null) { query['client_gravatar'] = clientGravatar; }
        if (includeCustomProfileFields != null) { query['include_custom_profile_fields'] = includeCustomProfileFields; }

        return this.request<JsonSuccessBase & object>({
            url: '/users/{user_id}'.replace('{user_id}', encodeURI(userId)),
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     * Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
     * Get a user by email
     */
    getUserByEmail({ email, clientGravatar, includeCustomProfileFields }: GetUserByEmailRequest): Observable<JsonSuccessBase & object>
    getUserByEmail({ email, clientGravatar, includeCustomProfileFields }: GetUserByEmailRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccessBase & object>>
    getUserByEmail({ email, clientGravatar, includeCustomProfileFields }: GetUserByEmailRequest, opts?: OperationOpts): Observable<JsonSuccessBase & object | RawAjaxResponse<JsonSuccessBase & object>> {
        throwIfNullOrUndefined(email, 'email', 'getUserByEmail');

        const query: HttpQuery = {};

        if (clientGravatar != null) { query['client_gravatar'] = clientGravatar; }
        if (includeCustomProfileFields != null) { query['include_custom_profile_fields'] = includeCustomProfileFields; }

        return this.request<JsonSuccessBase & object>({
            url: '/users/{email}'.replace('{email}', encodeURI(email)),
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     * {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
     * Get user groups
     */
    getUserGroups(): Observable<JsonSuccessBase & object>
    getUserGroups(opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccessBase & object>>
    getUserGroups(opts?: OperationOpts): Observable<JsonSuccessBase & object | RawAjaxResponse<JsonSuccessBase & object>> {
        return this.request<JsonSuccessBase & object>({
            url: '/user_groups',
            method: 'GET',
        }, opts?.responseOpts);
    };

    /**
     * Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user\'s presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip\'s developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
     * Get user presence
     */
    getUserPresence({ userIdOrEmail }: GetUserPresenceRequest): Observable<JsonSuccessBase & object>
    getUserPresence({ userIdOrEmail }: GetUserPresenceRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccessBase & object>>
    getUserPresence({ userIdOrEmail }: GetUserPresenceRequest, opts?: OperationOpts): Observable<JsonSuccessBase & object | RawAjaxResponse<JsonSuccessBase & object>> {
        throwIfNullOrUndefined(userIdOrEmail, 'userIdOrEmail', 'getUserPresence');

        return this.request<JsonSuccessBase & object>({
            url: '/users/{user_id_or_email}/presence'.replace('{user_id_or_email}', encodeURI(userIdOrEmail)),
            method: 'GET',
        }, opts?.responseOpts);
    };

    /**
     * Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
     * Get all users
     */
    getUsers({ clientGravatar, includeCustomProfileFields }: GetUsersRequest): Observable<JsonSuccessBase & object>
    getUsers({ clientGravatar, includeCustomProfileFields }: GetUsersRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccessBase & object>>
    getUsers({ clientGravatar, includeCustomProfileFields }: GetUsersRequest, opts?: OperationOpts): Observable<JsonSuccessBase & object | RawAjaxResponse<JsonSuccessBase & object>> {

        const query: HttpQuery = {};

        if (clientGravatar != null) { query['client_gravatar'] = clientGravatar; }
        if (includeCustomProfileFields != null) { query['include_custom_profile_fields'] = includeCustomProfileFields; }

        return this.request<JsonSuccessBase & object>({
            url: '/users',
            method: 'GET',
            query,
        }, opts?.responseOpts);
    };

    /**
     * This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you\'ve muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user\'s name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
     * Mute a user
     */
    muteUser({ mutedUserId }: MuteUserRequest): Observable<JsonSuccess>
    muteUser({ mutedUserId }: MuteUserRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    muteUser({ mutedUserId }: MuteUserRequest, opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        throwIfNullOrUndefined(mutedUserId, 'mutedUserId', 'muteUser');

        return this.request<JsonSuccess>({
            url: '/users/me/muted_users/{muted_user_id}'.replace('{muted_user_id}', encodeURI(mutedUserId)),
            method: 'POST',
        }, opts?.responseOpts);
    };

    /**
     * [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
     * Reactivate a user
     */
    reactivateUser({ userId }: ReactivateUserRequest): Observable<JsonSuccess>
    reactivateUser({ userId }: ReactivateUserRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    reactivateUser({ userId }: ReactivateUserRequest, opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        throwIfNullOrUndefined(userId, 'userId', 'reactivateUser');

        return this.request<JsonSuccess>({
            url: '/users/{user_id}/reactivate'.replace('{user_id}', encodeURI(userId)),
            method: 'POST',
        }, opts?.responseOpts);
    };

    /**
     * Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
     * Delete a user group
     */
    removeUserGroup({ userGroupId }: RemoveUserGroupRequest): Observable<JsonSuccess>
    removeUserGroup({ userGroupId }: RemoveUserGroupRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    removeUserGroup({ userGroupId }: RemoveUserGroupRequest, opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        throwIfNullOrUndefined(userGroupId, 'userGroupId', 'removeUserGroup');

        return this.request<JsonSuccess>({
            url: '/user_groups/{user_group_id}'.replace('{user_group_id}', encodeURI(userGroupId)),
            method: 'DELETE',
        }, opts?.responseOpts);
    };

    /**
     * Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip\'s typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip\'s typing notifications protocol. 
     * Set \"typing\" status
     */
    setTypingStatus({ op, to, type, topic }: SetTypingStatusRequest): Observable<JsonSuccess>
    setTypingStatus({ op, to, type, topic }: SetTypingStatusRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    setTypingStatus({ op, to, type, topic }: SetTypingStatusRequest, opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        throwIfNullOrUndefined(op, 'op', 'setTypingStatus');
        throwIfNullOrUndefined(to, 'to', 'setTypingStatus');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'op': op,
            'to': to,
        };

        if (type != null) { query['type'] = type; }
        if (topic != null) { query['topic'] = topic; }

        return this.request<JsonSuccess>({
            url: '/typing',
            method: 'POST',
            query,
        }, opts?.responseOpts);
    };

    /**
     * This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
     * Unmute a user
     */
    unmuteUser({ mutedUserId }: UnmuteUserRequest): Observable<JsonSuccess>
    unmuteUser({ mutedUserId }: UnmuteUserRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    unmuteUser({ mutedUserId }: UnmuteUserRequest, opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        throwIfNullOrUndefined(mutedUserId, 'mutedUserId', 'unmuteUser');

        return this.request<JsonSuccess>({
            url: '/users/me/muted_users/{muted_user_id}'.replace('{muted_user_id}', encodeURI(mutedUserId)),
            method: 'DELETE',
        }, opts?.responseOpts);
    };

    /**
     * This endpoint is used to edit the current user\'s user interface settings.  `PATCH {{ api_url }}/v1/settings/display` 
     * Update display settings
     */
    updateDisplaySettings({ twentyFourHourTime, denseMode, starredMessageCounts, fluidLayoutWidth, highContrastMode, colorScheme, translateEmoticons, defaultLanguage, defaultView, leftSideUserlist, emojiset, demoteInactiveStreams, timezone }: UpdateDisplaySettingsRequest): Observable<JsonSuccessBase & object>
    updateDisplaySettings({ twentyFourHourTime, denseMode, starredMessageCounts, fluidLayoutWidth, highContrastMode, colorScheme, translateEmoticons, defaultLanguage, defaultView, leftSideUserlist, emojiset, demoteInactiveStreams, timezone }: UpdateDisplaySettingsRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccessBase & object>>
    updateDisplaySettings({ twentyFourHourTime, denseMode, starredMessageCounts, fluidLayoutWidth, highContrastMode, colorScheme, translateEmoticons, defaultLanguage, defaultView, leftSideUserlist, emojiset, demoteInactiveStreams, timezone }: UpdateDisplaySettingsRequest, opts?: OperationOpts): Observable<JsonSuccessBase & object | RawAjaxResponse<JsonSuccessBase & object>> {

        const query: HttpQuery = {};

        if (twentyFourHourTime != null) { query['twenty_four_hour_time'] = twentyFourHourTime; }
        if (denseMode != null) { query['dense_mode'] = denseMode; }
        if (starredMessageCounts != null) { query['starred_message_counts'] = starredMessageCounts; }
        if (fluidLayoutWidth != null) { query['fluid_layout_width'] = fluidLayoutWidth; }
        if (highContrastMode != null) { query['high_contrast_mode'] = highContrastMode; }
        if (colorScheme != null) { query['color_scheme'] = colorScheme; }
        if (translateEmoticons != null) { query['translate_emoticons'] = translateEmoticons; }
        if (defaultLanguage != null) { query['default_language'] = defaultLanguage; }
        if (defaultView != null) { query['default_view'] = defaultView; }
        if (leftSideUserlist != null) { query['left_side_userlist'] = leftSideUserlist; }
        if (emojiset != null) { query['emojiset'] = emojiset; }
        if (demoteInactiveStreams != null) { query['demote_inactive_streams'] = demoteInactiveStreams; }
        if (timezone != null) { query['timezone'] = timezone; }

        return this.request<JsonSuccessBase & object>({
            url: '/settings/display',
            method: 'PATCH',
            query,
        }, opts?.responseOpts);
    };

    /**
     * This endpoint is used to edit the user\'s global notification settings. See [this endpoint](/api/update-subscription-settings) for per-stream notification settings.  `PATCH {{ api_url }}/v1/settings/notifications` 
     * Update notification settings
     */
    updateNotificationSettings({ enableStreamDesktopNotifications, enableStreamEmailNotifications, enableStreamPushNotifications, enableStreamAudibleNotifications, notificationSound, enableDesktopNotifications, enableSounds, enableOfflineEmailNotifications, enableOfflinePushNotifications, enableOnlinePushNotifications, enableDigestEmails, enableMarketingEmails, enableLoginEmails, messageContentInEmailNotifications, pmContentInDesktopNotifications, wildcardMentionsNotify, desktopIconCountDisplay, realmNameInNotifications, presenceEnabled }: UpdateNotificationSettingsRequest): Observable<JsonSuccessBase & object>
    updateNotificationSettings({ enableStreamDesktopNotifications, enableStreamEmailNotifications, enableStreamPushNotifications, enableStreamAudibleNotifications, notificationSound, enableDesktopNotifications, enableSounds, enableOfflineEmailNotifications, enableOfflinePushNotifications, enableOnlinePushNotifications, enableDigestEmails, enableMarketingEmails, enableLoginEmails, messageContentInEmailNotifications, pmContentInDesktopNotifications, wildcardMentionsNotify, desktopIconCountDisplay, realmNameInNotifications, presenceEnabled }: UpdateNotificationSettingsRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccessBase & object>>
    updateNotificationSettings({ enableStreamDesktopNotifications, enableStreamEmailNotifications, enableStreamPushNotifications, enableStreamAudibleNotifications, notificationSound, enableDesktopNotifications, enableSounds, enableOfflineEmailNotifications, enableOfflinePushNotifications, enableOnlinePushNotifications, enableDigestEmails, enableMarketingEmails, enableLoginEmails, messageContentInEmailNotifications, pmContentInDesktopNotifications, wildcardMentionsNotify, desktopIconCountDisplay, realmNameInNotifications, presenceEnabled }: UpdateNotificationSettingsRequest, opts?: OperationOpts): Observable<JsonSuccessBase & object | RawAjaxResponse<JsonSuccessBase & object>> {

        const query: HttpQuery = {};

        if (enableStreamDesktopNotifications != null) { query['enable_stream_desktop_notifications'] = enableStreamDesktopNotifications; }
        if (enableStreamEmailNotifications != null) { query['enable_stream_email_notifications'] = enableStreamEmailNotifications; }
        if (enableStreamPushNotifications != null) { query['enable_stream_push_notifications'] = enableStreamPushNotifications; }
        if (enableStreamAudibleNotifications != null) { query['enable_stream_audible_notifications'] = enableStreamAudibleNotifications; }
        if (notificationSound != null) { query['notification_sound'] = notificationSound; }
        if (enableDesktopNotifications != null) { query['enable_desktop_notifications'] = enableDesktopNotifications; }
        if (enableSounds != null) { query['enable_sounds'] = enableSounds; }
        if (enableOfflineEmailNotifications != null) { query['enable_offline_email_notifications'] = enableOfflineEmailNotifications; }
        if (enableOfflinePushNotifications != null) { query['enable_offline_push_notifications'] = enableOfflinePushNotifications; }
        if (enableOnlinePushNotifications != null) { query['enable_online_push_notifications'] = enableOnlinePushNotifications; }
        if (enableDigestEmails != null) { query['enable_digest_emails'] = enableDigestEmails; }
        if (enableMarketingEmails != null) { query['enable_marketing_emails'] = enableMarketingEmails; }
        if (enableLoginEmails != null) { query['enable_login_emails'] = enableLoginEmails; }
        if (messageContentInEmailNotifications != null) { query['message_content_in_email_notifications'] = messageContentInEmailNotifications; }
        if (pmContentInDesktopNotifications != null) { query['pm_content_in_desktop_notifications'] = pmContentInDesktopNotifications; }
        if (wildcardMentionsNotify != null) { query['wildcard_mentions_notify'] = wildcardMentionsNotify; }
        if (desktopIconCountDisplay != null) { query['desktop_icon_count_display'] = desktopIconCountDisplay; }
        if (realmNameInNotifications != null) { query['realm_name_in_notifications'] = realmNameInNotifications; }
        if (presenceEnabled != null) { query['presence_enabled'] = presenceEnabled; }

        return this.request<JsonSuccessBase & object>({
            url: '/settings/notifications',
            method: 'PATCH',
            query,
        }, opts?.responseOpts);
    };

    /**
     * Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user\'s account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
     * Update a user
     */
    updateUser({ userId, fullName, role, profileData }: UpdateUserRequest): Observable<JsonSuccess>
    updateUser({ userId, fullName, role, profileData }: UpdateUserRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    updateUser({ userId, fullName, role, profileData }: UpdateUserRequest, opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        throwIfNullOrUndefined(userId, 'userId', 'updateUser');

        const query: HttpQuery = {};

        if (fullName != null) { query['full_name'] = fullName; }
        if (role != null) { query['role'] = role; }
        if (profileData != null) { query['profile_data'] = profileData; }

        return this.request<JsonSuccess>({
            url: '/users/{user_id}'.replace('{user_id}', encodeURI(userId)),
            method: 'PATCH',
            query,
        }, opts?.responseOpts);
    };

    /**
     * Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
     * Update a user group
     */
    updateUserGroup({ userGroupId, name, description }: UpdateUserGroupRequest): Observable<JsonSuccess>
    updateUserGroup({ userGroupId, name, description }: UpdateUserGroupRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    updateUserGroup({ userGroupId, name, description }: UpdateUserGroupRequest, opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        throwIfNullOrUndefined(userGroupId, 'userGroupId', 'updateUserGroup');
        throwIfNullOrUndefined(name, 'name', 'updateUserGroup');
        throwIfNullOrUndefined(description, 'description', 'updateUserGroup');

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'name': name,
            'description': description,
        };

        return this.request<JsonSuccess>({
            url: '/user_groups/{user_group_id}'.replace('{user_group_id}', encodeURI(userGroupId)),
            method: 'PATCH',
            query,
        }, opts?.responseOpts);
    };

    /**
     * Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
     * Update user group members
     */
    updateUserGroupMembers({ userGroupId, _delete, add }: UpdateUserGroupMembersRequest): Observable<JsonSuccess>
    updateUserGroupMembers({ userGroupId, _delete, add }: UpdateUserGroupMembersRequest, opts?: OperationOpts): Observable<RawAjaxResponse<JsonSuccess>>
    updateUserGroupMembers({ userGroupId, _delete, add }: UpdateUserGroupMembersRequest, opts?: OperationOpts): Observable<JsonSuccess | RawAjaxResponse<JsonSuccess>> {
        throwIfNullOrUndefined(userGroupId, 'userGroupId', 'updateUserGroupMembers');

        const query: HttpQuery = {};

        if (_delete != null) { query['delete'] = _delete; }
        if (add != null) { query['add'] = add; }

        return this.request<JsonSuccess>({
            url: '/user_groups/{user_group_id}/members'.replace('{user_group_id}', encodeURI(userGroupId)),
            method: 'POST',
            query,
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum SetTypingStatusOpEnum {
    Start = 'start',
    Stop = 'stop'
}
/**
 * @export
 * @enum {string}
 */
export enum SetTypingStatusTypeEnum {
    Private = 'private',
    Stream = 'stream'
}
/**
 * @export
 * @enum {string}
 */
export enum UpdateDisplaySettingsColorSchemeEnum {
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3
}
/**
 * @export
 * @enum {string}
 */
export enum UpdateDisplaySettingsDemoteInactiveStreamsEnum {
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3
}
/**
 * @export
 * @enum {string}
 */
export enum UpdateNotificationSettingsDesktopIconCountDisplayEnum {
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3
}
