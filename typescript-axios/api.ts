/* tslint:disable */
/* eslint-disable */
/**
 * Zulip REST API
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddSubscriptionsResponse
 */
export interface AddSubscriptionsResponse {
    /**
     * 
     * @type {any}
     * @memberof AddSubscriptionsResponse
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof AddSubscriptionsResponse
     */
    msg: any | null;
    /**
     * A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that were subscribed to as a result of the query. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AddSubscriptionsResponse
     */
    subscribed?: { [key: string]: Array<string>; };
    /**
     * A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that the user/bot is already subscribed to. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AddSubscriptionsResponse
     */
    already_subscribed?: { [key: string]: Array<string>; };
    /**
     * A list of names of streams that the requesting user/bot was not authorized to subscribe to.  Only present if `authorization_errors_fatal=false`. 
     * @type {Array<string>}
     * @memberof AddSubscriptionsResponse
     */
    unauthorized?: Array<string>;
}
/**
 * 
 * @export
 * @interface AddSubscriptionsResponseAllOf
 */
export interface AddSubscriptionsResponseAllOf {
    /**
     * 
     * @type {any}
     * @memberof AddSubscriptionsResponseAllOf
     */
    result?: any | null;
    /**
     * 
     * @type {any}
     * @memberof AddSubscriptionsResponseAllOf
     */
    msg?: any | null;
    /**
     * A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that were subscribed to as a result of the query. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AddSubscriptionsResponseAllOf
     */
    subscribed?: { [key: string]: Array<string>; };
    /**
     * A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that the user/bot is already subscribed to. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AddSubscriptionsResponseAllOf
     */
    already_subscribed?: { [key: string]: Array<string>; };
    /**
     * A list of names of streams that the requesting user/bot was not authorized to subscribe to.  Only present if `authorization_errors_fatal=false`. 
     * @type {Array<string>}
     * @memberof AddSubscriptionsResponseAllOf
     */
    unauthorized?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiKeyResponse
 */
export interface ApiKeyResponse {
    /**
     * 
     * @type {any}
     * @memberof ApiKeyResponse
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof ApiKeyResponse
     */
    msg: any | null;
    /**
     * The API key that can be used to authenticate as the requested user. 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    api_key: string;
    /**
     * The email address of the user who owns the API key 
     * @type {string}
     * @memberof ApiKeyResponse
     */
    email: string;
}
/**
 * 
 * @export
 * @interface ApiKeyResponseAllOf
 */
export interface ApiKeyResponseAllOf {
    /**
     * 
     * @type {any}
     * @memberof ApiKeyResponseAllOf
     */
    result?: any | null;
    /**
     * 
     * @type {any}
     * @memberof ApiKeyResponseAllOf
     */
    msg?: any | null;
    /**
     * The API key that can be used to authenticate as the requested user. 
     * @type {string}
     * @memberof ApiKeyResponseAllOf
     */
    api_key: string;
    /**
     * The email address of the user who owns the API key 
     * @type {string}
     * @memberof ApiKeyResponseAllOf
     */
    email: string;
}
/**
 * Dictionary containing details of a file uploaded by a user. 
 * @export
 * @interface Attachments
 */
export interface Attachments {
    /**
     * The unique ID for the attachment. 
     * @type {number}
     * @memberof Attachments
     */
    id?: number;
    /**
     * Name of the uploaded file. 
     * @type {string}
     * @memberof Attachments
     */
    name?: string;
    /**
     * A representation of the path of the file within the repository of user-uploaded files.  If the `path_id` of a file is `{realm_id}/ab/cdef/temp_file.py`, its URL will be: `{server_url}/user_uploads/{realm_id}/ab/cdef/temp_file.py`. 
     * @type {string}
     * @memberof Attachments
     */
    path_id?: string;
    /**
     * Size of the file in bytes. 
     * @type {number}
     * @memberof Attachments
     */
    size?: number;
    /**
     * Time when the attachment was uploaded as a UNIX timestamp multiplied by 1000 (matching the format of getTime() in JavaScript).  **Changes**: Changed in Zulip 2.2 (feature level 22).  This field was previously a floating point number. 
     * @type {number}
     * @memberof Attachments
     */
    create_time?: number;
    /**
     * Contains basic details on any Zulip messages that have been sent referencing this [uploaded file](/api/upload-file). This includes messages sent by any user in the Zulip organization who sent a message containing a link to the uploaded file. 
     * @type {Array<AttachmentsMessages>}
     * @memberof Attachments
     */
    messages?: Array<AttachmentsMessages>;
}
/**
 * 
 * @export
 * @interface AttachmentsMessages
 */
export interface AttachmentsMessages {
    /**
     * Time when the message was sent as a UNIX timestamp multiplied by 1000 (matching the format of getTime() in JavaScript).  **Changes**: Changed in Zulip 2.2 (feature level 22).  This field was previously strangely called `name` and was a floating point number. 
     * @type {number}
     * @memberof AttachmentsMessages
     */
    date_sent?: number;
    /**
     * The unique message ID.  Messages should always be displayed sorted by ID. 
     * @type {number}
     * @memberof AttachmentsMessages
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface BadEventQueueIdError
 */
export interface BadEventQueueIdError {
    /**
     * 
     * @type {any}
     * @memberof BadEventQueueIdError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof BadEventQueueIdError
     */
    msg: any | null;
    /**
     * 
     * @type {any}
     * @memberof BadEventQueueIdError
     */
    code?: any | null;
    /**
     * The string that identifies the invalid event queue. 
     * @type {string}
     * @memberof BadEventQueueIdError
     */
    queue_id?: string;
}
/**
 * 
 * @export
 * @interface BadEventQueueIdErrorAllOf
 */
export interface BadEventQueueIdErrorAllOf {
    /**
     * 
     * @type {any}
     * @memberof BadEventQueueIdErrorAllOf
     */
    result?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BadEventQueueIdErrorAllOf
     */
    msg?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BadEventQueueIdErrorAllOf
     */
    code?: any | null;
    /**
     * The string that identifies the invalid event queue. 
     * @type {string}
     * @memberof BadEventQueueIdErrorAllOf
     */
    queue_id?: string;
}
/**
 * 
 * @export
 * @interface BasicBot
 */
export interface BasicBot {
    /**
     * 
     * @type {any}
     * @memberof BasicBot
     */
    user_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBot
     */
    full_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBot
     */
    api_key?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBot
     */
    default_sending_stream?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBot
     */
    default_events_register_stream?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBot
     */
    default_all_public_streams?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBot
     */
    avatar_url?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBot
     */
    owner_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBot
     */
    services?: any | null;
}
/**
 * 
 * @export
 * @interface BasicBotAllOf
 */
export interface BasicBotAllOf {
    /**
     * 
     * @type {any}
     * @memberof BasicBotAllOf
     */
    user_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBotAllOf
     */
    full_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBotAllOf
     */
    api_key?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBotAllOf
     */
    default_sending_stream?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBotAllOf
     */
    default_events_register_stream?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBotAllOf
     */
    default_all_public_streams?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBotAllOf
     */
    avatar_url?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBotAllOf
     */
    owner_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicBotAllOf
     */
    services?: any | null;
}
/**
 * 
 * @export
 * @interface BasicBotBase
 */
export interface BasicBotBase {
    /**
     * The user id of the bot. 
     * @type {number}
     * @memberof BasicBotBase
     */
    user_id?: number;
    /**
     * The full name of the bot. 
     * @type {string}
     * @memberof BasicBotBase
     */
    full_name?: string;
    /**
     * The API key of the bot which it uses to make API requests. 
     * @type {string}
     * @memberof BasicBotBase
     */
    api_key?: string;
    /**
     * The default sending stream of the bot. Null if the bot doesn\'t have a default sending stream. 
     * @type {string}
     * @memberof BasicBotBase
     */
    default_sending_stream?: string | null;
    /**
     * The default stream for which the bot receives events/register data. Null if the bot doesn\'t have such a default stream. 
     * @type {string}
     * @memberof BasicBotBase
     */
    default_events_register_stream?: string | null;
    /**
     * Whether the bot can send messages to all streams by default. 
     * @type {boolean}
     * @memberof BasicBotBase
     */
    default_all_public_streams?: boolean;
    /**
     * The URL of the bot\'s avatar. 
     * @type {string}
     * @memberof BasicBotBase
     */
    avatar_url?: string;
    /**
     * The user id of the bot\'s owner.  Null if the bot has no owner. 
     * @type {number}
     * @memberof BasicBotBase
     */
    owner_id?: number | null;
    /**
     * The \"Services\" array contains extra configuration fields only relevant for Outgoing webhook bots and Embedded bots.  It is always a single-element array.  We consider this part of the Zulip API to be unstable; it is used only for UI elements for administering bots and is likely to change. 
     * @type {Array<object>}
     * @memberof BasicBotBase
     */
    services?: Array<object>;
}
/**
 * 
 * @export
 * @interface BasicStream
 */
export interface BasicStream {
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    stream_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    description?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    date_created?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    invite_only?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    rendered_description?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    is_web_public?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    stream_post_policy?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    message_retention_days?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    history_public_to_subscribers?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    first_message_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStream
     */
    is_announcement_only?: any | null;
}
/**
 * 
 * @export
 * @interface BasicStreamAllOf
 */
export interface BasicStreamAllOf {
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    stream_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    description?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    date_created?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    invite_only?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    rendered_description?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    is_web_public?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    stream_post_policy?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    message_retention_days?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    history_public_to_subscribers?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    first_message_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BasicStreamAllOf
     */
    is_announcement_only?: any | null;
}
/**
 * Object containing basic details about the stream. 
 * @export
 * @interface BasicStreamBase
 */
export interface BasicStreamBase {
    /**
     * The unique ID of the stream. 
     * @type {number}
     * @memberof BasicStreamBase
     */
    stream_id?: number;
    /**
     * The name of the stream. 
     * @type {string}
     * @memberof BasicStreamBase
     */
    name?: string;
    /**
     * The short description of the stream in text/markdown format, intended to be used to prepopulate UI for editing a stream\'s description. 
     * @type {string}
     * @memberof BasicStreamBase
     */
    description?: string;
    /**
     * The UNIX timestamp for when the stream was created, in UTC seconds.  **Changes**: New in Zulip 4.0 (feature level 30). 
     * @type {number}
     * @memberof BasicStreamBase
     */
    date_created?: number;
    /**
     * Specifies whether the stream is private or not. Only people who have been invited can access a private stream. 
     * @type {boolean}
     * @memberof BasicStreamBase
     */
    invite_only?: boolean;
    /**
     * The short description of the stream rendered as HTML, intended to be used when displaying the stream description in a UI.  One should use the standard Zulip rendered_markdown CSS when displaying this content so that emoji, LaTeX, and other syntax work correctly.  And any client-side security logic for user-generated message content should be applied when displaying this HTML as though it were the body of a Zulip message. 
     * @type {string}
     * @memberof BasicStreamBase
     */
    rendered_description?: string;
    /**
     * Whether the stream has been configured to allow unauthenticated access to its message history from the web. 
     * @type {boolean}
     * @memberof BasicStreamBase
     */
    is_web_public?: boolean;
    /**
     * Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
     * @type {number}
     * @memberof BasicStreamBase
     */
    stream_post_policy?: number;
    /**
     * Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  There are two special values:  * `null`, the default, means the stream will inherit the organization   level setting. * `-1` encodes retaining messages in this stream forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
     * @type {number}
     * @memberof BasicStreamBase
     */
    message_retention_days?: number | null;
    /**
     * Whether the history of the stream is public to its subscribers.  Currently always true for public streams (i.e. invite_only=False implies history_public_to_subscribers=True), but clients should not make that assumption, as we may change that behavior in the future. 
     * @type {boolean}
     * @memberof BasicStreamBase
     */
    history_public_to_subscribers?: boolean;
    /**
     * The id of the first message in the stream.  Intended to help clients determine whether they need to display UI like the \"more topics\" widget that would suggest the stream has older history that can be accessed.  Null is used for streams with no message history. 
     * @type {number}
     * @memberof BasicStreamBase
     */
    first_message_id?: number | null;
    /**
     * Whether the given stream is announcement only or not.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use `stream_post_policy` instead. 
     * @type {boolean}
     * @memberof BasicStreamBase
     * @deprecated
     */
    is_announcement_only?: boolean;
}
/**
 * 
 * @export
 * @interface Bot
 */
export interface Bot {
    /**
     * 
     * @type {any}
     * @memberof Bot
     */
    user_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Bot
     */
    full_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Bot
     */
    api_key?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Bot
     */
    default_sending_stream?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Bot
     */
    default_events_register_stream?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Bot
     */
    default_all_public_streams?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Bot
     */
    avatar_url?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Bot
     */
    owner_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Bot
     */
    services?: any | null;
    /**
     * The email of the bot. 
     * @type {string}
     * @memberof Bot
     */
    email?: string;
    /**
     * An integer describing the type of bot: * `1` for a `Generic` bot. * `2` for an `Incoming webhook` bot. * `3` for an `Outgoing webhook` bot. * `4` for an `Embedded` bot. 
     * @type {number}
     * @memberof Bot
     */
    bot_type?: number | null;
    /**
     * A boolean describing whether the user account has been deactivated. 
     * @type {boolean}
     * @memberof Bot
     */
    is_active?: boolean;
}
/**
 * Object containing details of a bot. 
 * @export
 * @interface BotAllOf
 */
export interface BotAllOf {
    /**
     * 
     * @type {any}
     * @memberof BotAllOf
     */
    user_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BotAllOf
     */
    full_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BotAllOf
     */
    api_key?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BotAllOf
     */
    default_sending_stream?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BotAllOf
     */
    default_events_register_stream?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BotAllOf
     */
    default_all_public_streams?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BotAllOf
     */
    avatar_url?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BotAllOf
     */
    owner_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof BotAllOf
     */
    services?: any | null;
    /**
     * The email of the bot. 
     * @type {string}
     * @memberof BotAllOf
     */
    email?: string;
    /**
     * An integer describing the type of bot: * `1` for a `Generic` bot. * `2` for an `Incoming webhook` bot. * `3` for an `Outgoing webhook` bot. * `4` for an `Embedded` bot. 
     * @type {number}
     * @memberof BotAllOf
     */
    bot_type?: number | null;
    /**
     * A boolean describing whether the user account has been deactivated. 
     * @type {boolean}
     * @memberof BotAllOf
     */
    is_active?: boolean;
}
/**
 * 
 * @export
 * @interface CodedError
 */
export interface CodedError {
    /**
     * 
     * @type {any}
     * @memberof CodedError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof CodedError
     */
    msg: any | null;
    /**
     * 
     * @type {any}
     * @memberof CodedError
     */
    code?: any | null;
}
/**
 * 
 * @export
 * @interface CodedErrorAllOf
 */
export interface CodedErrorAllOf {
    /**
     * 
     * @type {any}
     * @memberof CodedErrorAllOf
     */
    result?: any | null;
    /**
     * 
     * @type {any}
     * @memberof CodedErrorAllOf
     */
    msg?: any | null;
    /**
     * 
     * @type {any}
     * @memberof CodedErrorAllOf
     */
    code?: any | null;
}
/**
 * 
 * @export
 * @interface CodedErrorBase
 */
export interface CodedErrorBase {
    /**
     * 
     * @type {any}
     * @memberof CodedErrorBase
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof CodedErrorBase
     */
    msg: any | null;
    /**
     * A string that identifies the error. 
     * @type {string}
     * @memberof CodedErrorBase
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface CodedErrorBaseAllOf
 */
export interface CodedErrorBaseAllOf {
    /**
     * 
     * @type {any}
     * @memberof CodedErrorBaseAllOf
     */
    result?: any | null;
    /**
     * 
     * @type {any}
     * @memberof CodedErrorBaseAllOf
     */
    msg?: any | null;
    /**
     * A string that identifies the error. 
     * @type {string}
     * @memberof CodedErrorBaseAllOf
     */
    code?: string;
}
/**
 * Dictionary containing the details of a custom profile field configured for this organization. 
 * @export
 * @interface CustomProfileField
 */
export interface CustomProfileField {
    /**
     * The ID of the custom profile field.  This will be referenced in custom the profile fields section of user objects. 
     * @type {number}
     * @memberof CustomProfileField
     */
    id?: number;
    /**
     * An integer indicating the type of the custom profile field, which determines how it is configured and displayed to users.  See the [Add custom profile fields](/help/add-custom-profile-fields) article for details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
     * @type {number}
     * @memberof CustomProfileField
     */
    type?: number;
    /**
     * Custom profile fields are displayed in both settings UI and UI showing users\' profiles in increasing `order`. 
     * @type {number}
     * @memberof CustomProfileField
     */
    order?: number;
    /**
     * The name of the custom profile field. 
     * @type {string}
     * @memberof CustomProfileField
     */
    name?: string;
    /**
     * The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
     * @type {string}
     * @memberof CustomProfileField
     */
    hint?: string;
    /**
     * Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the `field_data` attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
     * @type {string}
     * @memberof CustomProfileField
     */
    field_data?: string;
}
/**
 * Dictionary containing details of a default stream group. 
 * @export
 * @interface DefaultStreamGroup
 */
export interface DefaultStreamGroup {
    /**
     * Name of the default stream group. 
     * @type {string}
     * @memberof DefaultStreamGroup
     */
    name?: string;
    /**
     * Description of the default stream group. 
     * @type {string}
     * @memberof DefaultStreamGroup
     */
    description?: string;
    /**
     * id of the default stream group. 
     * @type {number}
     * @memberof DefaultStreamGroup
     */
    id?: number;
    /**
     * Array containing details about the streams in the default stream group. 
     * @type {Array<BasicStream>}
     * @memberof DefaultStreamGroup
     */
    streams?: Array<BasicStream>;
}
/**
 * A dictionary for representing a message draft. 
 * @export
 * @interface Draft
 */
export interface Draft {
    /**
     * The unique ID of the draft. It will only used whenever the drafts are fetched. This field should not be specified when the draft is being created or edited. 
     * @type {number}
     * @memberof Draft
     */
    id?: number;
    /**
     * The type of the draft. Either unaddressed (empty string), \"stream\", or \"private\" (for PMs and private group messages). 
     * @type {string}
     * @memberof Draft
     */
    type: DraftTypeEnum;
    /**
     * An array of the tentative target audience IDs. For \"stream\" messages, this should contain exactly 1 ID, the ID of the target stream. For private messages, this should be an array of target user IDs. For unaddressed drafts, this is ignored, and clients should send an empty array. 
     * @type {Array<number>}
     * @memberof Draft
     */
    to: Array<number>;
    /**
     * For stream message drafts, the tentative topic name. For private or unaddressed messages, this will be ignored and should ideally be the empty string. Should not contain null bytes. 
     * @type {string}
     * @memberof Draft
     */
    topic: string;
    /**
     * The body of the draft. Should not contain null bytes. 
     * @type {string}
     * @memberof Draft
     */
    content: string;
    /**
     * A Unix timestamp (seconds only) representing when the draft was last edited. When creating a draft, this key need not be present and it will be filled in automatically by the server. 
     * @type {number}
     * @memberof Draft
     */
    timestamp?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum DraftTypeEnum {
    Empty = '',
    Stream = 'stream',
    Private = 'private'
}

/**
 * 
 * @export
 * @interface EmojiBase
 */
export interface EmojiBase {
    /**
     * A unique identifier, defining the specific emoji codepoint requested, within the namespace of the `reaction_type`.  For example, for `unicode_emoji`, this will be an encoding of the Unicode codepoint; for `realm_emoji`, it\'ll be the ID of the realm emoji. 
     * @type {string}
     * @memberof EmojiBase
     */
    emoji_code?: string;
    /**
     * Name of the emoji. 
     * @type {string}
     * @memberof EmojiBase
     */
    emoji_name?: string;
    /**
     * One of the following values:  * `unicode_emoji`: Unicode emoji (`emoji_code` will be its Unicode   codepoint). * `realm_emoji`: [Custom emoji](/help/add-custom-emoji).   (`emoji_code` will be its ID). * `zulip_extra_emoji`: Special emoji included with Zulip.  Exists to   namespace the `zulip` emoji. 
     * @type {string}
     * @memberof EmojiBase
     */
    reaction_type?: string;
}
/**
 * 
 * @export
 * @interface EmojiReaction
 */
export interface EmojiReaction {
    /**
     * 
     * @type {any}
     * @memberof EmojiReaction
     */
    emoji_code?: any | null;
    /**
     * 
     * @type {any}
     * @memberof EmojiReaction
     */
    emoji_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof EmojiReaction
     */
    reaction_type?: any | null;
    /**
     * 
     * @type {any}
     * @memberof EmojiReaction
     */
    user_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof EmojiReaction
     */
    user?: any | null;
}
/**
 * 
 * @export
 * @interface EmojiReactionAllOf
 */
export interface EmojiReactionAllOf {
    /**
     * 
     * @type {any}
     * @memberof EmojiReactionAllOf
     */
    emoji_code?: any | null;
    /**
     * 
     * @type {any}
     * @memberof EmojiReactionAllOf
     */
    emoji_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof EmojiReactionAllOf
     */
    reaction_type?: any | null;
    /**
     * 
     * @type {any}
     * @memberof EmojiReactionAllOf
     */
    user_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof EmojiReactionAllOf
     */
    user?: any | null;
}
/**
 * 
 * @export
 * @interface EmojiReactionBase
 */
export interface EmojiReactionBase {
    /**
     * A unique identifier, defining the specific emoji codepoint requested, within the namespace of the `reaction_type`.  For example, for `unicode_emoji`, this will be an encoding of the Unicode codepoint; for `realm_emoji`, it\'ll be the ID of the realm emoji. 
     * @type {string}
     * @memberof EmojiReactionBase
     */
    emoji_code?: string;
    /**
     * Name of the emoji. 
     * @type {string}
     * @memberof EmojiReactionBase
     */
    emoji_name?: string;
    /**
     * One of the following values:  * `unicode_emoji`: Unicode emoji (`emoji_code` will be its Unicode   codepoint). * `realm_emoji`: [Custom emoji](/help/add-custom-emoji).   (`emoji_code` will be its ID). * `zulip_extra_emoji`: Special emoji included with Zulip.  Exists to   namespace the `zulip` emoji. 
     * @type {string}
     * @memberof EmojiReactionBase
     */
    reaction_type?: string;
    /**
     * The ID of the user who added the reaction.  **Changes**: New in Zulip 3.0 (feature level 2). The `user` object is deprecated and will be removed in the future. 
     * @type {number}
     * @memberof EmojiReactionBase
     */
    user_id?: number;
    /**
     * 
     * @type {EmojiReactionBaseAllOfUser}
     * @memberof EmojiReactionBase
     * @deprecated
     */
    user?: EmojiReactionBaseAllOfUser;
}
/**
 * 
 * @export
 * @interface EmojiReactionBaseAllOf
 */
export interface EmojiReactionBaseAllOf {
    /**
     * The ID of the user who added the reaction.  **Changes**: New in Zulip 3.0 (feature level 2). The `user` object is deprecated and will be removed in the future. 
     * @type {number}
     * @memberof EmojiReactionBaseAllOf
     */
    user_id?: number;
    /**
     * 
     * @type {EmojiReactionBaseAllOfUser}
     * @memberof EmojiReactionBaseAllOf
     * @deprecated
     */
    user?: EmojiReactionBaseAllOfUser;
}
/**
 * Whether the user is a mirror dummy. Dictionary with data on the user who added the reaction, including the user ID as the `id` field.  **Note**: In the [events API](/api/get-events), this `user` dictionary confusing had the user ID in a field called `user_id` instead.  We recommend ignoring fields other than the user ID.  **Deprecated** and to be removed in a future release once core clients have migrated to use the `user_id` field. 
 * @export
 * @interface EmojiReactionBaseAllOfUser
 */
export interface EmojiReactionBaseAllOfUser {
    /**
     * ID of the user. 
     * @type {number}
     * @memberof EmojiReactionBaseAllOfUser
     */
    id?: number;
    /**
     * Email of the user. 
     * @type {string}
     * @memberof EmojiReactionBaseAllOfUser
     */
    email?: string;
    /**
     * Full name of the user. 
     * @type {string}
     * @memberof EmojiReactionBaseAllOfUser
     */
    full_name?: string;
    /**
     * Whether the user is a mirror dummy. 
     * @type {boolean}
     * @memberof EmojiReactionBaseAllOfUser
     */
    is_mirror_dummy?: boolean;
}
/**
 * 
 * @export
 * @interface GetMessages
 */
export interface GetMessages {
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    avatar_url?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    client?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    content?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    content_type?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    display_recipient?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    is_me_message?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    reactions?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    recipient_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    sender_email?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    sender_full_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    sender_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    sender_realm_str?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    stream_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    subject?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    topic_links?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    submessages?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    timestamp?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessages
     */
    type?: any | null;
    /**
     * The user\'s [message flags][message-flags] for the message.  [message-flags]: /api/update-message-flags#available-flags 
     * @type {Array<string>}
     * @memberof GetMessages
     */
    flags?: Array<string>;
    /**
     * The UNIX timestamp for when the message was last edited, in UTC seconds. 
     * @type {number}
     * @memberof GetMessages
     */
    last_edit_timestamp?: number;
    /**
     * Only present if keyword search was included among the narrow parameters. HTML content of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords. 
     * @type {string}
     * @memberof GetMessages
     */
    match_content?: string;
    /**
     * Only present if keyword search was included among the narrow parameters. HTML-escaped topic of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords. 
     * @type {string}
     * @memberof GetMessages
     */
    match_subject?: string;
}
/**
 * 
 * @export
 * @interface GetMessagesAllOf
 */
export interface GetMessagesAllOf {
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    avatar_url?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    client?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    content?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    content_type?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    display_recipient?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    is_me_message?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    reactions?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    recipient_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    sender_email?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    sender_full_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    sender_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    sender_realm_str?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    stream_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    subject?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    topic_links?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    submessages?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    timestamp?: any | null;
    /**
     * 
     * @type {any}
     * @memberof GetMessagesAllOf
     */
    type?: any | null;
    /**
     * The user\'s [message flags][message-flags] for the message.  [message-flags]: /api/update-message-flags#available-flags 
     * @type {Array<string>}
     * @memberof GetMessagesAllOf
     */
    flags?: Array<string>;
    /**
     * The UNIX timestamp for when the message was last edited, in UTC seconds. 
     * @type {number}
     * @memberof GetMessagesAllOf
     */
    last_edit_timestamp?: number;
    /**
     * Only present if keyword search was included among the narrow parameters. HTML content of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords. 
     * @type {string}
     * @memberof GetMessagesAllOf
     */
    match_content?: string;
    /**
     * Only present if keyword search was included among the narrow parameters. HTML-escaped topic of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords. 
     * @type {string}
     * @memberof GetMessagesAllOf
     */
    match_subject?: string;
}
/**
 * Dictionary containing details of a single hotspot. 
 * @export
 * @interface Hotspot
 */
export interface Hotspot {
    /**
     * The delay after which the user should be shown the hotspot. 
     * @type {number}
     * @memberof Hotspot
     */
    delay?: number;
    /**
     * The name of the hotspot. 
     * @type {string}
     * @memberof Hotspot
     */
    name?: string;
    /**
     * The title of the hotspot, as will be displayed to the user. 
     * @type {string}
     * @memberof Hotspot
     */
    title?: string;
    /**
     * The description of the hotspot, as will be displayed to the user. 
     * @type {string}
     * @memberof Hotspot
     */
    description?: string;
}
/**
 * This is an example of the JSON payload that the Zulip server will `POST` to your server 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Email of the bot user. 
     * @type {string}
     * @memberof InlineResponse200
     */
    bot_email?: string;
    /**
     * The full name of the bot user. 
     * @type {string}
     * @memberof InlineResponse200
     */
    bot_full_name?: string;
    /**
     * The message content, in raw Markdown format (not rendered to HTML). 
     * @type {string}
     * @memberof InlineResponse200
     */
    data?: string;
    /**
     * What aspect of the message triggered the outgoing webhook notification. Possible values include `private_message` and `mention`. 
     * @type {string}
     * @memberof InlineResponse200
     */
    trigger?: string;
    /**
     * A string of alphanumeric characters that can be used to authenticate the webhook request (each bot user uses a fixed token). You can get the token used by a given outgoing webhook bot in the `zuliprc` file downloaded when creating the bot. 
     * @type {string}
     * @memberof InlineResponse200
     */
    token?: string;
    /**
     * A dict containing details on the message that triggered the outgoing webhook, in the format used by [`GET /messages`](/api/get-messages). 
     * @type {MessagesBase & object}
     * @memberof InlineResponse200
     */
    message?: MessagesBase & object;
}
/**
 * 
 * @export
 * @interface InvalidApiKeyError
 */
export interface InvalidApiKeyError {
    /**
     * 
     * @type {any}
     * @memberof InvalidApiKeyError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof InvalidApiKeyError
     */
    msg: any | null;
}
/**
 * 
 * @export
 * @interface InvalidMessageError
 */
export interface InvalidMessageError {
    /**
     * 
     * @type {any}
     * @memberof InvalidMessageError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof InvalidMessageError
     */
    msg: any | null;
    /**
     * The raw content of the message. 
     * @type {string}
     * @memberof InvalidMessageError
     */
    raw_content?: string;
}
/**
 * 
 * @export
 * @interface InvalidMessageErrorAllOf
 */
export interface InvalidMessageErrorAllOf {
    /**
     * 
     * @type {any}
     * @memberof InvalidMessageErrorAllOf
     */
    result?: any | null;
    /**
     * 
     * @type {any}
     * @memberof InvalidMessageErrorAllOf
     */
    msg?: any | null;
    /**
     * The raw content of the message. 
     * @type {string}
     * @memberof InvalidMessageErrorAllOf
     */
    raw_content?: string;
}
/**
 * 
 * @export
 * @interface JsonError
 */
export interface JsonError {
    /**
     * 
     * @type {any}
     * @memberof JsonError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof JsonError
     */
    msg: any | null;
}
/**
 * 
 * @export
 * @interface JsonErrorBase
 */
export interface JsonErrorBase {
    /**
     * 
     * @type {string}
     * @memberof JsonErrorBase
     */
    result: JsonErrorBaseResultEnum;
    /**
     * 
     * @type {string}
     * @memberof JsonErrorBase
     */
    msg: string;
}

/**
    * @export
    * @enum {string}
    */
export enum JsonErrorBaseResultEnum {
    Error = 'error'
}

/**
 * 
 * @export
 * @interface JsonErrorBaseAllOf
 */
export interface JsonErrorBaseAllOf {
    /**
     * 
     * @type {string}
     * @memberof JsonErrorBaseAllOf
     */
    result: JsonErrorBaseAllOfResultEnum;
    /**
     * 
     * @type {string}
     * @memberof JsonErrorBaseAllOf
     */
    msg: string;
}

/**
    * @export
    * @enum {string}
    */
export enum JsonErrorBaseAllOfResultEnum {
    Error = 'error'
}

/**
 * 
 * @export
 * @interface JsonResponseBase
 */
export interface JsonResponseBase {
    /**
     * 
     * @type {string}
     * @memberof JsonResponseBase
     */
    result?: string;
}
/**
 * 
 * @export
 * @interface JsonSuccess
 */
export interface JsonSuccess {
    /**
     * 
     * @type {any}
     * @memberof JsonSuccess
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof JsonSuccess
     */
    msg: any | null;
}
/**
 * 
 * @export
 * @interface JsonSuccessAllOf
 */
export interface JsonSuccessAllOf {
    /**
     * 
     * @type {any}
     * @memberof JsonSuccessAllOf
     */
    result?: any | null;
    /**
     * 
     * @type {any}
     * @memberof JsonSuccessAllOf
     */
    msg?: any | null;
}
/**
 * 
 * @export
 * @interface JsonSuccessBase
 */
export interface JsonSuccessBase {
    /**
     * 
     * @type {string}
     * @memberof JsonSuccessBase
     */
    result: JsonSuccessBaseResultEnum;
    /**
     * 
     * @type {string}
     * @memberof JsonSuccessBase
     */
    msg: string;
}

/**
    * @export
    * @enum {string}
    */
export enum JsonSuccessBaseResultEnum {
    Success = 'success'
}

/**
 * 
 * @export
 * @interface JsonSuccessBaseAllOf
 */
export interface JsonSuccessBaseAllOf {
    /**
     * 
     * @type {string}
     * @memberof JsonSuccessBaseAllOf
     */
    result: JsonSuccessBaseAllOfResultEnum;
    /**
     * 
     * @type {string}
     * @memberof JsonSuccessBaseAllOf
     */
    msg: string;
}

/**
    * @export
    * @enum {string}
    */
export enum JsonSuccessBaseAllOfResultEnum {
    Success = 'success'
}

/**
 * 
 * @export
 * @interface Messages
 */
export interface Messages {
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    avatar_url?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    client?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    content?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    content_type?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    display_recipient?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    is_me_message?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    reactions?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    recipient_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    sender_email?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    sender_full_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    sender_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    sender_realm_str?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    stream_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    subject?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    topic_links?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    submessages?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    timestamp?: any | null;
    /**
     * 
     * @type {any}
     * @memberof Messages
     */
    type?: any | null;
}
/**
 * 
 * @export
 * @interface MessagesAllOf
 */
export interface MessagesAllOf {
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    avatar_url?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    client?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    content?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    content_type?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    display_recipient?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    is_me_message?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    reactions?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    recipient_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    sender_email?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    sender_full_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    sender_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    sender_realm_str?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    stream_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    subject?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    topic_links?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    submessages?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    timestamp?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MessagesAllOf
     */
    type?: any | null;
}
/**
 * Object containing details of the message. 
 * @export
 * @interface MessagesBase
 */
export interface MessagesBase {
    /**
     * The URL of the user\'s avatar.  Can be null only if client_gravatar was passed, which means that the user has not uploaded an avatar in Zulip, and the client should compute the gravatar URL by hashing the user\'s email address itself for this user. 
     * @type {string}
     * @memberof MessagesBase
     */
    avatar_url?: string | null;
    /**
     * A Zulip \"client\" string, describing what Zulip client sent the message. 
     * @type {string}
     * @memberof MessagesBase
     */
    client?: string;
    /**
     * The content/body of the message. 
     * @type {string}
     * @memberof MessagesBase
     */
    content?: string;
    /**
     * The HTTP `content_type` for the message content.  This will be `text/html` or `text/x-markdown`, depending on whether `apply_markdown` was set. 
     * @type {string}
     * @memberof MessagesBase
     */
    content_type?: string;
    /**
     * Data on the recipient of the message; either the name of a stream or a dictionary containing basic data on the users who received the message. 
     * @type {string | Array<object>}
     * @memberof MessagesBase
     */
    display_recipient?: string | Array<object>;
    /**
     * The unique message ID.  Messages should always be displayed sorted by ID. 
     * @type {number}
     * @memberof MessagesBase
     */
    id?: number;
    /**
     * Whether the message is a [/me status message][status-messages]  [status-messages]: /help/format-your-message-using-markdown#status-messages 
     * @type {boolean}
     * @memberof MessagesBase
     */
    is_me_message?: boolean;
    /**
     * Data on any reactions to the message. 
     * @type {Array<EmojiReaction>}
     * @memberof MessagesBase
     */
    reactions?: Array<EmojiReaction>;
    /**
     * A unique ID for the set of users receiving the message (either a stream or group of users).  Useful primarily for hashing. 
     * @type {number}
     * @memberof MessagesBase
     */
    recipient_id?: number;
    /**
     * The Zulip display email address of the message\'s sender. 
     * @type {string}
     * @memberof MessagesBase
     */
    sender_email?: string;
    /**
     * The full name of the message\'s sender. 
     * @type {string}
     * @memberof MessagesBase
     */
    sender_full_name?: string;
    /**
     * The user ID of the message\'s sender. 
     * @type {number}
     * @memberof MessagesBase
     */
    sender_id?: number;
    /**
     * A string identifier for the realm the sender is in.  Unique only within the context of a given Zulip server.  E.g. on `example.zulip.com`, this will be `example`. 
     * @type {string}
     * @memberof MessagesBase
     */
    sender_realm_str?: string;
    /**
     * Only present for stream messages; the ID of the stream. 
     * @type {number}
     * @memberof MessagesBase
     */
    stream_id?: number;
    /**
     * The `topic` of the message.  Currently always `\"\"` for private messages, though this could change if Zulip adds support for topics in private message conversations.  The field name is a legacy holdover from when topics were called \"subjects\" and will eventually change. 
     * @type {string}
     * @memberof MessagesBase
     */
    subject?: string;
    /**
     * Data on any links to be included in the `topic` line (these are generated by [custom linkification filters](/help/add-a-custom-linkifier) that match content in the message\'s topic.)  **Changes**: This field contained a list of urls before   Zulip 4.0 (feature level 46).  New in Zulip 3.0 (feature level 1): Previously, this field was called `subject_links`; clients are recommended to rename `subject_links` to `topic_links` if present for compatibility with older Zulip servers. 
     * @type {Array<MessagesBaseTopicLinks>}
     * @memberof MessagesBase
     */
    topic_links?: Array<MessagesBaseTopicLinks>;
    /**
     * Data used for certain experimental Zulip integrations. 
     * @type {Array<string>}
     * @memberof MessagesBase
     */
    submessages?: Array<string>;
    /**
     * The UNIX timestamp for when the message was sent, in UTC seconds. 
     * @type {number}
     * @memberof MessagesBase
     */
    timestamp?: number;
    /**
     * The type of the message: `stream` or `private`. 
     * @type {string}
     * @memberof MessagesBase
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface MessagesBaseTopicLinks
 */
export interface MessagesBaseTopicLinks {
    /**
     * The original link text present in the topic. 
     * @type {string}
     * @memberof MessagesBaseTopicLinks
     */
    text?: string;
    /**
     * The expanded target url which the link points to. 
     * @type {string}
     * @memberof MessagesBaseTopicLinks
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface MissingArgumentError
 */
export interface MissingArgumentError {
    /**
     * 
     * @type {any}
     * @memberof MissingArgumentError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof MissingArgumentError
     */
    msg: any | null;
    /**
     * 
     * @type {any}
     * @memberof MissingArgumentError
     */
    code?: any | null;
    /**
     * It contains the information about the missing parameter. 
     * @type {string}
     * @memberof MissingArgumentError
     */
    var_name?: string;
}
/**
 * ## Missing request parameter(s)  A typical failed JSON response for when a required request parameter is not supplied 
 * @export
 * @interface MissingArgumentErrorAllOf
 */
export interface MissingArgumentErrorAllOf {
    /**
     * 
     * @type {any}
     * @memberof MissingArgumentErrorAllOf
     */
    result?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MissingArgumentErrorAllOf
     */
    msg?: any | null;
    /**
     * 
     * @type {any}
     * @memberof MissingArgumentErrorAllOf
     */
    code?: any | null;
    /**
     * It contains the information about the missing parameter. 
     * @type {string}
     * @memberof MissingArgumentErrorAllOf
     */
    var_name?: string;
}
/**
 * 
 * @export
 * @interface NonExistingStreamError
 */
export interface NonExistingStreamError {
    /**
     * 
     * @type {any}
     * @memberof NonExistingStreamError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof NonExistingStreamError
     */
    msg: any | null;
    /**
     * 
     * @type {any}
     * @memberof NonExistingStreamError
     */
    code?: any | null;
    /**
     * The name of the stream that could not be found. 
     * @type {string}
     * @memberof NonExistingStreamError
     */
    stream?: string;
}
/**
 * 
 * @export
 * @interface NonExistingStreamErrorAllOf
 */
export interface NonExistingStreamErrorAllOf {
    /**
     * 
     * @type {any}
     * @memberof NonExistingStreamErrorAllOf
     */
    result?: any | null;
    /**
     * 
     * @type {any}
     * @memberof NonExistingStreamErrorAllOf
     */
    msg?: any | null;
    /**
     * 
     * @type {any}
     * @memberof NonExistingStreamErrorAllOf
     */
    code?: any | null;
    /**
     * The name of the stream that could not be found. 
     * @type {string}
     * @memberof NonExistingStreamErrorAllOf
     */
    stream?: string;
}
/**
 * `{client_name}`: Object containing the details of the user\'s presence on a particular platform with the client\'s platform name being the object key. 
 * @export
 * @interface Presence
 */
export interface Presence {
    /**
     * The client\'s platform name. 
     * @type {string}
     * @memberof Presence
     */
    client?: string;
    /**
     * The status of the user on this client. It is either `idle` or `active`. 
     * @type {string}
     * @memberof Presence
     */
    status?: PresenceStatusEnum;
    /**
     * The UNIX timestamp of when this client sent the user\'s presence to the server with the precision of a second. 
     * @type {number}
     * @memberof Presence
     */
    timestamp?: number;
    /**
     * Whether the client is capable of showing mobile/push notifications to the user. 
     * @type {boolean}
     * @memberof Presence
     */
    pushable?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum PresenceStatusEnum {
    Idle = 'idle',
    Active = 'active'
}

/**
 * 
 * @export
 * @interface RateLimitedError
 */
export interface RateLimitedError {
    /**
     * 
     * @type {any}
     * @memberof RateLimitedError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof RateLimitedError
     */
    msg: any | null;
    /**
     * 
     * @type {any}
     * @memberof RateLimitedError
     */
    code?: any | null;
}
/**
 * 
 * @export
 * @interface RealmDeactivatedError
 */
export interface RealmDeactivatedError {
    /**
     * 
     * @type {any}
     * @memberof RealmDeactivatedError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof RealmDeactivatedError
     */
    msg: any | null;
    /**
     * 
     * @type {any}
     * @memberof RealmDeactivatedError
     */
    code?: any | null;
}
/**
 * Object containing details of the newly added domain. 
 * @export
 * @interface RealmDomain
 */
export interface RealmDomain {
    /**
     * The new allowed domain. 
     * @type {string}
     * @memberof RealmDomain
     */
    domain?: string;
    /**
     * Whether subdomains are allowed for this domain. 
     * @type {boolean}
     * @memberof RealmDomain
     */
    allow_subdomains?: boolean;
}
/**
 * `{emoji_id}`: Object containing details about the emoji with  the specified ID. It has the following properties: 
 * @export
 * @interface RealmEmoji
 */
export interface RealmEmoji {
    /**
     * The ID for this emoji, same as the object\'s key. 
     * @type {string}
     * @memberof RealmEmoji
     */
    id?: string;
    /**
     * The user-friendly name for this emoji. Users in the organization can use this emoji by writing this name between colons (`:name  :`). 
     * @type {string}
     * @memberof RealmEmoji
     */
    name?: string;
    /**
     * The path relative to the organization\'s URL where the emoji\'s image can be found. 
     * @type {string}
     * @memberof RealmEmoji
     */
    source_url?: string;
    /**
     * Whether the emoji has been deactivated or not. 
     * @type {boolean}
     * @memberof RealmEmoji
     */
    deactivated?: boolean;
    /**
     * The user ID of the user who uploaded the custom emoji. Will be null if the uploader is unknown.  **Changes**: New in Zulip 3.0 (feature level 7).  Previously was accessible via and `author` object with an `id` field. 
     * @type {number}
     * @memberof RealmEmoji
     */
    author_id?: number | null;
}
/**
 * Object containing details about a realm export. 
 * @export
 * @interface RealmExport
 */
export interface RealmExport {
    /**
     * The id of the export. 
     * @type {number}
     * @memberof RealmExport
     */
    id?: number;
    /**
     * The id of the user who did the export. 
     * @type {number}
     * @memberof RealmExport
     */
    acting_user_id?: number;
    /**
     * The UNIX timestamp of when the export was made. 
     * @type {number}
     * @memberof RealmExport
     */
    export_time?: number;
    /**
     * The timestamp of when the export was deleted. Null if it wasn\'t. 
     * @type {number}
     * @memberof RealmExport
     */
    deleted_timestamp?: number | null;
    /**
     * The timestamp of when the export failed. Null if it didn\'t. 
     * @type {number}
     * @memberof RealmExport
     */
    failed_timestamp?: number | null;
    /**
     * The URL of the export. `null` if there\'s no URL. 
     * @type {string}
     * @memberof RealmExport
     */
    export_url?: string | null;
    /**
     * Whether the export is pending or not. 
     * @type {boolean}
     * @memberof RealmExport
     */
    pending?: boolean;
}
/**
 * Object containing details about a realm playground. 
 * @export
 * @interface RealmPlayground
 */
export interface RealmPlayground {
    /**
     * The unique ID for the realm playground. 
     * @type {number}
     * @memberof RealmPlayground
     */
    id?: number;
    /**
     * The user-visible display name of the playground.  Clients should display this in UI for picking which playground to open a code block in, to differentiate between multiple configured playground options for a given pygments language.  **Changes**: New in Zulip 4.0 (feature level 49). 
     * @type {string}
     * @memberof RealmPlayground
     */
    name?: string;
    /**
     * The name of the Pygments language lexer for that programming language. 
     * @type {string}
     * @memberof RealmPlayground
     */
    pygments_language?: string;
    /**
     * The url prefix for the playground. 
     * @type {string}
     * @memberof RealmPlayground
     */
    url_prefix?: string;
}
/**
 * 
 * @export
 * @interface Subscriptions
 */
export interface Subscriptions {
    /**
     * The unique ID of a stream. 
     * @type {number}
     * @memberof Subscriptions
     */
    stream_id?: number;
    /**
     * The name of a stream. 
     * @type {string}
     * @memberof Subscriptions
     */
    name?: string;
    /**
     * The short description of a stream in text/markdown format, intended to be used to prepopulate UI for editing a stream\'s description. 
     * @type {string}
     * @memberof Subscriptions
     */
    description?: string;
    /**
     * A short description of a stream rendered as HTML, intended to be used when displaying the stream description in a UI.  One should use the standard Zulip rendered_markdown CSS when displaying this content so that emoji, LaTeX, and other syntax work correctly.  And any client-side security logic for user-generated message content should be applied when displaying this HTML as though it were the body of a Zulip message. 
     * @type {string}
     * @memberof Subscriptions
     */
    rendered_description?: string;
    /**
     * The UNIX timestamp for when the stream was created, in UTC seconds.  **Changes**: New in Zulip 4.0 (feature level 30). 
     * @type {number}
     * @memberof Subscriptions
     */
    date_created?: number;
    /**
     * Specifies whether the stream is private or not. Only people who have been invited can access a private stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    invite_only?: boolean;
    /**
     * A list of user IDs of users who are also subscribed to a given stream. Included only if `include_subscribers` is `true`. 
     * @type {Array<number>}
     * @memberof Subscriptions
     */
    subscribers?: Array<number>;
    /**
     * A boolean specifying whether desktop notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_desktop_notifications, for this stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    desktop_notifications?: boolean | null;
    /**
     * A boolean specifying whether email notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_email_notifications, for this stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    email_notifications?: boolean | null;
    /**
     * A boolean specifying whether wildcard mentions trigger notifications as though they were personal mentions in this stream.  A null value means the value of this setting should be inherited from the user-level default setting, wildcard_mentions_notify, for this stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    wildcard_mentions_notify?: boolean | null;
    /**
     * A boolean specifying whether push notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_push_notifications, for this stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    push_notifications?: boolean | null;
    /**
     * A boolean specifying whether audible notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_audible_notifications, for this stream. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    audible_notifications?: boolean | null;
    /**
     * A boolean specifying whether the given stream has been pinned to the top. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    pin_to_top?: boolean;
    /**
     * Email address of the given stream, used for [sending emails to the stream](/help/message-a-stream-by-email). 
     * @type {string}
     * @memberof Subscriptions
     */
    email_address?: string;
    /**
     * Whether the user has muted the stream. Muted streams do not count towards your total unread count and do not show up in `All messages` view (previously known as `Home` view).  **Changes**: Prior to Zulip 2.1, this feature was represented by the more confusingly named `in_home_view` (with the opposite value, `in_home_view=!is_muted`). 
     * @type {boolean}
     * @memberof Subscriptions
     */
    is_muted?: boolean;
    /**
     * Legacy property for if the given stream is muted, with inverted meeting.  **Deprecated**; clients should use is_muted where available. 
     * @type {boolean}
     * @memberof Subscriptions
     * @deprecated
     */
    in_home_view?: boolean;
    /**
     * Whether only organization administrators can post to the stream.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use `stream_post_policy` instead. 
     * @type {boolean}
     * @memberof Subscriptions
     * @deprecated
     */
    is_announcement_only?: boolean;
    /**
     * Whether the stream has been configured to allow unauthenticated access to its message history from the web. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    is_web_public?: boolean;
    /**
     * The user\'s role within the stream (distinct from the user\'s [organization-level role](/help/roles-and-permissions)). Valid values are:  * 20 => Stream administrator. * 50 => Subscriber.  **Changes**: New in Zulip 4.0 (feature level 31). 
     * @type {number}
     * @memberof Subscriptions
     */
    role?: SubscriptionsRoleEnum;
    /**
     * The user\'s personal color for the stream. 
     * @type {string}
     * @memberof Subscriptions
     */
    color?: string;
    /**
     * Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
     * @type {number}
     * @memberof Subscriptions
     */
    stream_post_policy?: number;
    /**
     * Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  There are two special values:  * `null`, the default, means the stream will inherit the organization   level setting. * `-1` encodes retaining messages in this stream forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
     * @type {number}
     * @memberof Subscriptions
     */
    message_retention_days?: number | null;
    /**
     * Whether the history of the stream is public to its subscribers.  Currently always true for public streams (i.e. invite_only=False implies history_public_to_subscribers=True), but clients should not make that assumption, as we may change that behavior in the future. 
     * @type {boolean}
     * @memberof Subscriptions
     */
    history_public_to_subscribers?: boolean;
    /**
     * The id of the first message in the stream.  Intended to help clients determine whether they need to display UI like the \"more topics\" widget that would suggest the stream has older history that can be accessed.  Null is used for streams with no message history. 
     * @type {number}
     * @memberof Subscriptions
     */
    first_message_id?: number | null;
    /**
     * The average number of messages sent to the stream in recent weeks, rounded to the nearest integer.  Null means the stream was recently created and there is insufficient data to estimate the average traffic. 
     * @type {number}
     * @memberof Subscriptions
     */
    stream_weekly_traffic?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum SubscriptionsRoleEnum {
    NUMBER_20 = 20,
    NUMBER_50 = 50
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {any}
     * @memberof User
     */
    email?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    is_bot?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    avatar_url?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    avatar_version?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    full_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    is_admin?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    is_owner?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    is_billing_admin?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    role?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    bot_type?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    user_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    bot_owner_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    is_active?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    is_guest?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    timezone?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    date_joined?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    delivery_email?: any | null;
    /**
     * 
     * @type {any}
     * @memberof User
     */
    profile_data?: any | null;
}
/**
 * 
 * @export
 * @interface UserAllOf
 */
export interface UserAllOf {
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    email?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    is_bot?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    avatar_url?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    avatar_version?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    full_name?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    is_admin?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    is_owner?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    is_billing_admin?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    role?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    bot_type?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    user_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    bot_owner_id?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    is_active?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    is_guest?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    timezone?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    date_joined?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    delivery_email?: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserAllOf
     */
    profile_data?: any | null;
}
/**
 * A dictionary containing basic data on a given Zulip user. 
 * @export
 * @interface UserBase
 */
export interface UserBase {
    /**
     * The Zulip API email address of the user or bot.  If you do not have permission to view the email address of the target user, this will be a fake email address that is usable for the Zulip API but nothing else. 
     * @type {string}
     * @memberof UserBase
     */
    email?: string;
    /**
     * A boolean specifying whether the user is a bot or full account. 
     * @type {boolean}
     * @memberof UserBase
     */
    is_bot?: boolean;
    /**
     * URL for the user\'s avatar.  Will be `null` if the `client_gravatar` query parameter was set to `True` and the user\'s avatar is hosted by the Gravatar provider (i.e. the user has never uploaded an avatar).  **Changes**: In Zulip 3.0 (feature level 18), if the client has the `user_avatar_url_field_optional` capability, this will be missing at the server\'s sole discretion. 
     * @type {string}
     * @memberof UserBase
     */
    avatar_url?: string | null;
    /**
     * Version for the user\'s avatar.  Used for cache-busting requests for the user\'s avatar.  Clients generally shouldn\'t need to use this; most avatar URLs sent by Zulip will already end with `?v={avatar_version}`. 
     * @type {number}
     * @memberof UserBase
     */
    avatar_version?: number;
    /**
     * Full name of the user or bot, used for all display purposes. 
     * @type {string}
     * @memberof UserBase
     */
    full_name?: string;
    /**
     * A boolean specifying whether the user is an organization administrator. 
     * @type {boolean}
     * @memberof UserBase
     */
    is_admin?: boolean;
    /**
     * A boolean specifying whether the user is an organization owner. If true, is_admin will also be true.  **Changes**: New in Zulip 3.0 (feature level 8). 
     * @type {boolean}
     * @memberof UserBase
     */
    is_owner?: boolean;
    /**
     * A boolean specifying whether the user is a billing administrator.  **Changes**: New in Zulip 5.0 (feature level 73). 
     * @type {boolean}
     * @memberof UserBase
     */
    is_billing_admin?: boolean;
    /**
     * [Organization-level role](/help/roles-and-permissions)) of the user. Poosible values are:  * Organization owner => 100 * Organization administrator => 200 * Organization moderator => 300 * Member => 400 * Guest => 600  **Changes**: New in Zulip 4.0 (feature level 59). 
     * @type {number}
     * @memberof UserBase
     */
    role?: UserBaseRoleEnum;
    /**
     * An integer describing the type of bot: * `null` if the user isn\'t a bot. * `1` for a `Generic` bot. * `2` for an `Incoming webhook` bot. * `3` for an `Outgoing webhook` bot. * `4` for an `Embedded` bot. 
     * @type {number}
     * @memberof UserBase
     */
    bot_type?: number | null;
    /**
     * The unique ID of the user. 
     * @type {number}
     * @memberof UserBase
     */
    user_id?: number;
    /**
     * If the user is a bot (i.e. `is_bot` is `True`), `bot_owner` is the user ID of the bot\'s owner (usually, whoever created the bot).  Will be null for legacy bots that do not have an owner.  **Changes**: New in Zulip 3.0 (feature level 1).  In previous versions, there was a `bot_owner` field containing the email address of the bot\'s owner. 
     * @type {number}
     * @memberof UserBase
     */
    bot_owner_id?: number | null;
    /**
     * A boolean specifying whether the user account has been deactivated. 
     * @type {boolean}
     * @memberof UserBase
     */
    is_active?: boolean;
    /**
     * A boolean specifying whether the user is a guest user. 
     * @type {boolean}
     * @memberof UserBase
     */
    is_guest?: boolean;
    /**
     * The time zone of the user. 
     * @type {string}
     * @memberof UserBase
     */
    timezone?: string;
    /**
     * The time the user account was created. 
     * @type {string}
     * @memberof UserBase
     */
    date_joined?: string;
    /**
     * The user\'s real email address.  This field is present only if [email address visibility](/help/restrict-visibility-of-email-addresses) is limited and you are an administrator with access to real email addresses under the configured policy. 
     * @type {string}
     * @memberof UserBase
     */
    delivery_email?: string;
    /**
     * A dictionary containing custom profile field data for the user. Each entry maps the integer ID of a custom profile field in the organization to a dictionary containing the user\'s data for that field.  Generally the data includes just a single `value` key; for those custom profile fields supporting Markdown, a `rendered_value` key will also be present. 
     * @type {{ [key: string]: object; }}
     * @memberof UserBase
     */
    profile_data?: { [key: string]: object; };
}

/**
    * @export
    * @enum {string}
    */
export enum UserBaseRoleEnum {
    NUMBER_100 = 100,
    NUMBER_200 = 200,
    NUMBER_300 = 300,
    NUMBER_400 = 400,
    NUMBER_600 = 600
}

/**
 * 
 * @export
 * @interface UserDeactivatedError
 */
export interface UserDeactivatedError {
    /**
     * 
     * @type {any}
     * @memberof UserDeactivatedError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserDeactivatedError
     */
    msg: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserDeactivatedError
     */
    code?: any | null;
}
/**
 * Object containing the user group\'s attributes. 
 * @export
 * @interface UserGroup
 */
export interface UserGroup {
    /**
     * The name of the user group. 
     * @type {string}
     * @memberof UserGroup
     */
    name?: string;
    /**
     * The description of the user group. 
     * @type {string}
     * @memberof UserGroup
     */
    description?: string;
    /**
     * Array containing the id of the users who are members of this user group. 
     * @type {Array<number>}
     * @memberof UserGroup
     */
    members?: Array<number>;
    /**
     * The ID of the user group. 
     * @type {number}
     * @memberof UserGroup
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface UserNotAuthorizedError
 */
export interface UserNotAuthorizedError {
    /**
     * 
     * @type {any}
     * @memberof UserNotAuthorizedError
     */
    result: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserNotAuthorizedError
     */
    msg: any | null;
    /**
     * 
     * @type {any}
     * @memberof UserNotAuthorizedError
     */
    code?: any | null;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For easy testing of mobile apps and other clients and against Zulip development servers, we support fetching a Zulip API key for any user on the development server without authentication (so that they can implement analogues of the one-click login process available for Zulip development servers on the web).  **Note:** This endpoint is only available on Zulip development servers; for obvious security reasons it will always return an error in a Zulip production server.  `POST {{ api_url }}/v1/dev_fetch_api_key` 
         * @summary Fetch an API key (development only)
         * @param {string} username The email address for the user that owns the API key. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devFetchApiKey: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('devFetchApiKey', 'username', username)
            const localVarPath = `/dev_fetch_api_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint is used by clients such as the Zulip mobile and terminal apps to implement password-based authentication.  Given the user\'s Zulip login credentials, it returns a Zulip API key that the client can use to make requests requests as the user.  This endpoint is only useful for Zulip servers/organizations with EmailAuthBackend or LDAPAuthBackend enabled.  The Zulip mobile apps also support SSO/social authentication (GitHub auth, Google auth, SAML, etc.) that does not use this endpoint.  Instead, the mobile apps reuse the web login flow passing the `mobile_flow_otp` in a webview, and the credentials are returned to the app (encrypted) via a redirect to a `zulip://` URL.  !!! warn \"\"     **Note:** If you signed up using passwordless authentication and     never had a password, you can [reset your password](/help/change-your-password).      See the [API keys](/api/api-keys) documentation for     more details on how to download API key manually.  In a [Zulip development environment](https://zulip.readthedocs.io/en/latest/development/overview.html), see also [the unauthenticated variant](/api/dev-fetch-api-key). 
         * @summary Fetch an API key (production)
         * @param {string} username The username to be used for authentication (typically, the email address, but depending on configuration, it could be an LDAP username).  See the &#x60;require_email_format_usernames&#x60; parameter documented in [GET /server_settings](/api/get-server-settings) for details. 
         * @param {string} password The user\&#39;s Zulip password (or LDAP password, if LDAP authentication is in use). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchApiKey: async (username: string, password: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('fetchApiKey', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('fetchApiKey', 'password', password)
            const localVarPath = `/fetch_api_key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * For easy testing of mobile apps and other clients and against Zulip development servers, we support fetching a Zulip API key for any user on the development server without authentication (so that they can implement analogues of the one-click login process available for Zulip development servers on the web).  **Note:** This endpoint is only available on Zulip development servers; for obvious security reasons it will always return an error in a Zulip production server.  `POST {{ api_url }}/v1/dev_fetch_api_key` 
         * @summary Fetch an API key (development only)
         * @param {string} username The email address for the user that owns the API key. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devFetchApiKey(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devFetchApiKey(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This API endpoint is used by clients such as the Zulip mobile and terminal apps to implement password-based authentication.  Given the user\'s Zulip login credentials, it returns a Zulip API key that the client can use to make requests requests as the user.  This endpoint is only useful for Zulip servers/organizations with EmailAuthBackend or LDAPAuthBackend enabled.  The Zulip mobile apps also support SSO/social authentication (GitHub auth, Google auth, SAML, etc.) that does not use this endpoint.  Instead, the mobile apps reuse the web login flow passing the `mobile_flow_otp` in a webview, and the credentials are returned to the app (encrypted) via a redirect to a `zulip://` URL.  !!! warn \"\"     **Note:** If you signed up using passwordless authentication and     never had a password, you can [reset your password](/help/change-your-password).      See the [API keys](/api/api-keys) documentation for     more details on how to download API key manually.  In a [Zulip development environment](https://zulip.readthedocs.io/en/latest/development/overview.html), see also [the unauthenticated variant](/api/dev-fetch-api-key). 
         * @summary Fetch an API key (production)
         * @param {string} username The username to be used for authentication (typically, the email address, but depending on configuration, it could be an LDAP username).  See the &#x60;require_email_format_usernames&#x60; parameter documented in [GET /server_settings](/api/get-server-settings) for details. 
         * @param {string} password The user\&#39;s Zulip password (or LDAP password, if LDAP authentication is in use). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchApiKey(username: string, password: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchApiKey(username, password, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * For easy testing of mobile apps and other clients and against Zulip development servers, we support fetching a Zulip API key for any user on the development server without authentication (so that they can implement analogues of the one-click login process available for Zulip development servers on the web).  **Note:** This endpoint is only available on Zulip development servers; for obvious security reasons it will always return an error in a Zulip production server.  `POST {{ api_url }}/v1/dev_fetch_api_key` 
         * @summary Fetch an API key (development only)
         * @param {string} username The email address for the user that owns the API key. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devFetchApiKey(username: string, options?: any): AxiosPromise<ApiKeyResponse> {
            return localVarFp.devFetchApiKey(username, options).then((request) => request(axios, basePath));
        },
        /**
         * This API endpoint is used by clients such as the Zulip mobile and terminal apps to implement password-based authentication.  Given the user\'s Zulip login credentials, it returns a Zulip API key that the client can use to make requests requests as the user.  This endpoint is only useful for Zulip servers/organizations with EmailAuthBackend or LDAPAuthBackend enabled.  The Zulip mobile apps also support SSO/social authentication (GitHub auth, Google auth, SAML, etc.) that does not use this endpoint.  Instead, the mobile apps reuse the web login flow passing the `mobile_flow_otp` in a webview, and the credentials are returned to the app (encrypted) via a redirect to a `zulip://` URL.  !!! warn \"\"     **Note:** If you signed up using passwordless authentication and     never had a password, you can [reset your password](/help/change-your-password).      See the [API keys](/api/api-keys) documentation for     more details on how to download API key manually.  In a [Zulip development environment](https://zulip.readthedocs.io/en/latest/development/overview.html), see also [the unauthenticated variant](/api/dev-fetch-api-key). 
         * @summary Fetch an API key (production)
         * @param {string} username The username to be used for authentication (typically, the email address, but depending on configuration, it could be an LDAP username).  See the &#x60;require_email_format_usernames&#x60; parameter documented in [GET /server_settings](/api/get-server-settings) for details. 
         * @param {string} password The user\&#39;s Zulip password (or LDAP password, if LDAP authentication is in use). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchApiKey(username: string, password: string, options?: any): AxiosPromise<ApiKeyResponse> {
            return localVarFp.fetchApiKey(username, password, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * For easy testing of mobile apps and other clients and against Zulip development servers, we support fetching a Zulip API key for any user on the development server without authentication (so that they can implement analogues of the one-click login process available for Zulip development servers on the web).  **Note:** This endpoint is only available on Zulip development servers; for obvious security reasons it will always return an error in a Zulip production server.  `POST {{ api_url }}/v1/dev_fetch_api_key` 
     * @summary Fetch an API key (development only)
     * @param {string} username The email address for the user that owns the API key. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public devFetchApiKey(username: string, options?: any) {
        return AuthenticationApiFp(this.configuration).devFetchApiKey(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This API endpoint is used by clients such as the Zulip mobile and terminal apps to implement password-based authentication.  Given the user\'s Zulip login credentials, it returns a Zulip API key that the client can use to make requests requests as the user.  This endpoint is only useful for Zulip servers/organizations with EmailAuthBackend or LDAPAuthBackend enabled.  The Zulip mobile apps also support SSO/social authentication (GitHub auth, Google auth, SAML, etc.) that does not use this endpoint.  Instead, the mobile apps reuse the web login flow passing the `mobile_flow_otp` in a webview, and the credentials are returned to the app (encrypted) via a redirect to a `zulip://` URL.  !!! warn \"\"     **Note:** If you signed up using passwordless authentication and     never had a password, you can [reset your password](/help/change-your-password).      See the [API keys](/api/api-keys) documentation for     more details on how to download API key manually.  In a [Zulip development environment](https://zulip.readthedocs.io/en/latest/development/overview.html), see also [the unauthenticated variant](/api/dev-fetch-api-key). 
     * @summary Fetch an API key (production)
     * @param {string} username The username to be used for authentication (typically, the email address, but depending on configuration, it could be an LDAP username).  See the &#x60;require_email_format_usernames&#x60; parameter documented in [GET /server_settings](/api/get-server-settings) for details. 
     * @param {string} password The user\&#39;s Zulip password (or LDAP password, if LDAP authentication is in use). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public fetchApiKey(username: string, password: string, options?: any) {
        return AuthenticationApiFp(this.configuration).fetchApiKey(username, password, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DraftsApi - axios parameter creator
 * @export
 */
export const DraftsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create one or more drafts on the server. These drafts will be automatically synchronized to other clients via `drafts` events.  `POST {{ api_url }}/v1/drafts` 
         * @summary Create drafts
         * @param {Array<Draft>} [drafts] A JSON-encoded list of containing new draft objects. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrafts: async (drafts?: Array<Draft>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (drafts) {
                localVarQueryParameter['drafts'] = drafts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a single draft from the server. The deletion will be automatically synchronized to other clients via a `drafts` event.  `DELETE {{ api_url }}/v1/drafts/{draft_id}` 
         * @summary Delete a draft
         * @param {number} draftId The ID of the draft you want to delete. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDraft: async (draftId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'draftId' is not null or undefined
            assertParamExists('deleteDraft', 'draftId', draftId)
            const localVarPath = `/drafts/{draft_id}`
                .replace(`{${"draft_id"}}`, encodeURIComponent(String(draftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit a draft on the server. The edit will be automatically synchronized to other clients via `drafts` events.  `PATCH {{ api_url }}/v1/drafts/{draft_id}` 
         * @summary Edit a draft
         * @param {number} draftId The ID of the draft to be edited. 
         * @param {Draft} draft A JSON-encoded object containing a replacement draft object for this ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDraft: async (draftId: number, draft: Draft, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'draftId' is not null or undefined
            assertParamExists('editDraft', 'draftId', draftId)
            // verify required parameter 'draft' is not null or undefined
            assertParamExists('editDraft', 'draft', draft)
            const localVarPath = `/drafts/{draft_id}`
                .replace(`{${"draft_id"}}`, encodeURIComponent(String(draftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all drafts for the current user.  `GET {{ api_url }}/v1/drafts` 
         * @summary Get drafts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrafts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DraftsApi - functional programming interface
 * @export
 */
export const DraftsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DraftsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create one or more drafts on the server. These drafts will be automatically synchronized to other clients via `drafts` events.  `POST {{ api_url }}/v1/drafts` 
         * @summary Create drafts
         * @param {Array<Draft>} [drafts] A JSON-encoded list of containing new draft objects. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDrafts(drafts?: Array<Draft>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDrafts(drafts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a single draft from the server. The deletion will be automatically synchronized to other clients via a `drafts` event.  `DELETE {{ api_url }}/v1/drafts/{draft_id}` 
         * @summary Delete a draft
         * @param {number} draftId The ID of the draft you want to delete. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDraft(draftId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDraft(draftId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit a draft on the server. The edit will be automatically synchronized to other clients via `drafts` events.  `PATCH {{ api_url }}/v1/drafts/{draft_id}` 
         * @summary Edit a draft
         * @param {number} draftId The ID of the draft to be edited. 
         * @param {Draft} draft A JSON-encoded object containing a replacement draft object for this ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editDraft(draftId: number, draft: Draft, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editDraft(draftId, draft, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch all drafts for the current user.  `GET {{ api_url }}/v1/drafts` 
         * @summary Get drafts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDrafts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDrafts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DraftsApi - factory interface
 * @export
 */
export const DraftsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DraftsApiFp(configuration)
    return {
        /**
         * Create one or more drafts on the server. These drafts will be automatically synchronized to other clients via `drafts` events.  `POST {{ api_url }}/v1/drafts` 
         * @summary Create drafts
         * @param {Array<Draft>} [drafts] A JSON-encoded list of containing new draft objects. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDrafts(drafts?: Array<Draft>, options?: any): AxiosPromise<JsonSuccess & object> {
            return localVarFp.createDrafts(drafts, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a single draft from the server. The deletion will be automatically synchronized to other clients via a `drafts` event.  `DELETE {{ api_url }}/v1/drafts/{draft_id}` 
         * @summary Delete a draft
         * @param {number} draftId The ID of the draft you want to delete. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDraft(draftId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.deleteDraft(draftId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit a draft on the server. The edit will be automatically synchronized to other clients via `drafts` events.  `PATCH {{ api_url }}/v1/drafts/{draft_id}` 
         * @summary Edit a draft
         * @param {number} draftId The ID of the draft to be edited. 
         * @param {Draft} draft A JSON-encoded object containing a replacement draft object for this ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editDraft(draftId: number, draft: Draft, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.editDraft(draftId, draft, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all drafts for the current user.  `GET {{ api_url }}/v1/drafts` 
         * @summary Get drafts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrafts(options?: any): AxiosPromise<JsonSuccess & object> {
            return localVarFp.getDrafts(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DraftsApi - object-oriented interface
 * @export
 * @class DraftsApi
 * @extends {BaseAPI}
 */
export class DraftsApi extends BaseAPI {
    /**
     * Create one or more drafts on the server. These drafts will be automatically synchronized to other clients via `drafts` events.  `POST {{ api_url }}/v1/drafts` 
     * @summary Create drafts
     * @param {Array<Draft>} [drafts] A JSON-encoded list of containing new draft objects. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftsApi
     */
    public createDrafts(drafts?: Array<Draft>, options?: any) {
        return DraftsApiFp(this.configuration).createDrafts(drafts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a single draft from the server. The deletion will be automatically synchronized to other clients via a `drafts` event.  `DELETE {{ api_url }}/v1/drafts/{draft_id}` 
     * @summary Delete a draft
     * @param {number} draftId The ID of the draft you want to delete. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftsApi
     */
    public deleteDraft(draftId: number, options?: any) {
        return DraftsApiFp(this.configuration).deleteDraft(draftId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit a draft on the server. The edit will be automatically synchronized to other clients via `drafts` events.  `PATCH {{ api_url }}/v1/drafts/{draft_id}` 
     * @summary Edit a draft
     * @param {number} draftId The ID of the draft to be edited. 
     * @param {Draft} draft A JSON-encoded object containing a replacement draft object for this ID. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftsApi
     */
    public editDraft(draftId: number, draft: Draft, options?: any) {
        return DraftsApiFp(this.configuration).editDraft(draftId, draft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch all drafts for the current user.  `GET {{ api_url }}/v1/drafts` 
     * @summary Get drafts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DraftsApi
     */
    public getDrafts(options?: any) {
        return DraftsApiFp(this.configuration).getDrafts(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an [emoji reaction](/help/emoji-reactions) to a message.  `POST {{ api_url }}/v1/messages/{message_id}/reactions` 
         * @summary Add an emoji reaction
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {string} emojiName The target emoji\&#39;s human-readable name.  To find an emoji\&#39;s name, hover over a message to reveal three icons on the right, then click the smiley face icon. Images of available reaction emojis appear. Hover over the emoji you want, and note that emoji\&#39;s text name. 
         * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For most API clients, you won\&#39;t need this, but it\&#39;s important for Zulip apps to handle rare corner cases when adding/removing votes on an emoji reaction added previously by another user.  If the existing reaction was added when the Zulip server was using a previous version of the emoji data mapping between Unicode codepoints and human-readable names, sending the &#x60;emoji_code&#x60; in the data for the original reaction allows the Zulip server to correctly interpret your upvote as an upvote rather than a reaction with a \&quot;diffenent\&quot; emoji. 
         * @param {string} [reactionType] If an app is adding/removing a vote on an existing reaction, it should pass this parameter using the value the server provided for the existing reaction for specificity.  Supported values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode codepoint). * &#x60;realm_emoji&#x60;: Custom emoji. (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to    namespace the &#x60;zulip&#x60; emoji.  **Changes**: In Zulip 3.0 (feature level 2), this become optional for [custom emoji](/help/add-custom-emoji); previously, this endpoint assumed &#x60;unicode_emoji&#x60; if this parameter was not specified. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addReaction: async (messageId: number, emojiName: string, emojiCode?: string, reactionType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('addReaction', 'messageId', messageId)
            // verify required parameter 'emojiName' is not null or undefined
            assertParamExists('addReaction', 'emojiName', emojiName)
            const localVarPath = `/messages/{message_id}/reactions`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (emojiName !== undefined) {
                localVarQueryParameter['emoji_name'] = emojiName;
            }

            if (emojiCode !== undefined) {
                localVarQueryParameter['emoji_code'] = emojiCode;
            }

            if (reactionType !== undefined) {
                localVarQueryParameter['reaction_type'] = reactionType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check whether a set of messages match a [narrow](/api/construct-narrow).  `GET {{ api_url }}/v1/messages/matches_narrow`  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the `match_subject` and `match_content` objects is designed to match those of `GET /messages`, so that a client can splice these fields into a `message` object received from `GET /events` and end up with an extended message object identical to how a `GET /messages` for the current narrow would have returned the message. 
         * @summary Check if messages match a narrow
         * @param {Array<number>} msgIds List of IDs for the messages to check.
         * @param {Array<object>} narrow A structure defining the narrow to check against. See how to [construct a narrow](/api/construct-narrow).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMessagesMatchNarrow: async (msgIds: Array<number>, narrow: Array<object>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'msgIds' is not null or undefined
            assertParamExists('checkMessagesMatchNarrow', 'msgIds', msgIds)
            // verify required parameter 'narrow' is not null or undefined
            assertParamExists('checkMessagesMatchNarrow', 'narrow', narrow)
            const localVarPath = `/messages/matches_narrow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (msgIds) {
                localVarQueryParameter['msg_ids'] = msgIds;
            }

            if (narrow) {
                localVarQueryParameter['narrow'] = narrow;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a message.  `DELETE {{ api_url }}/v1/messages/{msg_id}`  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
         * @summary Delete a message
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (messageId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessage', 'messageId', messageId)
            const localVarPath = `/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a temporary URL for access to the file that doesn\'t require authentication. 
         * @summary Get public temporary URL
         * @param {number} realmIdStr The realm id. 
         * @param {string} filename Path to the URL. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileTemporaryUrl: async (realmIdStr: number, filename: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'realmIdStr' is not null or undefined
            assertParamExists('getFileTemporaryUrl', 'realmIdStr', realmIdStr)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getFileTemporaryUrl', 'filename', filename)
            const localVarPath = `/user_uploads/{realm_id_str}/{filename}`
                .replace(`{${"realm_id_str"}}`, encodeURIComponent(String(realmIdStr)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the message edit history of a previously edited message.  `GET {{ api_url }}/v1/messages/{message_id}/history`  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
         * @summary Get a message\'s edit history
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageHistory: async (messageId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getMessageHistory', 'messageId', messageId)
            const localVarPath = `/messages/{message_id}/history`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch message history from a Zulip server.  `GET {{ api_url }}/v1/messages`  This `GET /api/v1/messages` endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip\'s powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user\'s message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an `anchor` message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the `num_before` and `num_after` limits.  We recommend using `num_before <= 1000` and `num_after <= 1000` to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
         * @summary Get messages
         * @param {number} numBefore The number of messages with IDs less than the anchor to retrieve. 
         * @param {number} numAfter The number of messages with IDs greater than the anchor to retrieve. 
         * @param {string | number} [anchor] Integer message ID to anchor fetching of new messages. Supports special string values for when the client wants the server to compute the anchor to use:  * &#x60;newest&#x60;: The most recent message. * &#x60;oldest&#x60;: The oldest message. * &#x60;first_unread&#x60;: The oldest unread message matching the   query, if any; otherwise, the most recent message.  The special values of &#x60;\&#39;newest\&#39;&#x60; and &#x60;\&#39;oldest\&#39;&#x60; are also supported for anchoring the query at the most recent or oldest messages.  **Changes**: String values are new in Zulip 3.0 (feature level 1).  The   &#x60;first_unread&#x60; functionality was supported in Zulip 2.1.x   and older by not sending anchor and using use_first_unread_anchor.    In Zulip 2.1.x and older, &#x60;oldest&#x60; can be emulated with   &#x60;anchor&#x3D;0&#x60;, and &#x60;newest&#x60; with &#x60;anchor&#x3D;10000000000000000&#x60;   (that specific large value works around a bug in Zulip   2.1.x and older in the &#x60;found_newest&#x60; return value). 
         * @param {Array<object>} [narrow] The narrow where you want to fetch the messages from. See how to [construct a narrow](/api/construct-narrow). 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [applyMarkdown] If &#x60;true&#x60;, message content is returned in the rendered HTML format. If &#x60;false&#x60;, message content is returned in the raw Markdown-format text that user entered. 
         * @param {boolean} [useFirstUnreadAnchor] Legacy way to specify &#x60;anchor&#x3D;\&quot;first_unread\&quot;&#x60; in Zulip 2.1.x and older.  Whether to use the (computed by the server) first unread message matching the narrow as the &#x60;anchor&#x60;.  Mutually exclusive with &#x60;anchor&#x60;.  **Changes**: Deprecated in Zulip 3.0, replaced by &#x60;anchor&#x3D;\&quot;first_unread\&quot;&#x60; instead. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages: async (numBefore: number, numAfter: number, anchor?: string | number, narrow?: Array<object>, clientGravatar?: boolean, applyMarkdown?: boolean, useFirstUnreadAnchor?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'numBefore' is not null or undefined
            assertParamExists('getMessages', 'numBefore', numBefore)
            // verify required parameter 'numAfter' is not null or undefined
            assertParamExists('getMessages', 'numAfter', numAfter)
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (anchor !== undefined) {
                localVarQueryParameter['anchor'] = anchor;
            }

            if (numBefore !== undefined) {
                localVarQueryParameter['num_before'] = numBefore;
            }

            if (numAfter !== undefined) {
                localVarQueryParameter['num_after'] = numAfter;
            }

            if (narrow) {
                localVarQueryParameter['narrow'] = narrow;
            }

            if (clientGravatar !== undefined) {
                localVarQueryParameter['client_gravatar'] = clientGravatar;
            }

            if (applyMarkdown !== undefined) {
                localVarQueryParameter['apply_markdown'] = applyMarkdown;
            }

            if (useFirstUnreadAnchor !== undefined) {
                localVarQueryParameter['use_first_unread_anchor'] = useFirstUnreadAnchor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the raw content of a message.  `GET {{ api_url }}/v1/messages/{msg_id}`  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message\'s raw Markdown (e.g. for pre-filling a message-editing UI). 
         * @summary Get a message\'s raw Markdown
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawMessage: async (messageId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getRawMessage', 'messageId', messageId)
            const localVarPath = `/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks all of the current user\'s unread messages as read.  `POST {{ api_url }}/v1/mark_all_as_read` 
         * @summary Mark all messages as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllAsRead: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/mark_all_as_read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all the unread messages in a stream as read. 
         * @summary Mark messages in a stream as read
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markStreamAsRead: async (streamId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('markStreamAsRead', 'streamId', streamId)
            const localVarPath = `/mark_stream_as_read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = streamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all the unread messages in a topic as read. 
         * @summary Mark messages in a topic as read
         * @param {number} streamId The ID of the stream to access. 
         * @param {string} topicName The name of the topic whose messages should be marked as read. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTopicAsRead: async (streamId: number, topicName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('markTopicAsRead', 'streamId', streamId)
            // verify required parameter 'topicName' is not null or undefined
            assertParamExists('markTopicAsRead', 'topicName', topicName)
            const localVarPath = `/mark_topic_as_read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = streamId;
            }

            if (topicName !== undefined) {
                localVarQueryParameter['topic_name'] = topicName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an [emoji reaction](/help/emoji-reactions) from a message.  `DELETE {{ api_url }}/v1/messages/{message_id}/reactions` 
         * @summary Remove an emoji reaction
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {string} [emojiName] The target emoji\&#39;s human-readable name.  To find an emoji\&#39;s name, hover over a message to reveal three icons on the right, then click the smiley face icon. Images of available reaction emojis appear. Hover over the emoji you want, and note that emoji\&#39;s text name. 
         * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For most API clients, you won\&#39;t need this, but it\&#39;s important for Zulip apps to handle rare corner cases when adding/removing votes on an emoji reaction added previously by another user.  If the existing reaction was added when the Zulip server was using a previous version of the emoji data mapping between Unicode codepoints and human-readable names, sending the &#x60;emoji_code&#x60; in the data for the original reaction allows the Zulip server to correctly interpret your upvote as an upvote rather than a reaction with a \&quot;diffenent\&quot; emoji. 
         * @param {string} [reactionType] If an app is adding/removing a vote on an existing reaction, it should pass this parameter using the value the server provided for the existing reaction for specificity.  Supported values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode codepoint). * &#x60;realm_emoji&#x60;: Custom emoji. (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to    namespace the &#x60;zulip&#x60; emoji.  **Changes**: In Zulip 3.0 (feature level 2), this become optional for [custom emoji](/help/add-custom-emoji); previously, this endpoint assumed &#x60;unicode_emoji&#x60; if this parameter was not specified. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReaction: async (messageId: number, emojiName?: string, emojiCode?: string, reactionType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('removeReaction', 'messageId', messageId)
            const localVarPath = `/messages/{message_id}/reactions`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (emojiName !== undefined) {
                localVarQueryParameter['emoji_name'] = emojiName;
            }

            if (emojiCode !== undefined) {
                localVarQueryParameter['emoji_code'] = emojiCode;
            }

            if (reactionType !== undefined) {
                localVarQueryParameter['reaction_type'] = reactionType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Render a message to HTML.  `POST {{ api_url }}/v1/messages/render` 
         * @summary Render message
         * @param {string} content The content of the message. Maximum message size of 10000 bytes. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderMessage: async (content: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'content' is not null or undefined
            assertParamExists('renderMessage', 'content', content)
            const localVarPath = `/messages/render`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a stream or a private message.  `POST {{ api_url }}/v1/messages` 
         * @summary Send a message
         * @param {'private' | 'stream'} type The type of message to be sent. &#x60;private&#x60; for a private message and &#x60;stream&#x60; for a stream message. 
         * @param {Array<number>} to For stream messages, either the name or integer ID of the stream. For private messages, either a list containing integer user IDs or a list containing string email addresses.  **Changes**: Support for using user/stream IDs was added in Zulip 2.0.0. 
         * @param {string} content The content of the message. Maximum message size of 10000 bytes. 
         * @param {string} [topic] The topic of the message. Only required for stream messages (&#x60;type&#x3D;\&quot;stream\&quot;&#x60;), ignored otherwise.  Maximum length of 60 characters.  **Changes**: New in Zulip 2.0.  Previous Zulip releases encoded this as &#x60;subject&#x60;, which is currently a deprecated alias. 
         * @param {string} [queueId] For clients supporting [local echo](https://zulip.readthedocs.io/en/latest/subsystems/sending-messages.html#local-echo), the [event queue](/api/register-queue) ID for the client.  If passed, &#x60;local_id&#x60; is required.  If the message is successfully sent, the server will include &#x60;local_id&#x60; in the &#x60;message&#x60; event that the client with this &#x60;queue_id&#x60; will receive notifying it of the new message via [&#x60;GET /events&#x60;](/api/get-events).  This lets the client know unambiguously that it should replace the locally echoed message, rather than adding this new message (which would be correct if the user had sent the new message from another device). 
         * @param {string} [localId] For clients supporting local echo, a unique string-format identifier chosen freely by the client; the server will pass it back to the client without inspecting it, as described in the &#x60;queue_id&#x60; description. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (type: 'private' | 'stream', to: Array<number>, content: string, topic?: string, queueId?: string, localId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('sendMessage', 'type', type)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('sendMessage', 'to', to)
            // verify required parameter 'content' is not null or undefined
            assertParamExists('sendMessage', 'content', content)
            const localVarPath = `/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (to) {
                localVarQueryParameter['to'] = to;
            }

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (queueId !== undefined) {
                localVarQueryParameter['queue_id'] = queueId;
            }

            if (localId !== undefined) {
                localVarQueryParameter['local_id'] = localId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit/update the content or topic of a message.  `PATCH {{ api_url }}/v1/messages/{msg_id}`  `{msg_id}` in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to ` {original_topic}`.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
         * @summary Edit a message
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {string} [topic] The topic to move the message(s) to, to request changing the topic. Should only be sent when changing the topic, and will throw an error if the target message is not a stream message.  Maximum length of 60 characters.  **Changes**: New in Zulip 2.0.  Previous Zulip releases encoded this as &#x60;subject&#x60;, which is currently a deprecated alias. 
         * @param {'change_one' | 'change_later' | 'change_all'} [propagateMode] Which message(s) should be edited: just the one indicated in &#x60;message_id&#x60;, messages in the same topic that had been sent after this one, or all of them.  Only the default value of &#x60;change_one&#x60; is valid when editing only the content of a message.  This parameter determines both which messages get moved and also whether clients that are currently narrowed to the topic containing the message should navigate or adjust their compose box recipient to point to the post-edit stream/topic. 
         * @param {boolean} [sendNotificationToOldThread] Whether to send breadcrumb message to the old thread to notify users where the messages were moved to.  **Changes**: New in Zulip 3.0 (feature level 9). 
         * @param {boolean} [sendNotificationToNewThread] Whether to send a notification message to the new thread to notify users where the messages came from.  **Changes**: New in Zulip 3.0 (feature level 9). 
         * @param {string} [content] The content of the message. Maximum message size of 10000 bytes. 
         * @param {number} [streamId] The stream ID to move the message(s) to, to request moving messages to another stream.  Should only be sent when changing the stream, and will throw an error if the target message is not a stream message. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage: async (messageId: number, topic?: string, propagateMode?: 'change_one' | 'change_later' | 'change_all', sendNotificationToOldThread?: boolean, sendNotificationToNewThread?: boolean, content?: string, streamId?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('updateMessage', 'messageId', messageId)
            const localVarPath = `/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (propagateMode !== undefined) {
                localVarQueryParameter['propagate_mode'] = propagateMode;
            }

            if (sendNotificationToOldThread !== undefined) {
                localVarQueryParameter['send_notification_to_old_thread'] = sendNotificationToOldThread;
            }

            if (sendNotificationToNewThread !== undefined) {
                localVarQueryParameter['send_notification_to_new_thread'] = sendNotificationToNewThread;
            }

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = streamId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or remove personal message flags like `read` and `starred` on a collection of message IDs.  `POST {{ api_url }}/v1/messages/flags`  For updating the `read` flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
         * @summary Update personal message flags
         * @param {Array<number>} messages An array containing the IDs of the target messages. 
         * @param {'add' | 'remove'} op Whether to &#x60;add&#x60; the flag or &#x60;remove&#x60; it. 
         * @param {string} flag The flag that should be added/removed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageFlags: async (messages: Array<number>, op: 'add' | 'remove', flag: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'messages' is not null or undefined
            assertParamExists('updateMessageFlags', 'messages', messages)
            // verify required parameter 'op' is not null or undefined
            assertParamExists('updateMessageFlags', 'op', op)
            // verify required parameter 'flag' is not null or undefined
            assertParamExists('updateMessageFlags', 'flag', flag)
            const localVarPath = `/messages/flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (messages) {
                localVarQueryParameter['messages'] = messages;
            }

            if (op !== undefined) {
                localVarQueryParameter['op'] = op;
            }

            if (flag !== undefined) {
                localVarQueryParameter['flag'] = flag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a single file and get the corresponding URI.  `POST {{ api_url }}/v1/user_uploads`  Initially, only you will be able to access the link.  To share the uploaded file, you\'ll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
         * @summary Upload a file
         * @param {any} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (filename?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (filename !== undefined) { 
                localVarFormParams.append('filename', filename as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add an [emoji reaction](/help/emoji-reactions) to a message.  `POST {{ api_url }}/v1/messages/{message_id}/reactions` 
         * @summary Add an emoji reaction
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {string} emojiName The target emoji\&#39;s human-readable name.  To find an emoji\&#39;s name, hover over a message to reveal three icons on the right, then click the smiley face icon. Images of available reaction emojis appear. Hover over the emoji you want, and note that emoji\&#39;s text name. 
         * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For most API clients, you won\&#39;t need this, but it\&#39;s important for Zulip apps to handle rare corner cases when adding/removing votes on an emoji reaction added previously by another user.  If the existing reaction was added when the Zulip server was using a previous version of the emoji data mapping between Unicode codepoints and human-readable names, sending the &#x60;emoji_code&#x60; in the data for the original reaction allows the Zulip server to correctly interpret your upvote as an upvote rather than a reaction with a \&quot;diffenent\&quot; emoji. 
         * @param {string} [reactionType] If an app is adding/removing a vote on an existing reaction, it should pass this parameter using the value the server provided for the existing reaction for specificity.  Supported values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode codepoint). * &#x60;realm_emoji&#x60;: Custom emoji. (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to    namespace the &#x60;zulip&#x60; emoji.  **Changes**: In Zulip 3.0 (feature level 2), this become optional for [custom emoji](/help/add-custom-emoji); previously, this endpoint assumed &#x60;unicode_emoji&#x60; if this parameter was not specified. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addReaction(messageId: number, emojiName: string, emojiCode?: string, reactionType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addReaction(messageId, emojiName, emojiCode, reactionType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check whether a set of messages match a [narrow](/api/construct-narrow).  `GET {{ api_url }}/v1/messages/matches_narrow`  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the `match_subject` and `match_content` objects is designed to match those of `GET /messages`, so that a client can splice these fields into a `message` object received from `GET /events` and end up with an extended message object identical to how a `GET /messages` for the current narrow would have returned the message. 
         * @summary Check if messages match a narrow
         * @param {Array<number>} msgIds List of IDs for the messages to check.
         * @param {Array<object>} narrow A structure defining the narrow to check against. See how to [construct a narrow](/api/construct-narrow).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkMessagesMatchNarrow(msgIds: Array<number>, narrow: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkMessagesMatchNarrow(msgIds, narrow, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently delete a message.  `DELETE {{ api_url }}/v1/messages/{msg_id}`  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
         * @summary Delete a message
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(messageId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a temporary URL for access to the file that doesn\'t require authentication. 
         * @summary Get public temporary URL
         * @param {number} realmIdStr The realm id. 
         * @param {string} filename Path to the URL. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileTemporaryUrl(realmIdStr: number, filename: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileTemporaryUrl(realmIdStr, filename, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch the message edit history of a previously edited message.  `GET {{ api_url }}/v1/messages/{message_id}/history`  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
         * @summary Get a message\'s edit history
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageHistory(messageId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageHistory(messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch message history from a Zulip server.  `GET {{ api_url }}/v1/messages`  This `GET /api/v1/messages` endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip\'s powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user\'s message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an `anchor` message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the `num_before` and `num_after` limits.  We recommend using `num_before <= 1000` and `num_after <= 1000` to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
         * @summary Get messages
         * @param {number} numBefore The number of messages with IDs less than the anchor to retrieve. 
         * @param {number} numAfter The number of messages with IDs greater than the anchor to retrieve. 
         * @param {string | number} [anchor] Integer message ID to anchor fetching of new messages. Supports special string values for when the client wants the server to compute the anchor to use:  * &#x60;newest&#x60;: The most recent message. * &#x60;oldest&#x60;: The oldest message. * &#x60;first_unread&#x60;: The oldest unread message matching the   query, if any; otherwise, the most recent message.  The special values of &#x60;\&#39;newest\&#39;&#x60; and &#x60;\&#39;oldest\&#39;&#x60; are also supported for anchoring the query at the most recent or oldest messages.  **Changes**: String values are new in Zulip 3.0 (feature level 1).  The   &#x60;first_unread&#x60; functionality was supported in Zulip 2.1.x   and older by not sending anchor and using use_first_unread_anchor.    In Zulip 2.1.x and older, &#x60;oldest&#x60; can be emulated with   &#x60;anchor&#x3D;0&#x60;, and &#x60;newest&#x60; with &#x60;anchor&#x3D;10000000000000000&#x60;   (that specific large value works around a bug in Zulip   2.1.x and older in the &#x60;found_newest&#x60; return value). 
         * @param {Array<object>} [narrow] The narrow where you want to fetch the messages from. See how to [construct a narrow](/api/construct-narrow). 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [applyMarkdown] If &#x60;true&#x60;, message content is returned in the rendered HTML format. If &#x60;false&#x60;, message content is returned in the raw Markdown-format text that user entered. 
         * @param {boolean} [useFirstUnreadAnchor] Legacy way to specify &#x60;anchor&#x3D;\&quot;first_unread\&quot;&#x60; in Zulip 2.1.x and older.  Whether to use the (computed by the server) first unread message matching the narrow as the &#x60;anchor&#x60;.  Mutually exclusive with &#x60;anchor&#x60;.  **Changes**: Deprecated in Zulip 3.0, replaced by &#x60;anchor&#x3D;\&quot;first_unread\&quot;&#x60; instead. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessages(numBefore: number, numAfter: number, anchor?: string | number, narrow?: Array<object>, clientGravatar?: boolean, applyMarkdown?: boolean, useFirstUnreadAnchor?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessages(numBefore, numAfter, anchor, narrow, clientGravatar, applyMarkdown, useFirstUnreadAnchor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the raw content of a message.  `GET {{ api_url }}/v1/messages/{msg_id}`  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message\'s raw Markdown (e.g. for pre-filling a message-editing UI). 
         * @summary Get a message\'s raw Markdown
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawMessage(messageId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRawMessage(messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Marks all of the current user\'s unread messages as read.  `POST {{ api_url }}/v1/mark_all_as_read` 
         * @summary Mark all messages as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAllAsRead(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAllAsRead(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark all the unread messages in a stream as read. 
         * @summary Mark messages in a stream as read
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markStreamAsRead(streamId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markStreamAsRead(streamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark all the unread messages in a topic as read. 
         * @summary Mark messages in a topic as read
         * @param {number} streamId The ID of the stream to access. 
         * @param {string} topicName The name of the topic whose messages should be marked as read. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markTopicAsRead(streamId: number, topicName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markTopicAsRead(streamId, topicName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove an [emoji reaction](/help/emoji-reactions) from a message.  `DELETE {{ api_url }}/v1/messages/{message_id}/reactions` 
         * @summary Remove an emoji reaction
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {string} [emojiName] The target emoji\&#39;s human-readable name.  To find an emoji\&#39;s name, hover over a message to reveal three icons on the right, then click the smiley face icon. Images of available reaction emojis appear. Hover over the emoji you want, and note that emoji\&#39;s text name. 
         * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For most API clients, you won\&#39;t need this, but it\&#39;s important for Zulip apps to handle rare corner cases when adding/removing votes on an emoji reaction added previously by another user.  If the existing reaction was added when the Zulip server was using a previous version of the emoji data mapping between Unicode codepoints and human-readable names, sending the &#x60;emoji_code&#x60; in the data for the original reaction allows the Zulip server to correctly interpret your upvote as an upvote rather than a reaction with a \&quot;diffenent\&quot; emoji. 
         * @param {string} [reactionType] If an app is adding/removing a vote on an existing reaction, it should pass this parameter using the value the server provided for the existing reaction for specificity.  Supported values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode codepoint). * &#x60;realm_emoji&#x60;: Custom emoji. (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to    namespace the &#x60;zulip&#x60; emoji.  **Changes**: In Zulip 3.0 (feature level 2), this become optional for [custom emoji](/help/add-custom-emoji); previously, this endpoint assumed &#x60;unicode_emoji&#x60; if this parameter was not specified. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeReaction(messageId: number, emojiName?: string, emojiCode?: string, reactionType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeReaction(messageId, emojiName, emojiCode, reactionType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Render a message to HTML.  `POST {{ api_url }}/v1/messages/render` 
         * @summary Render message
         * @param {string} content The content of the message. Maximum message size of 10000 bytes. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderMessage(content: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderMessage(content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a stream or a private message.  `POST {{ api_url }}/v1/messages` 
         * @summary Send a message
         * @param {'private' | 'stream'} type The type of message to be sent. &#x60;private&#x60; for a private message and &#x60;stream&#x60; for a stream message. 
         * @param {Array<number>} to For stream messages, either the name or integer ID of the stream. For private messages, either a list containing integer user IDs or a list containing string email addresses.  **Changes**: Support for using user/stream IDs was added in Zulip 2.0.0. 
         * @param {string} content The content of the message. Maximum message size of 10000 bytes. 
         * @param {string} [topic] The topic of the message. Only required for stream messages (&#x60;type&#x3D;\&quot;stream\&quot;&#x60;), ignored otherwise.  Maximum length of 60 characters.  **Changes**: New in Zulip 2.0.  Previous Zulip releases encoded this as &#x60;subject&#x60;, which is currently a deprecated alias. 
         * @param {string} [queueId] For clients supporting [local echo](https://zulip.readthedocs.io/en/latest/subsystems/sending-messages.html#local-echo), the [event queue](/api/register-queue) ID for the client.  If passed, &#x60;local_id&#x60; is required.  If the message is successfully sent, the server will include &#x60;local_id&#x60; in the &#x60;message&#x60; event that the client with this &#x60;queue_id&#x60; will receive notifying it of the new message via [&#x60;GET /events&#x60;](/api/get-events).  This lets the client know unambiguously that it should replace the locally echoed message, rather than adding this new message (which would be correct if the user had sent the new message from another device). 
         * @param {string} [localId] For clients supporting local echo, a unique string-format identifier chosen freely by the client; the server will pass it back to the client without inspecting it, as described in the &#x60;queue_id&#x60; description. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(type: 'private' | 'stream', to: Array<number>, content: string, topic?: string, queueId?: string, localId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(type, to, content, topic, queueId, localId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edit/update the content or topic of a message.  `PATCH {{ api_url }}/v1/messages/{msg_id}`  `{msg_id}` in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to ` {original_topic}`.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
         * @summary Edit a message
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {string} [topic] The topic to move the message(s) to, to request changing the topic. Should only be sent when changing the topic, and will throw an error if the target message is not a stream message.  Maximum length of 60 characters.  **Changes**: New in Zulip 2.0.  Previous Zulip releases encoded this as &#x60;subject&#x60;, which is currently a deprecated alias. 
         * @param {'change_one' | 'change_later' | 'change_all'} [propagateMode] Which message(s) should be edited: just the one indicated in &#x60;message_id&#x60;, messages in the same topic that had been sent after this one, or all of them.  Only the default value of &#x60;change_one&#x60; is valid when editing only the content of a message.  This parameter determines both which messages get moved and also whether clients that are currently narrowed to the topic containing the message should navigate or adjust their compose box recipient to point to the post-edit stream/topic. 
         * @param {boolean} [sendNotificationToOldThread] Whether to send breadcrumb message to the old thread to notify users where the messages were moved to.  **Changes**: New in Zulip 3.0 (feature level 9). 
         * @param {boolean} [sendNotificationToNewThread] Whether to send a notification message to the new thread to notify users where the messages came from.  **Changes**: New in Zulip 3.0 (feature level 9). 
         * @param {string} [content] The content of the message. Maximum message size of 10000 bytes. 
         * @param {number} [streamId] The stream ID to move the message(s) to, to request moving messages to another stream.  Should only be sent when changing the stream, and will throw an error if the target message is not a stream message. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMessage(messageId: number, topic?: string, propagateMode?: 'change_one' | 'change_later' | 'change_all', sendNotificationToOldThread?: boolean, sendNotificationToNewThread?: boolean, content?: string, streamId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessage(messageId, topic, propagateMode, sendNotificationToOldThread, sendNotificationToNewThread, content, streamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add or remove personal message flags like `read` and `starred` on a collection of message IDs.  `POST {{ api_url }}/v1/messages/flags`  For updating the `read` flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
         * @summary Update personal message flags
         * @param {Array<number>} messages An array containing the IDs of the target messages. 
         * @param {'add' | 'remove'} op Whether to &#x60;add&#x60; the flag or &#x60;remove&#x60; it. 
         * @param {string} flag The flag that should be added/removed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMessageFlags(messages: Array<number>, op: 'add' | 'remove', flag: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessageFlags(messages, op, flag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload a single file and get the corresponding URI.  `POST {{ api_url }}/v1/user_uploads`  Initially, only you will be able to access the link.  To share the uploaded file, you\'ll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
         * @summary Upload a file
         * @param {any} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(filename?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(filename, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * Add an [emoji reaction](/help/emoji-reactions) to a message.  `POST {{ api_url }}/v1/messages/{message_id}/reactions` 
         * @summary Add an emoji reaction
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {string} emojiName The target emoji\&#39;s human-readable name.  To find an emoji\&#39;s name, hover over a message to reveal three icons on the right, then click the smiley face icon. Images of available reaction emojis appear. Hover over the emoji you want, and note that emoji\&#39;s text name. 
         * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For most API clients, you won\&#39;t need this, but it\&#39;s important for Zulip apps to handle rare corner cases when adding/removing votes on an emoji reaction added previously by another user.  If the existing reaction was added when the Zulip server was using a previous version of the emoji data mapping between Unicode codepoints and human-readable names, sending the &#x60;emoji_code&#x60; in the data for the original reaction allows the Zulip server to correctly interpret your upvote as an upvote rather than a reaction with a \&quot;diffenent\&quot; emoji. 
         * @param {string} [reactionType] If an app is adding/removing a vote on an existing reaction, it should pass this parameter using the value the server provided for the existing reaction for specificity.  Supported values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode codepoint). * &#x60;realm_emoji&#x60;: Custom emoji. (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to    namespace the &#x60;zulip&#x60; emoji.  **Changes**: In Zulip 3.0 (feature level 2), this become optional for [custom emoji](/help/add-custom-emoji); previously, this endpoint assumed &#x60;unicode_emoji&#x60; if this parameter was not specified. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addReaction(messageId: number, emojiName: string, emojiCode?: string, reactionType?: string, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.addReaction(messageId, emojiName, emojiCode, reactionType, options).then((request) => request(axios, basePath));
        },
        /**
         * Check whether a set of messages match a [narrow](/api/construct-narrow).  `GET {{ api_url }}/v1/messages/matches_narrow`  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the `match_subject` and `match_content` objects is designed to match those of `GET /messages`, so that a client can splice these fields into a `message` object received from `GET /events` and end up with an extended message object identical to how a `GET /messages` for the current narrow would have returned the message. 
         * @summary Check if messages match a narrow
         * @param {Array<number>} msgIds List of IDs for the messages to check.
         * @param {Array<object>} narrow A structure defining the narrow to check against. See how to [construct a narrow](/api/construct-narrow).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMessagesMatchNarrow(msgIds: Array<number>, narrow: Array<object>, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.checkMessagesMatchNarrow(msgIds, narrow, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete a message.  `DELETE {{ api_url }}/v1/messages/{msg_id}`  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
         * @summary Delete a message
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.deleteMessage(messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a temporary URL for access to the file that doesn\'t require authentication. 
         * @summary Get public temporary URL
         * @param {number} realmIdStr The realm id. 
         * @param {string} filename Path to the URL. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileTemporaryUrl(realmIdStr: number, filename: string, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getFileTemporaryUrl(realmIdStr, filename, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the message edit history of a previously edited message.  `GET {{ api_url }}/v1/messages/{message_id}/history`  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
         * @summary Get a message\'s edit history
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageHistory(messageId: number, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getMessageHistory(messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch message history from a Zulip server.  `GET {{ api_url }}/v1/messages`  This `GET /api/v1/messages` endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip\'s powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user\'s message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an `anchor` message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the `num_before` and `num_after` limits.  We recommend using `num_before <= 1000` and `num_after <= 1000` to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
         * @summary Get messages
         * @param {number} numBefore The number of messages with IDs less than the anchor to retrieve. 
         * @param {number} numAfter The number of messages with IDs greater than the anchor to retrieve. 
         * @param {string | number} [anchor] Integer message ID to anchor fetching of new messages. Supports special string values for when the client wants the server to compute the anchor to use:  * &#x60;newest&#x60;: The most recent message. * &#x60;oldest&#x60;: The oldest message. * &#x60;first_unread&#x60;: The oldest unread message matching the   query, if any; otherwise, the most recent message.  The special values of &#x60;\&#39;newest\&#39;&#x60; and &#x60;\&#39;oldest\&#39;&#x60; are also supported for anchoring the query at the most recent or oldest messages.  **Changes**: String values are new in Zulip 3.0 (feature level 1).  The   &#x60;first_unread&#x60; functionality was supported in Zulip 2.1.x   and older by not sending anchor and using use_first_unread_anchor.    In Zulip 2.1.x and older, &#x60;oldest&#x60; can be emulated with   &#x60;anchor&#x3D;0&#x60;, and &#x60;newest&#x60; with &#x60;anchor&#x3D;10000000000000000&#x60;   (that specific large value works around a bug in Zulip   2.1.x and older in the &#x60;found_newest&#x60; return value). 
         * @param {Array<object>} [narrow] The narrow where you want to fetch the messages from. See how to [construct a narrow](/api/construct-narrow). 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [applyMarkdown] If &#x60;true&#x60;, message content is returned in the rendered HTML format. If &#x60;false&#x60;, message content is returned in the raw Markdown-format text that user entered. 
         * @param {boolean} [useFirstUnreadAnchor] Legacy way to specify &#x60;anchor&#x3D;\&quot;first_unread\&quot;&#x60; in Zulip 2.1.x and older.  Whether to use the (computed by the server) first unread message matching the narrow as the &#x60;anchor&#x60;.  Mutually exclusive with &#x60;anchor&#x60;.  **Changes**: Deprecated in Zulip 3.0, replaced by &#x60;anchor&#x3D;\&quot;first_unread\&quot;&#x60; instead. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessages(numBefore: number, numAfter: number, anchor?: string | number, narrow?: Array<object>, clientGravatar?: boolean, applyMarkdown?: boolean, useFirstUnreadAnchor?: boolean, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getMessages(numBefore, numAfter, anchor, narrow, clientGravatar, applyMarkdown, useFirstUnreadAnchor, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the raw content of a message.  `GET {{ api_url }}/v1/messages/{msg_id}`  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message\'s raw Markdown (e.g. for pre-filling a message-editing UI). 
         * @summary Get a message\'s raw Markdown
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawMessage(messageId: number, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getRawMessage(messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks all of the current user\'s unread messages as read.  `POST {{ api_url }}/v1/mark_all_as_read` 
         * @summary Mark all messages as read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllAsRead(options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.markAllAsRead(options).then((request) => request(axios, basePath));
        },
        /**
         * Mark all the unread messages in a stream as read. 
         * @summary Mark messages in a stream as read
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markStreamAsRead(streamId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.markStreamAsRead(streamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark all the unread messages in a topic as read. 
         * @summary Mark messages in a topic as read
         * @param {number} streamId The ID of the stream to access. 
         * @param {string} topicName The name of the topic whose messages should be marked as read. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markTopicAsRead(streamId: number, topicName: string, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.markTopicAsRead(streamId, topicName, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an [emoji reaction](/help/emoji-reactions) from a message.  `DELETE {{ api_url }}/v1/messages/{message_id}/reactions` 
         * @summary Remove an emoji reaction
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {string} [emojiName] The target emoji\&#39;s human-readable name.  To find an emoji\&#39;s name, hover over a message to reveal three icons on the right, then click the smiley face icon. Images of available reaction emojis appear. Hover over the emoji you want, and note that emoji\&#39;s text name. 
         * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For most API clients, you won\&#39;t need this, but it\&#39;s important for Zulip apps to handle rare corner cases when adding/removing votes on an emoji reaction added previously by another user.  If the existing reaction was added when the Zulip server was using a previous version of the emoji data mapping between Unicode codepoints and human-readable names, sending the &#x60;emoji_code&#x60; in the data for the original reaction allows the Zulip server to correctly interpret your upvote as an upvote rather than a reaction with a \&quot;diffenent\&quot; emoji. 
         * @param {string} [reactionType] If an app is adding/removing a vote on an existing reaction, it should pass this parameter using the value the server provided for the existing reaction for specificity.  Supported values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode codepoint). * &#x60;realm_emoji&#x60;: Custom emoji. (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to    namespace the &#x60;zulip&#x60; emoji.  **Changes**: In Zulip 3.0 (feature level 2), this become optional for [custom emoji](/help/add-custom-emoji); previously, this endpoint assumed &#x60;unicode_emoji&#x60; if this parameter was not specified. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReaction(messageId: number, emojiName?: string, emojiCode?: string, reactionType?: string, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.removeReaction(messageId, emojiName, emojiCode, reactionType, options).then((request) => request(axios, basePath));
        },
        /**
         * Render a message to HTML.  `POST {{ api_url }}/v1/messages/render` 
         * @summary Render message
         * @param {string} content The content of the message. Maximum message size of 10000 bytes. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderMessage(content: string, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.renderMessage(content, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a stream or a private message.  `POST {{ api_url }}/v1/messages` 
         * @summary Send a message
         * @param {'private' | 'stream'} type The type of message to be sent. &#x60;private&#x60; for a private message and &#x60;stream&#x60; for a stream message. 
         * @param {Array<number>} to For stream messages, either the name or integer ID of the stream. For private messages, either a list containing integer user IDs or a list containing string email addresses.  **Changes**: Support for using user/stream IDs was added in Zulip 2.0.0. 
         * @param {string} content The content of the message. Maximum message size of 10000 bytes. 
         * @param {string} [topic] The topic of the message. Only required for stream messages (&#x60;type&#x3D;\&quot;stream\&quot;&#x60;), ignored otherwise.  Maximum length of 60 characters.  **Changes**: New in Zulip 2.0.  Previous Zulip releases encoded this as &#x60;subject&#x60;, which is currently a deprecated alias. 
         * @param {string} [queueId] For clients supporting [local echo](https://zulip.readthedocs.io/en/latest/subsystems/sending-messages.html#local-echo), the [event queue](/api/register-queue) ID for the client.  If passed, &#x60;local_id&#x60; is required.  If the message is successfully sent, the server will include &#x60;local_id&#x60; in the &#x60;message&#x60; event that the client with this &#x60;queue_id&#x60; will receive notifying it of the new message via [&#x60;GET /events&#x60;](/api/get-events).  This lets the client know unambiguously that it should replace the locally echoed message, rather than adding this new message (which would be correct if the user had sent the new message from another device). 
         * @param {string} [localId] For clients supporting local echo, a unique string-format identifier chosen freely by the client; the server will pass it back to the client without inspecting it, as described in the &#x60;queue_id&#x60; description. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(type: 'private' | 'stream', to: Array<number>, content: string, topic?: string, queueId?: string, localId?: string, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.sendMessage(type, to, content, topic, queueId, localId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit/update the content or topic of a message.  `PATCH {{ api_url }}/v1/messages/{msg_id}`  `{msg_id}` in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to ` {original_topic}`.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
         * @summary Edit a message
         * @param {number} messageId The target message\&#39;s ID. 
         * @param {string} [topic] The topic to move the message(s) to, to request changing the topic. Should only be sent when changing the topic, and will throw an error if the target message is not a stream message.  Maximum length of 60 characters.  **Changes**: New in Zulip 2.0.  Previous Zulip releases encoded this as &#x60;subject&#x60;, which is currently a deprecated alias. 
         * @param {'change_one' | 'change_later' | 'change_all'} [propagateMode] Which message(s) should be edited: just the one indicated in &#x60;message_id&#x60;, messages in the same topic that had been sent after this one, or all of them.  Only the default value of &#x60;change_one&#x60; is valid when editing only the content of a message.  This parameter determines both which messages get moved and also whether clients that are currently narrowed to the topic containing the message should navigate or adjust their compose box recipient to point to the post-edit stream/topic. 
         * @param {boolean} [sendNotificationToOldThread] Whether to send breadcrumb message to the old thread to notify users where the messages were moved to.  **Changes**: New in Zulip 3.0 (feature level 9). 
         * @param {boolean} [sendNotificationToNewThread] Whether to send a notification message to the new thread to notify users where the messages came from.  **Changes**: New in Zulip 3.0 (feature level 9). 
         * @param {string} [content] The content of the message. Maximum message size of 10000 bytes. 
         * @param {number} [streamId] The stream ID to move the message(s) to, to request moving messages to another stream.  Should only be sent when changing the stream, and will throw an error if the target message is not a stream message. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(messageId: number, topic?: string, propagateMode?: 'change_one' | 'change_later' | 'change_all', sendNotificationToOldThread?: boolean, sendNotificationToNewThread?: boolean, content?: string, streamId?: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.updateMessage(messageId, topic, propagateMode, sendNotificationToOldThread, sendNotificationToNewThread, content, streamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add or remove personal message flags like `read` and `starred` on a collection of message IDs.  `POST {{ api_url }}/v1/messages/flags`  For updating the `read` flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
         * @summary Update personal message flags
         * @param {Array<number>} messages An array containing the IDs of the target messages. 
         * @param {'add' | 'remove'} op Whether to &#x60;add&#x60; the flag or &#x60;remove&#x60; it. 
         * @param {string} flag The flag that should be added/removed. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessageFlags(messages: Array<number>, op: 'add' | 'remove', flag: string, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.updateMessageFlags(messages, op, flag, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a single file and get the corresponding URI.  `POST {{ api_url }}/v1/user_uploads`  Initially, only you will be able to access the link.  To share the uploaded file, you\'ll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
         * @summary Upload a file
         * @param {any} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(filename?: any, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.uploadFile(filename, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * Add an [emoji reaction](/help/emoji-reactions) to a message.  `POST {{ api_url }}/v1/messages/{message_id}/reactions` 
     * @summary Add an emoji reaction
     * @param {number} messageId The target message\&#39;s ID. 
     * @param {string} emojiName The target emoji\&#39;s human-readable name.  To find an emoji\&#39;s name, hover over a message to reveal three icons on the right, then click the smiley face icon. Images of available reaction emojis appear. Hover over the emoji you want, and note that emoji\&#39;s text name. 
     * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For most API clients, you won\&#39;t need this, but it\&#39;s important for Zulip apps to handle rare corner cases when adding/removing votes on an emoji reaction added previously by another user.  If the existing reaction was added when the Zulip server was using a previous version of the emoji data mapping between Unicode codepoints and human-readable names, sending the &#x60;emoji_code&#x60; in the data for the original reaction allows the Zulip server to correctly interpret your upvote as an upvote rather than a reaction with a \&quot;diffenent\&quot; emoji. 
     * @param {string} [reactionType] If an app is adding/removing a vote on an existing reaction, it should pass this parameter using the value the server provided for the existing reaction for specificity.  Supported values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode codepoint). * &#x60;realm_emoji&#x60;: Custom emoji. (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to    namespace the &#x60;zulip&#x60; emoji.  **Changes**: In Zulip 3.0 (feature level 2), this become optional for [custom emoji](/help/add-custom-emoji); previously, this endpoint assumed &#x60;unicode_emoji&#x60; if this parameter was not specified. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public addReaction(messageId: number, emojiName: string, emojiCode?: string, reactionType?: string, options?: any) {
        return MessagesApiFp(this.configuration).addReaction(messageId, emojiName, emojiCode, reactionType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check whether a set of messages match a [narrow](/api/construct-narrow).  `GET {{ api_url }}/v1/messages/matches_narrow`  For many common narrows (E.g. a topic), clients can write an efficient client-side check to determine whether a newly arrived message belongs in the view.  This endpoint is designed to allow clients to handle more complex narrows for which the client does not (or in the case of full-text search, cannot) implement this check.  The format of the `match_subject` and `match_content` objects is designed to match those of `GET /messages`, so that a client can splice these fields into a `message` object received from `GET /events` and end up with an extended message object identical to how a `GET /messages` for the current narrow would have returned the message. 
     * @summary Check if messages match a narrow
     * @param {Array<number>} msgIds List of IDs for the messages to check.
     * @param {Array<object>} narrow A structure defining the narrow to check against. See how to [construct a narrow](/api/construct-narrow).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public checkMessagesMatchNarrow(msgIds: Array<number>, narrow: Array<object>, options?: any) {
        return MessagesApiFp(this.configuration).checkMessagesMatchNarrow(msgIds, narrow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete a message.  `DELETE {{ api_url }}/v1/messages/{msg_id}`  This API corresponds to the [delete a message completely][delete-completely] feature documented in the Zulip Help Center.  [delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely 
     * @summary Delete a message
     * @param {number} messageId The target message\&#39;s ID. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public deleteMessage(messageId: number, options?: any) {
        return MessagesApiFp(this.configuration).deleteMessage(messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a temporary URL for access to the file that doesn\'t require authentication. 
     * @summary Get public temporary URL
     * @param {number} realmIdStr The realm id. 
     * @param {string} filename Path to the URL. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getFileTemporaryUrl(realmIdStr: number, filename: string, options?: any) {
        return MessagesApiFp(this.configuration).getFileTemporaryUrl(realmIdStr, filename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch the message edit history of a previously edited message.  `GET {{ api_url }}/v1/messages/{message_id}/history`  Note that edit history may be disabled in some organizations; see the [Zulip Help Center documentation on editing messages][edit-settings].  [edit-settings]: /help/view-a-messages-edit-history 
     * @summary Get a message\'s edit history
     * @param {number} messageId The target message\&#39;s ID. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessageHistory(messageId: number, options?: any) {
        return MessagesApiFp(this.configuration).getMessageHistory(messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch message history from a Zulip server.  `GET {{ api_url }}/v1/messages`  This `GET /api/v1/messages` endpoint is the primary way to fetch message history from a Zulip server.  It is useful both for Zulip clients (e.g. the web, desktop, mobile, and terminal clients) as well as bots, API clients, backup scripts, etc.  By specifying a [narrow filter](/api/construct-narrow), you can use this endpoint to fetch the messages matching any search query that is supported by Zulip\'s powerful full-text search backend.  When a narrow is not specified, it can be used to fetch a user\'s message history. (We recommend paginating to 1000 messages at a time.)  In either case, you specify an `anchor` message (or ask the server to calculate the first unread message for you and use that as the anchor), as well as a number of messages before and after the anchor message.  The server returns those messages, sorted by message ID, as well as some metadata that makes it easy for a client to determine whether there are more messages matching the query that were not returned due to the `num_before` and `num_after` limits.  We recommend using `num_before <= 1000` and `num_after <= 1000` to avoid generating very large HTTP responses. A maximum of 5000 messages can be obtained per request; attempting to exceed this will result in an error. 
     * @summary Get messages
     * @param {number} numBefore The number of messages with IDs less than the anchor to retrieve. 
     * @param {number} numAfter The number of messages with IDs greater than the anchor to retrieve. 
     * @param {string | number} [anchor] Integer message ID to anchor fetching of new messages. Supports special string values for when the client wants the server to compute the anchor to use:  * &#x60;newest&#x60;: The most recent message. * &#x60;oldest&#x60;: The oldest message. * &#x60;first_unread&#x60;: The oldest unread message matching the   query, if any; otherwise, the most recent message.  The special values of &#x60;\&#39;newest\&#39;&#x60; and &#x60;\&#39;oldest\&#39;&#x60; are also supported for anchoring the query at the most recent or oldest messages.  **Changes**: String values are new in Zulip 3.0 (feature level 1).  The   &#x60;first_unread&#x60; functionality was supported in Zulip 2.1.x   and older by not sending anchor and using use_first_unread_anchor.    In Zulip 2.1.x and older, &#x60;oldest&#x60; can be emulated with   &#x60;anchor&#x3D;0&#x60;, and &#x60;newest&#x60; with &#x60;anchor&#x3D;10000000000000000&#x60;   (that specific large value works around a bug in Zulip   2.1.x and older in the &#x60;found_newest&#x60; return value). 
     * @param {Array<object>} [narrow] The narrow where you want to fetch the messages from. See how to [construct a narrow](/api/construct-narrow). 
     * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
     * @param {boolean} [applyMarkdown] If &#x60;true&#x60;, message content is returned in the rendered HTML format. If &#x60;false&#x60;, message content is returned in the raw Markdown-format text that user entered. 
     * @param {boolean} [useFirstUnreadAnchor] Legacy way to specify &#x60;anchor&#x3D;\&quot;first_unread\&quot;&#x60; in Zulip 2.1.x and older.  Whether to use the (computed by the server) first unread message matching the narrow as the &#x60;anchor&#x60;.  Mutually exclusive with &#x60;anchor&#x60;.  **Changes**: Deprecated in Zulip 3.0, replaced by &#x60;anchor&#x3D;\&quot;first_unread\&quot;&#x60; instead. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessages(numBefore: number, numAfter: number, anchor?: string | number, narrow?: Array<object>, clientGravatar?: boolean, applyMarkdown?: boolean, useFirstUnreadAnchor?: boolean, options?: any) {
        return MessagesApiFp(this.configuration).getMessages(numBefore, numAfter, anchor, narrow, clientGravatar, applyMarkdown, useFirstUnreadAnchor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the raw content of a message.  `GET {{ api_url }}/v1/messages/{msg_id}`  This is a rarely-used endpoint relevant for clients that primarily work with HTML-rendered messages but might need to occasionally fetch the message\'s raw Markdown (e.g. for pre-filling a message-editing UI). 
     * @summary Get a message\'s raw Markdown
     * @param {number} messageId The target message\&#39;s ID. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getRawMessage(messageId: number, options?: any) {
        return MessagesApiFp(this.configuration).getRawMessage(messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks all of the current user\'s unread messages as read.  `POST {{ api_url }}/v1/mark_all_as_read` 
     * @summary Mark all messages as read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public markAllAsRead(options?: any) {
        return MessagesApiFp(this.configuration).markAllAsRead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark all the unread messages in a stream as read. 
     * @summary Mark messages in a stream as read
     * @param {number} streamId The ID of the stream to access. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public markStreamAsRead(streamId: number, options?: any) {
        return MessagesApiFp(this.configuration).markStreamAsRead(streamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark all the unread messages in a topic as read. 
     * @summary Mark messages in a topic as read
     * @param {number} streamId The ID of the stream to access. 
     * @param {string} topicName The name of the topic whose messages should be marked as read. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public markTopicAsRead(streamId: number, topicName: string, options?: any) {
        return MessagesApiFp(this.configuration).markTopicAsRead(streamId, topicName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an [emoji reaction](/help/emoji-reactions) from a message.  `DELETE {{ api_url }}/v1/messages/{message_id}/reactions` 
     * @summary Remove an emoji reaction
     * @param {number} messageId The target message\&#39;s ID. 
     * @param {string} [emojiName] The target emoji\&#39;s human-readable name.  To find an emoji\&#39;s name, hover over a message to reveal three icons on the right, then click the smiley face icon. Images of available reaction emojis appear. Hover over the emoji you want, and note that emoji\&#39;s text name. 
     * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For most API clients, you won\&#39;t need this, but it\&#39;s important for Zulip apps to handle rare corner cases when adding/removing votes on an emoji reaction added previously by another user.  If the existing reaction was added when the Zulip server was using a previous version of the emoji data mapping between Unicode codepoints and human-readable names, sending the &#x60;emoji_code&#x60; in the data for the original reaction allows the Zulip server to correctly interpret your upvote as an upvote rather than a reaction with a \&quot;diffenent\&quot; emoji. 
     * @param {string} [reactionType] If an app is adding/removing a vote on an existing reaction, it should pass this parameter using the value the server provided for the existing reaction for specificity.  Supported values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode codepoint). * &#x60;realm_emoji&#x60;: Custom emoji. (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to    namespace the &#x60;zulip&#x60; emoji.  **Changes**: In Zulip 3.0 (feature level 2), this become optional for [custom emoji](/help/add-custom-emoji); previously, this endpoint assumed &#x60;unicode_emoji&#x60; if this parameter was not specified. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public removeReaction(messageId: number, emojiName?: string, emojiCode?: string, reactionType?: string, options?: any) {
        return MessagesApiFp(this.configuration).removeReaction(messageId, emojiName, emojiCode, reactionType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Render a message to HTML.  `POST {{ api_url }}/v1/messages/render` 
     * @summary Render message
     * @param {string} content The content of the message. Maximum message size of 10000 bytes. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public renderMessage(content: string, options?: any) {
        return MessagesApiFp(this.configuration).renderMessage(content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a stream or a private message.  `POST {{ api_url }}/v1/messages` 
     * @summary Send a message
     * @param {'private' | 'stream'} type The type of message to be sent. &#x60;private&#x60; for a private message and &#x60;stream&#x60; for a stream message. 
     * @param {Array<number>} to For stream messages, either the name or integer ID of the stream. For private messages, either a list containing integer user IDs or a list containing string email addresses.  **Changes**: Support for using user/stream IDs was added in Zulip 2.0.0. 
     * @param {string} content The content of the message. Maximum message size of 10000 bytes. 
     * @param {string} [topic] The topic of the message. Only required for stream messages (&#x60;type&#x3D;\&quot;stream\&quot;&#x60;), ignored otherwise.  Maximum length of 60 characters.  **Changes**: New in Zulip 2.0.  Previous Zulip releases encoded this as &#x60;subject&#x60;, which is currently a deprecated alias. 
     * @param {string} [queueId] For clients supporting [local echo](https://zulip.readthedocs.io/en/latest/subsystems/sending-messages.html#local-echo), the [event queue](/api/register-queue) ID for the client.  If passed, &#x60;local_id&#x60; is required.  If the message is successfully sent, the server will include &#x60;local_id&#x60; in the &#x60;message&#x60; event that the client with this &#x60;queue_id&#x60; will receive notifying it of the new message via [&#x60;GET /events&#x60;](/api/get-events).  This lets the client know unambiguously that it should replace the locally echoed message, rather than adding this new message (which would be correct if the user had sent the new message from another device). 
     * @param {string} [localId] For clients supporting local echo, a unique string-format identifier chosen freely by the client; the server will pass it back to the client without inspecting it, as described in the &#x60;queue_id&#x60; description. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public sendMessage(type: 'private' | 'stream', to: Array<number>, content: string, topic?: string, queueId?: string, localId?: string, options?: any) {
        return MessagesApiFp(this.configuration).sendMessage(type, to, content, topic, queueId, localId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit/update the content or topic of a message.  `PATCH {{ api_url }}/v1/messages/{msg_id}`  `{msg_id}` in the above URL should be replaced with the ID of the message you wish you update.  You can [resolve topics](/help/resolve-a-topic) by editing the topic to ` {original_topic}`.  **Note**: See [configuring message editing][config-message-editing] for detailed documentation on when users are allowed to edit topics.  [config-message-editing]: /help/configure-message-editing-and-deletion 
     * @summary Edit a message
     * @param {number} messageId The target message\&#39;s ID. 
     * @param {string} [topic] The topic to move the message(s) to, to request changing the topic. Should only be sent when changing the topic, and will throw an error if the target message is not a stream message.  Maximum length of 60 characters.  **Changes**: New in Zulip 2.0.  Previous Zulip releases encoded this as &#x60;subject&#x60;, which is currently a deprecated alias. 
     * @param {'change_one' | 'change_later' | 'change_all'} [propagateMode] Which message(s) should be edited: just the one indicated in &#x60;message_id&#x60;, messages in the same topic that had been sent after this one, or all of them.  Only the default value of &#x60;change_one&#x60; is valid when editing only the content of a message.  This parameter determines both which messages get moved and also whether clients that are currently narrowed to the topic containing the message should navigate or adjust their compose box recipient to point to the post-edit stream/topic. 
     * @param {boolean} [sendNotificationToOldThread] Whether to send breadcrumb message to the old thread to notify users where the messages were moved to.  **Changes**: New in Zulip 3.0 (feature level 9). 
     * @param {boolean} [sendNotificationToNewThread] Whether to send a notification message to the new thread to notify users where the messages came from.  **Changes**: New in Zulip 3.0 (feature level 9). 
     * @param {string} [content] The content of the message. Maximum message size of 10000 bytes. 
     * @param {number} [streamId] The stream ID to move the message(s) to, to request moving messages to another stream.  Should only be sent when changing the stream, and will throw an error if the target message is not a stream message. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public updateMessage(messageId: number, topic?: string, propagateMode?: 'change_one' | 'change_later' | 'change_all', sendNotificationToOldThread?: boolean, sendNotificationToNewThread?: boolean, content?: string, streamId?: number, options?: any) {
        return MessagesApiFp(this.configuration).updateMessage(messageId, topic, propagateMode, sendNotificationToOldThread, sendNotificationToNewThread, content, streamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add or remove personal message flags like `read` and `starred` on a collection of message IDs.  `POST {{ api_url }}/v1/messages/flags`  For updating the `read` flag on common collections of messages, see also the [special endpoints for marking message as read in bulk](/api/mark-all-as-read). 
     * @summary Update personal message flags
     * @param {Array<number>} messages An array containing the IDs of the target messages. 
     * @param {'add' | 'remove'} op Whether to &#x60;add&#x60; the flag or &#x60;remove&#x60; it. 
     * @param {string} flag The flag that should be added/removed. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public updateMessageFlags(messages: Array<number>, op: 'add' | 'remove', flag: string, options?: any) {
        return MessagesApiFp(this.configuration).updateMessageFlags(messages, op, flag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a single file and get the corresponding URI.  `POST {{ api_url }}/v1/user_uploads`  Initially, only you will be able to access the link.  To share the uploaded file, you\'ll need to [send a message][send-message] containing the resulting link.  Users who can already access the link can reshare it with other users by sending additional Zulip messages containing the link.  [uploaded-files]: /help/manage-your-uploaded-files [send-message]: /api/send-message 
     * @summary Upload a file
     * @param {any} [filename] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public uploadFile(filename?: any, options?: any) {
        return MessagesApiFp(this.configuration).uploadFile(filename, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RealTimeEventsApi - axios parameter creator
 * @export
 */
export const RealTimeEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a previously registered queue.  `DELETE {{ api_url }}/v1/events` 
         * @summary Delete an event queue
         * @param {string} queueId The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue: async (queueId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueId' is not null or undefined
            assertParamExists('deleteQueue', 'queueId', queueId)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (queueId !== undefined) {
                localVarQueryParameter['queue_id'] = queueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * `GET {{ api_url }}/v1/events`  This endpoint allows you to receive new events from [a registered event queue](/api/register-queue).  Long-lived clients should use the `event_queue_longpoll_timeout_seconds` property returned by `POST /register` as the client-side HTTP request timeout for calls to this endpoint.  It is guaranteed to be higher than heartbeat frequency and should be respected by clients to avoid breaking when heartbeat frequency increases. 
         * @summary Get events from an event queue
         * @param {string} queueId The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). 
         * @param {number} [lastEventId] The highest event ID in this queue that you\&#39;ve received and wish to acknowledge. See the [code for &#x60;call_on_each_event&#x60;](https://github.com/zulip/python-zulip-api/blob/master/zulip/zulip/__init__.py) in the [zulip Python module](https://github.com/zulip/python-zulip-api) for an example implementation of correctly processing each event exactly once. 
         * @param {boolean} [dontBlock] Set to &#x60;true&#x60; if the client is requesting a nonblocking reply. If not specified, the request will block until either a new event is available or a few minutes have passed, in which case the server will send the client a heartbeat event. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (queueId: string, lastEventId?: number, dontBlock?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueId' is not null or undefined
            assertParamExists('getEvents', 'queueId', queueId)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (queueId !== undefined) {
                localVarQueryParameter['queue_id'] = queueId;
            }

            if (lastEventId !== undefined) {
                localVarQueryParameter['last_event_id'] = lastEventId;
            }

            if (dontBlock !== undefined) {
                localVarQueryParameter['dont_block'] = dontBlock;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (Ignored) 
         * @param {Array<string>} [eventTypes] A JSON-encoded array indicating which types of events you\&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[\&#39;message\&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
         * @param {Array<Array<string>>} [narrow] A JSON-encoded array of arrays of length 2 indicating the narrow for which you\&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[\&#39;stream\&#39;, \&#39;Denmark\&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[\&#39;is\&#39;, \&#39;private\&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;. 
         * @param {boolean} [allPublicStreams] Whether you would like to request message events from all public streams.  Useful for workflow bots that you\&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        realTimePost: async (eventTypes?: Array<string>, narrow?: Array<Array<string>>, allPublicStreams?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/real-time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventTypes) {
                localVarQueryParameter['event_types'] = eventTypes;
            }

            if (narrow) {
                localVarQueryParameter['narrow'] = narrow;
            }

            if (allPublicStreams !== undefined) {
                localVarQueryParameter['all_public_streams'] = allPublicStreams;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * `POST {{ api_url }}/v1/register`  This powerful endpoint can be used to register a Zulip \"event queue\" (subscribed to certain types of \"events\", or updates to the messages and other Zulip data the current user has access to), as well as to fetch the current state of that data.  (`register` also powers the `call_on_each_event` Python API, and is intended primarily for complex applications for which the more convenient `call_on_each_event` API is insufficient).  This endpoint returns a `queue_id` and a `last_event_id`; these can be used in subsequent calls to the [\"events\" endpoint](/api/get-events) to request events from the Zulip server using long-polling.  The server will queue events for up to 10 minutes of inactivity. After 10 minutes, your event queue will be garbage-collected.  The server will send `heartbeat` events every minute, which makes it easy to implement a robust client that does not miss events unless the client loses network connectivity with the Zulip server for 10 minutes or longer.  Once the server garbage-collects your event queue, the server will [return an error](/api/get-events#bad_event_queue_id-errors) with a code of `BAD_EVENT_QUEUE_ID` if you try to fetch events from the event queue.  Your software will need to handle that error condition by re-initializing itself (e.g. this is what triggers your browser reloading the Zulip web app when your laptop comes back online after being offline for more than 10 minutes).  When prototyping with this API, we recommend first calling `register` with no `event_types` parameter to see all the available data from all supported event types.  Before using your client in production, you should set appropriate `event_types` and `fetch_event_types` filters so that your client only requests the data it needs.  A few minutes doing this often saves 90% of the total bandwidth and other resources consumed by a client using this API.  See the [events system developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/events-system.html) if you need deeper details about how the Zulip event queue system works, avoids clients needing to worry about large classes of potentially messy races, etc. 
         * @summary Register an event queue
         * @param {boolean} [applyMarkdown] Set to &#x60;true&#x60; if you would like the content to be rendered in HTML format (otherwise the API will return the raw text that the user entered) 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [slimPresence] Setting this to &#x60;true&#x60; will make presence dictionaries be keyed by user_id instead of email.  **Changes**: New in Zulip 3.0 (Unstable with no feature level yet). 
         * @param {Array<string>} [eventTypes] A JSON-encoded array indicating which types of events you\&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[\&#39;message\&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
         * @param {boolean} [allPublicStreams] Whether you would like to request message events from all public streams.  Useful for workflow bots that you\&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams). 
         * @param {boolean} [includeSubscribers] Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
         * @param {object} [clientCapabilities] Dictionary containing details on features the client supports that are relevant to the format of responses sent by the server.  * &#x60;notification_settings_null&#x60;: Boolean for whether the   client can handle the current API with null values for   stream-level notification settings (which means the stream   is not customized and should inherit the user\&#39;s global   notification settings for stream messages).   &lt;br /&gt;   New in Zulip 2.1.0; in earlier Zulip releases, stream-level   notification settings were simple booleans.  * &#x60;bulk_message_deletion&#x60;: Boolean for whether the client\&#39;s    handler for the &#x60;delete_message&#x60; event type has been    updated to process the new bulk format (with a    &#x60;message_ids&#x60;, rather than a singleton &#x60;message_id&#x60;).    Otherwise, the server will send &#x60;delete_message&#x60; events    in a loop.    &lt;br /&gt;    New in Zulip 3.0 (feature level 13).  This    capability is for backwards-compatibility; it will be    required in a future server release.  * &#x60;user_avatar_url_field_optional&#x60;: Boolean for whether the    client required avatar URLs for all users, or supports    using &#x60;GET /avatar/{user_id}&#x60; to access user avatars.  If the    client has this capability, the server may skip sending a    &#x60;avatar_url&#x60; field in the &#x60;realm_user&#x60; at its sole discretion    to optimize network performance.  This is an important optimization    in organizations with 10,000s of users.    &lt;br /&gt;    New in Zulip 3.0 (feature level 18).  * &#x60;stream_typing_notifications&#x60;: Boolean for whether the client   supports stream typing notifications.   &lt;br /&gt;   New in Zulip 4.0 (feature level 58).  This capability is   for backwards-compatibility; it will be required in a   future server release.  * &#x60;user_settings_object&#x60;: Boolean for whether the client supports the modern   &#x60;user_settings&#x60; event type. If False, the server will additionally send the   legacy &#x60;update_display_settings&#x60; and &#x60;update_global_notifications&#x60; event   types for backwards-compatibility with clients that predate this API migration.   &lt;br /&gt;   &lt;br /&gt;   Because the feature level 89 API changes were merged together, clients can   safely make a request with this client capability and requesting all of the   &#x60;user_settings&#x60;, &#x60;update_display_settings&#x60;, and   &#x60;update_global_notifications&#x60; event types, and get exactly one copy of   settings data on any server version. (And then use the &#x60;zulip_feature_level&#x60;   in the &#x60;/register&#x60; response or the presence/absence of a &#x60;user_settings&#x60; key   to determine where to look).   &lt;br /&gt;   New in Zulip 5.0 (feature level 89).  This capability is for   backwards-compatibility; it will be removed in a future server release. 
         * @param {Array<string>} [fetchEventTypes] Same as the &#x60;event_types&#x60; parameter except that the values in &#x60;fetch_event_types&#x60; are used to fetch initial data. If &#x60;fetch_event_types&#x60; is not provided, &#x60;event_types&#x60; is used and if &#x60;event_types&#x60; is not provided, this parameter defaults to &#x60;None&#x60;.  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
         * @param {Array<Array<string>>} [narrow] A JSON-encoded array of arrays of length 2 indicating the narrow for which you\&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[\&#39;stream\&#39;, \&#39;Denmark\&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[\&#39;is\&#39;, \&#39;private\&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerQueue: async (applyMarkdown?: boolean, clientGravatar?: boolean, slimPresence?: boolean, eventTypes?: Array<string>, allPublicStreams?: boolean, includeSubscribers?: boolean, clientCapabilities?: object, fetchEventTypes?: Array<string>, narrow?: Array<Array<string>>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applyMarkdown !== undefined) {
                localVarQueryParameter['apply_markdown'] = applyMarkdown;
            }

            if (clientGravatar !== undefined) {
                localVarQueryParameter['client_gravatar'] = clientGravatar;
            }

            if (slimPresence !== undefined) {
                localVarQueryParameter['slim_presence'] = slimPresence;
            }

            if (eventTypes) {
                localVarQueryParameter['event_types'] = eventTypes;
            }

            if (allPublicStreams !== undefined) {
                localVarQueryParameter['all_public_streams'] = allPublicStreams;
            }

            if (includeSubscribers !== undefined) {
                localVarQueryParameter['include_subscribers'] = includeSubscribers;
            }

            if (clientCapabilities !== undefined) {
                localVarQueryParameter['client_capabilities'] = clientCapabilities;
            }

            if (fetchEventTypes) {
                localVarQueryParameter['fetch_event_types'] = fetchEventTypes;
            }

            if (narrow) {
                localVarQueryParameter['narrow'] = narrow;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Common error to many endpoints 
         * @summary Error handling
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restErrorHandling: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest-error-handling`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealTimeEventsApi - functional programming interface
 * @export
 */
export const RealTimeEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RealTimeEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a previously registered queue.  `DELETE {{ api_url }}/v1/events` 
         * @summary Delete an event queue
         * @param {string} queueId The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQueue(queueId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQueue(queueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * `GET {{ api_url }}/v1/events`  This endpoint allows you to receive new events from [a registered event queue](/api/register-queue).  Long-lived clients should use the `event_queue_longpoll_timeout_seconds` property returned by `POST /register` as the client-side HTTP request timeout for calls to this endpoint.  It is guaranteed to be higher than heartbeat frequency and should be respected by clients to avoid breaking when heartbeat frequency increases. 
         * @summary Get events from an event queue
         * @param {string} queueId The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). 
         * @param {number} [lastEventId] The highest event ID in this queue that you\&#39;ve received and wish to acknowledge. See the [code for &#x60;call_on_each_event&#x60;](https://github.com/zulip/python-zulip-api/blob/master/zulip/zulip/__init__.py) in the [zulip Python module](https://github.com/zulip/python-zulip-api) for an example implementation of correctly processing each event exactly once. 
         * @param {boolean} [dontBlock] Set to &#x60;true&#x60; if the client is requesting a nonblocking reply. If not specified, the request will block until either a new event is available or a few minutes have passed, in which case the server will send the client a heartbeat event. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(queueId: string, lastEventId?: number, dontBlock?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(queueId, lastEventId, dontBlock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (Ignored) 
         * @param {Array<string>} [eventTypes] A JSON-encoded array indicating which types of events you\&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[\&#39;message\&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
         * @param {Array<Array<string>>} [narrow] A JSON-encoded array of arrays of length 2 indicating the narrow for which you\&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[\&#39;stream\&#39;, \&#39;Denmark\&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[\&#39;is\&#39;, \&#39;private\&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;. 
         * @param {boolean} [allPublicStreams] Whether you would like to request message events from all public streams.  Useful for workflow bots that you\&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async realTimePost(eventTypes?: Array<string>, narrow?: Array<Array<string>>, allPublicStreams?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.realTimePost(eventTypes, narrow, allPublicStreams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * `POST {{ api_url }}/v1/register`  This powerful endpoint can be used to register a Zulip \"event queue\" (subscribed to certain types of \"events\", or updates to the messages and other Zulip data the current user has access to), as well as to fetch the current state of that data.  (`register` also powers the `call_on_each_event` Python API, and is intended primarily for complex applications for which the more convenient `call_on_each_event` API is insufficient).  This endpoint returns a `queue_id` and a `last_event_id`; these can be used in subsequent calls to the [\"events\" endpoint](/api/get-events) to request events from the Zulip server using long-polling.  The server will queue events for up to 10 minutes of inactivity. After 10 minutes, your event queue will be garbage-collected.  The server will send `heartbeat` events every minute, which makes it easy to implement a robust client that does not miss events unless the client loses network connectivity with the Zulip server for 10 minutes or longer.  Once the server garbage-collects your event queue, the server will [return an error](/api/get-events#bad_event_queue_id-errors) with a code of `BAD_EVENT_QUEUE_ID` if you try to fetch events from the event queue.  Your software will need to handle that error condition by re-initializing itself (e.g. this is what triggers your browser reloading the Zulip web app when your laptop comes back online after being offline for more than 10 minutes).  When prototyping with this API, we recommend first calling `register` with no `event_types` parameter to see all the available data from all supported event types.  Before using your client in production, you should set appropriate `event_types` and `fetch_event_types` filters so that your client only requests the data it needs.  A few minutes doing this often saves 90% of the total bandwidth and other resources consumed by a client using this API.  See the [events system developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/events-system.html) if you need deeper details about how the Zulip event queue system works, avoids clients needing to worry about large classes of potentially messy races, etc. 
         * @summary Register an event queue
         * @param {boolean} [applyMarkdown] Set to &#x60;true&#x60; if you would like the content to be rendered in HTML format (otherwise the API will return the raw text that the user entered) 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [slimPresence] Setting this to &#x60;true&#x60; will make presence dictionaries be keyed by user_id instead of email.  **Changes**: New in Zulip 3.0 (Unstable with no feature level yet). 
         * @param {Array<string>} [eventTypes] A JSON-encoded array indicating which types of events you\&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[\&#39;message\&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
         * @param {boolean} [allPublicStreams] Whether you would like to request message events from all public streams.  Useful for workflow bots that you\&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams). 
         * @param {boolean} [includeSubscribers] Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
         * @param {object} [clientCapabilities] Dictionary containing details on features the client supports that are relevant to the format of responses sent by the server.  * &#x60;notification_settings_null&#x60;: Boolean for whether the   client can handle the current API with null values for   stream-level notification settings (which means the stream   is not customized and should inherit the user\&#39;s global   notification settings for stream messages).   &lt;br /&gt;   New in Zulip 2.1.0; in earlier Zulip releases, stream-level   notification settings were simple booleans.  * &#x60;bulk_message_deletion&#x60;: Boolean for whether the client\&#39;s    handler for the &#x60;delete_message&#x60; event type has been    updated to process the new bulk format (with a    &#x60;message_ids&#x60;, rather than a singleton &#x60;message_id&#x60;).    Otherwise, the server will send &#x60;delete_message&#x60; events    in a loop.    &lt;br /&gt;    New in Zulip 3.0 (feature level 13).  This    capability is for backwards-compatibility; it will be    required in a future server release.  * &#x60;user_avatar_url_field_optional&#x60;: Boolean for whether the    client required avatar URLs for all users, or supports    using &#x60;GET /avatar/{user_id}&#x60; to access user avatars.  If the    client has this capability, the server may skip sending a    &#x60;avatar_url&#x60; field in the &#x60;realm_user&#x60; at its sole discretion    to optimize network performance.  This is an important optimization    in organizations with 10,000s of users.    &lt;br /&gt;    New in Zulip 3.0 (feature level 18).  * &#x60;stream_typing_notifications&#x60;: Boolean for whether the client   supports stream typing notifications.   &lt;br /&gt;   New in Zulip 4.0 (feature level 58).  This capability is   for backwards-compatibility; it will be required in a   future server release.  * &#x60;user_settings_object&#x60;: Boolean for whether the client supports the modern   &#x60;user_settings&#x60; event type. If False, the server will additionally send the   legacy &#x60;update_display_settings&#x60; and &#x60;update_global_notifications&#x60; event   types for backwards-compatibility with clients that predate this API migration.   &lt;br /&gt;   &lt;br /&gt;   Because the feature level 89 API changes were merged together, clients can   safely make a request with this client capability and requesting all of the   &#x60;user_settings&#x60;, &#x60;update_display_settings&#x60;, and   &#x60;update_global_notifications&#x60; event types, and get exactly one copy of   settings data on any server version. (And then use the &#x60;zulip_feature_level&#x60;   in the &#x60;/register&#x60; response or the presence/absence of a &#x60;user_settings&#x60; key   to determine where to look).   &lt;br /&gt;   New in Zulip 5.0 (feature level 89).  This capability is for   backwards-compatibility; it will be removed in a future server release. 
         * @param {Array<string>} [fetchEventTypes] Same as the &#x60;event_types&#x60; parameter except that the values in &#x60;fetch_event_types&#x60; are used to fetch initial data. If &#x60;fetch_event_types&#x60; is not provided, &#x60;event_types&#x60; is used and if &#x60;event_types&#x60; is not provided, this parameter defaults to &#x60;None&#x60;.  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
         * @param {Array<Array<string>>} [narrow] A JSON-encoded array of arrays of length 2 indicating the narrow for which you\&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[\&#39;stream\&#39;, \&#39;Denmark\&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[\&#39;is\&#39;, \&#39;private\&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerQueue(applyMarkdown?: boolean, clientGravatar?: boolean, slimPresence?: boolean, eventTypes?: Array<string>, allPublicStreams?: boolean, includeSubscribers?: boolean, clientCapabilities?: object, fetchEventTypes?: Array<string>, narrow?: Array<Array<string>>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerQueue(applyMarkdown, clientGravatar, slimPresence, eventTypes, allPublicStreams, includeSubscribers, clientCapabilities, fetchEventTypes, narrow, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Common error to many endpoints 
         * @summary Error handling
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restErrorHandling(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restErrorHandling(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RealTimeEventsApi - factory interface
 * @export
 */
export const RealTimeEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealTimeEventsApiFp(configuration)
    return {
        /**
         * Delete a previously registered queue.  `DELETE {{ api_url }}/v1/events` 
         * @summary Delete an event queue
         * @param {string} queueId The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(queueId: string, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.deleteQueue(queueId, options).then((request) => request(axios, basePath));
        },
        /**
         * `GET {{ api_url }}/v1/events`  This endpoint allows you to receive new events from [a registered event queue](/api/register-queue).  Long-lived clients should use the `event_queue_longpoll_timeout_seconds` property returned by `POST /register` as the client-side HTTP request timeout for calls to this endpoint.  It is guaranteed to be higher than heartbeat frequency and should be respected by clients to avoid breaking when heartbeat frequency increases. 
         * @summary Get events from an event queue
         * @param {string} queueId The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). 
         * @param {number} [lastEventId] The highest event ID in this queue that you\&#39;ve received and wish to acknowledge. See the [code for &#x60;call_on_each_event&#x60;](https://github.com/zulip/python-zulip-api/blob/master/zulip/zulip/__init__.py) in the [zulip Python module](https://github.com/zulip/python-zulip-api) for an example implementation of correctly processing each event exactly once. 
         * @param {boolean} [dontBlock] Set to &#x60;true&#x60; if the client is requesting a nonblocking reply. If not specified, the request will block until either a new event is available or a few minutes have passed, in which case the server will send the client a heartbeat event. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(queueId: string, lastEventId?: number, dontBlock?: boolean, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getEvents(queueId, lastEventId, dontBlock, options).then((request) => request(axios, basePath));
        },
        /**
         * (Ignored) 
         * @param {Array<string>} [eventTypes] A JSON-encoded array indicating which types of events you\&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[\&#39;message\&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
         * @param {Array<Array<string>>} [narrow] A JSON-encoded array of arrays of length 2 indicating the narrow for which you\&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[\&#39;stream\&#39;, \&#39;Denmark\&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[\&#39;is\&#39;, \&#39;private\&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;. 
         * @param {boolean} [allPublicStreams] Whether you would like to request message events from all public streams.  Useful for workflow bots that you\&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        realTimePost(eventTypes?: Array<string>, narrow?: Array<Array<string>>, allPublicStreams?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.realTimePost(eventTypes, narrow, allPublicStreams, options).then((request) => request(axios, basePath));
        },
        /**
         * `POST {{ api_url }}/v1/register`  This powerful endpoint can be used to register a Zulip \"event queue\" (subscribed to certain types of \"events\", or updates to the messages and other Zulip data the current user has access to), as well as to fetch the current state of that data.  (`register` also powers the `call_on_each_event` Python API, and is intended primarily for complex applications for which the more convenient `call_on_each_event` API is insufficient).  This endpoint returns a `queue_id` and a `last_event_id`; these can be used in subsequent calls to the [\"events\" endpoint](/api/get-events) to request events from the Zulip server using long-polling.  The server will queue events for up to 10 minutes of inactivity. After 10 minutes, your event queue will be garbage-collected.  The server will send `heartbeat` events every minute, which makes it easy to implement a robust client that does not miss events unless the client loses network connectivity with the Zulip server for 10 minutes or longer.  Once the server garbage-collects your event queue, the server will [return an error](/api/get-events#bad_event_queue_id-errors) with a code of `BAD_EVENT_QUEUE_ID` if you try to fetch events from the event queue.  Your software will need to handle that error condition by re-initializing itself (e.g. this is what triggers your browser reloading the Zulip web app when your laptop comes back online after being offline for more than 10 minutes).  When prototyping with this API, we recommend first calling `register` with no `event_types` parameter to see all the available data from all supported event types.  Before using your client in production, you should set appropriate `event_types` and `fetch_event_types` filters so that your client only requests the data it needs.  A few minutes doing this often saves 90% of the total bandwidth and other resources consumed by a client using this API.  See the [events system developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/events-system.html) if you need deeper details about how the Zulip event queue system works, avoids clients needing to worry about large classes of potentially messy races, etc. 
         * @summary Register an event queue
         * @param {boolean} [applyMarkdown] Set to &#x60;true&#x60; if you would like the content to be rendered in HTML format (otherwise the API will return the raw text that the user entered) 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [slimPresence] Setting this to &#x60;true&#x60; will make presence dictionaries be keyed by user_id instead of email.  **Changes**: New in Zulip 3.0 (Unstable with no feature level yet). 
         * @param {Array<string>} [eventTypes] A JSON-encoded array indicating which types of events you\&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[\&#39;message\&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
         * @param {boolean} [allPublicStreams] Whether you would like to request message events from all public streams.  Useful for workflow bots that you\&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams). 
         * @param {boolean} [includeSubscribers] Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
         * @param {object} [clientCapabilities] Dictionary containing details on features the client supports that are relevant to the format of responses sent by the server.  * &#x60;notification_settings_null&#x60;: Boolean for whether the   client can handle the current API with null values for   stream-level notification settings (which means the stream   is not customized and should inherit the user\&#39;s global   notification settings for stream messages).   &lt;br /&gt;   New in Zulip 2.1.0; in earlier Zulip releases, stream-level   notification settings were simple booleans.  * &#x60;bulk_message_deletion&#x60;: Boolean for whether the client\&#39;s    handler for the &#x60;delete_message&#x60; event type has been    updated to process the new bulk format (with a    &#x60;message_ids&#x60;, rather than a singleton &#x60;message_id&#x60;).    Otherwise, the server will send &#x60;delete_message&#x60; events    in a loop.    &lt;br /&gt;    New in Zulip 3.0 (feature level 13).  This    capability is for backwards-compatibility; it will be    required in a future server release.  * &#x60;user_avatar_url_field_optional&#x60;: Boolean for whether the    client required avatar URLs for all users, or supports    using &#x60;GET /avatar/{user_id}&#x60; to access user avatars.  If the    client has this capability, the server may skip sending a    &#x60;avatar_url&#x60; field in the &#x60;realm_user&#x60; at its sole discretion    to optimize network performance.  This is an important optimization    in organizations with 10,000s of users.    &lt;br /&gt;    New in Zulip 3.0 (feature level 18).  * &#x60;stream_typing_notifications&#x60;: Boolean for whether the client   supports stream typing notifications.   &lt;br /&gt;   New in Zulip 4.0 (feature level 58).  This capability is   for backwards-compatibility; it will be required in a   future server release.  * &#x60;user_settings_object&#x60;: Boolean for whether the client supports the modern   &#x60;user_settings&#x60; event type. If False, the server will additionally send the   legacy &#x60;update_display_settings&#x60; and &#x60;update_global_notifications&#x60; event   types for backwards-compatibility with clients that predate this API migration.   &lt;br /&gt;   &lt;br /&gt;   Because the feature level 89 API changes were merged together, clients can   safely make a request with this client capability and requesting all of the   &#x60;user_settings&#x60;, &#x60;update_display_settings&#x60;, and   &#x60;update_global_notifications&#x60; event types, and get exactly one copy of   settings data on any server version. (And then use the &#x60;zulip_feature_level&#x60;   in the &#x60;/register&#x60; response or the presence/absence of a &#x60;user_settings&#x60; key   to determine where to look).   &lt;br /&gt;   New in Zulip 5.0 (feature level 89).  This capability is for   backwards-compatibility; it will be removed in a future server release. 
         * @param {Array<string>} [fetchEventTypes] Same as the &#x60;event_types&#x60; parameter except that the values in &#x60;fetch_event_types&#x60; are used to fetch initial data. If &#x60;fetch_event_types&#x60; is not provided, &#x60;event_types&#x60; is used and if &#x60;event_types&#x60; is not provided, this parameter defaults to &#x60;None&#x60;.  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
         * @param {Array<Array<string>>} [narrow] A JSON-encoded array of arrays of length 2 indicating the narrow for which you\&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[\&#39;stream\&#39;, \&#39;Denmark\&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[\&#39;is\&#39;, \&#39;private\&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerQueue(applyMarkdown?: boolean, clientGravatar?: boolean, slimPresence?: boolean, eventTypes?: Array<string>, allPublicStreams?: boolean, includeSubscribers?: boolean, clientCapabilities?: object, fetchEventTypes?: Array<string>, narrow?: Array<Array<string>>, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.registerQueue(applyMarkdown, clientGravatar, slimPresence, eventTypes, allPublicStreams, includeSubscribers, clientCapabilities, fetchEventTypes, narrow, options).then((request) => request(axios, basePath));
        },
        /**
         * Common error to many endpoints 
         * @summary Error handling
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restErrorHandling(options?: any): AxiosPromise<void> {
            return localVarFp.restErrorHandling(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealTimeEventsApi - object-oriented interface
 * @export
 * @class RealTimeEventsApi
 * @extends {BaseAPI}
 */
export class RealTimeEventsApi extends BaseAPI {
    /**
     * Delete a previously registered queue.  `DELETE {{ api_url }}/v1/events` 
     * @summary Delete an event queue
     * @param {string} queueId The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealTimeEventsApi
     */
    public deleteQueue(queueId: string, options?: any) {
        return RealTimeEventsApiFp(this.configuration).deleteQueue(queueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * `GET {{ api_url }}/v1/events`  This endpoint allows you to receive new events from [a registered event queue](/api/register-queue).  Long-lived clients should use the `event_queue_longpoll_timeout_seconds` property returned by `POST /register` as the client-side HTTP request timeout for calls to this endpoint.  It is guaranteed to be higher than heartbeat frequency and should be respected by clients to avoid breaking when heartbeat frequency increases. 
     * @summary Get events from an event queue
     * @param {string} queueId The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). 
     * @param {number} [lastEventId] The highest event ID in this queue that you\&#39;ve received and wish to acknowledge. See the [code for &#x60;call_on_each_event&#x60;](https://github.com/zulip/python-zulip-api/blob/master/zulip/zulip/__init__.py) in the [zulip Python module](https://github.com/zulip/python-zulip-api) for an example implementation of correctly processing each event exactly once. 
     * @param {boolean} [dontBlock] Set to &#x60;true&#x60; if the client is requesting a nonblocking reply. If not specified, the request will block until either a new event is available or a few minutes have passed, in which case the server will send the client a heartbeat event. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealTimeEventsApi
     */
    public getEvents(queueId: string, lastEventId?: number, dontBlock?: boolean, options?: any) {
        return RealTimeEventsApiFp(this.configuration).getEvents(queueId, lastEventId, dontBlock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (Ignored) 
     * @param {Array<string>} [eventTypes] A JSON-encoded array indicating which types of events you\&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[\&#39;message\&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
     * @param {Array<Array<string>>} [narrow] A JSON-encoded array of arrays of length 2 indicating the narrow for which you\&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[\&#39;stream\&#39;, \&#39;Denmark\&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[\&#39;is\&#39;, \&#39;private\&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;. 
     * @param {boolean} [allPublicStreams] Whether you would like to request message events from all public streams.  Useful for workflow bots that you\&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealTimeEventsApi
     */
    public realTimePost(eventTypes?: Array<string>, narrow?: Array<Array<string>>, allPublicStreams?: boolean, options?: any) {
        return RealTimeEventsApiFp(this.configuration).realTimePost(eventTypes, narrow, allPublicStreams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * `POST {{ api_url }}/v1/register`  This powerful endpoint can be used to register a Zulip \"event queue\" (subscribed to certain types of \"events\", or updates to the messages and other Zulip data the current user has access to), as well as to fetch the current state of that data.  (`register` also powers the `call_on_each_event` Python API, and is intended primarily for complex applications for which the more convenient `call_on_each_event` API is insufficient).  This endpoint returns a `queue_id` and a `last_event_id`; these can be used in subsequent calls to the [\"events\" endpoint](/api/get-events) to request events from the Zulip server using long-polling.  The server will queue events for up to 10 minutes of inactivity. After 10 minutes, your event queue will be garbage-collected.  The server will send `heartbeat` events every minute, which makes it easy to implement a robust client that does not miss events unless the client loses network connectivity with the Zulip server for 10 minutes or longer.  Once the server garbage-collects your event queue, the server will [return an error](/api/get-events#bad_event_queue_id-errors) with a code of `BAD_EVENT_QUEUE_ID` if you try to fetch events from the event queue.  Your software will need to handle that error condition by re-initializing itself (e.g. this is what triggers your browser reloading the Zulip web app when your laptop comes back online after being offline for more than 10 minutes).  When prototyping with this API, we recommend first calling `register` with no `event_types` parameter to see all the available data from all supported event types.  Before using your client in production, you should set appropriate `event_types` and `fetch_event_types` filters so that your client only requests the data it needs.  A few minutes doing this often saves 90% of the total bandwidth and other resources consumed by a client using this API.  See the [events system developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/events-system.html) if you need deeper details about how the Zulip event queue system works, avoids clients needing to worry about large classes of potentially messy races, etc. 
     * @summary Register an event queue
     * @param {boolean} [applyMarkdown] Set to &#x60;true&#x60; if you would like the content to be rendered in HTML format (otherwise the API will return the raw text that the user entered) 
     * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
     * @param {boolean} [slimPresence] Setting this to &#x60;true&#x60; will make presence dictionaries be keyed by user_id instead of email.  **Changes**: New in Zulip 3.0 (Unstable with no feature level yet). 
     * @param {Array<string>} [eventTypes] A JSON-encoded array indicating which types of events you\&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[\&#39;message\&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
     * @param {boolean} [allPublicStreams] Whether you would like to request message events from all public streams.  Useful for workflow bots that you\&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams). 
     * @param {boolean} [includeSubscribers] Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
     * @param {object} [clientCapabilities] Dictionary containing details on features the client supports that are relevant to the format of responses sent by the server.  * &#x60;notification_settings_null&#x60;: Boolean for whether the   client can handle the current API with null values for   stream-level notification settings (which means the stream   is not customized and should inherit the user\&#39;s global   notification settings for stream messages).   &lt;br /&gt;   New in Zulip 2.1.0; in earlier Zulip releases, stream-level   notification settings were simple booleans.  * &#x60;bulk_message_deletion&#x60;: Boolean for whether the client\&#39;s    handler for the &#x60;delete_message&#x60; event type has been    updated to process the new bulk format (with a    &#x60;message_ids&#x60;, rather than a singleton &#x60;message_id&#x60;).    Otherwise, the server will send &#x60;delete_message&#x60; events    in a loop.    &lt;br /&gt;    New in Zulip 3.0 (feature level 13).  This    capability is for backwards-compatibility; it will be    required in a future server release.  * &#x60;user_avatar_url_field_optional&#x60;: Boolean for whether the    client required avatar URLs for all users, or supports    using &#x60;GET /avatar/{user_id}&#x60; to access user avatars.  If the    client has this capability, the server may skip sending a    &#x60;avatar_url&#x60; field in the &#x60;realm_user&#x60; at its sole discretion    to optimize network performance.  This is an important optimization    in organizations with 10,000s of users.    &lt;br /&gt;    New in Zulip 3.0 (feature level 18).  * &#x60;stream_typing_notifications&#x60;: Boolean for whether the client   supports stream typing notifications.   &lt;br /&gt;   New in Zulip 4.0 (feature level 58).  This capability is   for backwards-compatibility; it will be required in a   future server release.  * &#x60;user_settings_object&#x60;: Boolean for whether the client supports the modern   &#x60;user_settings&#x60; event type. If False, the server will additionally send the   legacy &#x60;update_display_settings&#x60; and &#x60;update_global_notifications&#x60; event   types for backwards-compatibility with clients that predate this API migration.   &lt;br /&gt;   &lt;br /&gt;   Because the feature level 89 API changes were merged together, clients can   safely make a request with this client capability and requesting all of the   &#x60;user_settings&#x60;, &#x60;update_display_settings&#x60;, and   &#x60;update_global_notifications&#x60; event types, and get exactly one copy of   settings data on any server version. (And then use the &#x60;zulip_feature_level&#x60;   in the &#x60;/register&#x60; response or the presence/absence of a &#x60;user_settings&#x60; key   to determine where to look).   &lt;br /&gt;   New in Zulip 5.0 (feature level 89).  This capability is for   backwards-compatibility; it will be removed in a future server release. 
     * @param {Array<string>} [fetchEventTypes] Same as the &#x60;event_types&#x60; parameter except that the values in &#x60;fetch_event_types&#x60; are used to fetch initial data. If &#x60;fetch_event_types&#x60; is not provided, &#x60;event_types&#x60; is used and if &#x60;event_types&#x60; is not provided, this parameter defaults to &#x60;None&#x60;.  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. 
     * @param {Array<Array<string>>} [narrow] A JSON-encoded array of arrays of length 2 indicating the narrow for which you\&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[\&#39;stream\&#39;, \&#39;Denmark\&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[\&#39;is\&#39;, \&#39;private\&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealTimeEventsApi
     */
    public registerQueue(applyMarkdown?: boolean, clientGravatar?: boolean, slimPresence?: boolean, eventTypes?: Array<string>, allPublicStreams?: boolean, includeSubscribers?: boolean, clientCapabilities?: object, fetchEventTypes?: Array<string>, narrow?: Array<Array<string>>, options?: any) {
        return RealTimeEventsApiFp(this.configuration).registerQueue(applyMarkdown, clientGravatar, slimPresence, eventTypes, allPublicStreams, includeSubscribers, clientCapabilities, fetchEventTypes, narrow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Common error to many endpoints 
     * @summary Error handling
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealTimeEventsApi
     */
    public restErrorHandling(options?: any) {
        return RealTimeEventsApiFp(this.configuration).restErrorHandling(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerAndOrganizationsApi - axios parameter creator
 * @export
 */
export const ServerAndOrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  `POST {{ api_url }}/v1/realm/playgrounds`  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
         * @summary Add a code playground
         * @param {string} name The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language. 
         * @param {string} pygmentsLanguage The name of the Pygments language lexer for that programming language. 
         * @param {string} urlPrefix The url prefix for the playground. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCodePlayground: async (name: string, pygmentsLanguage: string, urlPrefix: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('addCodePlayground', 'name', name)
            // verify required parameter 'pygmentsLanguage' is not null or undefined
            assertParamExists('addCodePlayground', 'pygmentsLanguage', pygmentsLanguage)
            // verify required parameter 'urlPrefix' is not null or undefined
            assertParamExists('addCodePlayground', 'urlPrefix', urlPrefix)
            const localVarPath = `/realm/playgrounds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (pygmentsLanguage !== undefined) {
                localVarQueryParameter['pygments_language'] = pygmentsLanguage;
            }

            if (urlPrefix !== undefined) {
                localVarQueryParameter['url_prefix'] = urlPrefix;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `POST {{ api_url }}/v1/realm/filters` 
         * @summary Add a linkifier
         * @param {string} pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
         * @param {string} urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLinkifier: async (pattern: string, urlFormatString: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pattern' is not null or undefined
            assertParamExists('addLinkifier', 'pattern', pattern)
            // verify required parameter 'urlFormatString' is not null or undefined
            assertParamExists('addLinkifier', 'urlFormatString', urlFormatString)
            const localVarPath = `/realm/filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pattern !== undefined) {
                localVarQueryParameter['pattern'] = pattern;
            }

            if (urlFormatString !== undefined) {
                localVarQueryParameter['url_format_string'] = urlFormatString;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [Create a custom profile field](/help/add-custom-profile-fields) in the user\'s organization.  `POST {{ api_url }}/v1/realm/profile_fields` 
         * @summary Create a custom profile field
         * @param {number} fieldType The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/add-custom-profile-fields) more details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
         * @param {string} [name] The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user\&#39;s profile. 
         * @param {string} [hint] The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
         * @param {object} [fieldData] Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the &#x60;field_data&#x60; attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomProfileField: async (fieldType: number, name?: string, hint?: string, fieldData?: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fieldType' is not null or undefined
            assertParamExists('createCustomProfileField', 'fieldType', fieldType)
            const localVarPath = `/realm/profile_fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (hint !== undefined) {
                localVarQueryParameter['hint'] = hint;
            }

            if (fieldType !== undefined) {
                localVarQueryParameter['field_type'] = fieldType;
            }

            if (fieldData !== undefined) {
                localVarQueryParameter['field_data'] = fieldData;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the custom emoji in the user\'s organization.  `GET {{ api_url }}/v1/realm/emoji` 
         * @summary Get all custom emoji
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomEmoji: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/realm/emoji`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user\'s organization.  `GET {{ api_url }}/v1/realm/profile_fields` 
         * @summary Get all custom profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomProfileFields: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/realm/profile_fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of an organization\'s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `GET {{ api_url }}/v1/realm/linkifiers`  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar `GET /realm/filters` endpoint was available with each entry in a `[pattern, url_format, id]` tuple format. 
         * @summary Get linkifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkifiers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/realm/linkifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch global settings for a Zulip server.  `GET {{ api_url }}/v1/server_settings`  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it\'s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
         * @summary Get server settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSettings: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/server_settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  `DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}`  **Changes**: New in Zulip 4.0 (feature level 49). 
         * @summary Remove a code playground
         * @param {number} playgroundId The ID of the playground that you want to remove. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCodePlayground: async (playgroundId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playgroundId' is not null or undefined
            assertParamExists('removeCodePlayground', 'playgroundId', playgroundId)
            const localVarPath = `/realm/playgrounds/{playground_id}`
                .replace(`{${"playground_id"}}`, encodeURIComponent(String(playgroundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `DELETE {{ api_url }}/v1/realm/filters/{filter_id}` 
         * @summary Remove a linkifier
         * @param {number} filterId The ID of the linkifier that you want to remove. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeLinkifier: async (filterId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('removeLinkifier', 'filterId', filterId)
            const localVarPath = `/realm/filters/{filter_id}`
                .replace(`{${"filter_id"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reorder the custom profile fields in the user\'s organization.  `PATCH {{ api_url }}/v1/realm/profile_fields`  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
         * @summary Reorder custom profile fields
         * @param {Array<number>} order A list of the IDs of all the custom profile fields defined in this organization, in the desired new order. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderCustomProfileFields: async (order: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('reorderCustomProfileFields', 'order', order)
            const localVarPath = `/realm/profile_fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (order) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `PATCH {{ api_url }}/v1/realm/filters/{filter_id}`  **Changes**: New in Zulip 4.0 (feature level 57). 
         * @summary Update a linkifier
         * @param {number} filterId The ID of the linkifier that you want to update. 
         * @param {string} pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
         * @param {string} urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkifier: async (filterId: number, pattern: string, urlFormatString: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('updateLinkifier', 'filterId', filterId)
            // verify required parameter 'pattern' is not null or undefined
            assertParamExists('updateLinkifier', 'pattern', pattern)
            // verify required parameter 'urlFormatString' is not null or undefined
            assertParamExists('updateLinkifier', 'urlFormatString', urlFormatString)
            const localVarPath = `/realm/filters/{filter_id}`
                .replace(`{${"filter_id"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pattern !== undefined) {
                localVarQueryParameter['pattern'] = pattern;
            }

            if (urlFormatString !== undefined) {
                localVarQueryParameter['url_format_string'] = urlFormatString;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to upload a custom emoji for use in the user\'s organization.  Access to this endpoint depends on the [organization\'s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  `POST {{ api_url }}/v1/realm/emoji/{emoji_name}` 
         * @summary Upload custom emoji
         * @param {string} emojiName The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (_) are treated the same as spaces (consistent with how the Zulip UI handles emoji). 
         * @param {any} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCustomEmoji: async (emojiName: string, filename?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'emojiName' is not null or undefined
            assertParamExists('uploadCustomEmoji', 'emojiName', emojiName)
            const localVarPath = `/realm/emoji/{emoji_name}`
                .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (filename !== undefined) { 
                localVarFormParams.append('filename', filename as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerAndOrganizationsApi - functional programming interface
 * @export
 */
export const ServerAndOrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerAndOrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  `POST {{ api_url }}/v1/realm/playgrounds`  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
         * @summary Add a code playground
         * @param {string} name The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language. 
         * @param {string} pygmentsLanguage The name of the Pygments language lexer for that programming language. 
         * @param {string} urlPrefix The url prefix for the playground. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCodePlayground(name: string, pygmentsLanguage: string, urlPrefix: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCodePlayground(name, pygmentsLanguage, urlPrefix, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `POST {{ api_url }}/v1/realm/filters` 
         * @summary Add a linkifier
         * @param {string} pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
         * @param {string} urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addLinkifier(pattern: string, urlFormatString: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLinkifier(pattern, urlFormatString, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * [Create a custom profile field](/help/add-custom-profile-fields) in the user\'s organization.  `POST {{ api_url }}/v1/realm/profile_fields` 
         * @summary Create a custom profile field
         * @param {number} fieldType The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/add-custom-profile-fields) more details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
         * @param {string} [name] The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user\&#39;s profile. 
         * @param {string} [hint] The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
         * @param {object} [fieldData] Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the &#x60;field_data&#x60; attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomProfileField(fieldType: number, name?: string, hint?: string, fieldData?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomProfileField(fieldType, name, hint, fieldData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the custom emoji in the user\'s organization.  `GET {{ api_url }}/v1/realm/emoji` 
         * @summary Get all custom emoji
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomEmoji(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomEmoji(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user\'s organization.  `GET {{ api_url }}/v1/realm/profile_fields` 
         * @summary Get all custom profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomProfileFields(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomProfileFields(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all of an organization\'s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `GET {{ api_url }}/v1/realm/linkifiers`  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar `GET /realm/filters` endpoint was available with each entry in a `[pattern, url_format, id]` tuple format. 
         * @summary Get linkifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLinkifiers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLinkifiers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch global settings for a Zulip server.  `GET {{ api_url }}/v1/server_settings`  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it\'s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
         * @summary Get server settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerSettings(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  `DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}`  **Changes**: New in Zulip 4.0 (feature level 49). 
         * @summary Remove a code playground
         * @param {number} playgroundId The ID of the playground that you want to remove. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCodePlayground(playgroundId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCodePlayground(playgroundId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `DELETE {{ api_url }}/v1/realm/filters/{filter_id}` 
         * @summary Remove a linkifier
         * @param {number} filterId The ID of the linkifier that you want to remove. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeLinkifier(filterId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeLinkifier(filterId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reorder the custom profile fields in the user\'s organization.  `PATCH {{ api_url }}/v1/realm/profile_fields`  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
         * @summary Reorder custom profile fields
         * @param {Array<number>} order A list of the IDs of all the custom profile fields defined in this organization, in the desired new order. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reorderCustomProfileFields(order: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reorderCustomProfileFields(order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `PATCH {{ api_url }}/v1/realm/filters/{filter_id}`  **Changes**: New in Zulip 4.0 (feature level 57). 
         * @summary Update a linkifier
         * @param {number} filterId The ID of the linkifier that you want to update. 
         * @param {string} pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
         * @param {string} urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLinkifier(filterId: number, pattern: string, urlFormatString: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLinkifier(filterId, pattern, urlFormatString, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used to upload a custom emoji for use in the user\'s organization.  Access to this endpoint depends on the [organization\'s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  `POST {{ api_url }}/v1/realm/emoji/{emoji_name}` 
         * @summary Upload custom emoji
         * @param {string} emojiName The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (_) are treated the same as spaces (consistent with how the Zulip UI handles emoji). 
         * @param {any} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCustomEmoji(emojiName: string, filename?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCustomEmoji(emojiName, filename, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerAndOrganizationsApi - factory interface
 * @export
 */
export const ServerAndOrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerAndOrganizationsApiFp(configuration)
    return {
        /**
         * Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  `POST {{ api_url }}/v1/realm/playgrounds`  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
         * @summary Add a code playground
         * @param {string} name The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language. 
         * @param {string} pygmentsLanguage The name of the Pygments language lexer for that programming language. 
         * @param {string} urlPrefix The url prefix for the playground. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCodePlayground(name: string, pygmentsLanguage: string, urlPrefix: string, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.addCodePlayground(name, pygmentsLanguage, urlPrefix, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `POST {{ api_url }}/v1/realm/filters` 
         * @summary Add a linkifier
         * @param {string} pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
         * @param {string} urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLinkifier(pattern: string, urlFormatString: string, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.addLinkifier(pattern, urlFormatString, options).then((request) => request(axios, basePath));
        },
        /**
         * [Create a custom profile field](/help/add-custom-profile-fields) in the user\'s organization.  `POST {{ api_url }}/v1/realm/profile_fields` 
         * @summary Create a custom profile field
         * @param {number} fieldType The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/add-custom-profile-fields) more details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
         * @param {string} [name] The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user\&#39;s profile. 
         * @param {string} [hint] The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
         * @param {object} [fieldData] Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the &#x60;field_data&#x60; attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomProfileField(fieldType: number, name?: string, hint?: string, fieldData?: object, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.createCustomProfileField(fieldType, name, hint, fieldData, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the custom emoji in the user\'s organization.  `GET {{ api_url }}/v1/realm/emoji` 
         * @summary Get all custom emoji
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomEmoji(options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getCustomEmoji(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user\'s organization.  `GET {{ api_url }}/v1/realm/profile_fields` 
         * @summary Get all custom profile fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomProfileFields(options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getCustomProfileFields(options).then((request) => request(axios, basePath));
        },
        /**
         * List all of an organization\'s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `GET {{ api_url }}/v1/realm/linkifiers`  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar `GET /realm/filters` endpoint was available with each entry in a `[pattern, url_format, id]` tuple format. 
         * @summary Get linkifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkifiers(options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getLinkifiers(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch global settings for a Zulip server.  `GET {{ api_url }}/v1/server_settings`  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it\'s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
         * @summary Get server settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSettings(options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getServerSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  `DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}`  **Changes**: New in Zulip 4.0 (feature level 49). 
         * @summary Remove a code playground
         * @param {number} playgroundId The ID of the playground that you want to remove. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCodePlayground(playgroundId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.removeCodePlayground(playgroundId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `DELETE {{ api_url }}/v1/realm/filters/{filter_id}` 
         * @summary Remove a linkifier
         * @param {number} filterId The ID of the linkifier that you want to remove. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeLinkifier(filterId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.removeLinkifier(filterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Reorder the custom profile fields in the user\'s organization.  `PATCH {{ api_url }}/v1/realm/profile_fields`  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
         * @summary Reorder custom profile fields
         * @param {Array<number>} order A list of the IDs of all the custom profile fields defined in this organization, in the desired new order. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderCustomProfileFields(order: Array<number>, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.reorderCustomProfileFields(order, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `PATCH {{ api_url }}/v1/realm/filters/{filter_id}`  **Changes**: New in Zulip 4.0 (feature level 57). 
         * @summary Update a linkifier
         * @param {number} filterId The ID of the linkifier that you want to update. 
         * @param {string} pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
         * @param {string} urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLinkifier(filterId: number, pattern: string, urlFormatString: string, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.updateLinkifier(filterId, pattern, urlFormatString, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used to upload a custom emoji for use in the user\'s organization.  Access to this endpoint depends on the [organization\'s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  `POST {{ api_url }}/v1/realm/emoji/{emoji_name}` 
         * @summary Upload custom emoji
         * @param {string} emojiName The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (_) are treated the same as spaces (consistent with how the Zulip UI handles emoji). 
         * @param {any} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCustomEmoji(emojiName: string, filename?: any, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.uploadCustomEmoji(emojiName, filename, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerAndOrganizationsApi - object-oriented interface
 * @export
 * @class ServerAndOrganizationsApi
 * @extends {BaseAPI}
 */
export class ServerAndOrganizationsApi extends BaseAPI {
    /**
     * Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  `POST {{ api_url }}/v1/realm/playgrounds`  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
     * @summary Add a code playground
     * @param {string} name The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language. 
     * @param {string} pygmentsLanguage The name of the Pygments language lexer for that programming language. 
     * @param {string} urlPrefix The url prefix for the playground. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public addCodePlayground(name: string, pygmentsLanguage: string, urlPrefix: string, options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).addCodePlayground(name, pygmentsLanguage, urlPrefix, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `POST {{ api_url }}/v1/realm/filters` 
     * @summary Add a linkifier
     * @param {string} pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
     * @param {string} urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public addLinkifier(pattern: string, urlFormatString: string, options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).addLinkifier(pattern, urlFormatString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [Create a custom profile field](/help/add-custom-profile-fields) in the user\'s organization.  `POST {{ api_url }}/v1/realm/profile_fields` 
     * @summary Create a custom profile field
     * @param {number} fieldType The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/add-custom-profile-fields) more details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
     * @param {string} [name] The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user\&#39;s profile. 
     * @param {string} [hint] The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
     * @param {object} [fieldData] Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the &#x60;field_data&#x60; attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public createCustomProfileField(fieldType: number, name?: string, hint?: string, fieldData?: object, options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).createCustomProfileField(fieldType, name, hint, fieldData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the custom emoji in the user\'s organization.  `GET {{ api_url }}/v1/realm/emoji` 
     * @summary Get all custom emoji
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public getCustomEmoji(options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).getCustomEmoji(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user\'s organization.  `GET {{ api_url }}/v1/realm/profile_fields` 
     * @summary Get all custom profile fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public getCustomProfileFields(options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).getCustomProfileFields(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all of an organization\'s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `GET {{ api_url }}/v1/realm/linkifiers`  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar `GET /realm/filters` endpoint was available with each entry in a `[pattern, url_format, id]` tuple format. 
     * @summary Get linkifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public getLinkifiers(options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).getLinkifiers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch global settings for a Zulip server.  `GET {{ api_url }}/v1/server_settings`  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it\'s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
     * @summary Get server settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public getServerSettings(options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).getServerSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  `DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}`  **Changes**: New in Zulip 4.0 (feature level 49). 
     * @summary Remove a code playground
     * @param {number} playgroundId The ID of the playground that you want to remove. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public removeCodePlayground(playgroundId: number, options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).removeCodePlayground(playgroundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `DELETE {{ api_url }}/v1/realm/filters/{filter_id}` 
     * @summary Remove a linkifier
     * @param {number} filterId The ID of the linkifier that you want to remove. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public removeLinkifier(filterId: number, options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).removeLinkifier(filterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reorder the custom profile fields in the user\'s organization.  `PATCH {{ api_url }}/v1/realm/profile_fields`  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
     * @summary Reorder custom profile fields
     * @param {Array<number>} order A list of the IDs of all the custom profile fields defined in this organization, in the desired new order. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public reorderCustomProfileFields(order: Array<number>, options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).reorderCustomProfileFields(order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  `PATCH {{ api_url }}/v1/realm/filters/{filter_id}`  **Changes**: New in Zulip 4.0 (feature level 57). 
     * @summary Update a linkifier
     * @param {number} filterId The ID of the linkifier that you want to update. 
     * @param {string} pattern The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
     * @param {string} urlFormatString The URL used for the link. If you used named groups for the &#x60;pattern&#x60;, you can insert their content here with &#x60;%(name_of_the_capturing_group)s&#x60;. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public updateLinkifier(filterId: number, pattern: string, urlFormatString: string, options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).updateLinkifier(filterId, pattern, urlFormatString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used to upload a custom emoji for use in the user\'s organization.  Access to this endpoint depends on the [organization\'s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  `POST {{ api_url }}/v1/realm/emoji/{emoji_name}` 
     * @summary Upload custom emoji
     * @param {string} emojiName The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (_) are treated the same as spaces (consistent with how the Zulip UI handles emoji). 
     * @param {any} [filename] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerAndOrganizationsApi
     */
    public uploadCustomEmoji(emojiName: string, filename?: any, options?: any) {
        return ServerAndOrganizationsApiFp(this.configuration).uploadCustomEmoji(emojiName, filename, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StreamsApi - axios parameter creator
 * @export
 */
export const StreamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
         * @summary Archive a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveStream: async (streamId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('archiveStream', 'streamId', streamId)
            const localVarPath = `/streams/{stream_id}`
                .replace(`{${"stream_id"}}`, encodeURIComponent(String(streamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
         * @summary Create BigBlueButton video call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigBlueButtonVideoCall: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/calls/bigbluebutton/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all messages in a topic.  `POST {{ api_url }}/v1/streams/{stream_id}/delete_topic`  Topics are a field on messages (not an independent data structure), so deleting all the messages in the topic deletes the topic from Zulip. 
         * @summary Delete a topic
         * @param {number} streamId The ID of the stream to access. 
         * @param {string} topicName The name of the topic to delete. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic: async (streamId: number, topicName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('deleteTopic', 'streamId', streamId)
            // verify required parameter 'topicName' is not null or undefined
            assertParamExists('deleteTopic', 'topicName', topicName)
            const localVarPath = `/streams/{stream_id}/delete_topic`
                .replace(`{${"stream_id"}}`, encodeURIComponent(String(streamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicName !== undefined) {
                localVarQueryParameter['topic_name'] = topicName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
         * @summary Get stream ID
         * @param {string} stream The name of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamId: async (stream: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stream' is not null or undefined
            assertParamExists('getStreamId', 'stream', stream)
            const localVarPath = `/get_stream_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
         * @summary Get topics in a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamTopics: async (streamId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('getStreamTopics', 'streamId', streamId)
            const localVarPath = `/users/me/{stream_id}/topics`
                .replace(`{${"stream_id"}}`, encodeURIComponent(String(streamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
         * @summary Get all streams
         * @param {boolean} [includePublic] Include all public streams. 
         * @param {boolean} [includeWebPublic] Include all web public streams. 
         * @param {boolean} [includeSubscribed] Include all streams that the user is subscribed to. 
         * @param {boolean} [includeAllActive] Include all active streams. The user must have administrative privileges to use this parameter. 
         * @param {boolean} [includeDefault] Include all default streams for the user\&#39;s realm. 
         * @param {boolean} [includeOwnerSubscribed] If the user is a bot, include all streams that the bot\&#39;s owner is subscribed to. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreams: async (includePublic?: boolean, includeWebPublic?: boolean, includeSubscribed?: boolean, includeAllActive?: boolean, includeDefault?: boolean, includeOwnerSubscribed?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/streams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includePublic !== undefined) {
                localVarQueryParameter['include_public'] = includePublic;
            }

            if (includeWebPublic !== undefined) {
                localVarQueryParameter['include_web_public'] = includeWebPublic;
            }

            if (includeSubscribed !== undefined) {
                localVarQueryParameter['include_subscribed'] = includeSubscribed;
            }

            if (includeAllActive !== undefined) {
                localVarQueryParameter['include_all_active'] = includeAllActive;
            }

            if (includeDefault !== undefined) {
                localVarQueryParameter['include_default'] = includeDefault;
            }

            if (includeOwnerSubscribed !== undefined) {
                localVarQueryParameter['include_owner_subscribed'] = includeOwnerSubscribed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users subscribed to a stream.  `Get {{ api_url }}/v1/streams/{stream_id}/members` 
         * @summary Get the subscribers of a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribers: async (streamId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('getSubscribers', 'streamId', streamId)
            const localVarPath = `/streams/{stream_id}/members`
                .replace(`{${"stream_id"}}`, encodeURIComponent(String(streamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
         * @summary Get subscription status
         * @param {number} userId The target user\&#39;s ID. 
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionStatus: async (userId: number, streamId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getSubscriptionStatus', 'userId', userId)
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('getSubscriptionStatus', 'streamId', streamId)
            const localVarPath = `/users/{user_id}/subscriptions/{stream_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"stream_id"}}`, encodeURIComponent(String(streamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
         * @summary Get subscribed streams
         * @param {boolean} [includeSubscribers] Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions: async (includeSubscribers?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeSubscribers !== undefined) {
                localVarQueryParameter['include_subscribers'] = includeSubscribers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user\'s unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
         * @summary Topic muting
         * @param {string} topic The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. 
         * @param {'add' | 'remove'} op Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. 
         * @param {string} [stream] The name of the stream to access. 
         * @param {number} [streamId] The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        muteTopic: async (topic: string, op: 'add' | 'remove', stream?: string, streamId?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('muteTopic', 'topic', topic)
            // verify required parameter 'op' is not null or undefined
            assertParamExists('muteTopic', 'op', op)
            const localVarPath = `/users/me/subscriptions/muted_topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stream !== undefined) {
                localVarQueryParameter['stream'] = stream;
            }

            if (streamId !== undefined) {
                localVarQueryParameter['stream_id'] = streamId;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (op !== undefined) {
                localVarQueryParameter['op'] = op;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
         * @summary Subscribe to a stream
         * @param {Array<object>} subscriptions A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. 
         * @param {Array<string | number>} [principals] A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
         * @param {boolean} [authorizationErrorsFatal] A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key. 
         * @param {boolean} [announce] If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream\&#39;s creation. 
         * @param {boolean} [inviteOnly] As described above, this endpoint will create a new stream if passed a stream name that doesn\&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams. 
         * @param {boolean} [historyPublicToSubscribers] Whether the stream\&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
         * @param {number} [streamPostPolicy] Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean. 
         * @param {string | number} [messageRetentionDays] Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribe: async (subscriptions: Array<object>, principals?: Array<string | number>, authorizationErrorsFatal?: boolean, announce?: boolean, inviteOnly?: boolean, historyPublicToSubscribers?: boolean, streamPostPolicy?: number, messageRetentionDays?: string | number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptions' is not null or undefined
            assertParamExists('subscribe', 'subscriptions', subscriptions)
            const localVarPath = `/users/me/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (subscriptions) {
                localVarQueryParameter['subscriptions'] = subscriptions;
            }

            if (principals) {
                localVarQueryParameter['principals'] = principals;
            }

            if (authorizationErrorsFatal !== undefined) {
                localVarQueryParameter['authorization_errors_fatal'] = authorizationErrorsFatal;
            }

            if (announce !== undefined) {
                localVarQueryParameter['announce'] = announce;
            }

            if (inviteOnly !== undefined) {
                localVarQueryParameter['invite_only'] = inviteOnly;
            }

            if (historyPublicToSubscribers !== undefined) {
                localVarQueryParameter['history_public_to_subscribers'] = historyPublicToSubscribers;
            }

            if (streamPostPolicy !== undefined) {
                localVarQueryParameter['stream_post_policy'] = streamPostPolicy;
            }

            if (messageRetentionDays !== undefined) {
                localVarQueryParameter['message_retention_days'] = messageRetentionDays;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
         * @summary Unsubscribe from a stream
         * @param {Array<string>} subscriptions A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. 
         * @param {Array<string | number>} [principals] A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe: async (subscriptions: Array<string>, principals?: Array<string | number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptions' is not null or undefined
            assertParamExists('unsubscribe', 'subscriptions', subscriptions)
            const localVarPath = `/users/me/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (subscriptions) {
                localVarQueryParameter['subscriptions'] = subscriptions;
            }

            if (principals) {
                localVarQueryParameter['principals'] = principals;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
         * @summary Update a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {string} [description] The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
         * @param {string} [newName] The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
         * @param {boolean} [isPrivate] Change whether the stream is a private stream. 
         * @param {boolean} [isAnnouncementOnly] Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead. 
         * @param {number} [streamPostPolicy] Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean. 
         * @param {boolean} [historyPublicToSubscribers] Whether the stream\&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
         * @param {string | number} [messageRetentionDays] Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStream: async (streamId: number, description?: string, newName?: string, isPrivate?: boolean, isAnnouncementOnly?: boolean, streamPostPolicy?: number, historyPublicToSubscribers?: boolean, messageRetentionDays?: string | number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            assertParamExists('updateStream', 'streamId', streamId)
            const localVarPath = `/streams/{stream_id}`
                .replace(`{${"stream_id"}}`, encodeURIComponent(String(streamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (newName !== undefined) {
                localVarQueryParameter['new_name'] = newName;
            }

            if (isPrivate !== undefined) {
                localVarQueryParameter['is_private'] = isPrivate;
            }

            if (isAnnouncementOnly !== undefined) {
                localVarQueryParameter['is_announcement_only'] = isAnnouncementOnly;
            }

            if (streamPostPolicy !== undefined) {
                localVarQueryParameter['stream_post_policy'] = streamPostPolicy;
            }

            if (historyPublicToSubscribers !== undefined) {
                localVarQueryParameter['history_public_to_subscribers'] = historyPublicToSubscribers;
            }

            if (messageRetentionDays !== undefined) {
                localVarQueryParameter['message_retention_days'] = messageRetentionDays;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to update the user\'s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
         * @summary Update subscription settings
         * @param {Array<object>} subscriptionData A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user\&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionSettings: async (subscriptionData: Array<object>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionData' is not null or undefined
            assertParamExists('updateSubscriptionSettings', 'subscriptionData', subscriptionData)
            const localVarPath = `/users/me/subscriptions/properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (subscriptionData) {
                localVarQueryParameter['subscription_data'] = subscriptionData;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update which streams you are are subscribed to. 
         * @summary Update subscriptions
         * @param {Array<string>} [_delete] A list of stream names to unsubscribe from. 
         * @param {Array<object>} [add] A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptions: async (_delete?: Array<string>, add?: Array<object>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_delete) {
                localVarQueryParameter['delete'] = _delete;
            }

            if (add) {
                localVarQueryParameter['add'] = add;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamsApi - functional programming interface
 * @export
 */
export const StreamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StreamsApiAxiosParamCreator(configuration)
    return {
        /**
         * [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
         * @summary Archive a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveStream(streamId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveStream(streamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
         * @summary Create BigBlueButton video call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBigBlueButtonVideoCall(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBigBlueButtonVideoCall(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all messages in a topic.  `POST {{ api_url }}/v1/streams/{stream_id}/delete_topic`  Topics are a field on messages (not an independent data structure), so deleting all the messages in the topic deletes the topic from Zulip. 
         * @summary Delete a topic
         * @param {number} streamId The ID of the stream to access. 
         * @param {string} topicName The name of the topic to delete. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTopic(streamId: number, topicName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTopic(streamId, topicName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
         * @summary Get stream ID
         * @param {string} stream The name of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamId(stream: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamId(stream, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
         * @summary Get topics in a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamTopics(streamId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamTopics(streamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
         * @summary Get all streams
         * @param {boolean} [includePublic] Include all public streams. 
         * @param {boolean} [includeWebPublic] Include all web public streams. 
         * @param {boolean} [includeSubscribed] Include all streams that the user is subscribed to. 
         * @param {boolean} [includeAllActive] Include all active streams. The user must have administrative privileges to use this parameter. 
         * @param {boolean} [includeDefault] Include all default streams for the user\&#39;s realm. 
         * @param {boolean} [includeOwnerSubscribed] If the user is a bot, include all streams that the bot\&#39;s owner is subscribed to. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreams(includePublic?: boolean, includeWebPublic?: boolean, includeSubscribed?: boolean, includeAllActive?: boolean, includeDefault?: boolean, includeOwnerSubscribed?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreams(includePublic, includeWebPublic, includeSubscribed, includeAllActive, includeDefault, includeOwnerSubscribed, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all users subscribed to a stream.  `Get {{ api_url }}/v1/streams/{stream_id}/members` 
         * @summary Get the subscribers of a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscribers(streamId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscribers(streamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
         * @summary Get subscription status
         * @param {number} userId The target user\&#39;s ID. 
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionStatus(userId: number, streamId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionStatus(userId, streamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
         * @summary Get subscribed streams
         * @param {boolean} [includeSubscribers] Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptions(includeSubscribers?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptions(includeSubscribers, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user\'s unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
         * @summary Topic muting
         * @param {string} topic The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. 
         * @param {'add' | 'remove'} op Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. 
         * @param {string} [stream] The name of the stream to access. 
         * @param {number} [streamId] The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async muteTopic(topic: string, op: 'add' | 'remove', stream?: string, streamId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.muteTopic(topic, op, stream, streamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
         * @summary Subscribe to a stream
         * @param {Array<object>} subscriptions A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. 
         * @param {Array<string | number>} [principals] A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
         * @param {boolean} [authorizationErrorsFatal] A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key. 
         * @param {boolean} [announce] If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream\&#39;s creation. 
         * @param {boolean} [inviteOnly] As described above, this endpoint will create a new stream if passed a stream name that doesn\&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams. 
         * @param {boolean} [historyPublicToSubscribers] Whether the stream\&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
         * @param {number} [streamPostPolicy] Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean. 
         * @param {string | number} [messageRetentionDays] Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribe(subscriptions: Array<object>, principals?: Array<string | number>, authorizationErrorsFatal?: boolean, announce?: boolean, inviteOnly?: boolean, historyPublicToSubscribers?: boolean, streamPostPolicy?: number, messageRetentionDays?: string | number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddSubscriptionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribe(subscriptions, principals, authorizationErrorsFatal, announce, inviteOnly, historyPublicToSubscribers, streamPostPolicy, messageRetentionDays, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
         * @summary Unsubscribe from a stream
         * @param {Array<string>} subscriptions A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. 
         * @param {Array<string | number>} [principals] A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribe(subscriptions: Array<string>, principals?: Array<string | number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribe(subscriptions, principals, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
         * @summary Update a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {string} [description] The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
         * @param {string} [newName] The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
         * @param {boolean} [isPrivate] Change whether the stream is a private stream. 
         * @param {boolean} [isAnnouncementOnly] Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead. 
         * @param {number} [streamPostPolicy] Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean. 
         * @param {boolean} [historyPublicToSubscribers] Whether the stream\&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
         * @param {string | number} [messageRetentionDays] Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStream(streamId: number, description?: string, newName?: string, isPrivate?: boolean, isAnnouncementOnly?: boolean, streamPostPolicy?: number, historyPublicToSubscribers?: boolean, messageRetentionDays?: string | number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStream(streamId, description, newName, isPrivate, isAnnouncementOnly, streamPostPolicy, historyPublicToSubscribers, messageRetentionDays, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used to update the user\'s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
         * @summary Update subscription settings
         * @param {Array<object>} subscriptionData A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user\&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionSettings(subscriptionData: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionSettings(subscriptionData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update which streams you are are subscribed to. 
         * @summary Update subscriptions
         * @param {Array<string>} [_delete] A list of stream names to unsubscribe from. 
         * @param {Array<object>} [add] A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptions(_delete?: Array<string>, add?: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptions(_delete, add, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StreamsApi - factory interface
 * @export
 */
export const StreamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StreamsApiFp(configuration)
    return {
        /**
         * [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
         * @summary Archive a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveStream(streamId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.archiveStream(streamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
         * @summary Create BigBlueButton video call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBigBlueButtonVideoCall(options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.createBigBlueButtonVideoCall(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all messages in a topic.  `POST {{ api_url }}/v1/streams/{stream_id}/delete_topic`  Topics are a field on messages (not an independent data structure), so deleting all the messages in the topic deletes the topic from Zulip. 
         * @summary Delete a topic
         * @param {number} streamId The ID of the stream to access. 
         * @param {string} topicName The name of the topic to delete. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic(streamId: number, topicName: string, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.deleteTopic(streamId, topicName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
         * @summary Get stream ID
         * @param {string} stream The name of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamId(stream: string, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getStreamId(stream, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
         * @summary Get topics in a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamTopics(streamId: number, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getStreamTopics(streamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
         * @summary Get all streams
         * @param {boolean} [includePublic] Include all public streams. 
         * @param {boolean} [includeWebPublic] Include all web public streams. 
         * @param {boolean} [includeSubscribed] Include all streams that the user is subscribed to. 
         * @param {boolean} [includeAllActive] Include all active streams. The user must have administrative privileges to use this parameter. 
         * @param {boolean} [includeDefault] Include all default streams for the user\&#39;s realm. 
         * @param {boolean} [includeOwnerSubscribed] If the user is a bot, include all streams that the bot\&#39;s owner is subscribed to. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreams(includePublic?: boolean, includeWebPublic?: boolean, includeSubscribed?: boolean, includeAllActive?: boolean, includeDefault?: boolean, includeOwnerSubscribed?: boolean, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getStreams(includePublic, includeWebPublic, includeSubscribed, includeAllActive, includeDefault, includeOwnerSubscribed, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users subscribed to a stream.  `Get {{ api_url }}/v1/streams/{stream_id}/members` 
         * @summary Get the subscribers of a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribers(streamId: number, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getSubscribers(streamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
         * @summary Get subscription status
         * @param {number} userId The target user\&#39;s ID. 
         * @param {number} streamId The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionStatus(userId: number, streamId: number, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getSubscriptionStatus(userId, streamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
         * @summary Get subscribed streams
         * @param {boolean} [includeSubscribers] Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(includeSubscribers?: boolean, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getSubscriptions(includeSubscribers, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user\'s unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
         * @summary Topic muting
         * @param {string} topic The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. 
         * @param {'add' | 'remove'} op Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. 
         * @param {string} [stream] The name of the stream to access. 
         * @param {number} [streamId] The ID of the stream to access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        muteTopic(topic: string, op: 'add' | 'remove', stream?: string, streamId?: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.muteTopic(topic, op, stream, streamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
         * @summary Subscribe to a stream
         * @param {Array<object>} subscriptions A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. 
         * @param {Array<string | number>} [principals] A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
         * @param {boolean} [authorizationErrorsFatal] A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key. 
         * @param {boolean} [announce] If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream\&#39;s creation. 
         * @param {boolean} [inviteOnly] As described above, this endpoint will create a new stream if passed a stream name that doesn\&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams. 
         * @param {boolean} [historyPublicToSubscribers] Whether the stream\&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
         * @param {number} [streamPostPolicy] Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean. 
         * @param {string | number} [messageRetentionDays] Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribe(subscriptions: Array<object>, principals?: Array<string | number>, authorizationErrorsFatal?: boolean, announce?: boolean, inviteOnly?: boolean, historyPublicToSubscribers?: boolean, streamPostPolicy?: number, messageRetentionDays?: string | number, options?: any): AxiosPromise<AddSubscriptionsResponse> {
            return localVarFp.subscribe(subscriptions, principals, authorizationErrorsFatal, announce, inviteOnly, historyPublicToSubscribers, streamPostPolicy, messageRetentionDays, options).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
         * @summary Unsubscribe from a stream
         * @param {Array<string>} subscriptions A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. 
         * @param {Array<string | number>} [principals] A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe(subscriptions: Array<string>, principals?: Array<string | number>, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.unsubscribe(subscriptions, principals, options).then((request) => request(axios, basePath));
        },
        /**
         * Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
         * @summary Update a stream
         * @param {number} streamId The ID of the stream to access. 
         * @param {string} [description] The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
         * @param {string} [newName] The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
         * @param {boolean} [isPrivate] Change whether the stream is a private stream. 
         * @param {boolean} [isAnnouncementOnly] Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead. 
         * @param {number} [streamPostPolicy] Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean. 
         * @param {boolean} [historyPublicToSubscribers] Whether the stream\&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
         * @param {string | number} [messageRetentionDays] Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStream(streamId: number, description?: string, newName?: string, isPrivate?: boolean, isAnnouncementOnly?: boolean, streamPostPolicy?: number, historyPublicToSubscribers?: boolean, messageRetentionDays?: string | number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.updateStream(streamId, description, newName, isPrivate, isAnnouncementOnly, streamPostPolicy, historyPublicToSubscribers, messageRetentionDays, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used to update the user\'s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
         * @summary Update subscription settings
         * @param {Array<object>} subscriptionData A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user\&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionSettings(subscriptionData: Array<object>, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.updateSubscriptionSettings(subscriptionData, options).then((request) => request(axios, basePath));
        },
        /**
         * Update which streams you are are subscribed to. 
         * @summary Update subscriptions
         * @param {Array<string>} [_delete] A list of stream names to unsubscribe from. 
         * @param {Array<object>} [add] A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptions(_delete?: Array<string>, add?: Array<object>, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.updateSubscriptions(_delete, add, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreamsApi - object-oriented interface
 * @export
 * @class StreamsApi
 * @extends {BaseAPI}
 */
export class StreamsApi extends BaseAPI {
    /**
     * [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}` 
     * @summary Archive a stream
     * @param {number} streamId The ID of the stream to access. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public archiveStream(streamId: number, options?: any) {
        return StreamsApiFp(this.configuration).archiveStream(streamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
     * @summary Create BigBlueButton video call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public createBigBlueButtonVideoCall(options?: any) {
        return StreamsApiFp(this.configuration).createBigBlueButtonVideoCall(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all messages in a topic.  `POST {{ api_url }}/v1/streams/{stream_id}/delete_topic`  Topics are a field on messages (not an independent data structure), so deleting all the messages in the topic deletes the topic from Zulip. 
     * @summary Delete a topic
     * @param {number} streamId The ID of the stream to access. 
     * @param {string} topicName The name of the topic to delete. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public deleteTopic(streamId: number, topicName: string, options?: any) {
        return StreamsApiFp(this.configuration).deleteTopic(streamId, topicName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id` 
     * @summary Get stream ID
     * @param {string} stream The name of the stream to access. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getStreamId(stream: string, options?: any) {
        return StreamsApiFp(this.configuration).getStreamId(stream, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics` 
     * @summary Get topics in a stream
     * @param {number} streamId The ID of the stream to access. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getStreamTopics(streamId: number, options?: any) {
        return StreamsApiFp(this.configuration).getStreamTopics(streamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams` 
     * @summary Get all streams
     * @param {boolean} [includePublic] Include all public streams. 
     * @param {boolean} [includeWebPublic] Include all web public streams. 
     * @param {boolean} [includeSubscribed] Include all streams that the user is subscribed to. 
     * @param {boolean} [includeAllActive] Include all active streams. The user must have administrative privileges to use this parameter. 
     * @param {boolean} [includeDefault] Include all default streams for the user\&#39;s realm. 
     * @param {boolean} [includeOwnerSubscribed] If the user is a bot, include all streams that the bot\&#39;s owner is subscribed to. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getStreams(includePublic?: boolean, includeWebPublic?: boolean, includeSubscribed?: boolean, includeAllActive?: boolean, includeDefault?: boolean, includeOwnerSubscribed?: boolean, options?: any) {
        return StreamsApiFp(this.configuration).getStreams(includePublic, includeWebPublic, includeSubscribed, includeAllActive, includeDefault, includeOwnerSubscribed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all users subscribed to a stream.  `Get {{ api_url }}/v1/streams/{stream_id}/members` 
     * @summary Get the subscribers of a stream
     * @param {number} streamId The ID of the stream to access. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getSubscribers(streamId: number, options?: any) {
        return StreamsApiFp(this.configuration).getSubscribers(streamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11). 
     * @summary Get subscription status
     * @param {number} userId The target user\&#39;s ID. 
     * @param {number} streamId The ID of the stream to access. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getSubscriptionStatus(userId: number, streamId: number, options?: any) {
        return StreamsApiFp(this.configuration).getSubscriptionStatus(userId, streamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions` 
     * @summary Get subscribed streams
     * @param {boolean} [includeSubscribers] Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getSubscriptions(includeSubscribers?: boolean, options?: any) {
        return StreamsApiFp(this.configuration).getSubscriptions(includeSubscribers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user\'s unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics` 
     * @summary Topic muting
     * @param {string} topic The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. 
     * @param {'add' | 'remove'} op Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. 
     * @param {string} [stream] The name of the stream to access. 
     * @param {number} [streamId] The ID of the stream to access. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public muteTopic(topic: string, op: 'add' | 'remove', stream?: string, streamId?: number, options?: any) {
        return StreamsApiFp(this.configuration).muteTopic(topic, op, stream, streamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below. 
     * @summary Subscribe to a stream
     * @param {Array<object>} subscriptions A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. 
     * @param {Array<string | number>} [principals] A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
     * @param {boolean} [authorizationErrorsFatal] A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key. 
     * @param {boolean} [announce] If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream\&#39;s creation. 
     * @param {boolean} [inviteOnly] As described above, this endpoint will create a new stream if passed a stream name that doesn\&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams. 
     * @param {boolean} [historyPublicToSubscribers] Whether the stream\&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
     * @param {number} [streamPostPolicy] Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean. 
     * @param {string | number} [messageRetentionDays] Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public subscribe(subscriptions: Array<object>, principals?: Array<string | number>, authorizationErrorsFatal?: boolean, announce?: boolean, inviteOnly?: boolean, historyPublicToSubscribers?: boolean, streamPostPolicy?: number, messageRetentionDays?: string | number, options?: any) {
        return StreamsApiFp(this.configuration).subscribe(subscriptions, principals, authorizationErrorsFatal, announce, inviteOnly, historyPublicToSubscribers, streamPostPolicy, messageRetentionDays, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions` 
     * @summary Unsubscribe from a stream
     * @param {Array<string>} subscriptions A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. 
     * @param {Array<string | number>} [principals] A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public unsubscribe(subscriptions: Array<string>, principals?: Array<string | number>, options?: any) {
        return StreamsApiFp(this.configuration).unsubscribe(subscriptions, principals, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}` 
     * @summary Update a stream
     * @param {number} streamId The ID of the stream to access. 
     * @param {string} [description] The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
     * @param {string} [newName] The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
     * @param {boolean} [isPrivate] Change whether the stream is a private stream. 
     * @param {boolean} [isAnnouncementOnly] Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead. 
     * @param {number} [streamPostPolicy] Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean. 
     * @param {boolean} [historyPublicToSubscribers] Whether the stream\&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
     * @param {string | number} [messageRetentionDays] Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public updateStream(streamId: number, description?: string, newName?: string, isPrivate?: boolean, isAnnouncementOnly?: boolean, streamPostPolicy?: number, historyPublicToSubscribers?: boolean, messageRetentionDays?: string | number, options?: any) {
        return StreamsApiFp(this.configuration).updateStream(streamId, description, newName, isPrivate, isAnnouncementOnly, streamPostPolicy, historyPublicToSubscribers, messageRetentionDays, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used to update the user\'s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties` 
     * @summary Update subscription settings
     * @param {Array<object>} subscriptionData A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user\&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public updateSubscriptionSettings(subscriptionData: Array<object>, options?: any) {
        return StreamsApiFp(this.configuration).updateSubscriptionSettings(subscriptionData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update which streams you are are subscribed to. 
     * @summary Update subscriptions
     * @param {Array<string>} [_delete] A list of stream names to unsubscribe from. 
     * @param {Array<object>} [add] A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public updateSubscriptions(_delete?: Array<string>, add?: Array<object>, options?: any) {
        return StreamsApiFp(this.configuration).updateSubscriptions(_delete, add, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
         * @summary Create a user
         * @param {string} email The email address of the new user. 
         * @param {string} password The password of the new user. 
         * @param {string} fullName The full name of the new user. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (email: string, password: string, fullName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('createUser', 'email', email)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('createUser', 'password', password)
            // verify required parameter 'fullName' is not null or undefined
            assertParamExists('createUser', 'fullName', fullName)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            if (fullName !== undefined) {
                localVarQueryParameter['full_name'] = fullName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
         * @summary Create a user group
         * @param {string} name The name of the user group. 
         * @param {string} description The description of the user group. 
         * @param {Array<number>} members An array containing the user IDs of the initial members for the new user group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup: async (name: string, description: string, members: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createUserGroup', 'name', name)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('createUserGroup', 'description', description)
            // verify required parameter 'members' is not null or undefined
            assertParamExists('createUserGroup', 'members', members)
            const localVarPath = `/user_groups/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (members) {
                localVarQueryParameter['members'] = members;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates the user\'s account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
         * @summary Deactivate own user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateOwnUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
         * @summary Deactivate a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deactivateUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
         * @summary Get attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
         * @summary Get own user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
         * @summary Get a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: number, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientGravatar !== undefined) {
                localVarQueryParameter['client_gravatar'] = clientGravatar;
            }

            if (includeCustomProfileFields !== undefined) {
                localVarQueryParameter['include_custom_profile_fields'] = includeCustomProfileFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
         * @summary Get a user by email
         * @param {string} email The email address of the user whose details you want to fetch. 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByEmail: async (email: string, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getUserByEmail', 'email', email)
            const localVarPath = `/users/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientGravatar !== undefined) {
                localVarQueryParameter['client_gravatar'] = clientGravatar;
            }

            if (includeCustomProfileFields !== undefined) {
                localVarQueryParameter['include_custom_profile_fields'] = includeCustomProfileFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
         * @summary Get user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user\'s presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip\'s developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
         * @summary Get user presence
         * @param {string} userIdOrEmail The user_id or Zulip display email address of the user whose presence you want to fetch.  **Changes**: New in Zulip 4.0 (feature level 43). Previous versions only supported identifying the user by Zulip display email. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPresence: async (userIdOrEmail: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIdOrEmail' is not null or undefined
            assertParamExists('getUserPresence', 'userIdOrEmail', userIdOrEmail)
            const localVarPath = `/users/{user_id_or_email}/presence`
                .replace(`{${"user_id_or_email"}}`, encodeURIComponent(String(userIdOrEmail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
         * @summary Get all users
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (clientGravatar?: boolean, includeCustomProfileFields?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientGravatar !== undefined) {
                localVarQueryParameter['client_gravatar'] = clientGravatar;
            }

            if (includeCustomProfileFields !== undefined) {
                localVarQueryParameter['include_custom_profile_fields'] = includeCustomProfileFields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you\'ve muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user\'s name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
         * @summary Mute a user
         * @param {number} mutedUserId The ID of the user to mute/un-mute. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        muteUser: async (mutedUserId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mutedUserId' is not null or undefined
            assertParamExists('muteUser', 'mutedUserId', mutedUserId)
            const localVarPath = `/users/me/muted_users/{muted_user_id}`
                .replace(`{${"muted_user_id"}}`, encodeURIComponent(String(mutedUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
         * @summary Reactivate a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivateUser: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('reactivateUser', 'userId', userId)
            const localVarPath = `/users/{user_id}/reactivate`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
         * @summary Delete a user group
         * @param {number} userGroupId The ID of the target user group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserGroup: async (userGroupId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGroupId' is not null or undefined
            assertParamExists('removeUserGroup', 'userGroupId', userGroupId)
            const localVarPath = `/user_groups/{user_group_id}`
                .replace(`{${"user_group_id"}}`, encodeURIComponent(String(userGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip\'s typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip\'s typing notifications protocol. 
         * @summary Set \"typing\" status
         * @param {'start' | 'stop'} op Whether the user has started (&#x60;start&#x60;) or stopped (&#x60;stop&#x60;) to type. 
         * @param {Array<number>} to For \&#39;private\&#39; type it is the user_ids of the recipients of the message being typed. Send a JSON-encoded list of user_ids. (Use a list even if there is only one recipient.)  For \&#39;stream\&#39; type it is a single element list containing ID of stream in which the message is being typed.  **Changes**: Before Zulip 2.0, this parameter accepted only a JSON-encoded list of email addresses.  Support for the email address-based format was removed in Zulip 3.0 (feature level 11). 
         * @param {'private' | 'stream'} [type] Type of the message being composed. 
         * @param {string} [topic] Topic to which message is being typed. Required for the \&#39;stream\&#39; type. Ignored in case of \&#39;private\&#39; type. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTypingStatus: async (op: 'start' | 'stop', to: Array<number>, type?: 'private' | 'stream', topic?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'op' is not null or undefined
            assertParamExists('setTypingStatus', 'op', op)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('setTypingStatus', 'to', to)
            const localVarPath = `/typing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (op !== undefined) {
                localVarQueryParameter['op'] = op;
            }

            if (to) {
                localVarQueryParameter['to'] = to;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
         * @summary Unmute a user
         * @param {number} mutedUserId The ID of the user to mute/un-mute. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmuteUser: async (mutedUserId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mutedUserId' is not null or undefined
            assertParamExists('unmuteUser', 'mutedUserId', mutedUserId)
            const localVarPath = `/users/me/muted_users/{muted_user_id}`
                .replace(`{${"muted_user_id"}}`, encodeURIComponent(String(mutedUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is used to edit the current user\'s settings.  `PATCH {{ api_url }}/v1/settings`  **Changes**: Prior to Zulip 5.0 (feature level 80), this endpoint only supported the `full_name`, `email`, `old_password`, and `new_password` parameters. Notification settings were managed by `PATCH /settings/notifications`, and all other settings by `PATCH /settings/display`. The feature level 80 migration to merge these endpoints did not change how request parameters are encoded. Note, however, that it did change the handling of any invalid parameters present in a request to change notification or display settings, since the merged endpoint uses the new response format that was introduced for `/settings` in Zulip 5.0 (feature level 78).  The `/settings/display` and `/settings/notifications` endpoints are now deprecated aliases for this endpoint for backwards-compatibility, and will be removed once clients have migrated to use this endpoint. 
         * @summary Update settings
         * @param {string} [fullName] A new display name for the user. 
         * @param {string} [email] Asks the server to initiate a confirmation sequence to change the user\&#39;s email address to the indicated value. The user will need to demonstrate control of the new email address by clicking a confirmation link sent to that address. 
         * @param {string} [oldPassword] The user\&#39;s old Zulip password (or LDAP password, if LDAP authentication is in use).  Required only when sending the &#x60;new_password&#x60; parameter. 
         * @param {string} [newPassword] The user\&#39;s new Zulip password (or LDAP password, if LDAP authentication is in use).  The &#x60;old_password&#x60; parameter must be included in the request. 
         * @param {boolean} [twentyFourHourTime] Whether time should be [displayed in 24-hour notation](/help/change-the-time-format).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [denseMode] This setting has no effect at present.  It is reserved for use in controlling the default font size in Zulip.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [starredMessageCounts] Whether clients should display the [number of starred messages](/help/star-a-message#display-the-number-of-starred-messages).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [fluidLayoutWidth] Whether to use the [maximum available screen width](/help/enable-full-width-display) for the web app\&#39;s center panel (message feed, recent topics) on wide screens.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [highContrastMode] This setting is reserved for use to control variations in Zulip\&#39;s design to help visually impaired users.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {1 | 2 | 3} [colorScheme] Controls which [color theme](/help/night-mode) to use.  * 1 - Automatic * 2 - Night mode * 3 - Day mode  Automatic detection is implementing using the standard &#x60;prefers-color-scheme&#x60; media query.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [enableDraftsSynchronization] A boolean parameter to control whether synchronizing drafts is enabled for the user. When synchronization is disabled, all drafts stored in the server will be automatically deleted from the server.  This does not do anything (like sending events) to delete local copies of drafts stored in clients.  **Changes**: New in Zulip 5.0 (feature level 87). 
         * @param {boolean} [translateEmoticons] Whether to [translate emoticons to emoji](/help/enable-emoticon-translations) in messages the user sends.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {string} [defaultLanguage] What [default language](/help/change-your-language) to use for the account.  This controls both the Zulip UI as well as email notifications sent to the user.  The value needs to be a standard language code that the Zulip server has translation data for; for example, &#x60;\&quot;en\&quot;&#x60; for English or &#x60;\&quot;de\&quot;&#x60; for German.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 63). 
         * @param {string} [defaultView] The [default view](/help/change-default-view) used when opening a new Zulip web app window or hitting the &#x60;Esc&#x60; keyboard shortcut repeatedly.  * \&quot;recent_topics\&quot; - Recent topics view * \&quot;all_messages\&quot; - All messages view  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
         * @param {boolean} [leftSideUserlist] Whether the users list on left sidebar in narrow windows.  This feature is not heavily used and is likely to be reworked.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {string} [emojiset] The user\&#39;s configured [emoji set](/help/emoji-and-emoticons#use-emoticons), used to display emoji to the user everything they appear in the UI.  * \&quot;google\&quot; - Google modern * \&quot;google-blob\&quot; - Google classic * \&quot;twitter\&quot; - Twitter * \&quot;text\&quot; - Plain text  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
         * @param {1 | 2 | 3} [demoteInactiveStreams] Whether to [demote inactive streams](/help/manage-inactive-streams) in the left sidebar.  * 1 - Automatic * 2 - Always * 3 - Never  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {string} [timezone] The user\&#39;s [configured timezone](/help/change-your-timezone).  Timezone values supported by the server are served at [/static/generated/timezones.json](/static/generated/timezones.json).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
         * @param {boolean} [enableStreamDesktopNotifications] Enable visual desktop notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableStreamEmailNotifications] Enable email notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableStreamPushNotifications] Enable mobile notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableStreamAudibleNotifications] Enable audible desktop notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {string} [notificationSound] Notification sound name.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 63). 
         * @param {boolean} [enableDesktopNotifications] Enable visual desktop notifications for private messages and @-mentions.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableSounds] Enable audible desktop notifications for private messages and @-mentions.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {number} [emailNotificationsBatchingPeriodSeconds] The duration (in seconds) for which the server should wait to batch email notifications before sending them.  **Changes**: New in Zulip 5.0 (feature level 82) 
         * @param {boolean} [enableOfflineEmailNotifications] Enable email notifications for private messages and @-mentions received when the user is offline.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableOfflinePushNotifications] Enable mobile notification for private messages and @-mentions received when the user is offline.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableOnlinePushNotifications] Enable mobile notification for private messages and @-mentions received when the user is online.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableDigestEmails] Enable digest emails when the user is away.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableMarketingEmails] Enable marketing emails. Has no function outside Zulip Cloud.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableLoginEmails] Enable email notifications for new logins to account.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [messageContentInEmailNotifications] Include the message\&#39;s content in email notifications for new messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [pmContentInDesktopNotifications] Include content of private messages in desktop notifications.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [wildcardMentionsNotify] Whether wildcard mentions (E.g. @**all**) should send notifications like a personal mention.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {1 | 2 | 3} [desktopIconCountDisplay] Unread count summary (appears in desktop sidebar and browser tab)  * 1 - All unreads * 2 - Private messages and mentions * 3 - None  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [realmNameInNotifications] Include organization name in subject of message notification emails.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [presenceEnabled] Display the presence status to other users when online.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enterSends] Whether pressing Enter in the compose box sends a message (or saves a message edit).  **Changes**: Before Zulip 5.0 (feature level 81), this setting was managed by the &#x60;POST /users/me/enter-sends&#x60; endpoint, with the same parameter format. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings: async (fullName?: string, email?: string, oldPassword?: string, newPassword?: string, twentyFourHourTime?: boolean, denseMode?: boolean, starredMessageCounts?: boolean, fluidLayoutWidth?: boolean, highContrastMode?: boolean, colorScheme?: 1 | 2 | 3, enableDraftsSynchronization?: boolean, translateEmoticons?: boolean, defaultLanguage?: string, defaultView?: string, leftSideUserlist?: boolean, emojiset?: string, demoteInactiveStreams?: 1 | 2 | 3, timezone?: string, enableStreamDesktopNotifications?: boolean, enableStreamEmailNotifications?: boolean, enableStreamPushNotifications?: boolean, enableStreamAudibleNotifications?: boolean, notificationSound?: string, enableDesktopNotifications?: boolean, enableSounds?: boolean, emailNotificationsBatchingPeriodSeconds?: number, enableOfflineEmailNotifications?: boolean, enableOfflinePushNotifications?: boolean, enableOnlinePushNotifications?: boolean, enableDigestEmails?: boolean, enableMarketingEmails?: boolean, enableLoginEmails?: boolean, messageContentInEmailNotifications?: boolean, pmContentInDesktopNotifications?: boolean, wildcardMentionsNotify?: boolean, desktopIconCountDisplay?: 1 | 2 | 3, realmNameInNotifications?: boolean, presenceEnabled?: boolean, enterSends?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fullName !== undefined) {
                localVarQueryParameter['full_name'] = fullName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (oldPassword !== undefined) {
                localVarQueryParameter['old_password'] = oldPassword;
            }

            if (newPassword !== undefined) {
                localVarQueryParameter['new_password'] = newPassword;
            }

            if (twentyFourHourTime !== undefined) {
                localVarQueryParameter['twenty_four_hour_time'] = twentyFourHourTime;
            }

            if (denseMode !== undefined) {
                localVarQueryParameter['dense_mode'] = denseMode;
            }

            if (starredMessageCounts !== undefined) {
                localVarQueryParameter['starred_message_counts'] = starredMessageCounts;
            }

            if (fluidLayoutWidth !== undefined) {
                localVarQueryParameter['fluid_layout_width'] = fluidLayoutWidth;
            }

            if (highContrastMode !== undefined) {
                localVarQueryParameter['high_contrast_mode'] = highContrastMode;
            }

            if (colorScheme !== undefined) {
                localVarQueryParameter['color_scheme'] = colorScheme;
            }

            if (enableDraftsSynchronization !== undefined) {
                localVarQueryParameter['enable_drafts_synchronization'] = enableDraftsSynchronization;
            }

            if (translateEmoticons !== undefined) {
                localVarQueryParameter['translate_emoticons'] = translateEmoticons;
            }

            if (defaultLanguage !== undefined) {
                localVarQueryParameter['default_language'] = defaultLanguage;
            }

            if (defaultView !== undefined) {
                localVarQueryParameter['default_view'] = defaultView;
            }

            if (leftSideUserlist !== undefined) {
                localVarQueryParameter['left_side_userlist'] = leftSideUserlist;
            }

            if (emojiset !== undefined) {
                localVarQueryParameter['emojiset'] = emojiset;
            }

            if (demoteInactiveStreams !== undefined) {
                localVarQueryParameter['demote_inactive_streams'] = demoteInactiveStreams;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            if (enableStreamDesktopNotifications !== undefined) {
                localVarQueryParameter['enable_stream_desktop_notifications'] = enableStreamDesktopNotifications;
            }

            if (enableStreamEmailNotifications !== undefined) {
                localVarQueryParameter['enable_stream_email_notifications'] = enableStreamEmailNotifications;
            }

            if (enableStreamPushNotifications !== undefined) {
                localVarQueryParameter['enable_stream_push_notifications'] = enableStreamPushNotifications;
            }

            if (enableStreamAudibleNotifications !== undefined) {
                localVarQueryParameter['enable_stream_audible_notifications'] = enableStreamAudibleNotifications;
            }

            if (notificationSound !== undefined) {
                localVarQueryParameter['notification_sound'] = notificationSound;
            }

            if (enableDesktopNotifications !== undefined) {
                localVarQueryParameter['enable_desktop_notifications'] = enableDesktopNotifications;
            }

            if (enableSounds !== undefined) {
                localVarQueryParameter['enable_sounds'] = enableSounds;
            }

            if (emailNotificationsBatchingPeriodSeconds !== undefined) {
                localVarQueryParameter['email_notifications_batching_period_seconds'] = emailNotificationsBatchingPeriodSeconds;
            }

            if (enableOfflineEmailNotifications !== undefined) {
                localVarQueryParameter['enable_offline_email_notifications'] = enableOfflineEmailNotifications;
            }

            if (enableOfflinePushNotifications !== undefined) {
                localVarQueryParameter['enable_offline_push_notifications'] = enableOfflinePushNotifications;
            }

            if (enableOnlinePushNotifications !== undefined) {
                localVarQueryParameter['enable_online_push_notifications'] = enableOnlinePushNotifications;
            }

            if (enableDigestEmails !== undefined) {
                localVarQueryParameter['enable_digest_emails'] = enableDigestEmails;
            }

            if (enableMarketingEmails !== undefined) {
                localVarQueryParameter['enable_marketing_emails'] = enableMarketingEmails;
            }

            if (enableLoginEmails !== undefined) {
                localVarQueryParameter['enable_login_emails'] = enableLoginEmails;
            }

            if (messageContentInEmailNotifications !== undefined) {
                localVarQueryParameter['message_content_in_email_notifications'] = messageContentInEmailNotifications;
            }

            if (pmContentInDesktopNotifications !== undefined) {
                localVarQueryParameter['pm_content_in_desktop_notifications'] = pmContentInDesktopNotifications;
            }

            if (wildcardMentionsNotify !== undefined) {
                localVarQueryParameter['wildcard_mentions_notify'] = wildcardMentionsNotify;
            }

            if (desktopIconCountDisplay !== undefined) {
                localVarQueryParameter['desktop_icon_count_display'] = desktopIconCountDisplay;
            }

            if (realmNameInNotifications !== undefined) {
                localVarQueryParameter['realm_name_in_notifications'] = realmNameInNotifications;
            }

            if (presenceEnabled !== undefined) {
                localVarQueryParameter['presence_enabled'] = presenceEnabled;
            }

            if (enterSends !== undefined) {
                localVarQueryParameter['enter_sends'] = enterSends;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change your [status](/help/status-and-availability).  `POST {{ api_url }}/v1/users/me/status`  A request to this endpoint will only change the parameters passed. For example, passing just `status_text` requests a change in the status text, but will leave the status emoji unchanged.  Clients that wish to set the user\'s status to a specific value should pass all supported parameters. 
         * @summary Update your status
         * @param {string} [statusText] The text content of the status message. Sending the empty string will clear the user\&#39;s status.  **Note**: The limit on the size of the message is 60 characters. 
         * @param {boolean} [away] Whether the user should be marked as \&quot;away\&quot;. 
         * @param {string} [emojiName] The name for the emoji to associate with this status. 
         * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For example, for &#x60;unicode_emoji&#x60;, this will be an encoding of the Unicode codepoint; for &#x60;realm_emoji&#x60;, it\&#39;ll be the ID of the realm emoji. 
         * @param {string} [reactionType] One of the following values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode   codepoint). * &#x60;realm_emoji&#x60;: [Custom emoji](/help/add-custom-emoji).   (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to   namespace the &#x60;zulip&#x60; emoji. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus: async (statusText?: string, away?: boolean, emojiName?: string, emojiCode?: string, reactionType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (statusText !== undefined) {
                localVarQueryParameter['status_text'] = statusText;
            }

            if (away !== undefined) {
                localVarQueryParameter['away'] = away;
            }

            if (emojiName !== undefined) {
                localVarQueryParameter['emoji_name'] = emojiName;
            }

            if (emojiCode !== undefined) {
                localVarQueryParameter['emoji_code'] = emojiCode;
            }

            if (reactionType !== undefined) {
                localVarQueryParameter['reaction_type'] = reactionType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user\'s account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
         * @summary Update a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {string} [fullName] The user\&#39;s full name. 
         * @param {number} [role] New [role](/help/roles-and-permissions) for the user.  Roles are encoded as:  * Organization owner: 100 * Organization administrator: 200 * Organization moderator: 300 * Member: 400 * Guest: 600  Only organization owners can add or remove the owner role.  The owner role cannot be removed from the only organization owner.  **Changes**: New in Zulip 3.0 (feature level 8), replacing the previous pair of &#x60;is_admin&#x60; and &#x60;is_guest&#x60; boolean parameters. Organization moderator role added in Zulip 4.0 (feature level 60). 
         * @param {Array<object>} [profileData] A dictionary containing the to be updated custom profile field data for the user. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: number, fullName?: string, role?: number, profileData?: Array<object>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fullName !== undefined) {
                localVarQueryParameter['full_name'] = fullName;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (profileData) {
                localVarQueryParameter['profile_data'] = profileData;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
         * @summary Update a user group
         * @param {number} userGroupId The ID of the target user group. 
         * @param {string} name The new name of the group. 
         * @param {string} description The new description of the group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup: async (userGroupId: number, name: string, description: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGroupId' is not null or undefined
            assertParamExists('updateUserGroup', 'userGroupId', userGroupId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateUserGroup', 'name', name)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('updateUserGroup', 'description', description)
            const localVarPath = `/user_groups/{user_group_id}`
                .replace(`{${"user_group_id"}}`, encodeURIComponent(String(userGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
         * @summary Update user group members
         * @param {number} userGroupId The ID of the target user group. 
         * @param {Array<number>} [_delete] The list of user ids to be removed from the user group. 
         * @param {Array<number>} [add] The list of user ids to be added to the user group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroupMembers: async (userGroupId: number, _delete?: Array<number>, add?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userGroupId' is not null or undefined
            assertParamExists('updateUserGroupMembers', 'userGroupId', userGroupId)
            const localVarPath = `/user_groups/{user_group_id}/members`
                .replace(`{${"user_group_id"}}`, encodeURIComponent(String(userGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_delete) {
                localVarQueryParameter['delete'] = _delete;
            }

            if (add) {
                localVarQueryParameter['add'] = add;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
         * @summary Create a user
         * @param {string} email The email address of the new user. 
         * @param {string} password The password of the new user. 
         * @param {string} fullName The full name of the new user. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(email: string, password: string, fullName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(email, password, fullName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
         * @summary Create a user group
         * @param {string} name The name of the user group. 
         * @param {string} description The description of the user group. 
         * @param {Array<number>} members An array containing the user IDs of the initial members for the new user group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserGroup(name: string, description: string, members: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserGroup(name, description, members, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deactivates the user\'s account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
         * @summary Deactivate own user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateOwnUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateOwnUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
         * @summary Deactivate a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateUser(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
         * @summary Get attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachments(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachments(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
         * @summary Get own user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOwnUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
         * @summary Get a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: number, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, clientGravatar, includeCustomProfileFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
         * @summary Get a user by email
         * @param {string} email The email address of the user whose details you want to fetch. 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByEmail(email: string, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByEmail(email, clientGravatar, includeCustomProfileFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
         * @summary Get user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user\'s presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip\'s developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
         * @summary Get user presence
         * @param {string} userIdOrEmail The user_id or Zulip display email address of the user whose presence you want to fetch.  **Changes**: New in Zulip 4.0 (feature level 43). Previous versions only supported identifying the user by Zulip display email. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPresence(userIdOrEmail: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPresence(userIdOrEmail, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
         * @summary Get all users
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(clientGravatar, includeCustomProfileFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you\'ve muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user\'s name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
         * @summary Mute a user
         * @param {number} mutedUserId The ID of the user to mute/un-mute. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async muteUser(mutedUserId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.muteUser(mutedUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
         * @summary Reactivate a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reactivateUser(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reactivateUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
         * @summary Delete a user group
         * @param {number} userGroupId The ID of the target user group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserGroup(userGroupId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserGroup(userGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip\'s typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip\'s typing notifications protocol. 
         * @summary Set \"typing\" status
         * @param {'start' | 'stop'} op Whether the user has started (&#x60;start&#x60;) or stopped (&#x60;stop&#x60;) to type. 
         * @param {Array<number>} to For \&#39;private\&#39; type it is the user_ids of the recipients of the message being typed. Send a JSON-encoded list of user_ids. (Use a list even if there is only one recipient.)  For \&#39;stream\&#39; type it is a single element list containing ID of stream in which the message is being typed.  **Changes**: Before Zulip 2.0, this parameter accepted only a JSON-encoded list of email addresses.  Support for the email address-based format was removed in Zulip 3.0 (feature level 11). 
         * @param {'private' | 'stream'} [type] Type of the message being composed. 
         * @param {string} [topic] Topic to which message is being typed. Required for the \&#39;stream\&#39; type. Ignored in case of \&#39;private\&#39; type. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTypingStatus(op: 'start' | 'stop', to: Array<number>, type?: 'private' | 'stream', topic?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTypingStatus(op, to, type, topic, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
         * @summary Unmute a user
         * @param {number} mutedUserId The ID of the user to mute/un-mute. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unmuteUser(mutedUserId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unmuteUser(mutedUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint is used to edit the current user\'s settings.  `PATCH {{ api_url }}/v1/settings`  **Changes**: Prior to Zulip 5.0 (feature level 80), this endpoint only supported the `full_name`, `email`, `old_password`, and `new_password` parameters. Notification settings were managed by `PATCH /settings/notifications`, and all other settings by `PATCH /settings/display`. The feature level 80 migration to merge these endpoints did not change how request parameters are encoded. Note, however, that it did change the handling of any invalid parameters present in a request to change notification or display settings, since the merged endpoint uses the new response format that was introduced for `/settings` in Zulip 5.0 (feature level 78).  The `/settings/display` and `/settings/notifications` endpoints are now deprecated aliases for this endpoint for backwards-compatibility, and will be removed once clients have migrated to use this endpoint. 
         * @summary Update settings
         * @param {string} [fullName] A new display name for the user. 
         * @param {string} [email] Asks the server to initiate a confirmation sequence to change the user\&#39;s email address to the indicated value. The user will need to demonstrate control of the new email address by clicking a confirmation link sent to that address. 
         * @param {string} [oldPassword] The user\&#39;s old Zulip password (or LDAP password, if LDAP authentication is in use).  Required only when sending the &#x60;new_password&#x60; parameter. 
         * @param {string} [newPassword] The user\&#39;s new Zulip password (or LDAP password, if LDAP authentication is in use).  The &#x60;old_password&#x60; parameter must be included in the request. 
         * @param {boolean} [twentyFourHourTime] Whether time should be [displayed in 24-hour notation](/help/change-the-time-format).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [denseMode] This setting has no effect at present.  It is reserved for use in controlling the default font size in Zulip.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [starredMessageCounts] Whether clients should display the [number of starred messages](/help/star-a-message#display-the-number-of-starred-messages).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [fluidLayoutWidth] Whether to use the [maximum available screen width](/help/enable-full-width-display) for the web app\&#39;s center panel (message feed, recent topics) on wide screens.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [highContrastMode] This setting is reserved for use to control variations in Zulip\&#39;s design to help visually impaired users.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {1 | 2 | 3} [colorScheme] Controls which [color theme](/help/night-mode) to use.  * 1 - Automatic * 2 - Night mode * 3 - Day mode  Automatic detection is implementing using the standard &#x60;prefers-color-scheme&#x60; media query.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [enableDraftsSynchronization] A boolean parameter to control whether synchronizing drafts is enabled for the user. When synchronization is disabled, all drafts stored in the server will be automatically deleted from the server.  This does not do anything (like sending events) to delete local copies of drafts stored in clients.  **Changes**: New in Zulip 5.0 (feature level 87). 
         * @param {boolean} [translateEmoticons] Whether to [translate emoticons to emoji](/help/enable-emoticon-translations) in messages the user sends.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {string} [defaultLanguage] What [default language](/help/change-your-language) to use for the account.  This controls both the Zulip UI as well as email notifications sent to the user.  The value needs to be a standard language code that the Zulip server has translation data for; for example, &#x60;\&quot;en\&quot;&#x60; for English or &#x60;\&quot;de\&quot;&#x60; for German.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 63). 
         * @param {string} [defaultView] The [default view](/help/change-default-view) used when opening a new Zulip web app window or hitting the &#x60;Esc&#x60; keyboard shortcut repeatedly.  * \&quot;recent_topics\&quot; - Recent topics view * \&quot;all_messages\&quot; - All messages view  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
         * @param {boolean} [leftSideUserlist] Whether the users list on left sidebar in narrow windows.  This feature is not heavily used and is likely to be reworked.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {string} [emojiset] The user\&#39;s configured [emoji set](/help/emoji-and-emoticons#use-emoticons), used to display emoji to the user everything they appear in the UI.  * \&quot;google\&quot; - Google modern * \&quot;google-blob\&quot; - Google classic * \&quot;twitter\&quot; - Twitter * \&quot;text\&quot; - Plain text  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
         * @param {1 | 2 | 3} [demoteInactiveStreams] Whether to [demote inactive streams](/help/manage-inactive-streams) in the left sidebar.  * 1 - Automatic * 2 - Always * 3 - Never  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {string} [timezone] The user\&#39;s [configured timezone](/help/change-your-timezone).  Timezone values supported by the server are served at [/static/generated/timezones.json](/static/generated/timezones.json).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
         * @param {boolean} [enableStreamDesktopNotifications] Enable visual desktop notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableStreamEmailNotifications] Enable email notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableStreamPushNotifications] Enable mobile notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableStreamAudibleNotifications] Enable audible desktop notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {string} [notificationSound] Notification sound name.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 63). 
         * @param {boolean} [enableDesktopNotifications] Enable visual desktop notifications for private messages and @-mentions.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableSounds] Enable audible desktop notifications for private messages and @-mentions.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {number} [emailNotificationsBatchingPeriodSeconds] The duration (in seconds) for which the server should wait to batch email notifications before sending them.  **Changes**: New in Zulip 5.0 (feature level 82) 
         * @param {boolean} [enableOfflineEmailNotifications] Enable email notifications for private messages and @-mentions received when the user is offline.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableOfflinePushNotifications] Enable mobile notification for private messages and @-mentions received when the user is offline.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableOnlinePushNotifications] Enable mobile notification for private messages and @-mentions received when the user is online.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableDigestEmails] Enable digest emails when the user is away.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableMarketingEmails] Enable marketing emails. Has no function outside Zulip Cloud.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableLoginEmails] Enable email notifications for new logins to account.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [messageContentInEmailNotifications] Include the message\&#39;s content in email notifications for new messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [pmContentInDesktopNotifications] Include content of private messages in desktop notifications.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [wildcardMentionsNotify] Whether wildcard mentions (E.g. @**all**) should send notifications like a personal mention.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {1 | 2 | 3} [desktopIconCountDisplay] Unread count summary (appears in desktop sidebar and browser tab)  * 1 - All unreads * 2 - Private messages and mentions * 3 - None  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [realmNameInNotifications] Include organization name in subject of message notification emails.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [presenceEnabled] Display the presence status to other users when online.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enterSends] Whether pressing Enter in the compose box sends a message (or saves a message edit).  **Changes**: Before Zulip 5.0 (feature level 81), this setting was managed by the &#x60;POST /users/me/enter-sends&#x60; endpoint, with the same parameter format. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSettings(fullName?: string, email?: string, oldPassword?: string, newPassword?: string, twentyFourHourTime?: boolean, denseMode?: boolean, starredMessageCounts?: boolean, fluidLayoutWidth?: boolean, highContrastMode?: boolean, colorScheme?: 1 | 2 | 3, enableDraftsSynchronization?: boolean, translateEmoticons?: boolean, defaultLanguage?: string, defaultView?: string, leftSideUserlist?: boolean, emojiset?: string, demoteInactiveStreams?: 1 | 2 | 3, timezone?: string, enableStreamDesktopNotifications?: boolean, enableStreamEmailNotifications?: boolean, enableStreamPushNotifications?: boolean, enableStreamAudibleNotifications?: boolean, notificationSound?: string, enableDesktopNotifications?: boolean, enableSounds?: boolean, emailNotificationsBatchingPeriodSeconds?: number, enableOfflineEmailNotifications?: boolean, enableOfflinePushNotifications?: boolean, enableOnlinePushNotifications?: boolean, enableDigestEmails?: boolean, enableMarketingEmails?: boolean, enableLoginEmails?: boolean, messageContentInEmailNotifications?: boolean, pmContentInDesktopNotifications?: boolean, wildcardMentionsNotify?: boolean, desktopIconCountDisplay?: 1 | 2 | 3, realmNameInNotifications?: boolean, presenceEnabled?: boolean, enterSends?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccessBase & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSettings(fullName, email, oldPassword, newPassword, twentyFourHourTime, denseMode, starredMessageCounts, fluidLayoutWidth, highContrastMode, colorScheme, enableDraftsSynchronization, translateEmoticons, defaultLanguage, defaultView, leftSideUserlist, emojiset, demoteInactiveStreams, timezone, enableStreamDesktopNotifications, enableStreamEmailNotifications, enableStreamPushNotifications, enableStreamAudibleNotifications, notificationSound, enableDesktopNotifications, enableSounds, emailNotificationsBatchingPeriodSeconds, enableOfflineEmailNotifications, enableOfflinePushNotifications, enableOnlinePushNotifications, enableDigestEmails, enableMarketingEmails, enableLoginEmails, messageContentInEmailNotifications, pmContentInDesktopNotifications, wildcardMentionsNotify, desktopIconCountDisplay, realmNameInNotifications, presenceEnabled, enterSends, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change your [status](/help/status-and-availability).  `POST {{ api_url }}/v1/users/me/status`  A request to this endpoint will only change the parameters passed. For example, passing just `status_text` requests a change in the status text, but will leave the status emoji unchanged.  Clients that wish to set the user\'s status to a specific value should pass all supported parameters. 
         * @summary Update your status
         * @param {string} [statusText] The text content of the status message. Sending the empty string will clear the user\&#39;s status.  **Note**: The limit on the size of the message is 60 characters. 
         * @param {boolean} [away] Whether the user should be marked as \&quot;away\&quot;. 
         * @param {string} [emojiName] The name for the emoji to associate with this status. 
         * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For example, for &#x60;unicode_emoji&#x60;, this will be an encoding of the Unicode codepoint; for &#x60;realm_emoji&#x60;, it\&#39;ll be the ID of the realm emoji. 
         * @param {string} [reactionType] One of the following values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode   codepoint). * &#x60;realm_emoji&#x60;: [Custom emoji](/help/add-custom-emoji).   (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to   namespace the &#x60;zulip&#x60; emoji. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatus(statusText?: string, away?: boolean, emojiName?: string, emojiCode?: string, reactionType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatus(statusText, away, emojiName, emojiCode, reactionType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user\'s account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
         * @summary Update a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {string} [fullName] The user\&#39;s full name. 
         * @param {number} [role] New [role](/help/roles-and-permissions) for the user.  Roles are encoded as:  * Organization owner: 100 * Organization administrator: 200 * Organization moderator: 300 * Member: 400 * Guest: 600  Only organization owners can add or remove the owner role.  The owner role cannot be removed from the only organization owner.  **Changes**: New in Zulip 3.0 (feature level 8), replacing the previous pair of &#x60;is_admin&#x60; and &#x60;is_guest&#x60; boolean parameters. Organization moderator role added in Zulip 4.0 (feature level 60). 
         * @param {Array<object>} [profileData] A dictionary containing the to be updated custom profile field data for the user. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: number, fullName?: string, role?: number, profileData?: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, fullName, role, profileData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
         * @summary Update a user group
         * @param {number} userGroupId The ID of the target user group. 
         * @param {string} name The new name of the group. 
         * @param {string} description The new description of the group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserGroup(userGroupId: number, name: string, description: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserGroup(userGroupId, name, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
         * @summary Update user group members
         * @param {number} userGroupId The ID of the target user group. 
         * @param {Array<number>} [_delete] The list of user ids to be removed from the user group. 
         * @param {Array<number>} [add] The list of user ids to be added to the user group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserGroupMembers(userGroupId: number, _delete?: Array<number>, add?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserGroupMembers(userGroupId, _delete, add, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
         * @summary Create a user
         * @param {string} email The email address of the new user. 
         * @param {string} password The password of the new user. 
         * @param {string} fullName The full name of the new user. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(email: string, password: string, fullName: string, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.createUser(email, password, fullName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
         * @summary Create a user group
         * @param {string} name The name of the user group. 
         * @param {string} description The description of the user group. 
         * @param {Array<number>} members An array containing the user IDs of the initial members for the new user group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserGroup(name: string, description: string, members: Array<number>, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.createUserGroup(name, description, members, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates the user\'s account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
         * @summary Deactivate own user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateOwnUser(options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.deactivateOwnUser(options).then((request) => request(axios, basePath));
        },
        /**
         * [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
         * @summary Deactivate a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser(userId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.deactivateUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
         * @summary Get attachments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getAttachments(options).then((request) => request(axios, basePath));
        },
        /**
         * Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
         * @summary Get own user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnUser(options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getOwnUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
         * @summary Get a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getUser(userId, clientGravatar, includeCustomProfileFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
         * @summary Get a user by email
         * @param {string} email The email address of the user whose details you want to fetch. 
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByEmail(email: string, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getUserByEmail(email, clientGravatar, includeCustomProfileFields, options).then((request) => request(axios, basePath));
        },
        /**
         * {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
         * @summary Get user groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroups(options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getUserGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user\'s presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip\'s developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
         * @summary Get user presence
         * @param {string} userIdOrEmail The user_id or Zulip display email address of the user whose presence you want to fetch.  **Changes**: New in Zulip 4.0 (feature level 43). Previous versions only supported identifying the user by Zulip display email. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPresence(userIdOrEmail: string, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getUserPresence(userIdOrEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
         * @summary Get all users
         * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
         * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.getUsers(clientGravatar, includeCustomProfileFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you\'ve muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user\'s name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
         * @summary Mute a user
         * @param {number} mutedUserId The ID of the user to mute/un-mute. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        muteUser(mutedUserId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.muteUser(mutedUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
         * @summary Reactivate a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivateUser(userId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.reactivateUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
         * @summary Delete a user group
         * @param {number} userGroupId The ID of the target user group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserGroup(userGroupId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.removeUserGroup(userGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip\'s typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip\'s typing notifications protocol. 
         * @summary Set \"typing\" status
         * @param {'start' | 'stop'} op Whether the user has started (&#x60;start&#x60;) or stopped (&#x60;stop&#x60;) to type. 
         * @param {Array<number>} to For \&#39;private\&#39; type it is the user_ids of the recipients of the message being typed. Send a JSON-encoded list of user_ids. (Use a list even if there is only one recipient.)  For \&#39;stream\&#39; type it is a single element list containing ID of stream in which the message is being typed.  **Changes**: Before Zulip 2.0, this parameter accepted only a JSON-encoded list of email addresses.  Support for the email address-based format was removed in Zulip 3.0 (feature level 11). 
         * @param {'private' | 'stream'} [type] Type of the message being composed. 
         * @param {string} [topic] Topic to which message is being typed. Required for the \&#39;stream\&#39; type. Ignored in case of \&#39;private\&#39; type. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTypingStatus(op: 'start' | 'stop', to: Array<number>, type?: 'private' | 'stream', topic?: string, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.setTypingStatus(op, to, type, topic, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
         * @summary Unmute a user
         * @param {number} mutedUserId The ID of the user to mute/un-mute. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmuteUser(mutedUserId: number, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.unmuteUser(mutedUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is used to edit the current user\'s settings.  `PATCH {{ api_url }}/v1/settings`  **Changes**: Prior to Zulip 5.0 (feature level 80), this endpoint only supported the `full_name`, `email`, `old_password`, and `new_password` parameters. Notification settings were managed by `PATCH /settings/notifications`, and all other settings by `PATCH /settings/display`. The feature level 80 migration to merge these endpoints did not change how request parameters are encoded. Note, however, that it did change the handling of any invalid parameters present in a request to change notification or display settings, since the merged endpoint uses the new response format that was introduced for `/settings` in Zulip 5.0 (feature level 78).  The `/settings/display` and `/settings/notifications` endpoints are now deprecated aliases for this endpoint for backwards-compatibility, and will be removed once clients have migrated to use this endpoint. 
         * @summary Update settings
         * @param {string} [fullName] A new display name for the user. 
         * @param {string} [email] Asks the server to initiate a confirmation sequence to change the user\&#39;s email address to the indicated value. The user will need to demonstrate control of the new email address by clicking a confirmation link sent to that address. 
         * @param {string} [oldPassword] The user\&#39;s old Zulip password (or LDAP password, if LDAP authentication is in use).  Required only when sending the &#x60;new_password&#x60; parameter. 
         * @param {string} [newPassword] The user\&#39;s new Zulip password (or LDAP password, if LDAP authentication is in use).  The &#x60;old_password&#x60; parameter must be included in the request. 
         * @param {boolean} [twentyFourHourTime] Whether time should be [displayed in 24-hour notation](/help/change-the-time-format).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [denseMode] This setting has no effect at present.  It is reserved for use in controlling the default font size in Zulip.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [starredMessageCounts] Whether clients should display the [number of starred messages](/help/star-a-message#display-the-number-of-starred-messages).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [fluidLayoutWidth] Whether to use the [maximum available screen width](/help/enable-full-width-display) for the web app\&#39;s center panel (message feed, recent topics) on wide screens.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [highContrastMode] This setting is reserved for use to control variations in Zulip\&#39;s design to help visually impaired users.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {1 | 2 | 3} [colorScheme] Controls which [color theme](/help/night-mode) to use.  * 1 - Automatic * 2 - Night mode * 3 - Day mode  Automatic detection is implementing using the standard &#x60;prefers-color-scheme&#x60; media query.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {boolean} [enableDraftsSynchronization] A boolean parameter to control whether synchronizing drafts is enabled for the user. When synchronization is disabled, all drafts stored in the server will be automatically deleted from the server.  This does not do anything (like sending events) to delete local copies of drafts stored in clients.  **Changes**: New in Zulip 5.0 (feature level 87). 
         * @param {boolean} [translateEmoticons] Whether to [translate emoticons to emoji](/help/enable-emoticon-translations) in messages the user sends.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {string} [defaultLanguage] What [default language](/help/change-your-language) to use for the account.  This controls both the Zulip UI as well as email notifications sent to the user.  The value needs to be a standard language code that the Zulip server has translation data for; for example, &#x60;\&quot;en\&quot;&#x60; for English or &#x60;\&quot;de\&quot;&#x60; for German.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 63). 
         * @param {string} [defaultView] The [default view](/help/change-default-view) used when opening a new Zulip web app window or hitting the &#x60;Esc&#x60; keyboard shortcut repeatedly.  * \&quot;recent_topics\&quot; - Recent topics view * \&quot;all_messages\&quot; - All messages view  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
         * @param {boolean} [leftSideUserlist] Whether the users list on left sidebar in narrow windows.  This feature is not heavily used and is likely to be reworked.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {string} [emojiset] The user\&#39;s configured [emoji set](/help/emoji-and-emoticons#use-emoticons), used to display emoji to the user everything they appear in the UI.  * \&quot;google\&quot; - Google modern * \&quot;google-blob\&quot; - Google classic * \&quot;twitter\&quot; - Twitter * \&quot;text\&quot; - Plain text  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
         * @param {1 | 2 | 3} [demoteInactiveStreams] Whether to [demote inactive streams](/help/manage-inactive-streams) in the left sidebar.  * 1 - Automatic * 2 - Always * 3 - Never  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
         * @param {string} [timezone] The user\&#39;s [configured timezone](/help/change-your-timezone).  Timezone values supported by the server are served at [/static/generated/timezones.json](/static/generated/timezones.json).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
         * @param {boolean} [enableStreamDesktopNotifications] Enable visual desktop notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableStreamEmailNotifications] Enable email notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableStreamPushNotifications] Enable mobile notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableStreamAudibleNotifications] Enable audible desktop notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {string} [notificationSound] Notification sound name.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 63). 
         * @param {boolean} [enableDesktopNotifications] Enable visual desktop notifications for private messages and @-mentions.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableSounds] Enable audible desktop notifications for private messages and @-mentions.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {number} [emailNotificationsBatchingPeriodSeconds] The duration (in seconds) for which the server should wait to batch email notifications before sending them.  **Changes**: New in Zulip 5.0 (feature level 82) 
         * @param {boolean} [enableOfflineEmailNotifications] Enable email notifications for private messages and @-mentions received when the user is offline.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableOfflinePushNotifications] Enable mobile notification for private messages and @-mentions received when the user is offline.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableOnlinePushNotifications] Enable mobile notification for private messages and @-mentions received when the user is online.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableDigestEmails] Enable digest emails when the user is away.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableMarketingEmails] Enable marketing emails. Has no function outside Zulip Cloud.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enableLoginEmails] Enable email notifications for new logins to account.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [messageContentInEmailNotifications] Include the message\&#39;s content in email notifications for new messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [pmContentInDesktopNotifications] Include content of private messages in desktop notifications.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [wildcardMentionsNotify] Whether wildcard mentions (E.g. @**all**) should send notifications like a personal mention.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {1 | 2 | 3} [desktopIconCountDisplay] Unread count summary (appears in desktop sidebar and browser tab)  * 1 - All unreads * 2 - Private messages and mentions * 3 - None  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [realmNameInNotifications] Include organization name in subject of message notification emails.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [presenceEnabled] Display the presence status to other users when online.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
         * @param {boolean} [enterSends] Whether pressing Enter in the compose box sends a message (or saves a message edit).  **Changes**: Before Zulip 5.0 (feature level 81), this setting was managed by the &#x60;POST /users/me/enter-sends&#x60; endpoint, with the same parameter format. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSettings(fullName?: string, email?: string, oldPassword?: string, newPassword?: string, twentyFourHourTime?: boolean, denseMode?: boolean, starredMessageCounts?: boolean, fluidLayoutWidth?: boolean, highContrastMode?: boolean, colorScheme?: 1 | 2 | 3, enableDraftsSynchronization?: boolean, translateEmoticons?: boolean, defaultLanguage?: string, defaultView?: string, leftSideUserlist?: boolean, emojiset?: string, demoteInactiveStreams?: 1 | 2 | 3, timezone?: string, enableStreamDesktopNotifications?: boolean, enableStreamEmailNotifications?: boolean, enableStreamPushNotifications?: boolean, enableStreamAudibleNotifications?: boolean, notificationSound?: string, enableDesktopNotifications?: boolean, enableSounds?: boolean, emailNotificationsBatchingPeriodSeconds?: number, enableOfflineEmailNotifications?: boolean, enableOfflinePushNotifications?: boolean, enableOnlinePushNotifications?: boolean, enableDigestEmails?: boolean, enableMarketingEmails?: boolean, enableLoginEmails?: boolean, messageContentInEmailNotifications?: boolean, pmContentInDesktopNotifications?: boolean, wildcardMentionsNotify?: boolean, desktopIconCountDisplay?: 1 | 2 | 3, realmNameInNotifications?: boolean, presenceEnabled?: boolean, enterSends?: boolean, options?: any): AxiosPromise<JsonSuccessBase & object> {
            return localVarFp.updateSettings(fullName, email, oldPassword, newPassword, twentyFourHourTime, denseMode, starredMessageCounts, fluidLayoutWidth, highContrastMode, colorScheme, enableDraftsSynchronization, translateEmoticons, defaultLanguage, defaultView, leftSideUserlist, emojiset, demoteInactiveStreams, timezone, enableStreamDesktopNotifications, enableStreamEmailNotifications, enableStreamPushNotifications, enableStreamAudibleNotifications, notificationSound, enableDesktopNotifications, enableSounds, emailNotificationsBatchingPeriodSeconds, enableOfflineEmailNotifications, enableOfflinePushNotifications, enableOnlinePushNotifications, enableDigestEmails, enableMarketingEmails, enableLoginEmails, messageContentInEmailNotifications, pmContentInDesktopNotifications, wildcardMentionsNotify, desktopIconCountDisplay, realmNameInNotifications, presenceEnabled, enterSends, options).then((request) => request(axios, basePath));
        },
        /**
         * Change your [status](/help/status-and-availability).  `POST {{ api_url }}/v1/users/me/status`  A request to this endpoint will only change the parameters passed. For example, passing just `status_text` requests a change in the status text, but will leave the status emoji unchanged.  Clients that wish to set the user\'s status to a specific value should pass all supported parameters. 
         * @summary Update your status
         * @param {string} [statusText] The text content of the status message. Sending the empty string will clear the user\&#39;s status.  **Note**: The limit on the size of the message is 60 characters. 
         * @param {boolean} [away] Whether the user should be marked as \&quot;away\&quot;. 
         * @param {string} [emojiName] The name for the emoji to associate with this status. 
         * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For example, for &#x60;unicode_emoji&#x60;, this will be an encoding of the Unicode codepoint; for &#x60;realm_emoji&#x60;, it\&#39;ll be the ID of the realm emoji. 
         * @param {string} [reactionType] One of the following values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode   codepoint). * &#x60;realm_emoji&#x60;: [Custom emoji](/help/add-custom-emoji).   (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to   namespace the &#x60;zulip&#x60; emoji. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus(statusText?: string, away?: boolean, emojiName?: string, emojiCode?: string, reactionType?: string, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.updateStatus(statusText, away, emojiName, emojiCode, reactionType, options).then((request) => request(axios, basePath));
        },
        /**
         * Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user\'s account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
         * @summary Update a user
         * @param {number} userId The target user\&#39;s ID. 
         * @param {string} [fullName] The user\&#39;s full name. 
         * @param {number} [role] New [role](/help/roles-and-permissions) for the user.  Roles are encoded as:  * Organization owner: 100 * Organization administrator: 200 * Organization moderator: 300 * Member: 400 * Guest: 600  Only organization owners can add or remove the owner role.  The owner role cannot be removed from the only organization owner.  **Changes**: New in Zulip 3.0 (feature level 8), replacing the previous pair of &#x60;is_admin&#x60; and &#x60;is_guest&#x60; boolean parameters. Organization moderator role added in Zulip 4.0 (feature level 60). 
         * @param {Array<object>} [profileData] A dictionary containing the to be updated custom profile field data for the user. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: number, fullName?: string, role?: number, profileData?: Array<object>, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.updateUser(userId, fullName, role, profileData, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
         * @summary Update a user group
         * @param {number} userGroupId The ID of the target user group. 
         * @param {string} name The new name of the group. 
         * @param {string} description The new description of the group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroup(userGroupId: number, name: string, description: string, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.updateUserGroup(userGroupId, name, description, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
         * @summary Update user group members
         * @param {number} userGroupId The ID of the target user group. 
         * @param {Array<number>} [_delete] The list of user ids to be removed from the user group. 
         * @param {Array<number>} [add] The list of user ids to be added to the user group. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserGroupMembers(userGroupId: number, _delete?: Array<number>, add?: Array<number>, options?: any): AxiosPromise<JsonSuccess> {
            return localVarFp.updateUserGroupMembers(userGroupId, _delete, add, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * {!can-create-users-only.md!}  Create a new user account via the API.  `POST {{ api_url }}/v1/users` 
     * @summary Create a user
     * @param {string} email The email address of the new user. 
     * @param {string} password The password of the new user. 
     * @param {string} fullName The full name of the new user. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(email: string, password: string, fullName: string, options?: any) {
        return UsersApiFp(this.configuration).createUser(email, password, fullName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/create` 
     * @summary Create a user group
     * @param {string} name The name of the user group. 
     * @param {string} description The description of the user group. 
     * @param {Array<number>} members An array containing the user IDs of the initial members for the new user group. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserGroup(name: string, description: string, members: Array<number>, options?: any) {
        return UsersApiFp(this.configuration).createUserGroup(name, description, members, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivates the user\'s account.  See also the administrative endpoint for [deactivating another user](/api/deactivate-user).  `DELETE {{ api_url }}/v1/users/me`  This endpoint is primarily useful to Zulip clients providing a user settings UI. 
     * @summary Deactivate own user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deactivateOwnUser(options?: any) {
        return UsersApiFp(this.configuration).deactivateOwnUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [Deactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `DELETE {{ api_url }}/v1/users/{user_id}` 
     * @summary Deactivate a user
     * @param {number} userId The target user\&#39;s ID. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deactivateUser(userId: number, options?: any) {
        return UsersApiFp(this.configuration).deactivateUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch metadata on files uploaded by the requesting user.  `GET {{ api_url }}/v1/attachments` 
     * @summary Get attachments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAttachments(options?: any) {
        return UsersApiFp(this.configuration).getAttachments(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get basic data about the user/bot that requests this endpoint.  `GET {{ api_url }}/v1/users/me` 
     * @summary Get own user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOwnUser(options?: any) {
        return UsersApiFp(this.configuration).getOwnUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch details for a single user in the organization.  `GET {{ api_url }}/v1/users/{user_id}`  You can also fetch details on [all users in the organization](/api/get-users) or [by email](/api/get-user-by-email).  *This endpoint is new in Zulip Server 3.0 (feature level 1).* 
     * @summary Get a user
     * @param {number} userId The target user\&#39;s ID. 
     * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
     * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: number, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: any) {
        return UsersApiFp(this.configuration).getUser(userId, clientGravatar, includeCustomProfileFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch details for a single user in the organization given a Zulip display email address.  `GET {{ api_url }}/v1/users/{email}`  Note that this endpoint uses Zulip display emails addresses for organizations that have configured limited [email address visibility](/help/restrict-visibility-of-email-addresses).  You can also fetch details on [all users in the organization](/api/get-users) or [by user ID](/api/get-user).  Fetching by user ID is generally recommended when possible, as users can [change their email address](/help/change-your-email-address).  *This endpoint is new in Zulip Server 4.0 (feature level 39).* 
     * @summary Get a user by email
     * @param {string} email The email address of the user whose details you want to fetch. 
     * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
     * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByEmail(email: string, clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: any) {
        return UsersApiFp(this.configuration).getUserByEmail(email, clientGravatar, includeCustomProfileFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * {!api-members-only.md!}  Fetches all of the user groups in the organization.  `GET {{ api_url }}/v1/user_groups` 
     * @summary Get user groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserGroups(options?: any) {
        return UsersApiFp(this.configuration).getUserGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the presence status for a specific user.  This endpoint is most useful for embedding data about a user\'s presence status in other sites (E.g. an employee directory).  Full Zulip clients like mobile/desktop apps will want to use the main presence endpoint, which returns data for all active users in the organization, instead.  `GET {{ api_url }}/v1/users/{user_id_or_email}/presence`  See [Zulip\'s developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html) for details on the data model for presence in Zulip. 
     * @summary Get user presence
     * @param {string} userIdOrEmail The user_id or Zulip display email address of the user whose presence you want to fetch.  **Changes**: New in Zulip 4.0 (feature level 43). Previous versions only supported identifying the user by Zulip display email. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserPresence(userIdOrEmail: string, options?: any) {
        return UsersApiFp(this.configuration).getUserPresence(userIdOrEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details on all users in the organization.  Optionally includes values of [custom profile field](/help/add-custom-profile-fields).  `GET {{ api_url }}/v1/users`  You can also [fetch details on a single user](/api/get-user). 
     * @summary Get all users
     * @param {boolean} [clientGravatar] Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. 
     * @param {boolean} [includeCustomProfileFields] Whether the client wants [custom profile field](/help/add-custom-profile-fields) data to be included in the response.  **Changes**: New in Zulip 2.1.0.  Previous versions do no offer these data via the API. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(clientGravatar?: boolean, includeCustomProfileFields?: boolean, options?: any) {
        return UsersApiFp(this.configuration).getUsers(clientGravatar, includeCustomProfileFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users you\'ve muted will be automatically marked as read and hidden.  `POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  Muted users should be implemented by clients as follows:  * The server will immediately mark all messages sent by the muted   user as read.  This will automatically clear any existing mobile   push notifications related to the muted user. * The server will mark any new messages sent by the muted user as read   for your account, which prevents all email and mobile push notifications. * Clients should exclude muted users from presence lists or other UI   for viewing or composing 1:1 private messages. 1:1 private messages sent by   muted users should be hidden everywhere in the Zulip UI. * Stream messages and group private messages sent by the muted   user should avoid displaying the content and name/avatar,   but should display that N messages by a muted user were   hidden (so that it is possible to interpret the messages by   other users who are talking with the muted user). * Group private message conversations including the muted user   should display muted users as \"Muted user\", rather than   showing their name, in lists of such conversations, along with using   a blank grey avatar where avatars are displayed. * Administrative/settings UI elements for showing \"All users that exist   on this stream or realm\", e.g. for organization   administration or showing stream subscribers, should display   the user\'s name as normal.  **Changes**: New in Zulip 4.0 (feature level 48). 
     * @summary Mute a user
     * @param {number} mutedUserId The ID of the user to mute/un-mute. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public muteUser(mutedUserId: number, options?: any) {
        return UsersApiFp(this.configuration).muteUser(mutedUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [Reactivates a user](https://zulip.com/help/deactivate-or-reactivate-a-user) given their user ID.  `POST {{ api_url }}/v1/users/{user_id}/reactivate` 
     * @summary Reactivate a user
     * @param {number} userId The target user\&#39;s ID. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public reactivateUser(userId: number, options?: any) {
        return UsersApiFp(this.configuration).reactivateUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a [user group](/help/user-groups).  `DELETE {{ api_url }}/v1/user_groups/{user_group_id}` 
     * @summary Delete a user group
     * @param {number} userGroupId The ID of the target user group. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public removeUserGroup(userGroupId: number, options?: any) {
        return UsersApiFp(this.configuration).removeUserGroup(userGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Notify other users whether the current user is typing a message.  `POST {{ api_url }}/v1/typing`  Clients implementing Zulip\'s typing notifications protocol should work as follows:  * Send a request to this endpoint with `op=\"start\"` when a user starts typing a message,   and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to   actively type or otherwise interact with the compose UI (E.g. interacting with the   compose box emoji picker). * Send a request to this endpoint with `op=\"stop\"` when a user pauses using the   compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels   the compose action (if it had previously sent a \"start\" operation for that   compose action). * Start displaying \"Sender is typing\" for a given conversation when the client   receives an `op=\"start\"` event from the [events API](/api/get-events). * Continue displaying \"Sender is typing\" until they receive an `op=\"stop\"` event   from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`   seconds have passed without a new `op=\"start\"` event for that conversation. * Clients that support displaying stream typing notifications (new in Zulip 4.0)   should indicate they support processing stream typing events via the   `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.  This protocol is designed to allow the server-side typing notifications implementation to be stateless while being resilient; network failures cannot result in a user being incorrectly displayed as perpetually typing.  See [the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html) for additional design details on Zulip\'s typing notifications protocol. 
     * @summary Set \"typing\" status
     * @param {'start' | 'stop'} op Whether the user has started (&#x60;start&#x60;) or stopped (&#x60;stop&#x60;) to type. 
     * @param {Array<number>} to For \&#39;private\&#39; type it is the user_ids of the recipients of the message being typed. Send a JSON-encoded list of user_ids. (Use a list even if there is only one recipient.)  For \&#39;stream\&#39; type it is a single element list containing ID of stream in which the message is being typed.  **Changes**: Before Zulip 2.0, this parameter accepted only a JSON-encoded list of email addresses.  Support for the email address-based format was removed in Zulip 3.0 (feature level 11). 
     * @param {'private' | 'stream'} [type] Type of the message being composed. 
     * @param {string} [topic] Topic to which message is being typed. Required for the \&#39;stream\&#39; type. Ignored in case of \&#39;private\&#39; type. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setTypingStatus(op: 'start' | 'stop', to: Array<number>, type?: 'private' | 'stream', topic?: string, options?: any) {
        return UsersApiFp(this.configuration).setTypingStatus(op, to, type, topic, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint unmutes a user.  `DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`  **Changes**: New in Zulip 4.0 (feature level 48). 
     * @summary Unmute a user
     * @param {number} mutedUserId The ID of the user to mute/un-mute. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unmuteUser(mutedUserId: number, options?: any) {
        return UsersApiFp(this.configuration).unmuteUser(mutedUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is used to edit the current user\'s settings.  `PATCH {{ api_url }}/v1/settings`  **Changes**: Prior to Zulip 5.0 (feature level 80), this endpoint only supported the `full_name`, `email`, `old_password`, and `new_password` parameters. Notification settings were managed by `PATCH /settings/notifications`, and all other settings by `PATCH /settings/display`. The feature level 80 migration to merge these endpoints did not change how request parameters are encoded. Note, however, that it did change the handling of any invalid parameters present in a request to change notification or display settings, since the merged endpoint uses the new response format that was introduced for `/settings` in Zulip 5.0 (feature level 78).  The `/settings/display` and `/settings/notifications` endpoints are now deprecated aliases for this endpoint for backwards-compatibility, and will be removed once clients have migrated to use this endpoint. 
     * @summary Update settings
     * @param {string} [fullName] A new display name for the user. 
     * @param {string} [email] Asks the server to initiate a confirmation sequence to change the user\&#39;s email address to the indicated value. The user will need to demonstrate control of the new email address by clicking a confirmation link sent to that address. 
     * @param {string} [oldPassword] The user\&#39;s old Zulip password (or LDAP password, if LDAP authentication is in use).  Required only when sending the &#x60;new_password&#x60; parameter. 
     * @param {string} [newPassword] The user\&#39;s new Zulip password (or LDAP password, if LDAP authentication is in use).  The &#x60;old_password&#x60; parameter must be included in the request. 
     * @param {boolean} [twentyFourHourTime] Whether time should be [displayed in 24-hour notation](/help/change-the-time-format).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
     * @param {boolean} [denseMode] This setting has no effect at present.  It is reserved for use in controlling the default font size in Zulip.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
     * @param {boolean} [starredMessageCounts] Whether clients should display the [number of starred messages](/help/star-a-message#display-the-number-of-starred-messages).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
     * @param {boolean} [fluidLayoutWidth] Whether to use the [maximum available screen width](/help/enable-full-width-display) for the web app\&#39;s center panel (message feed, recent topics) on wide screens.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
     * @param {boolean} [highContrastMode] This setting is reserved for use to control variations in Zulip\&#39;s design to help visually impaired users.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
     * @param {1 | 2 | 3} [colorScheme] Controls which [color theme](/help/night-mode) to use.  * 1 - Automatic * 2 - Night mode * 3 - Day mode  Automatic detection is implementing using the standard &#x60;prefers-color-scheme&#x60; media query.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
     * @param {boolean} [enableDraftsSynchronization] A boolean parameter to control whether synchronizing drafts is enabled for the user. When synchronization is disabled, all drafts stored in the server will be automatically deleted from the server.  This does not do anything (like sending events) to delete local copies of drafts stored in clients.  **Changes**: New in Zulip 5.0 (feature level 87). 
     * @param {boolean} [translateEmoticons] Whether to [translate emoticons to emoji](/help/enable-emoticon-translations) in messages the user sends.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
     * @param {string} [defaultLanguage] What [default language](/help/change-your-language) to use for the account.  This controls both the Zulip UI as well as email notifications sent to the user.  The value needs to be a standard language code that the Zulip server has translation data for; for example, &#x60;\&quot;en\&quot;&#x60; for English or &#x60;\&quot;de\&quot;&#x60; for German.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 63). 
     * @param {string} [defaultView] The [default view](/help/change-default-view) used when opening a new Zulip web app window or hitting the &#x60;Esc&#x60; keyboard shortcut repeatedly.  * \&quot;recent_topics\&quot; - Recent topics view * \&quot;all_messages\&quot; - All messages view  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
     * @param {boolean} [leftSideUserlist] Whether the users list on left sidebar in narrow windows.  This feature is not heavily used and is likely to be reworked.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
     * @param {string} [emojiset] The user\&#39;s configured [emoji set](/help/emoji-and-emoticons#use-emoticons), used to display emoji to the user everything they appear in the UI.  * \&quot;google\&quot; - Google modern * \&quot;google-blob\&quot; - Google classic * \&quot;twitter\&quot; - Twitter * \&quot;text\&quot; - Plain text  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
     * @param {1 | 2 | 3} [demoteInactiveStreams] Whether to [demote inactive streams](/help/manage-inactive-streams) in the left sidebar.  * 1 - Automatic * 2 - Always * 3 - Never  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint. 
     * @param {string} [timezone] The user\&#39;s [configured timezone](/help/change-your-timezone).  Timezone values supported by the server are served at [/static/generated/timezones.json](/static/generated/timezones.json).  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/display&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 64). 
     * @param {boolean} [enableStreamDesktopNotifications] Enable visual desktop notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [enableStreamEmailNotifications] Enable email notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [enableStreamPushNotifications] Enable mobile notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [enableStreamAudibleNotifications] Enable audible desktop notifications for stream messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {string} [notificationSound] Notification sound name.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint.  Unnecessary JSON-encoding of this parameter was removed in Zulip 4.0 (feature level 63). 
     * @param {boolean} [enableDesktopNotifications] Enable visual desktop notifications for private messages and @-mentions.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [enableSounds] Enable audible desktop notifications for private messages and @-mentions.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {number} [emailNotificationsBatchingPeriodSeconds] The duration (in seconds) for which the server should wait to batch email notifications before sending them.  **Changes**: New in Zulip 5.0 (feature level 82) 
     * @param {boolean} [enableOfflineEmailNotifications] Enable email notifications for private messages and @-mentions received when the user is offline.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [enableOfflinePushNotifications] Enable mobile notification for private messages and @-mentions received when the user is offline.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [enableOnlinePushNotifications] Enable mobile notification for private messages and @-mentions received when the user is online.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [enableDigestEmails] Enable digest emails when the user is away.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [enableMarketingEmails] Enable marketing emails. Has no function outside Zulip Cloud.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [enableLoginEmails] Enable email notifications for new logins to account.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [messageContentInEmailNotifications] Include the message\&#39;s content in email notifications for new messages.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [pmContentInDesktopNotifications] Include content of private messages in desktop notifications.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [wildcardMentionsNotify] Whether wildcard mentions (E.g. @**all**) should send notifications like a personal mention.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {1 | 2 | 3} [desktopIconCountDisplay] Unread count summary (appears in desktop sidebar and browser tab)  * 1 - All unreads * 2 - Private messages and mentions * 3 - None  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [realmNameInNotifications] Include organization name in subject of message notification emails.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [presenceEnabled] Display the presence status to other users when online.  **Changes**: Before Zulip 5.0 (feature level 80), this setting was managed by the &#x60;PATCH /settings/notifications&#x60; endpoint. 
     * @param {boolean} [enterSends] Whether pressing Enter in the compose box sends a message (or saves a message edit).  **Changes**: Before Zulip 5.0 (feature level 81), this setting was managed by the &#x60;POST /users/me/enter-sends&#x60; endpoint, with the same parameter format. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateSettings(fullName?: string, email?: string, oldPassword?: string, newPassword?: string, twentyFourHourTime?: boolean, denseMode?: boolean, starredMessageCounts?: boolean, fluidLayoutWidth?: boolean, highContrastMode?: boolean, colorScheme?: 1 | 2 | 3, enableDraftsSynchronization?: boolean, translateEmoticons?: boolean, defaultLanguage?: string, defaultView?: string, leftSideUserlist?: boolean, emojiset?: string, demoteInactiveStreams?: 1 | 2 | 3, timezone?: string, enableStreamDesktopNotifications?: boolean, enableStreamEmailNotifications?: boolean, enableStreamPushNotifications?: boolean, enableStreamAudibleNotifications?: boolean, notificationSound?: string, enableDesktopNotifications?: boolean, enableSounds?: boolean, emailNotificationsBatchingPeriodSeconds?: number, enableOfflineEmailNotifications?: boolean, enableOfflinePushNotifications?: boolean, enableOnlinePushNotifications?: boolean, enableDigestEmails?: boolean, enableMarketingEmails?: boolean, enableLoginEmails?: boolean, messageContentInEmailNotifications?: boolean, pmContentInDesktopNotifications?: boolean, wildcardMentionsNotify?: boolean, desktopIconCountDisplay?: 1 | 2 | 3, realmNameInNotifications?: boolean, presenceEnabled?: boolean, enterSends?: boolean, options?: any) {
        return UsersApiFp(this.configuration).updateSettings(fullName, email, oldPassword, newPassword, twentyFourHourTime, denseMode, starredMessageCounts, fluidLayoutWidth, highContrastMode, colorScheme, enableDraftsSynchronization, translateEmoticons, defaultLanguage, defaultView, leftSideUserlist, emojiset, demoteInactiveStreams, timezone, enableStreamDesktopNotifications, enableStreamEmailNotifications, enableStreamPushNotifications, enableStreamAudibleNotifications, notificationSound, enableDesktopNotifications, enableSounds, emailNotificationsBatchingPeriodSeconds, enableOfflineEmailNotifications, enableOfflinePushNotifications, enableOnlinePushNotifications, enableDigestEmails, enableMarketingEmails, enableLoginEmails, messageContentInEmailNotifications, pmContentInDesktopNotifications, wildcardMentionsNotify, desktopIconCountDisplay, realmNameInNotifications, presenceEnabled, enterSends, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change your [status](/help/status-and-availability).  `POST {{ api_url }}/v1/users/me/status`  A request to this endpoint will only change the parameters passed. For example, passing just `status_text` requests a change in the status text, but will leave the status emoji unchanged.  Clients that wish to set the user\'s status to a specific value should pass all supported parameters. 
     * @summary Update your status
     * @param {string} [statusText] The text content of the status message. Sending the empty string will clear the user\&#39;s status.  **Note**: The limit on the size of the message is 60 characters. 
     * @param {boolean} [away] Whether the user should be marked as \&quot;away\&quot;. 
     * @param {string} [emojiName] The name for the emoji to associate with this status. 
     * @param {string} [emojiCode] A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For example, for &#x60;unicode_emoji&#x60;, this will be an encoding of the Unicode codepoint; for &#x60;realm_emoji&#x60;, it\&#39;ll be the ID of the realm emoji. 
     * @param {string} [reactionType] One of the following values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode   codepoint). * &#x60;realm_emoji&#x60;: [Custom emoji](/help/add-custom-emoji).   (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to   namespace the &#x60;zulip&#x60; emoji. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateStatus(statusText?: string, away?: boolean, emojiName?: string, emojiCode?: string, reactionType?: string, options?: any) {
        return UsersApiFp(this.configuration).updateStatus(statusText, away, emojiName, emojiCode, reactionType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Administrative endpoint to update the details of another user in the organization.  `PATCH {{ api_url }}/v1/users/{user_id}`  Supports everything an administrator can do to edit details of another user\'s account, including editing full name, [role](/help/roles-and-permissions), and [custom profile fields](/help/add-custom-profile-fields). 
     * @summary Update a user
     * @param {number} userId The target user\&#39;s ID. 
     * @param {string} [fullName] The user\&#39;s full name. 
     * @param {number} [role] New [role](/help/roles-and-permissions) for the user.  Roles are encoded as:  * Organization owner: 100 * Organization administrator: 200 * Organization moderator: 300 * Member: 400 * Guest: 600  Only organization owners can add or remove the owner role.  The owner role cannot be removed from the only organization owner.  **Changes**: New in Zulip 3.0 (feature level 8), replacing the previous pair of &#x60;is_admin&#x60; and &#x60;is_guest&#x60; boolean parameters. Organization moderator role added in Zulip 4.0 (feature level 60). 
     * @param {Array<object>} [profileData] A dictionary containing the to be updated custom profile field data for the user. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(userId: number, fullName?: string, role?: number, profileData?: Array<object>, options?: any) {
        return UsersApiFp(this.configuration).updateUser(userId, fullName, role, profileData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the name or description of a [user group](/help/user-groups).  `PATCH {{ api_url }}/v1/user_groups/{user_group_id}` 
     * @summary Update a user group
     * @param {number} userGroupId The ID of the target user group. 
     * @param {string} name The new name of the group. 
     * @param {string} description The new description of the group. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserGroup(userGroupId: number, name: string, description: string, options?: any) {
        return UsersApiFp(this.configuration).updateUserGroup(userGroupId, name, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the members of a [user group](/help/user-groups).  `POST {{ api_url }}/v1/user_groups/{user_group_id}/members` 
     * @summary Update user group members
     * @param {number} userGroupId The ID of the target user group. 
     * @param {Array<number>} [_delete] The list of user ids to be removed from the user group. 
     * @param {Array<number>} [add] The list of user ids to be added to the user group. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserGroupMembers(userGroupId: number, _delete?: Array<number>, add?: Array<number>, options?: any) {
        return UsersApiFp(this.configuration).updateUserGroupMembers(userGroupId, _delete, add, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Outgoing webhooks allows to build or set up Zulip integrations which are notified when certain types of messages are sent in Zulip. 
         * @summary Outgoing webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zulipOutgoingWebhooks: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/zulip-outgoing-webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Outgoing webhooks allows to build or set up Zulip integrations which are notified when certain types of messages are sent in Zulip. 
         * @summary Outgoing webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zulipOutgoingWebhooks(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zulipOutgoingWebhooks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Outgoing webhooks allows to build or set up Zulip integrations which are notified when certain types of messages are sent in Zulip. 
         * @summary Outgoing webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zulipOutgoingWebhooks(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.zulipOutgoingWebhooks(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Outgoing webhooks allows to build or set up Zulip integrations which are notified when certain types of messages are sent in Zulip. 
     * @summary Outgoing webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public zulipOutgoingWebhooks(options?: any) {
        return WebhooksApiFp(this.configuration).zulipOutgoingWebhooks(options).then((request) => request(this.axios, this.basePath));
    }
}


