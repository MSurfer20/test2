/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using RestSharp;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IStreamsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Archive a stream
        /// </summary>
        /// <remarks>
        /// [Archive the stream](/help/archive-a-stream) with the ID &#x60;stream_id&#x60;.  &#x60;DELETE {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>JsonSuccess</returns>
        JsonSuccess ArchiveStream (int streamId);

        /// <summary>
        /// Archive a stream
        /// </summary>
        /// <remarks>
        /// [Archive the stream](/help/archive-a-stream) with the ID &#x60;stream_id&#x60;.  &#x60;DELETE {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>ApiResponse of JsonSuccess</returns>
        ApiResponse<JsonSuccess> ArchiveStreamWithHttpInfo (int streamId);
        /// <summary>
        /// Create BigBlueButton video call
        /// </summary>
        /// <remarks>
        /// Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>JsonSuccessBase</returns>
        JsonSuccessBase CreateBigBlueButtonVideoCall ();

        /// <summary>
        /// Create BigBlueButton video call
        /// </summary>
        /// <remarks>
        /// Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        ApiResponse<JsonSuccessBase> CreateBigBlueButtonVideoCallWithHttpInfo ();
        /// <summary>
        /// Get stream ID
        /// </summary>
        /// <remarks>
        /// Get the unique ID of a given stream.  &#x60;GET {{ api_url }}/v1/get_stream_id&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="stream">The name of the stream to access. </param>
        /// <returns>JsonSuccessBase</returns>
        JsonSuccessBase GetStreamId (string stream);

        /// <summary>
        /// Get stream ID
        /// </summary>
        /// <remarks>
        /// Get the unique ID of a given stream.  &#x60;GET {{ api_url }}/v1/get_stream_id&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="stream">The name of the stream to access. </param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        ApiResponse<JsonSuccessBase> GetStreamIdWithHttpInfo (string stream);
        /// <summary>
        /// Get topics in a stream
        /// </summary>
        /// <remarks>
        /// Get all the topics in a specific stream  &#x60;GET {{ api_url }}/v1/users/me/{stream_id}/topics&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>JsonSuccessBase</returns>
        JsonSuccessBase GetStreamTopics (int streamId);

        /// <summary>
        /// Get topics in a stream
        /// </summary>
        /// <remarks>
        /// Get all the topics in a specific stream  &#x60;GET {{ api_url }}/v1/users/me/{stream_id}/topics&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        ApiResponse<JsonSuccessBase> GetStreamTopicsWithHttpInfo (int streamId);
        /// <summary>
        /// Get all streams
        /// </summary>
        /// <remarks>
        /// Get all streams that the user has access to.  &#x60;GET {{ api_url }}/v1/streams&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includePublic">Include all public streams.  (optional, default to true)</param>
        /// <param name="includeWebPublic">Include all web public streams.  (optional, default to false)</param>
        /// <param name="includeSubscribed">Include all streams that the user is subscribed to.  (optional, default to true)</param>
        /// <param name="includeAllActive">Include all active streams. The user must have administrative privileges to use this parameter.  (optional, default to false)</param>
        /// <param name="includeDefault">Include all default streams for the user&#39;s realm.  (optional, default to false)</param>
        /// <param name="includeOwnerSubscribed">If the user is a bot, include all streams that the bot&#39;s owner is subscribed to.  (optional, default to false)</param>
        /// <returns>JsonSuccessBase</returns>
        JsonSuccessBase GetStreams (bool? includePublic = default(bool?), bool? includeWebPublic = default(bool?), bool? includeSubscribed = default(bool?), bool? includeAllActive = default(bool?), bool? includeDefault = default(bool?), bool? includeOwnerSubscribed = default(bool?));

        /// <summary>
        /// Get all streams
        /// </summary>
        /// <remarks>
        /// Get all streams that the user has access to.  &#x60;GET {{ api_url }}/v1/streams&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includePublic">Include all public streams.  (optional, default to true)</param>
        /// <param name="includeWebPublic">Include all web public streams.  (optional, default to false)</param>
        /// <param name="includeSubscribed">Include all streams that the user is subscribed to.  (optional, default to true)</param>
        /// <param name="includeAllActive">Include all active streams. The user must have administrative privileges to use this parameter.  (optional, default to false)</param>
        /// <param name="includeDefault">Include all default streams for the user&#39;s realm.  (optional, default to false)</param>
        /// <param name="includeOwnerSubscribed">If the user is a bot, include all streams that the bot&#39;s owner is subscribed to.  (optional, default to false)</param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        ApiResponse<JsonSuccessBase> GetStreamsWithHttpInfo (bool? includePublic = default(bool?), bool? includeWebPublic = default(bool?), bool? includeSubscribed = default(bool?), bool? includeAllActive = default(bool?), bool? includeDefault = default(bool?), bool? includeOwnerSubscribed = default(bool?));
        /// <summary>
        /// Get subscription status
        /// </summary>
        /// <remarks>
        /// Check whether a user is subscribed to a stream.  &#x60;GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}&#x60;  **Changes**: New in Zulip 3.0 (feature level 11). 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The target user&#39;s ID. </param>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>JsonSuccessBase</returns>
        JsonSuccessBase GetSubscriptionStatus (int userId, int streamId);

        /// <summary>
        /// Get subscription status
        /// </summary>
        /// <remarks>
        /// Check whether a user is subscribed to a stream.  &#x60;GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}&#x60;  **Changes**: New in Zulip 3.0 (feature level 11). 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The target user&#39;s ID. </param>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        ApiResponse<JsonSuccessBase> GetSubscriptionStatusWithHttpInfo (int userId, int streamId);
        /// <summary>
        /// Get subscribed streams
        /// </summary>
        /// <remarks>
        /// Get all streams that the user is subscribed to.  &#x60;GET {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeSubscribers">Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0.  (optional, default to false)</param>
        /// <returns>JsonSuccessBase</returns>
        JsonSuccessBase GetSubscriptions (bool? includeSubscribers = default(bool?));

        /// <summary>
        /// Get subscribed streams
        /// </summary>
        /// <remarks>
        /// Get all streams that the user is subscribed to.  &#x60;GET {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeSubscribers">Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0.  (optional, default to false)</param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        ApiResponse<JsonSuccessBase> GetSubscriptionsWithHttpInfo (bool? includeSubscribers = default(bool?));
        /// <summary>
        /// Topic muting
        /// </summary>
        /// <remarks>
        /// This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user&#39;s unread count totals.  &#x60;PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="topic">The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. </param>
        /// <param name="op">Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. </param>
        /// <param name="stream">The name of the stream to access.  (optional)</param>
        /// <param name="streamId">The ID of the stream to access.  (optional)</param>
        /// <returns>JsonSuccess</returns>
        JsonSuccess MuteTopic (string topic, string op, string stream = default(string), int? streamId = default(int?));

        /// <summary>
        /// Topic muting
        /// </summary>
        /// <remarks>
        /// This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user&#39;s unread count totals.  &#x60;PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="topic">The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. </param>
        /// <param name="op">Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. </param>
        /// <param name="stream">The name of the stream to access.  (optional)</param>
        /// <param name="streamId">The ID of the stream to access.  (optional)</param>
        /// <returns>ApiResponse of JsonSuccess</returns>
        ApiResponse<JsonSuccess> MuteTopicWithHttpInfo (string topic, string op, string stream = default(string), int? streamId = default(int?));
        /// <summary>
        /// Subscribe to a stream
        /// </summary>
        /// <remarks>
        /// Subscribe one or more users to one or more streams.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions&#x60;  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like &#x60;invite_only&#x60; detailed below. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="authorizationErrorsFatal">A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key.  (optional, default to true)</param>
        /// <param name="announce">If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream&#39;s creation.  (optional, default to false)</param>
        /// <param name="inviteOnly">As described above, this endpoint will create a new stream if passed a stream name that doesn&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams.  (optional, default to false)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <returns>OneOfobjectobject</returns>
        OneOfobjectobject Subscribe (List<Object> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), bool? authorizationErrorsFatal = default(bool?), bool? announce = default(bool?), bool? inviteOnly = default(bool?), bool? historyPublicToSubscribers = default(bool?), int? streamPostPolicy = default(int?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger));

        /// <summary>
        /// Subscribe to a stream
        /// </summary>
        /// <remarks>
        /// Subscribe one or more users to one or more streams.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions&#x60;  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like &#x60;invite_only&#x60; detailed below. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="authorizationErrorsFatal">A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key.  (optional, default to true)</param>
        /// <param name="announce">If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream&#39;s creation.  (optional, default to false)</param>
        /// <param name="inviteOnly">As described above, this endpoint will create a new stream if passed a stream name that doesn&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams.  (optional, default to false)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <returns>ApiResponse of OneOfobjectobject</returns>
        ApiResponse<OneOfobjectobject> SubscribeWithHttpInfo (List<Object> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), bool? authorizationErrorsFatal = default(bool?), bool? announce = default(bool?), bool? inviteOnly = default(bool?), bool? historyPublicToSubscribers = default(bool?), int? streamPostPolicy = default(int?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger));
        /// <summary>
        /// Unsubscribe from a stream
        /// </summary>
        /// <remarks>
        /// Unsubscribe yourself or other users from one or more streams.  &#x60;DELETE {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <returns>JsonSuccessBase</returns>
        JsonSuccessBase Unsubscribe (List<string> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>));

        /// <summary>
        /// Unsubscribe from a stream
        /// </summary>
        /// <remarks>
        /// Unsubscribe yourself or other users from one or more streams.  &#x60;DELETE {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        ApiResponse<JsonSuccessBase> UnsubscribeWithHttpInfo (List<string> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>));
        /// <summary>
        /// Update a stream
        /// </summary>
        /// <remarks>
        /// Configure the stream with the ID &#x60;stream_id&#x60;.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  &#x60;PATCH {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="description">The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="newName">The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="isPrivate">Change whether the stream is a private stream.  (optional)</param>
        /// <param name="isAnnouncementOnly">Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <returns>JsonSuccess</returns>
        JsonSuccess UpdateStream (int streamId, string description = default(string), string newName = default(string), bool? isPrivate = default(bool?), bool? isAnnouncementOnly = default(bool?), int? streamPostPolicy = default(int?), bool? historyPublicToSubscribers = default(bool?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger));

        /// <summary>
        /// Update a stream
        /// </summary>
        /// <remarks>
        /// Configure the stream with the ID &#x60;stream_id&#x60;.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  &#x60;PATCH {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="description">The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="newName">The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="isPrivate">Change whether the stream is a private stream.  (optional)</param>
        /// <param name="isAnnouncementOnly">Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <returns>ApiResponse of JsonSuccess</returns>
        ApiResponse<JsonSuccess> UpdateStreamWithHttpInfo (int streamId, string description = default(string), string newName = default(string), bool? isPrivate = default(bool?), bool? isAnnouncementOnly = default(bool?), int? streamPostPolicy = default(int?), bool? historyPublicToSubscribers = default(bool?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger));
        /// <summary>
        /// Update subscription settings
        /// </summary>
        /// <remarks>
        /// This endpoint is used to update the user&#39;s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions/properties&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionData">A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. </param>
        /// <returns>JsonSuccessBase</returns>
        JsonSuccessBase UpdateSubscriptionSettings (List<Object> subscriptionData);

        /// <summary>
        /// Update subscription settings
        /// </summary>
        /// <remarks>
        /// This endpoint is used to update the user&#39;s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions/properties&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionData">A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. </param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        ApiResponse<JsonSuccessBase> UpdateSubscriptionSettingsWithHttpInfo (List<Object> subscriptionData);
        /// <summary>
        /// Update subscriptions
        /// </summary>
        /// <remarks>
        /// Update which streams you are are subscribed to. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="delete">A list of stream names to unsubscribe from.  (optional)</param>
        /// <param name="add">A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description.  (optional)</param>
        /// <returns>JsonSuccessBase</returns>
        JsonSuccessBase UpdateSubscriptions (List<string> delete = default(List<string>), List<Object> add = default(List<Object>));

        /// <summary>
        /// Update subscriptions
        /// </summary>
        /// <remarks>
        /// Update which streams you are are subscribed to. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="delete">A list of stream names to unsubscribe from.  (optional)</param>
        /// <param name="add">A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description.  (optional)</param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        ApiResponse<JsonSuccessBase> UpdateSubscriptionsWithHttpInfo (List<string> delete = default(List<string>), List<Object> add = default(List<Object>));
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Archive a stream
        /// </summary>
        /// <remarks>
        /// [Archive the stream](/help/archive-a-stream) with the ID &#x60;stream_id&#x60;.  &#x60;DELETE {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccess</returns>
        System.Threading.Tasks.Task<JsonSuccess> ArchiveStreamAsync (int streamId, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Archive a stream
        /// </summary>
        /// <remarks>
        /// [Archive the stream](/help/archive-a-stream) with the ID &#x60;stream_id&#x60;.  &#x60;DELETE {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccess)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccess>> ArchiveStreamWithHttpInfoAsync (int streamId, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Create BigBlueButton video call
        /// </summary>
        /// <remarks>
        /// Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        System.Threading.Tasks.Task<JsonSuccessBase> CreateBigBlueButtonVideoCallAsync (CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Create BigBlueButton video call
        /// </summary>
        /// <remarks>
        /// Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> CreateBigBlueButtonVideoCallWithHttpInfoAsync (CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Get stream ID
        /// </summary>
        /// <remarks>
        /// Get the unique ID of a given stream.  &#x60;GET {{ api_url }}/v1/get_stream_id&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="stream">The name of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        System.Threading.Tasks.Task<JsonSuccessBase> GetStreamIdAsync (string stream, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get stream ID
        /// </summary>
        /// <remarks>
        /// Get the unique ID of a given stream.  &#x60;GET {{ api_url }}/v1/get_stream_id&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="stream">The name of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> GetStreamIdWithHttpInfoAsync (string stream, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Get topics in a stream
        /// </summary>
        /// <remarks>
        /// Get all the topics in a specific stream  &#x60;GET {{ api_url }}/v1/users/me/{stream_id}/topics&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        System.Threading.Tasks.Task<JsonSuccessBase> GetStreamTopicsAsync (int streamId, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get topics in a stream
        /// </summary>
        /// <remarks>
        /// Get all the topics in a specific stream  &#x60;GET {{ api_url }}/v1/users/me/{stream_id}/topics&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> GetStreamTopicsWithHttpInfoAsync (int streamId, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Get all streams
        /// </summary>
        /// <remarks>
        /// Get all streams that the user has access to.  &#x60;GET {{ api_url }}/v1/streams&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includePublic">Include all public streams.  (optional, default to true)</param>
        /// <param name="includeWebPublic">Include all web public streams.  (optional, default to false)</param>
        /// <param name="includeSubscribed">Include all streams that the user is subscribed to.  (optional, default to true)</param>
        /// <param name="includeAllActive">Include all active streams. The user must have administrative privileges to use this parameter.  (optional, default to false)</param>
        /// <param name="includeDefault">Include all default streams for the user&#39;s realm.  (optional, default to false)</param>
        /// <param name="includeOwnerSubscribed">If the user is a bot, include all streams that the bot&#39;s owner is subscribed to.  (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        System.Threading.Tasks.Task<JsonSuccessBase> GetStreamsAsync (bool? includePublic = default(bool?), bool? includeWebPublic = default(bool?), bool? includeSubscribed = default(bool?), bool? includeAllActive = default(bool?), bool? includeDefault = default(bool?), bool? includeOwnerSubscribed = default(bool?), CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get all streams
        /// </summary>
        /// <remarks>
        /// Get all streams that the user has access to.  &#x60;GET {{ api_url }}/v1/streams&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includePublic">Include all public streams.  (optional, default to true)</param>
        /// <param name="includeWebPublic">Include all web public streams.  (optional, default to false)</param>
        /// <param name="includeSubscribed">Include all streams that the user is subscribed to.  (optional, default to true)</param>
        /// <param name="includeAllActive">Include all active streams. The user must have administrative privileges to use this parameter.  (optional, default to false)</param>
        /// <param name="includeDefault">Include all default streams for the user&#39;s realm.  (optional, default to false)</param>
        /// <param name="includeOwnerSubscribed">If the user is a bot, include all streams that the bot&#39;s owner is subscribed to.  (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> GetStreamsWithHttpInfoAsync (bool? includePublic = default(bool?), bool? includeWebPublic = default(bool?), bool? includeSubscribed = default(bool?), bool? includeAllActive = default(bool?), bool? includeDefault = default(bool?), bool? includeOwnerSubscribed = default(bool?), CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Get subscription status
        /// </summary>
        /// <remarks>
        /// Check whether a user is subscribed to a stream.  &#x60;GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}&#x60;  **Changes**: New in Zulip 3.0 (feature level 11). 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The target user&#39;s ID. </param>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        System.Threading.Tasks.Task<JsonSuccessBase> GetSubscriptionStatusAsync (int userId, int streamId, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get subscription status
        /// </summary>
        /// <remarks>
        /// Check whether a user is subscribed to a stream.  &#x60;GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}&#x60;  **Changes**: New in Zulip 3.0 (feature level 11). 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The target user&#39;s ID. </param>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> GetSubscriptionStatusWithHttpInfoAsync (int userId, int streamId, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Get subscribed streams
        /// </summary>
        /// <remarks>
        /// Get all streams that the user is subscribed to.  &#x60;GET {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeSubscribers">Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0.  (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        System.Threading.Tasks.Task<JsonSuccessBase> GetSubscriptionsAsync (bool? includeSubscribers = default(bool?), CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Get subscribed streams
        /// </summary>
        /// <remarks>
        /// Get all streams that the user is subscribed to.  &#x60;GET {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeSubscribers">Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0.  (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> GetSubscriptionsWithHttpInfoAsync (bool? includeSubscribers = default(bool?), CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Topic muting
        /// </summary>
        /// <remarks>
        /// This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user&#39;s unread count totals.  &#x60;PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="topic">The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. </param>
        /// <param name="op">Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. </param>
        /// <param name="stream">The name of the stream to access.  (optional)</param>
        /// <param name="streamId">The ID of the stream to access.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccess</returns>
        System.Threading.Tasks.Task<JsonSuccess> MuteTopicAsync (string topic, string op, string stream = default(string), int? streamId = default(int?), CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Topic muting
        /// </summary>
        /// <remarks>
        /// This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user&#39;s unread count totals.  &#x60;PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="topic">The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. </param>
        /// <param name="op">Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. </param>
        /// <param name="stream">The name of the stream to access.  (optional)</param>
        /// <param name="streamId">The ID of the stream to access.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccess)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccess>> MuteTopicWithHttpInfoAsync (string topic, string op, string stream = default(string), int? streamId = default(int?), CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Subscribe to a stream
        /// </summary>
        /// <remarks>
        /// Subscribe one or more users to one or more streams.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions&#x60;  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like &#x60;invite_only&#x60; detailed below. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="authorizationErrorsFatal">A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key.  (optional, default to true)</param>
        /// <param name="announce">If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream&#39;s creation.  (optional, default to false)</param>
        /// <param name="inviteOnly">As described above, this endpoint will create a new stream if passed a stream name that doesn&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams.  (optional, default to false)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of OneOfobjectobject</returns>
        System.Threading.Tasks.Task<OneOfobjectobject> SubscribeAsync (List<Object> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), bool? authorizationErrorsFatal = default(bool?), bool? announce = default(bool?), bool? inviteOnly = default(bool?), bool? historyPublicToSubscribers = default(bool?), int? streamPostPolicy = default(int?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger), CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Subscribe to a stream
        /// </summary>
        /// <remarks>
        /// Subscribe one or more users to one or more streams.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions&#x60;  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like &#x60;invite_only&#x60; detailed below. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="authorizationErrorsFatal">A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key.  (optional, default to true)</param>
        /// <param name="announce">If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream&#39;s creation.  (optional, default to false)</param>
        /// <param name="inviteOnly">As described above, this endpoint will create a new stream if passed a stream name that doesn&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams.  (optional, default to false)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (OneOfobjectobject)</returns>
        System.Threading.Tasks.Task<ApiResponse<OneOfobjectobject>> SubscribeWithHttpInfoAsync (List<Object> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), bool? authorizationErrorsFatal = default(bool?), bool? announce = default(bool?), bool? inviteOnly = default(bool?), bool? historyPublicToSubscribers = default(bool?), int? streamPostPolicy = default(int?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger), CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Unsubscribe from a stream
        /// </summary>
        /// <remarks>
        /// Unsubscribe yourself or other users from one or more streams.  &#x60;DELETE {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        System.Threading.Tasks.Task<JsonSuccessBase> UnsubscribeAsync (List<string> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Unsubscribe from a stream
        /// </summary>
        /// <remarks>
        /// Unsubscribe yourself or other users from one or more streams.  &#x60;DELETE {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> UnsubscribeWithHttpInfoAsync (List<string> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Update a stream
        /// </summary>
        /// <remarks>
        /// Configure the stream with the ID &#x60;stream_id&#x60;.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  &#x60;PATCH {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="description">The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="newName">The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="isPrivate">Change whether the stream is a private stream.  (optional)</param>
        /// <param name="isAnnouncementOnly">Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccess</returns>
        System.Threading.Tasks.Task<JsonSuccess> UpdateStreamAsync (int streamId, string description = default(string), string newName = default(string), bool? isPrivate = default(bool?), bool? isAnnouncementOnly = default(bool?), int? streamPostPolicy = default(int?), bool? historyPublicToSubscribers = default(bool?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger), CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update a stream
        /// </summary>
        /// <remarks>
        /// Configure the stream with the ID &#x60;stream_id&#x60;.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  &#x60;PATCH {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="description">The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="newName">The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="isPrivate">Change whether the stream is a private stream.  (optional)</param>
        /// <param name="isAnnouncementOnly">Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccess)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccess>> UpdateStreamWithHttpInfoAsync (int streamId, string description = default(string), string newName = default(string), bool? isPrivate = default(bool?), bool? isAnnouncementOnly = default(bool?), int? streamPostPolicy = default(int?), bool? historyPublicToSubscribers = default(bool?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger), CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Update subscription settings
        /// </summary>
        /// <remarks>
        /// This endpoint is used to update the user&#39;s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions/properties&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionData">A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        System.Threading.Tasks.Task<JsonSuccessBase> UpdateSubscriptionSettingsAsync (List<Object> subscriptionData, CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update subscription settings
        /// </summary>
        /// <remarks>
        /// This endpoint is used to update the user&#39;s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions/properties&#x60; 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionData">A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> UpdateSubscriptionSettingsWithHttpInfoAsync (List<Object> subscriptionData, CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Update subscriptions
        /// </summary>
        /// <remarks>
        /// Update which streams you are are subscribed to. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="delete">A list of stream names to unsubscribe from.  (optional)</param>
        /// <param name="add">A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        System.Threading.Tasks.Task<JsonSuccessBase> UpdateSubscriptionsAsync (List<string> delete = default(List<string>), List<Object> add = default(List<Object>), CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Update subscriptions
        /// </summary>
        /// <remarks>
        /// Update which streams you are are subscribed to. 
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="delete">A list of stream names to unsubscribe from.  (optional)</param>
        /// <param name="add">A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> UpdateSubscriptionsWithHttpInfoAsync (List<string> delete = default(List<string>), List<Object> add = default(List<Object>), CancellationToken cancellationToken = default(CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class StreamsApi : IStreamsApi
    {
        private Org.OpenAPITools.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="StreamsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public StreamsApi(String basePath)
        {
            this.Configuration = new Org.OpenAPITools.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StreamsApi"/> class
        /// </summary>
        /// <returns></returns>
        public StreamsApi()
        {
            this.Configuration = Org.OpenAPITools.Client.Configuration.Default;

            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StreamsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public StreamsApi(Org.OpenAPITools.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Org.OpenAPITools.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Org.OpenAPITools.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Org.OpenAPITools.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Archive a stream [Archive the stream](/help/archive-a-stream) with the ID &#x60;stream_id&#x60;.  &#x60;DELETE {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>JsonSuccess</returns>
        public JsonSuccess ArchiveStream (int streamId)
        {
             ApiResponse<JsonSuccess> localVarResponse = ArchiveStreamWithHttpInfo(streamId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Archive a stream [Archive the stream](/help/archive-a-stream) with the ID &#x60;stream_id&#x60;.  &#x60;DELETE {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>ApiResponse of JsonSuccess</returns>
        public ApiResponse<JsonSuccess> ArchiveStreamWithHttpInfo (int streamId)
        {
            // verify the required parameter 'streamId' is set
            if (streamId == null)
                throw new ApiException(400, "Missing required parameter 'streamId' when calling StreamsApi->ArchiveStream");

            var localVarPath = "/streams/{stream_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (streamId != null) localVarPathParams.Add("stream_id", this.Configuration.ApiClient.ParameterToString(streamId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ArchiveStream", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccess>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccess) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccess)));
        }

        /// <summary>
        /// Archive a stream [Archive the stream](/help/archive-a-stream) with the ID &#x60;stream_id&#x60;.  &#x60;DELETE {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccess</returns>
        public async System.Threading.Tasks.Task<JsonSuccess> ArchiveStreamAsync (int streamId, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccess> localVarResponse = await ArchiveStreamWithHttpInfoAsync(streamId, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Archive a stream [Archive the stream](/help/archive-a-stream) with the ID &#x60;stream_id&#x60;.  &#x60;DELETE {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccess)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccess>> ArchiveStreamWithHttpInfoAsync (int streamId, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'streamId' is set
            if (streamId == null)
                throw new ApiException(400, "Missing required parameter 'streamId' when calling StreamsApi->ArchiveStream");

            var localVarPath = "/streams/{stream_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (streamId != null) localVarPathParams.Add("stream_id", this.Configuration.ApiClient.ParameterToString(streamId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ArchiveStream", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccess>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccess) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccess)));
        }

        /// <summary>
        /// Create BigBlueButton video call Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>JsonSuccessBase</returns>
        public JsonSuccessBase CreateBigBlueButtonVideoCall ()
        {
             ApiResponse<JsonSuccessBase> localVarResponse = CreateBigBlueButtonVideoCallWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create BigBlueButton video call Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        public ApiResponse<JsonSuccessBase> CreateBigBlueButtonVideoCallWithHttpInfo ()
        {

            var localVarPath = "/calls/bigbluebutton/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);



            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateBigBlueButtonVideoCall", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Create BigBlueButton video call Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        public async System.Threading.Tasks.Task<JsonSuccessBase> CreateBigBlueButtonVideoCallAsync (CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = await CreateBigBlueButtonVideoCallWithHttpInfoAsync(cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create BigBlueButton video call Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> CreateBigBlueButtonVideoCallWithHttpInfoAsync (CancellationToken cancellationToken = default(CancellationToken))
        {

            var localVarPath = "/calls/bigbluebutton/create";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);



            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateBigBlueButtonVideoCall", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Get stream ID Get the unique ID of a given stream.  &#x60;GET {{ api_url }}/v1/get_stream_id&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="stream">The name of the stream to access. </param>
        /// <returns>JsonSuccessBase</returns>
        public JsonSuccessBase GetStreamId (string stream)
        {
             ApiResponse<JsonSuccessBase> localVarResponse = GetStreamIdWithHttpInfo(stream);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get stream ID Get the unique ID of a given stream.  &#x60;GET {{ api_url }}/v1/get_stream_id&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="stream">The name of the stream to access. </param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        public ApiResponse<JsonSuccessBase> GetStreamIdWithHttpInfo (string stream)
        {
            // verify the required parameter 'stream' is set
            if (stream == null)
                throw new ApiException(400, "Missing required parameter 'stream' when calling StreamsApi->GetStreamId");

            var localVarPath = "/get_stream_id";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (stream != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "stream", stream)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetStreamId", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Get stream ID Get the unique ID of a given stream.  &#x60;GET {{ api_url }}/v1/get_stream_id&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="stream">The name of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        public async System.Threading.Tasks.Task<JsonSuccessBase> GetStreamIdAsync (string stream, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = await GetStreamIdWithHttpInfoAsync(stream, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get stream ID Get the unique ID of a given stream.  &#x60;GET {{ api_url }}/v1/get_stream_id&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="stream">The name of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> GetStreamIdWithHttpInfoAsync (string stream, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'stream' is set
            if (stream == null)
                throw new ApiException(400, "Missing required parameter 'stream' when calling StreamsApi->GetStreamId");

            var localVarPath = "/get_stream_id";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (stream != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "stream", stream)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetStreamId", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Get topics in a stream Get all the topics in a specific stream  &#x60;GET {{ api_url }}/v1/users/me/{stream_id}/topics&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>JsonSuccessBase</returns>
        public JsonSuccessBase GetStreamTopics (int streamId)
        {
             ApiResponse<JsonSuccessBase> localVarResponse = GetStreamTopicsWithHttpInfo(streamId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get topics in a stream Get all the topics in a specific stream  &#x60;GET {{ api_url }}/v1/users/me/{stream_id}/topics&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        public ApiResponse<JsonSuccessBase> GetStreamTopicsWithHttpInfo (int streamId)
        {
            // verify the required parameter 'streamId' is set
            if (streamId == null)
                throw new ApiException(400, "Missing required parameter 'streamId' when calling StreamsApi->GetStreamTopics");

            var localVarPath = "/users/me/{stream_id}/topics";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (streamId != null) localVarPathParams.Add("stream_id", this.Configuration.ApiClient.ParameterToString(streamId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetStreamTopics", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Get topics in a stream Get all the topics in a specific stream  &#x60;GET {{ api_url }}/v1/users/me/{stream_id}/topics&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        public async System.Threading.Tasks.Task<JsonSuccessBase> GetStreamTopicsAsync (int streamId, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = await GetStreamTopicsWithHttpInfoAsync(streamId, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get topics in a stream Get all the topics in a specific stream  &#x60;GET {{ api_url }}/v1/users/me/{stream_id}/topics&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> GetStreamTopicsWithHttpInfoAsync (int streamId, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'streamId' is set
            if (streamId == null)
                throw new ApiException(400, "Missing required parameter 'streamId' when calling StreamsApi->GetStreamTopics");

            var localVarPath = "/users/me/{stream_id}/topics";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (streamId != null) localVarPathParams.Add("stream_id", this.Configuration.ApiClient.ParameterToString(streamId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetStreamTopics", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Get all streams Get all streams that the user has access to.  &#x60;GET {{ api_url }}/v1/streams&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includePublic">Include all public streams.  (optional, default to true)</param>
        /// <param name="includeWebPublic">Include all web public streams.  (optional, default to false)</param>
        /// <param name="includeSubscribed">Include all streams that the user is subscribed to.  (optional, default to true)</param>
        /// <param name="includeAllActive">Include all active streams. The user must have administrative privileges to use this parameter.  (optional, default to false)</param>
        /// <param name="includeDefault">Include all default streams for the user&#39;s realm.  (optional, default to false)</param>
        /// <param name="includeOwnerSubscribed">If the user is a bot, include all streams that the bot&#39;s owner is subscribed to.  (optional, default to false)</param>
        /// <returns>JsonSuccessBase</returns>
        public JsonSuccessBase GetStreams (bool? includePublic = default(bool?), bool? includeWebPublic = default(bool?), bool? includeSubscribed = default(bool?), bool? includeAllActive = default(bool?), bool? includeDefault = default(bool?), bool? includeOwnerSubscribed = default(bool?))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = GetStreamsWithHttpInfo(includePublic, includeWebPublic, includeSubscribed, includeAllActive, includeDefault, includeOwnerSubscribed);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get all streams Get all streams that the user has access to.  &#x60;GET {{ api_url }}/v1/streams&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includePublic">Include all public streams.  (optional, default to true)</param>
        /// <param name="includeWebPublic">Include all web public streams.  (optional, default to false)</param>
        /// <param name="includeSubscribed">Include all streams that the user is subscribed to.  (optional, default to true)</param>
        /// <param name="includeAllActive">Include all active streams. The user must have administrative privileges to use this parameter.  (optional, default to false)</param>
        /// <param name="includeDefault">Include all default streams for the user&#39;s realm.  (optional, default to false)</param>
        /// <param name="includeOwnerSubscribed">If the user is a bot, include all streams that the bot&#39;s owner is subscribed to.  (optional, default to false)</param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        public ApiResponse<JsonSuccessBase> GetStreamsWithHttpInfo (bool? includePublic = default(bool?), bool? includeWebPublic = default(bool?), bool? includeSubscribed = default(bool?), bool? includeAllActive = default(bool?), bool? includeDefault = default(bool?), bool? includeOwnerSubscribed = default(bool?))
        {

            var localVarPath = "/streams";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (includePublic != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_public", includePublic)); // query parameter
            if (includeWebPublic != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_web_public", includeWebPublic)); // query parameter
            if (includeSubscribed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_subscribed", includeSubscribed)); // query parameter
            if (includeAllActive != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_all_active", includeAllActive)); // query parameter
            if (includeDefault != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_default", includeDefault)); // query parameter
            if (includeOwnerSubscribed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_owner_subscribed", includeOwnerSubscribed)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetStreams", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Get all streams Get all streams that the user has access to.  &#x60;GET {{ api_url }}/v1/streams&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includePublic">Include all public streams.  (optional, default to true)</param>
        /// <param name="includeWebPublic">Include all web public streams.  (optional, default to false)</param>
        /// <param name="includeSubscribed">Include all streams that the user is subscribed to.  (optional, default to true)</param>
        /// <param name="includeAllActive">Include all active streams. The user must have administrative privileges to use this parameter.  (optional, default to false)</param>
        /// <param name="includeDefault">Include all default streams for the user&#39;s realm.  (optional, default to false)</param>
        /// <param name="includeOwnerSubscribed">If the user is a bot, include all streams that the bot&#39;s owner is subscribed to.  (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        public async System.Threading.Tasks.Task<JsonSuccessBase> GetStreamsAsync (bool? includePublic = default(bool?), bool? includeWebPublic = default(bool?), bool? includeSubscribed = default(bool?), bool? includeAllActive = default(bool?), bool? includeDefault = default(bool?), bool? includeOwnerSubscribed = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = await GetStreamsWithHttpInfoAsync(includePublic, includeWebPublic, includeSubscribed, includeAllActive, includeDefault, includeOwnerSubscribed, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get all streams Get all streams that the user has access to.  &#x60;GET {{ api_url }}/v1/streams&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includePublic">Include all public streams.  (optional, default to true)</param>
        /// <param name="includeWebPublic">Include all web public streams.  (optional, default to false)</param>
        /// <param name="includeSubscribed">Include all streams that the user is subscribed to.  (optional, default to true)</param>
        /// <param name="includeAllActive">Include all active streams. The user must have administrative privileges to use this parameter.  (optional, default to false)</param>
        /// <param name="includeDefault">Include all default streams for the user&#39;s realm.  (optional, default to false)</param>
        /// <param name="includeOwnerSubscribed">If the user is a bot, include all streams that the bot&#39;s owner is subscribed to.  (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> GetStreamsWithHttpInfoAsync (bool? includePublic = default(bool?), bool? includeWebPublic = default(bool?), bool? includeSubscribed = default(bool?), bool? includeAllActive = default(bool?), bool? includeDefault = default(bool?), bool? includeOwnerSubscribed = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
        {

            var localVarPath = "/streams";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (includePublic != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_public", includePublic)); // query parameter
            if (includeWebPublic != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_web_public", includeWebPublic)); // query parameter
            if (includeSubscribed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_subscribed", includeSubscribed)); // query parameter
            if (includeAllActive != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_all_active", includeAllActive)); // query parameter
            if (includeDefault != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_default", includeDefault)); // query parameter
            if (includeOwnerSubscribed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_owner_subscribed", includeOwnerSubscribed)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetStreams", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Get subscription status Check whether a user is subscribed to a stream.  &#x60;GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}&#x60;  **Changes**: New in Zulip 3.0 (feature level 11). 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The target user&#39;s ID. </param>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>JsonSuccessBase</returns>
        public JsonSuccessBase GetSubscriptionStatus (int userId, int streamId)
        {
             ApiResponse<JsonSuccessBase> localVarResponse = GetSubscriptionStatusWithHttpInfo(userId, streamId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get subscription status Check whether a user is subscribed to a stream.  &#x60;GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}&#x60;  **Changes**: New in Zulip 3.0 (feature level 11). 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The target user&#39;s ID. </param>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        public ApiResponse<JsonSuccessBase> GetSubscriptionStatusWithHttpInfo (int userId, int streamId)
        {
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new ApiException(400, "Missing required parameter 'userId' when calling StreamsApi->GetSubscriptionStatus");
            // verify the required parameter 'streamId' is set
            if (streamId == null)
                throw new ApiException(400, "Missing required parameter 'streamId' when calling StreamsApi->GetSubscriptionStatus");

            var localVarPath = "/users/{user_id}/subscriptions/{stream_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarPathParams.Add("user_id", this.Configuration.ApiClient.ParameterToString(userId)); // path parameter
            if (streamId != null) localVarPathParams.Add("stream_id", this.Configuration.ApiClient.ParameterToString(streamId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSubscriptionStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Get subscription status Check whether a user is subscribed to a stream.  &#x60;GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}&#x60;  **Changes**: New in Zulip 3.0 (feature level 11). 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The target user&#39;s ID. </param>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        public async System.Threading.Tasks.Task<JsonSuccessBase> GetSubscriptionStatusAsync (int userId, int streamId, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = await GetSubscriptionStatusWithHttpInfoAsync(userId, streamId, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get subscription status Check whether a user is subscribed to a stream.  &#x60;GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}&#x60;  **Changes**: New in Zulip 3.0 (feature level 11). 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="userId">The target user&#39;s ID. </param>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> GetSubscriptionStatusWithHttpInfoAsync (int userId, int streamId, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'userId' is set
            if (userId == null)
                throw new ApiException(400, "Missing required parameter 'userId' when calling StreamsApi->GetSubscriptionStatus");
            // verify the required parameter 'streamId' is set
            if (streamId == null)
                throw new ApiException(400, "Missing required parameter 'streamId' when calling StreamsApi->GetSubscriptionStatus");

            var localVarPath = "/users/{user_id}/subscriptions/{stream_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (userId != null) localVarPathParams.Add("user_id", this.Configuration.ApiClient.ParameterToString(userId)); // path parameter
            if (streamId != null) localVarPathParams.Add("stream_id", this.Configuration.ApiClient.ParameterToString(streamId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSubscriptionStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Get subscribed streams Get all streams that the user is subscribed to.  &#x60;GET {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeSubscribers">Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0.  (optional, default to false)</param>
        /// <returns>JsonSuccessBase</returns>
        public JsonSuccessBase GetSubscriptions (bool? includeSubscribers = default(bool?))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = GetSubscriptionsWithHttpInfo(includeSubscribers);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get subscribed streams Get all streams that the user is subscribed to.  &#x60;GET {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeSubscribers">Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0.  (optional, default to false)</param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        public ApiResponse<JsonSuccessBase> GetSubscriptionsWithHttpInfo (bool? includeSubscribers = default(bool?))
        {

            var localVarPath = "/users/me/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (includeSubscribers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_subscribers", includeSubscribers)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Get subscribed streams Get all streams that the user is subscribed to.  &#x60;GET {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeSubscribers">Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0.  (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        public async System.Threading.Tasks.Task<JsonSuccessBase> GetSubscriptionsAsync (bool? includeSubscribers = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = await GetSubscriptionsWithHttpInfoAsync(includeSubscribers, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get subscribed streams Get all streams that the user is subscribed to.  &#x60;GET {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeSubscribers">Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0.  (optional, default to false)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> GetSubscriptionsWithHttpInfoAsync (bool? includeSubscribers = default(bool?), CancellationToken cancellationToken = default(CancellationToken))
        {

            var localVarPath = "/users/me/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (includeSubscribers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "include_subscribers", includeSubscribers)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Topic muting This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user&#39;s unread count totals.  &#x60;PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="topic">The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. </param>
        /// <param name="op">Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. </param>
        /// <param name="stream">The name of the stream to access.  (optional)</param>
        /// <param name="streamId">The ID of the stream to access.  (optional)</param>
        /// <returns>JsonSuccess</returns>
        public JsonSuccess MuteTopic (string topic, string op, string stream = default(string), int? streamId = default(int?))
        {
             ApiResponse<JsonSuccess> localVarResponse = MuteTopicWithHttpInfo(topic, op, stream, streamId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Topic muting This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user&#39;s unread count totals.  &#x60;PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="topic">The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. </param>
        /// <param name="op">Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. </param>
        /// <param name="stream">The name of the stream to access.  (optional)</param>
        /// <param name="streamId">The ID of the stream to access.  (optional)</param>
        /// <returns>ApiResponse of JsonSuccess</returns>
        public ApiResponse<JsonSuccess> MuteTopicWithHttpInfo (string topic, string op, string stream = default(string), int? streamId = default(int?))
        {
            // verify the required parameter 'topic' is set
            if (topic == null)
                throw new ApiException(400, "Missing required parameter 'topic' when calling StreamsApi->MuteTopic");
            // verify the required parameter 'op' is set
            if (op == null)
                throw new ApiException(400, "Missing required parameter 'op' when calling StreamsApi->MuteTopic");

            var localVarPath = "/users/me/subscriptions/muted_topics";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (stream != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "stream", stream)); // query parameter
            if (streamId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "stream_id", streamId)); // query parameter
            if (topic != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "topic", topic)); // query parameter
            if (op != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "op", op)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("MuteTopic", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccess>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccess) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccess)));
        }

        /// <summary>
        /// Topic muting This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user&#39;s unread count totals.  &#x60;PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="topic">The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. </param>
        /// <param name="op">Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. </param>
        /// <param name="stream">The name of the stream to access.  (optional)</param>
        /// <param name="streamId">The ID of the stream to access.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccess</returns>
        public async System.Threading.Tasks.Task<JsonSuccess> MuteTopicAsync (string topic, string op, string stream = default(string), int? streamId = default(int?), CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccess> localVarResponse = await MuteTopicWithHttpInfoAsync(topic, op, stream, streamId, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Topic muting This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user&#39;s unread count totals.  &#x60;PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="topic">The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. </param>
        /// <param name="op">Whether to mute (&#x60;add&#x60;) or unmute (&#x60;remove&#x60;) the provided topic. </param>
        /// <param name="stream">The name of the stream to access.  (optional)</param>
        /// <param name="streamId">The ID of the stream to access.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccess)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccess>> MuteTopicWithHttpInfoAsync (string topic, string op, string stream = default(string), int? streamId = default(int?), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'topic' is set
            if (topic == null)
                throw new ApiException(400, "Missing required parameter 'topic' when calling StreamsApi->MuteTopic");
            // verify the required parameter 'op' is set
            if (op == null)
                throw new ApiException(400, "Missing required parameter 'op' when calling StreamsApi->MuteTopic");

            var localVarPath = "/users/me/subscriptions/muted_topics";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (stream != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "stream", stream)); // query parameter
            if (streamId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "stream_id", streamId)); // query parameter
            if (topic != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "topic", topic)); // query parameter
            if (op != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "op", op)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("MuteTopic", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccess>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccess) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccess)));
        }

        /// <summary>
        /// Subscribe to a stream Subscribe one or more users to one or more streams.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions&#x60;  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like &#x60;invite_only&#x60; detailed below. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="authorizationErrorsFatal">A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key.  (optional, default to true)</param>
        /// <param name="announce">If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream&#39;s creation.  (optional, default to false)</param>
        /// <param name="inviteOnly">As described above, this endpoint will create a new stream if passed a stream name that doesn&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams.  (optional, default to false)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <returns>OneOfobjectobject</returns>
        public OneOfobjectobject Subscribe (List<Object> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), bool? authorizationErrorsFatal = default(bool?), bool? announce = default(bool?), bool? inviteOnly = default(bool?), bool? historyPublicToSubscribers = default(bool?), int? streamPostPolicy = default(int?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger))
        {
             ApiResponse<OneOfobjectobject> localVarResponse = SubscribeWithHttpInfo(subscriptions, principals, authorizationErrorsFatal, announce, inviteOnly, historyPublicToSubscribers, streamPostPolicy, messageRetentionDays);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Subscribe to a stream Subscribe one or more users to one or more streams.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions&#x60;  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like &#x60;invite_only&#x60; detailed below. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="authorizationErrorsFatal">A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key.  (optional, default to true)</param>
        /// <param name="announce">If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream&#39;s creation.  (optional, default to false)</param>
        /// <param name="inviteOnly">As described above, this endpoint will create a new stream if passed a stream name that doesn&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams.  (optional, default to false)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <returns>ApiResponse of OneOfobjectobject</returns>
        public ApiResponse<OneOfobjectobject> SubscribeWithHttpInfo (List<Object> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), bool? authorizationErrorsFatal = default(bool?), bool? announce = default(bool?), bool? inviteOnly = default(bool?), bool? historyPublicToSubscribers = default(bool?), int? streamPostPolicy = default(int?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger))
        {
            // verify the required parameter 'subscriptions' is set
            if (subscriptions == null)
                throw new ApiException(400, "Missing required parameter 'subscriptions' when calling StreamsApi->Subscribe");

            var localVarPath = "/users/me/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptions != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "subscriptions", subscriptions)); // query parameter
            if (principals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "principals", principals)); // query parameter
            if (authorizationErrorsFatal != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "authorization_errors_fatal", authorizationErrorsFatal)); // query parameter
            if (announce != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "announce", announce)); // query parameter
            if (inviteOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "invite_only", inviteOnly)); // query parameter
            if (historyPublicToSubscribers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "history_public_to_subscribers", historyPublicToSubscribers)); // query parameter
            if (streamPostPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "stream_post_policy", streamPostPolicy)); // query parameter
            if (messageRetentionDays != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "message_retention_days", messageRetentionDays)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("Subscribe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<OneOfobjectobject>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (OneOfobjectobject) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(OneOfobjectobject)));
        }

        /// <summary>
        /// Subscribe to a stream Subscribe one or more users to one or more streams.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions&#x60;  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like &#x60;invite_only&#x60; detailed below. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="authorizationErrorsFatal">A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key.  (optional, default to true)</param>
        /// <param name="announce">If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream&#39;s creation.  (optional, default to false)</param>
        /// <param name="inviteOnly">As described above, this endpoint will create a new stream if passed a stream name that doesn&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams.  (optional, default to false)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of OneOfobjectobject</returns>
        public async System.Threading.Tasks.Task<OneOfobjectobject> SubscribeAsync (List<Object> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), bool? authorizationErrorsFatal = default(bool?), bool? announce = default(bool?), bool? inviteOnly = default(bool?), bool? historyPublicToSubscribers = default(bool?), int? streamPostPolicy = default(int?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger), CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<OneOfobjectobject> localVarResponse = await SubscribeWithHttpInfoAsync(subscriptions, principals, authorizationErrorsFatal, announce, inviteOnly, historyPublicToSubscribers, streamPostPolicy, messageRetentionDays, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Subscribe to a stream Subscribe one or more users to one or more streams.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions&#x60;  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like &#x60;invite_only&#x60; detailed below. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of dictionaries containing the key &#x60;name&#x60; and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key &#x60;description&#x60; with an appropriate value. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="authorizationErrorsFatal">A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When &#x60;True&#x60;, an authorization error is reported as such. When set to &#x60;False&#x60;, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the &#x60;unauthorized&#x60; key.  (optional, default to true)</param>
        /// <param name="announce">If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream&#39;s creation.  (optional, default to false)</param>
        /// <param name="inviteOnly">As described above, this endpoint will create a new stream if passed a stream name that doesn&#39;t already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams.  (optional, default to false)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (OneOfobjectobject)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<OneOfobjectobject>> SubscribeWithHttpInfoAsync (List<Object> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), bool? authorizationErrorsFatal = default(bool?), bool? announce = default(bool?), bool? inviteOnly = default(bool?), bool? historyPublicToSubscribers = default(bool?), int? streamPostPolicy = default(int?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'subscriptions' is set
            if (subscriptions == null)
                throw new ApiException(400, "Missing required parameter 'subscriptions' when calling StreamsApi->Subscribe");

            var localVarPath = "/users/me/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptions != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "subscriptions", subscriptions)); // query parameter
            if (principals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "principals", principals)); // query parameter
            if (authorizationErrorsFatal != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "authorization_errors_fatal", authorizationErrorsFatal)); // query parameter
            if (announce != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "announce", announce)); // query parameter
            if (inviteOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "invite_only", inviteOnly)); // query parameter
            if (historyPublicToSubscribers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "history_public_to_subscribers", historyPublicToSubscribers)); // query parameter
            if (streamPostPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "stream_post_policy", streamPostPolicy)); // query parameter
            if (messageRetentionDays != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "message_retention_days", messageRetentionDays)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("Subscribe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<OneOfobjectobject>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (OneOfobjectobject) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(OneOfobjectobject)));
        }

        /// <summary>
        /// Unsubscribe from a stream Unsubscribe yourself or other users from one or more streams.  &#x60;DELETE {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <returns>JsonSuccessBase</returns>
        public JsonSuccessBase Unsubscribe (List<string> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = UnsubscribeWithHttpInfo(subscriptions, principals);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Unsubscribe from a stream Unsubscribe yourself or other users from one or more streams.  &#x60;DELETE {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        public ApiResponse<JsonSuccessBase> UnsubscribeWithHttpInfo (List<string> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>))
        {
            // verify the required parameter 'subscriptions' is set
            if (subscriptions == null)
                throw new ApiException(400, "Missing required parameter 'subscriptions' when calling StreamsApi->Unsubscribe");

            var localVarPath = "/users/me/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptions != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "subscriptions", subscriptions)); // query parameter
            if (principals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "principals", principals)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("Unsubscribe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Unsubscribe from a stream Unsubscribe yourself or other users from one or more streams.  &#x60;DELETE {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        public async System.Threading.Tasks.Task<JsonSuccessBase> UnsubscribeAsync (List<string> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = await UnsubscribeWithHttpInfoAsync(subscriptions, principals, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Unsubscribe from a stream Unsubscribe yourself or other users from one or more streams.  &#x60;DELETE {{ api_url }}/v1/users/me/subscriptions&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptions">A list of stream names to unsubscribe from. This parameter is called &#x60;streams&#x60; in our Python API. </param>
        /// <param name="principals">A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the &#x60;subscriptions&#x60; parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> UnsubscribeWithHttpInfoAsync (List<string> subscriptions, List<OneOfstringinteger> principals = default(List<OneOfstringinteger>), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'subscriptions' is set
            if (subscriptions == null)
                throw new ApiException(400, "Missing required parameter 'subscriptions' when calling StreamsApi->Unsubscribe");

            var localVarPath = "/users/me/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptions != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "subscriptions", subscriptions)); // query parameter
            if (principals != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "principals", principals)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("Unsubscribe", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Update a stream Configure the stream with the ID &#x60;stream_id&#x60;.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  &#x60;PATCH {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="description">The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="newName">The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="isPrivate">Change whether the stream is a private stream.  (optional)</param>
        /// <param name="isAnnouncementOnly">Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <returns>JsonSuccess</returns>
        public JsonSuccess UpdateStream (int streamId, string description = default(string), string newName = default(string), bool? isPrivate = default(bool?), bool? isAnnouncementOnly = default(bool?), int? streamPostPolicy = default(int?), bool? historyPublicToSubscribers = default(bool?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger))
        {
             ApiResponse<JsonSuccess> localVarResponse = UpdateStreamWithHttpInfo(streamId, description, newName, isPrivate, isAnnouncementOnly, streamPostPolicy, historyPublicToSubscribers, messageRetentionDays);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update a stream Configure the stream with the ID &#x60;stream_id&#x60;.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  &#x60;PATCH {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="description">The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="newName">The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="isPrivate">Change whether the stream is a private stream.  (optional)</param>
        /// <param name="isAnnouncementOnly">Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <returns>ApiResponse of JsonSuccess</returns>
        public ApiResponse<JsonSuccess> UpdateStreamWithHttpInfo (int streamId, string description = default(string), string newName = default(string), bool? isPrivate = default(bool?), bool? isAnnouncementOnly = default(bool?), int? streamPostPolicy = default(int?), bool? historyPublicToSubscribers = default(bool?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger))
        {
            // verify the required parameter 'streamId' is set
            if (streamId == null)
                throw new ApiException(400, "Missing required parameter 'streamId' when calling StreamsApi->UpdateStream");

            var localVarPath = "/streams/{stream_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (streamId != null) localVarPathParams.Add("stream_id", this.Configuration.ApiClient.ParameterToString(streamId)); // path parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "description", description)); // query parameter
            if (newName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "new_name", newName)); // query parameter
            if (isPrivate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "is_private", isPrivate)); // query parameter
            if (isAnnouncementOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "is_announcement_only", isAnnouncementOnly)); // query parameter
            if (streamPostPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "stream_post_policy", streamPostPolicy)); // query parameter
            if (historyPublicToSubscribers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "history_public_to_subscribers", historyPublicToSubscribers)); // query parameter
            if (messageRetentionDays != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "message_retention_days", messageRetentionDays)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateStream", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccess>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccess) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccess)));
        }

        /// <summary>
        /// Update a stream Configure the stream with the ID &#x60;stream_id&#x60;.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  &#x60;PATCH {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="description">The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="newName">The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="isPrivate">Change whether the stream is a private stream.  (optional)</param>
        /// <param name="isAnnouncementOnly">Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccess</returns>
        public async System.Threading.Tasks.Task<JsonSuccess> UpdateStreamAsync (int streamId, string description = default(string), string newName = default(string), bool? isPrivate = default(bool?), bool? isAnnouncementOnly = default(bool?), int? streamPostPolicy = default(int?), bool? historyPublicToSubscribers = default(bool?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger), CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccess> localVarResponse = await UpdateStreamWithHttpInfoAsync(streamId, description, newName, isPrivate, isAnnouncementOnly, streamPostPolicy, historyPublicToSubscribers, messageRetentionDays, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update a stream Configure the stream with the ID &#x60;stream_id&#x60;.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  &#x60;PATCH {{ api_url }}/v1/streams/{stream_id}&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="streamId">The ID of the stream to access. </param>
        /// <param name="description">The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="newName">The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64).  (optional)</param>
        /// <param name="isPrivate">Change whether the stream is a private stream.  (optional)</param>
        /// <param name="isAnnouncementOnly">Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   &#x60;stream_post_policy&#x60; instead.  (optional)</param>
        /// <param name="streamPostPolicy">Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean.  (optional, default to 1)</param>
        /// <param name="historyPublicToSubscribers">Whether the stream&#39;s message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation.  (optional)</param>
        /// <param name="messageRetentionDays">Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \&quot;realm_default\&quot; &#x3D;&gt; Return to the organization-level setting. * \&quot;forever\&quot; &#x3D;&gt; Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17).  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccess)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccess>> UpdateStreamWithHttpInfoAsync (int streamId, string description = default(string), string newName = default(string), bool? isPrivate = default(bool?), bool? isAnnouncementOnly = default(bool?), int? streamPostPolicy = default(int?), bool? historyPublicToSubscribers = default(bool?), OneOfstringinteger messageRetentionDays = default(OneOfstringinteger), CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'streamId' is set
            if (streamId == null)
                throw new ApiException(400, "Missing required parameter 'streamId' when calling StreamsApi->UpdateStream");

            var localVarPath = "/streams/{stream_id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (streamId != null) localVarPathParams.Add("stream_id", this.Configuration.ApiClient.ParameterToString(streamId)); // path parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "description", description)); // query parameter
            if (newName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "new_name", newName)); // query parameter
            if (isPrivate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "is_private", isPrivate)); // query parameter
            if (isAnnouncementOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "is_announcement_only", isAnnouncementOnly)); // query parameter
            if (streamPostPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "stream_post_policy", streamPostPolicy)); // query parameter
            if (historyPublicToSubscribers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "history_public_to_subscribers", historyPublicToSubscribers)); // query parameter
            if (messageRetentionDays != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "message_retention_days", messageRetentionDays)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateStream", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccess>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccess) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccess)));
        }

        /// <summary>
        /// Update subscription settings This endpoint is used to update the user&#39;s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions/properties&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionData">A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. </param>
        /// <returns>JsonSuccessBase</returns>
        public JsonSuccessBase UpdateSubscriptionSettings (List<Object> subscriptionData)
        {
             ApiResponse<JsonSuccessBase> localVarResponse = UpdateSubscriptionSettingsWithHttpInfo(subscriptionData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update subscription settings This endpoint is used to update the user&#39;s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions/properties&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionData">A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. </param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        public ApiResponse<JsonSuccessBase> UpdateSubscriptionSettingsWithHttpInfo (List<Object> subscriptionData)
        {
            // verify the required parameter 'subscriptionData' is set
            if (subscriptionData == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionData' when calling StreamsApi->UpdateSubscriptionSettings");

            var localVarPath = "/users/me/subscriptions/properties";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "subscription_data", subscriptionData)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSubscriptionSettings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Update subscription settings This endpoint is used to update the user&#39;s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions/properties&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionData">A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        public async System.Threading.Tasks.Task<JsonSuccessBase> UpdateSubscriptionSettingsAsync (List<Object> subscriptionData, CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = await UpdateSubscriptionSettingsWithHttpInfoAsync(subscriptionData, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update subscription settings This endpoint is used to update the user&#39;s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions/properties&#x60; 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="subscriptionData">A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a &#x60;stream_id&#x60; key that identifies the stream, as well as the &#x60;property&#x60; being modified and its new &#x60;value&#x60;.  The possible values for each &#x60;property&#x60; and &#x60;value&#x60; pairs are:  * &#x60;color&#x60; (string): the hex value of the user&#39;s display color for the stream. * &#x60;is_muted&#x60; (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named &#x60;in_home_view&#x60; (with the   opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;); for   backwards-compatibility, modern Zulip still accepts that value. * &#x60;pin_to_top&#x60; (boolean): whether to pin the stream at the top of the stream list. * &#x60;desktop_notifications&#x60; (boolean): whether to show desktop notifications     for all messages sent to the stream. * &#x60;audible_notifications&#x60; (boolean): whether to play a sound   notification for all messages sent to the stream. * &#x60;push_notifications&#x60; (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * &#x60;email_notifications&#x60; (boolean): whether to trigger an email     notification for all messages sent to the stream. </param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> UpdateSubscriptionSettingsWithHttpInfoAsync (List<Object> subscriptionData, CancellationToken cancellationToken = default(CancellationToken))
        {
            // verify the required parameter 'subscriptionData' is set
            if (subscriptionData == null)
                throw new ApiException(400, "Missing required parameter 'subscriptionData' when calling StreamsApi->UpdateSubscriptionSettings");

            var localVarPath = "/users/me/subscriptions/properties";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (subscriptionData != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "subscription_data", subscriptionData)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSubscriptionSettings", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Update subscriptions Update which streams you are are subscribed to. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="delete">A list of stream names to unsubscribe from.  (optional)</param>
        /// <param name="add">A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description.  (optional)</param>
        /// <returns>JsonSuccessBase</returns>
        public JsonSuccessBase UpdateSubscriptions (List<string> delete = default(List<string>), List<Object> add = default(List<Object>))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = UpdateSubscriptionsWithHttpInfo(delete, add);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update subscriptions Update which streams you are are subscribed to. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="delete">A list of stream names to unsubscribe from.  (optional)</param>
        /// <param name="add">A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description.  (optional)</param>
        /// <returns>ApiResponse of JsonSuccessBase</returns>
        public ApiResponse<JsonSuccessBase> UpdateSubscriptionsWithHttpInfo (List<string> delete = default(List<string>), List<Object> add = default(List<Object>))
        {

            var localVarPath = "/users/me/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (delete != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "delete", delete)); // query parameter
            if (add != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "add", add)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

        /// <summary>
        /// Update subscriptions Update which streams you are are subscribed to. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="delete">A list of stream names to unsubscribe from.  (optional)</param>
        /// <param name="add">A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of JsonSuccessBase</returns>
        public async System.Threading.Tasks.Task<JsonSuccessBase> UpdateSubscriptionsAsync (List<string> delete = default(List<string>), List<Object> add = default(List<Object>), CancellationToken cancellationToken = default(CancellationToken))
        {
             ApiResponse<JsonSuccessBase> localVarResponse = await UpdateSubscriptionsWithHttpInfoAsync(delete, add, cancellationToken);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update subscriptions Update which streams you are are subscribed to. 
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="delete">A list of stream names to unsubscribe from.  (optional)</param>
        /// <param name="add">A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel request (optional) </param>
        /// <returns>Task of ApiResponse (JsonSuccessBase)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<JsonSuccessBase>> UpdateSubscriptionsWithHttpInfoAsync (List<string> delete = default(List<string>), List<Object> add = default(List<Object>), CancellationToken cancellationToken = default(CancellationToken))
        {

            var localVarPath = "/users/me/subscriptions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (delete != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "delete", delete)); // query parameter
            if (add != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "add", add)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType, cancellationToken);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateSubscriptions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<JsonSuccessBase>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (JsonSuccessBase) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(JsonSuccessBase)));
        }

    }
}
