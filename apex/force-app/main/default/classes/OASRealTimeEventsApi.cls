/*
 * Zulip REST API
 * Powerful open source group chat\n
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the OAS code generator program.
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

public class OASRealTimeEventsApi {
    OASClient client;

    public OASRealTimeEventsApi(OASClient client) {
        this.client = client;
    }

    public OASRealTimeEventsApi() {
        this.client = new OASClient();
    }

    public OASClient getClient() {
        return this.client;
    }

    /**
     * Delete an event queue
     * Delete a previously registered queue.\n\n&#x60;DELETE {{ api_url }}/v1/events&#x60;\n
     * @param queueId The ID of an event queue that was previously registered via &#x60;POST\n/api/v1/register&#x60; (see [Register a queue](/api/register-queue)).\n (required)
     * @return OASJsonSuccess
     * @throws OAS.ApiException if fails to make API call
     */
    public OASJsonSuccess deleteQueue(Map<String, Object> params) {
        client.assertNotNull(params.get('queueId'), 'queueId');
        List<OAS.Param> query = new List<OAS.Param>();

        // cast query params to verify their expected type
        query.addAll(client.makeParam('queue_id', (String) params.get('queueId')));

        List<OAS.Param> form = new List<OAS.Param>();

        return (OASJsonSuccess) client.invoke(
            'DELETE', '/events', '',
            query, form,
            new Map<String, Object>(),
            new Map<String, Object>(),
            new List<String>{ 'application/json' },
            new List<String>(),
            new List<String>(),
            OASJsonSuccess.class
        );
    }
    /**
     * Get events from an event queue
     * &#x60;GET {{ api_url }}/v1/events&#x60;\n\nThis endpoint allows you to receive new events from\n[a registered event queue](/api/register-queue).\n\nLong-lived clients should use the\n&#x60;event_queue_longpoll_timeout_seconds&#x60; property returned by\n&#x60;POST /register&#x60; as the client-side HTTP request timeout for\ncalls to this endpoint.  It is guaranteed to be higher than\nheartbeat frequency and should be respected by clients to\navoid breaking when heartbeat frequency increases.\n
     * @param queueId The ID of an event queue that was previously registered via &#x60;POST\n/api/v1/register&#x60; (see [Register a queue](/api/register-queue)).\n (required)
     * @param lastEventId The highest event ID in this queue that you\&#39;ve received and\nwish to acknowledge. See the [code for\n&#x60;call_on_each_event&#x60;](https://github.com/zulip/python-zulip-api/blob/master/zulip/zulip/__init__.py)\nin the [zulip Python\nmodule](https://github.com/zulip/python-zulip-api) for an\nexample implementation of correctly processing each event\nexactly once.\n (optional)
     * @param dontBlock Set to &#x60;true&#x60; if the client is requesting a nonblocking reply. If not\nspecified, the request will block until either a new event is available\nor a few minutes have passed, in which case the server will send the\nclient a heartbeat event.\n (optional, default to false)
     * @return OASJsonSuccessBase
     * @throws OAS.ApiException if fails to make API call
     */
    public OASJsonSuccessBase getEvents(Map<String, Object> params) {
        client.assertNotNull(params.get('queueId'), 'queueId');
        List<OAS.Param> query = new List<OAS.Param>();

        // cast query params to verify their expected type
        query.addAll(client.makeParam('queue_id', (String) params.get('queueId')));
        query.addAll(client.makeParam('last_event_id', (Integer) params.get('lastEventId')));
        query.addAll(client.makeParam('dont_block', (Boolean) params.get('dontBlock')));

        List<OAS.Param> form = new List<OAS.Param>();

        return (OASJsonSuccessBase) client.invoke(
            'GET', '/events', '',
            query, form,
            new Map<String, Object>(),
            new Map<String, Object>(),
            new List<String>{ 'application/json' },
            new List<String>(),
            new List<String>(),
            OASJsonSuccessBase.class
        );
    }
    /**
     * 
     * (Ignored)\n
     * @param eventTypes A JSON-encoded array indicating which types of events you\&#39;re interested\nin. Values that you might find useful include:\n\n  * **message** (messages)\n  * **subscription** (changes in your subscriptions)\n  * **realm_user** (changes to users in the organization and\n    their properties, such as their name).\n\nIf you do not specify this parameter, you will receive all\nevents, and have to filter out the events not relevant to\nyour client in your client code.  For most applications, one\nis only interested in messages, so one specifies:\n&#x60;event_types&#x3D;[\&#39;message\&#39;]&#x60;\n\nEvent types not supported by the server are ignored, in order to simplify\nthe implementation of client apps that support multiple server versions.\n (optional, default to new List<String>())
     * @param narrow A JSON-encoded array of arrays of length 2 indicating the\nnarrow for which you\&#39;d like to receive events for. For\ninstance, to receive events for the stream &#x60;Denmark&#x60;, you\nwould specify &#x60;narrow&#x3D;[[\&#39;stream\&#39;, \&#39;Denmark\&#39;]]&#x60;.  Another\nexample is &#x60;narrow&#x3D;[[\&#39;is\&#39;, \&#39;private\&#39;]]&#x60; for private messages.\nDefault is &#x60;[]&#x60;.\n (optional, default to new List<List<String>>())
     * @param allPublicStreams Whether you would like to request message events from all public\nstreams.  Useful for workflow bots that you\&#39;d like to see all new messages\nsent to public streams.  (You can also subscribe the user to private streams).\n (optional, default to false)
     * @throws OAS.ApiException if fails to make API call
     */
    public void realTimePost(Map<String, Object> params) {
        List<OAS.Param> query = new List<OAS.Param>();

        // cast query params to verify their expected type
        query.addAll(client.makeParams('event_types', (List<String>) params.get('eventTypes')));
        query.addAll(client.makeParams('narrow', (List<List<String>>) params.get('narrow')));
        query.addAll(client.makeParam('all_public_streams', (Boolean) params.get('allPublicStreams')));

        List<OAS.Param> form = new List<OAS.Param>();

        client.invoke(
            'POST', '/real-time', '',
            query, form,
            new Map<String, Object>(),
            new Map<String, Object>(),
            new List<String>(),
            new List<String>(),
            new List<String>(),
            null
        );
    }
    /**
     * Register an event queue
     * &#x60;POST {{ api_url }}/v1/register&#x60;\n\nThis powerful endpoint can be used to register a Zulip &quot;event queue&quot;\n(subscribed to certain types of &quot;events&quot;, or updates to the messages\nand other Zulip data the current user has access to), as well as to\nfetch the current state of that data.\n\n(&#x60;register&#x60; also powers the &#x60;call_on_each_event&#x60; Python API, and is\nintended primarily for complex applications for which the more convenient\n&#x60;call_on_each_event&#x60; API is insufficient).\n\nThis endpoint returns a &#x60;queue_id&#x60; and a &#x60;last_event_id&#x60;; these can be\nused in subsequent calls to the\n[&quot;events&quot; endpoint](/api/get-events) to request events from\nthe Zulip server using long-polling.\n\nThe server will queue events for up to 10 minutes of inactivity.\nAfter 10 minutes, your event queue will be garbage-collected.  The\nserver will send &#x60;heartbeat&#x60; events every minute, which makes it easy\nto implement a robust client that does not miss events unless the\nclient loses network connectivity with the Zulip server for 10 minutes\nor longer.\n\nOnce the server garbage-collects your event queue, the server will\n[return an error](/api/get-events#bad_event_queue_id-errors)\nwith a code of &#x60;BAD_EVENT_QUEUE_ID&#x60; if you try to fetch events from\nthe event queue.  Your software will need to handle that error\ncondition by re-initializing itself (e.g. this is what triggers your\nbrowser reloading the Zulip web app when your laptop comes back online\nafter being offline for more than 10 minutes).\n\nWhen prototyping with this API, we recommend first calling &#x60;register&#x60;\nwith no &#x60;event_types&#x60; parameter to see all the available data from all\nsupported event types.  Before using your client in production, you\nshould set appropriate &#x60;event_types&#x60; and &#x60;fetch_event_types&#x60; filters\nso that your client only requests the data it needs.  A few minutes\ndoing this often saves 90% of the total bandwidth and other resources\nconsumed by a client using this API.\n\nSee the\n[events system developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/events-system.html)\nif you need deeper details about how the Zulip event queue system\nworks, avoids clients needing to worry about large classes of\npotentially messy races, etc.\n
     * @param applyMarkdown Set to &#x60;true&#x60; if you would like the content to be rendered in HTML\nformat (otherwise the API will return the raw text that the user\nentered)\n (optional, default to false)
     * @param clientGravatar Whether the client supports computing gravatars URLs.  If\nenabled, &#x60;avatar_url&#x60; will be included in the response only\nif there is a Zulip avatar, and will be &#x60;null&#x60; for users who\nare using gravatar as their avatar.  This option\nsignificantly reduces the compressed size of user data,\nsince gravatar URLs are long, random strings and thus do not\ncompress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if\nclients can compute their own gravatars.\n (optional, default to false)
     * @param slimPresence Setting this to &#x60;true&#x60; will make presence dictionaries be keyed by\nuser_id instead of email.\n\n**Changes**: New in Zulip 3.0 (Unstable with no feature level yet).\n (optional, default to false)
     * @param eventTypes A JSON-encoded array indicating which types of events you\&#39;re interested\nin. Values that you might find useful include:\n\n  * **message** (messages)\n  * **subscription** (changes in your subscriptions)\n  * **realm_user** (changes to users in the organization and\n    their properties, such as their name).\n\nIf you do not specify this parameter, you will receive all\nevents, and have to filter out the events not relevant to\nyour client in your client code.  For most applications, one\nis only interested in messages, so one specifies:\n&#x60;event_types&#x3D;[\&#39;message\&#39;]&#x60;\n\nEvent types not supported by the server are ignored, in order to simplify\nthe implementation of client apps that support multiple server versions.\n (optional, default to new List<String>())
     * @param allPublicStreams Whether you would like to request message events from all public\nstreams.  Useful for workflow bots that you\&#39;d like to see all new messages\nsent to public streams.  (You can also subscribe the user to private streams).\n (optional, default to false)
     * @param includeSubscribers Whether each returned stream object should include a &#x60;subscribers&#x60;\nfield containing a list of the user IDs of its subscribers.\n\n(This may be significantly slower in organizations with\nthousands of users subscribed to many streams.)\n\n**Changes**: New in Zulip 2.1.0.\n (optional, default to false)
     * @param clientCapabilities Dictionary containing details on features the client supports that are\nrelevant to the format of responses sent by the server.\n\n* &#x60;notification_settings_null&#x60;: Boolean for whether the\n  client can handle the current API with null values for\n  stream-level notification settings (which means the stream\n  is not customized and should inherit the user\&#39;s global\n  notification settings for stream messages).\n  &lt;br /&gt;\n  New in Zulip 2.1.0; in earlier Zulip releases, stream-level\n  notification settings were simple booleans.\n\n* &#x60;bulk_message_deletion&#x60;: Boolean for whether the client\&#39;s\n   handler for the &#x60;delete_message&#x60; event type has been\n   updated to process the new bulk format (with a\n   &#x60;message_ids&#x60;, rather than a singleton &#x60;message_id&#x60;).\n   Otherwise, the server will send &#x60;delete_message&#x60; events\n   in a loop.\n   &lt;br /&gt;\n   New in Zulip 3.0 (feature level 13).  This\n   capability is for backwards-compatibility; it will be\n   required in a future server release.\n\n* &#x60;user_avatar_url_field_optional&#x60;: Boolean for whether the\n   client required avatar URLs for all users, or supports\n   using &#x60;GET /avatar/{user_id}&#x60; to access user avatars.  If the\n   client has this capability, the server may skip sending a\n   &#x60;avatar_url&#x60; field in the &#x60;realm_user&#x60; at its sole discretion\n   to optimize network performance.  This is an important optimization\n   in organizations with 10,000s of users.\n   &lt;br /&gt;\n   New in Zulip 3.0 (feature level 18).\n\n* &#x60;stream_typing_notifications&#x60;: Boolean for whether the client\n  supports stream typing notifications.\n  &lt;br /&gt;\n  New in Zulip 4.0 (feature level 58).  This capability is\n  for backwards-compatibility; it will be required in a\n  future server release.\n\n* &#x60;user_settings_object&#x60;: Boolean for whether the client supports the modern\n  &#x60;user_settings&#x60; event type. If False, the server will additionally send the\n  legacy &#x60;update_display_settings&#x60; and &#x60;update_global_notifications&#x60; event\n  types for backwards-compatibility with clients that predate this API migration.\n  &lt;br /&gt;\n  &lt;br /&gt;\n  Because the feature level 89 API changes were merged together, clients can\n  safely make a request with this client capability and requesting all of the\n  &#x60;user_settings&#x60;, &#x60;update_display_settings&#x60;, and\n  &#x60;update_global_notifications&#x60; event types, and get exactly one copy of\n  settings data on any server version. (And then use the &#x60;zulip_feature_level&#x60;\n  in the &#x60;/register&#x60; response or the presence/absence of a &#x60;user_settings&#x60; key\n  to determine where to look).\n  &lt;br /&gt;\n  New in Zulip 5.0 (feature level 89).  This capability is for\n  backwards-compatibility; it will be removed in a future server release.\n (optional)
     * @param fetchEventTypes Same as the &#x60;event_types&#x60; parameter except that the values in\n&#x60;fetch_event_types&#x60; are used to fetch initial data. If\n&#x60;fetch_event_types&#x60; is not provided, &#x60;event_types&#x60; is used and if\n&#x60;event_types&#x60; is not provided, this parameter defaults to &#x60;None&#x60;.\n\nEvent types not supported by the server are ignored, in order to simplify\nthe implementation of client apps that support multiple server versions.\n (optional, default to new List<String>())
     * @param narrow A JSON-encoded array of arrays of length 2 indicating the\nnarrow for which you\&#39;d like to receive events for. For\ninstance, to receive events for the stream &#x60;Denmark&#x60;, you\nwould specify &#x60;narrow&#x3D;[[\&#39;stream\&#39;, \&#39;Denmark\&#39;]]&#x60;.  Another\nexample is &#x60;narrow&#x3D;[[\&#39;is\&#39;, \&#39;private\&#39;]]&#x60; for private messages.\nDefault is &#x60;[]&#x60;.\n (optional, default to new List<List<String>>())
     * @return OASJsonSuccessBase
     * @throws OAS.ApiException if fails to make API call
     */
    public OASJsonSuccessBase registerQueue(Map<String, Object> params) {
        List<OAS.Param> query = new List<OAS.Param>();

        // cast query params to verify their expected type
        query.addAll(client.makeParam('apply_markdown', (Boolean) params.get('applyMarkdown')));
        query.addAll(client.makeParam('client_gravatar', (Boolean) params.get('clientGravatar')));
        query.addAll(client.makeParam('slim_presence', (Boolean) params.get('slimPresence')));
        query.addAll(client.makeParams('event_types', (List<String>) params.get('eventTypes')));
        query.addAll(client.makeParam('all_public_streams', (Boolean) params.get('allPublicStreams')));
        query.addAll(client.makeParam('include_subscribers', (Boolean) params.get('includeSubscribers')));
        query.addAll(client.makeParam('client_capabilities', (Object) params.get('clientCapabilities')));
        query.addAll(client.makeParams('fetch_event_types', (List<String>) params.get('fetchEventTypes')));
        query.addAll(client.makeParams('narrow', (List<List<String>>) params.get('narrow')));

        List<OAS.Param> form = new List<OAS.Param>();

        return (OASJsonSuccessBase) client.invoke(
            'POST', '/register', '',
            query, form,
            new Map<String, Object>(),
            new Map<String, Object>(),
            new List<String>{ 'application/json' },
            new List<String>(),
            new List<String>(),
            OASJsonSuccessBase.class
        );
    }
    /**
     * Error handling
     * Common error to many endpoints\n
     * @throws OAS.ApiException if fails to make API call
     */
    public void restErrorHandling() {
        List<OAS.Param> query = new List<OAS.Param>();
        List<OAS.Param> form = new List<OAS.Param>();

        client.invoke(
            'POST', '/rest-error-handling', '',
            query, form,
            new Map<String, Object>(),
            new Map<String, Object>(),
            new List<String>{ 'application/json' },
            new List<String>(),
            new List<String>(),
            null
        );
    }
}
