=begin comment

Zulip REST API

Powerful open source group chat 

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::RealTimeEventsApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# delete_queue
#
# Delete an event queue
# 
# @param string $queue_id The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)).  (required)
{
    my $params = {
    'queue_id' => {
        data_type => 'string',
        description => 'The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). ',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_queue' } = { 
        summary => 'Delete an event queue',
        params => $params,
        returns => 'JsonSuccess',
        };
}
# @return JsonSuccess
#
sub delete_queue {
    my ($self, %args) = @_;

    # verify the required parameter 'queue_id' is set
    unless (exists $args{'queue_id'}) {
      croak("Missing the required parameter 'queue_id' when calling delete_queue");
    }

    # parse inputs
    my $_resource_path = '/events';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'queue_id'}) {
        $query_params->{'queue_id'} = $self->{api_client}->to_query_value($args{'queue_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('JsonSuccess', $response);
    return $_response_object;
}

#
# get_events
#
# Get events from an event queue
# 
# @param string $queue_id The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)).  (required)
# @param int $last_event_id The highest event ID in this queue that you&#39;ve received and wish to acknowledge. See the [code for &#x60;call_on_each_event&#x60;](https://github.com/zulip/python-zulip-api/blob/master/zulip/zulip/__init__.py) in the [zulip Python module](https://github.com/zulip/python-zulip-api) for an example implementation of correctly processing each event exactly once.  (optional)
# @param boolean $dont_block Set to &#x60;true&#x60; if the client is requesting a nonblocking reply. If not specified, the request will block until either a new event is available or a few minutes have passed, in which case the server will send the client a heartbeat event.  (optional, default to false)
{
    my $params = {
    'queue_id' => {
        data_type => 'string',
        description => 'The ID of an event queue that was previously registered via &#x60;POST /api/v1/register&#x60; (see [Register a queue](/api/register-queue)). ',
        required => '1',
    },
    'last_event_id' => {
        data_type => 'int',
        description => 'The highest event ID in this queue that you&#39;ve received and wish to acknowledge. See the [code for &#x60;call_on_each_event&#x60;](https://github.com/zulip/python-zulip-api/blob/master/zulip/zulip/__init__.py) in the [zulip Python module](https://github.com/zulip/python-zulip-api) for an example implementation of correctly processing each event exactly once. ',
        required => '0',
    },
    'dont_block' => {
        data_type => 'boolean',
        description => 'Set to &#x60;true&#x60; if the client is requesting a nonblocking reply. If not specified, the request will block until either a new event is available or a few minutes have passed, in which case the server will send the client a heartbeat event. ',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_events' } = { 
        summary => 'Get events from an event queue',
        params => $params,
        returns => 'JsonSuccessBase',
        };
}
# @return JsonSuccessBase
#
sub get_events {
    my ($self, %args) = @_;

    # verify the required parameter 'queue_id' is set
    unless (exists $args{'queue_id'}) {
      croak("Missing the required parameter 'queue_id' when calling get_events");
    }

    # parse inputs
    my $_resource_path = '/events';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'queue_id'}) {
        $query_params->{'queue_id'} = $self->{api_client}->to_query_value($args{'queue_id'});
    }

    # query params
    if ( exists $args{'last_event_id'}) {
        $query_params->{'last_event_id'} = $self->{api_client}->to_query_value($args{'last_event_id'});
    }

    # query params
    if ( exists $args{'dont_block'}) {
        $query_params->{'dont_block'} = $self->{api_client}->to_query_value($args{'dont_block'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('JsonSuccessBase', $response);
    return $_response_object;
}

#
# real_time_post
#
# 
# 
# @param ARRAY[string] $event_types A JSON-encoded array indicating which types of events you&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[&#39;message&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions.  (optional)
# @param ARRAY[ARRAY[string]] $narrow A JSON-encoded array of arrays of length 2 indicating the narrow for which you&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[&#39;stream&#39;, &#39;Denmark&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[&#39;is&#39;, &#39;private&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;.  (optional)
# @param boolean $all_public_streams Whether you would like to request message events from all public streams.  Useful for workflow bots that you&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams).  (optional, default to false)
{
    my $params = {
    'event_types' => {
        data_type => 'ARRAY[string]',
        description => 'A JSON-encoded array indicating which types of events you&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[&#39;message&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. ',
        required => '0',
    },
    'narrow' => {
        data_type => 'ARRAY[ARRAY[string]]',
        description => 'A JSON-encoded array of arrays of length 2 indicating the narrow for which you&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[&#39;stream&#39;, &#39;Denmark&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[&#39;is&#39;, &#39;private&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;. ',
        required => '0',
    },
    'all_public_streams' => {
        data_type => 'boolean',
        description => 'Whether you would like to request message events from all public streams.  Useful for workflow bots that you&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams). ',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'real_time_post' } = { 
        summary => '',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub real_time_post {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/real-time';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'event_types'}) {
        $query_params->{'event_types'} = $self->{api_client}->to_query_value($args{'event_types'});
    }

    # query params
    if ( exists $args{'narrow'}) {
        $query_params->{'narrow'} = $self->{api_client}->to_query_value($args{'narrow'});
    }

    # query params
    if ( exists $args{'all_public_streams'}) {
        $query_params->{'all_public_streams'} = $self->{api_client}->to_query_value($args{'all_public_streams'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# register_queue
#
# Register an event queue
# 
# @param boolean $apply_markdown Set to &#x60;true&#x60; if you would like the content to be rendered in HTML format (otherwise the API will return the raw text that the user entered)  (optional, default to false)
# @param boolean $client_gravatar Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars.  (optional, default to false)
# @param boolean $slim_presence Setting this to &#x60;true&#x60; will make presence dictionaries be keyed by user_id instead of email.  **Changes**: New in Zulip 3.0 (Unstable with no feature level yet).  (optional, default to false)
# @param ARRAY[string] $event_types A JSON-encoded array indicating which types of events you&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[&#39;message&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions.  (optional)
# @param boolean $all_public_streams Whether you would like to request message events from all public streams.  Useful for workflow bots that you&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams).  (optional, default to false)
# @param boolean $include_subscribers Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0.  (optional, default to false)
# @param object $client_capabilities Dictionary containing details on features the client supports that are relevant to the format of responses sent by the server.  * &#x60;notification_settings_null&#x60;: Boolean for whether the   client can handle the current API with null values for   stream-level notification settings (which means the stream   is not customized and should inherit the user&#39;s global   notification settings for stream messages).  New in Zulip   2.1.0; in earlier Zulip releases, stream-level   notification settings were simple booleans.  * &#x60;bulk_message_deletion&#x60;: Boolean for whether the client&#39;s    handler for the &#x60;delete_message&#x60; event type has been    updated to process the new bulk format (with a    &#x60;message_ids&#x60;, rather than a singleton &#x60;message_id&#x60;).    Otherwise, the server will send &#x60;delete_message&#x60; events    in a loop.  New in Zulip 3.0 (feature level 13).  This    capability is for backwards-compatibility; it will be    required in a future server release.  * &#x60;user_avatar_url_field_optional&#x60;: Boolean for whether the    client required avatar URLs for all users, or supports    using &#x60;GET /avatar/{user_id}&#x60; to access user avatars.  If the    client has this capability, the server may skip sending a    &#x60;avatar_url&#x60; field in the &#x60;realm_user&#x60; at its sole discretion    to optimize network performance.  This is an important optimization    in organizations with 10,000s of users.    New in Zulip 3.0 (feature level 18).  * &#x60;stream_typing_notifications&#x60;: Boolean for whether the client   supports stream typing notifications.    New in Zulip 4.0 (feature level 58).  This capability is   for backwards-compatibility; it will be required in a   future server release.  (optional)
# @param ARRAY[string] $fetch_event_types Same as the &#x60;event_types&#x60; parameter except that the values in &#x60;fetch_event_types&#x60; are used to fetch initial data. If &#x60;fetch_event_types&#x60; is not provided, &#x60;event_types&#x60; is used and if &#x60;event_types&#x60; is not provided, this parameter defaults to &#x60;None&#x60;.  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions.  (optional)
# @param ARRAY[ARRAY[string]] $narrow A JSON-encoded array of arrays of length 2 indicating the narrow for which you&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[&#39;stream&#39;, &#39;Denmark&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[&#39;is&#39;, &#39;private&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;.  (optional)
{
    my $params = {
    'apply_markdown' => {
        data_type => 'boolean',
        description => 'Set to &#x60;true&#x60; if you would like the content to be rendered in HTML format (otherwise the API will return the raw text that the user entered) ',
        required => '0',
    },
    'client_gravatar' => {
        data_type => 'boolean',
        description => 'Whether the client supports computing gravatars URLs.  If enabled, &#x60;avatar_url&#x60; will be included in the response only if there is a Zulip avatar, and will be &#x60;null&#x60; for users who are using gravatar as their avatar.  This option significantly reduces the compressed size of user data, since gravatar URLs are long, random strings and thus do not compress well. The &#x60;client_gravatar&#x60; field is set to &#x60;true&#x60; if clients can compute their own gravatars. ',
        required => '0',
    },
    'slim_presence' => {
        data_type => 'boolean',
        description => 'Setting this to &#x60;true&#x60; will make presence dictionaries be keyed by user_id instead of email.  **Changes**: New in Zulip 3.0 (Unstable with no feature level yet). ',
        required => '0',
    },
    'event_types' => {
        data_type => 'ARRAY[string]',
        description => 'A JSON-encoded array indicating which types of events you&#39;re interested in. Values that you might find useful include:    * **message** (messages)   * **subscription** (changes in your subscriptions)   * **realm_user** (changes to users in the organization and     their properties, such as their name).  If you do not specify this parameter, you will receive all events, and have to filter out the events not relevant to your client in your client code.  For most applications, one is only interested in messages, so one specifies: &#x60;event_types&#x3D;[&#39;message&#39;]&#x60;  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. ',
        required => '0',
    },
    'all_public_streams' => {
        data_type => 'boolean',
        description => 'Whether you would like to request message events from all public streams.  Useful for workflow bots that you&#39;d like to see all new messages sent to public streams.  (You can also subscribe the user to private streams). ',
        required => '0',
    },
    'include_subscribers' => {
        data_type => 'boolean',
        description => 'Whether each returned stream object should include a &#x60;subscribers&#x60; field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. ',
        required => '0',
    },
    'client_capabilities' => {
        data_type => 'object',
        description => 'Dictionary containing details on features the client supports that are relevant to the format of responses sent by the server.  * &#x60;notification_settings_null&#x60;: Boolean for whether the   client can handle the current API with null values for   stream-level notification settings (which means the stream   is not customized and should inherit the user&#39;s global   notification settings for stream messages).  New in Zulip   2.1.0; in earlier Zulip releases, stream-level   notification settings were simple booleans.  * &#x60;bulk_message_deletion&#x60;: Boolean for whether the client&#39;s    handler for the &#x60;delete_message&#x60; event type has been    updated to process the new bulk format (with a    &#x60;message_ids&#x60;, rather than a singleton &#x60;message_id&#x60;).    Otherwise, the server will send &#x60;delete_message&#x60; events    in a loop.  New in Zulip 3.0 (feature level 13).  This    capability is for backwards-compatibility; it will be    required in a future server release.  * &#x60;user_avatar_url_field_optional&#x60;: Boolean for whether the    client required avatar URLs for all users, or supports    using &#x60;GET /avatar/{user_id}&#x60; to access user avatars.  If the    client has this capability, the server may skip sending a    &#x60;avatar_url&#x60; field in the &#x60;realm_user&#x60; at its sole discretion    to optimize network performance.  This is an important optimization    in organizations with 10,000s of users.    New in Zulip 3.0 (feature level 18).  * &#x60;stream_typing_notifications&#x60;: Boolean for whether the client   supports stream typing notifications.    New in Zulip 4.0 (feature level 58).  This capability is   for backwards-compatibility; it will be required in a   future server release. ',
        required => '0',
    },
    'fetch_event_types' => {
        data_type => 'ARRAY[string]',
        description => 'Same as the &#x60;event_types&#x60; parameter except that the values in &#x60;fetch_event_types&#x60; are used to fetch initial data. If &#x60;fetch_event_types&#x60; is not provided, &#x60;event_types&#x60; is used and if &#x60;event_types&#x60; is not provided, this parameter defaults to &#x60;None&#x60;.  Event types not supported by the server are ignored, in order to simplify the implementation of client apps that support multiple server versions. ',
        required => '0',
    },
    'narrow' => {
        data_type => 'ARRAY[ARRAY[string]]',
        description => 'A JSON-encoded array of arrays of length 2 indicating the narrow for which you&#39;d like to receive events for. For instance, to receive events for the stream &#x60;Denmark&#x60;, you would specify &#x60;narrow&#x3D;[[&#39;stream&#39;, &#39;Denmark&#39;]]&#x60;.  Another example is &#x60;narrow&#x3D;[[&#39;is&#39;, &#39;private&#39;]]&#x60; for private messages. Default is &#x60;[]&#x60;. ',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'register_queue' } = { 
        summary => 'Register an event queue',
        params => $params,
        returns => 'JsonSuccessBase',
        };
}
# @return JsonSuccessBase
#
sub register_queue {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/register';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'apply_markdown'}) {
        $query_params->{'apply_markdown'} = $self->{api_client}->to_query_value($args{'apply_markdown'});
    }

    # query params
    if ( exists $args{'client_gravatar'}) {
        $query_params->{'client_gravatar'} = $self->{api_client}->to_query_value($args{'client_gravatar'});
    }

    # query params
    if ( exists $args{'slim_presence'}) {
        $query_params->{'slim_presence'} = $self->{api_client}->to_query_value($args{'slim_presence'});
    }

    # query params
    if ( exists $args{'event_types'}) {
        $query_params->{'event_types'} = $self->{api_client}->to_query_value($args{'event_types'});
    }

    # query params
    if ( exists $args{'all_public_streams'}) {
        $query_params->{'all_public_streams'} = $self->{api_client}->to_query_value($args{'all_public_streams'});
    }

    # query params
    if ( exists $args{'include_subscribers'}) {
        $query_params->{'include_subscribers'} = $self->{api_client}->to_query_value($args{'include_subscribers'});
    }

    # query params
    if ( exists $args{'client_capabilities'}) {
        $query_params->{'client_capabilities'} = $self->{api_client}->to_query_value($args{'client_capabilities'});
    }

    # query params
    if ( exists $args{'fetch_event_types'}) {
        $query_params->{'fetch_event_types'} = $self->{api_client}->to_query_value($args{'fetch_event_types'});
    }

    # query params
    if ( exists $args{'narrow'}) {
        $query_params->{'narrow'} = $self->{api_client}->to_query_value($args{'narrow'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('JsonSuccessBase', $response);
    return $_response_object;
}

#
# rest_error_handling
#
# Error handling
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'rest_error_handling' } = { 
        summary => 'Error handling',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub rest_error_handling {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/rest-error-handling';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

1;
