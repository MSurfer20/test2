{-
   Zulip REST API

   Powerful open source group chat 

   OpenAPI Version: 3.0.1
   Zulip REST API API version: 1.0.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : ZulipREST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module ZulipREST.Model where

import ZulipREST.Core
import ZulipREST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Add
newtype Add = Add { unAdd :: [A.Value] } deriving (P.Eq, P.Show)

-- ** AddInt
newtype AddInt = AddInt { unAddInt :: [Int] } deriving (P.Eq, P.Show)

-- ** AllPublicStreams
newtype AllPublicStreams = AllPublicStreams { unAllPublicStreams :: Bool } deriving (P.Eq, P.Show)

-- ** Anchor
newtype Anchor = Anchor { unAnchor :: OneOfstringinteger } deriving (P.Eq, P.Show)

-- ** Announce
newtype Announce = Announce { unAnnounce :: Bool } deriving (P.Eq, P.Show)

-- ** ApplyMarkdown
newtype ApplyMarkdown = ApplyMarkdown { unApplyMarkdown :: Bool } deriving (P.Eq, P.Show)

-- ** AuthorizationErrorsFatal
newtype AuthorizationErrorsFatal = AuthorizationErrorsFatal { unAuthorizationErrorsFatal :: Bool } deriving (P.Eq, P.Show)

-- ** ClientCapabilities
newtype ClientCapabilities = ClientCapabilities { unClientCapabilities :: A.Value } deriving (P.Eq, P.Show)

-- ** ClientGravatar
newtype ClientGravatar = ClientGravatar { unClientGravatar :: Bool } deriving (P.Eq, P.Show)

-- ** ColorScheme
newtype ColorScheme = ColorScheme { unColorScheme :: E'DesktopIconCountDisplay } deriving (P.Eq, P.Show)

-- ** Content
newtype Content = Content { unContent :: Text } deriving (P.Eq, P.Show)

-- ** DefaultLanguage
newtype DefaultLanguage = DefaultLanguage { unDefaultLanguage :: Text } deriving (P.Eq, P.Show)

-- ** DefaultView
newtype DefaultView = DefaultView { unDefaultView :: Text } deriving (P.Eq, P.Show)

-- ** Delete
newtype Delete = Delete { unDelete :: [Text] } deriving (P.Eq, P.Show)

-- ** DeleteInt
newtype DeleteInt = DeleteInt { unDeleteInt :: [Int] } deriving (P.Eq, P.Show)

-- ** DemoteInactiveStreams
newtype DemoteInactiveStreams = DemoteInactiveStreams { unDemoteInactiveStreams :: E'DesktopIconCountDisplay } deriving (P.Eq, P.Show)

-- ** DenseMode
newtype DenseMode = DenseMode { unDenseMode :: Bool } deriving (P.Eq, P.Show)

-- ** Description
newtype Description = Description { unDescription :: Text } deriving (P.Eq, P.Show)

-- ** DesktopIconCountDisplay
newtype DesktopIconCountDisplay = DesktopIconCountDisplay { unDesktopIconCountDisplay :: E'DesktopIconCountDisplay } deriving (P.Eq, P.Show)

-- ** DontBlock
newtype DontBlock = DontBlock { unDontBlock :: Bool } deriving (P.Eq, P.Show)

-- ** Email
newtype Email = Email { unEmail :: Text } deriving (P.Eq, P.Show)

-- ** EmojiCode
newtype EmojiCode = EmojiCode { unEmojiCode :: Text } deriving (P.Eq, P.Show)

-- ** EmojiName
newtype EmojiName = EmojiName { unEmojiName :: Text } deriving (P.Eq, P.Show)

-- ** Emojiset
newtype Emojiset = Emojiset { unEmojiset :: Text } deriving (P.Eq, P.Show)

-- ** EnableDesktopNotifications
newtype EnableDesktopNotifications = EnableDesktopNotifications { unEnableDesktopNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** EnableDigestEmails
newtype EnableDigestEmails = EnableDigestEmails { unEnableDigestEmails :: Bool } deriving (P.Eq, P.Show)

-- ** EnableLoginEmails
newtype EnableLoginEmails = EnableLoginEmails { unEnableLoginEmails :: Bool } deriving (P.Eq, P.Show)

-- ** EnableMarketingEmails
newtype EnableMarketingEmails = EnableMarketingEmails { unEnableMarketingEmails :: Bool } deriving (P.Eq, P.Show)

-- ** EnableOfflineEmailNotifications
newtype EnableOfflineEmailNotifications = EnableOfflineEmailNotifications { unEnableOfflineEmailNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** EnableOfflinePushNotifications
newtype EnableOfflinePushNotifications = EnableOfflinePushNotifications { unEnableOfflinePushNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** EnableOnlinePushNotifications
newtype EnableOnlinePushNotifications = EnableOnlinePushNotifications { unEnableOnlinePushNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** EnableSounds
newtype EnableSounds = EnableSounds { unEnableSounds :: Bool } deriving (P.Eq, P.Show)

-- ** EnableStreamAudibleNotifications
newtype EnableStreamAudibleNotifications = EnableStreamAudibleNotifications { unEnableStreamAudibleNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** EnableStreamDesktopNotifications
newtype EnableStreamDesktopNotifications = EnableStreamDesktopNotifications { unEnableStreamDesktopNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** EnableStreamEmailNotifications
newtype EnableStreamEmailNotifications = EnableStreamEmailNotifications { unEnableStreamEmailNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** EnableStreamPushNotifications
newtype EnableStreamPushNotifications = EnableStreamPushNotifications { unEnableStreamPushNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** EventTypes
newtype EventTypes = EventTypes { unEventTypes :: [Text] } deriving (P.Eq, P.Show)

-- ** FetchEventTypes
newtype FetchEventTypes = FetchEventTypes { unFetchEventTypes :: [Text] } deriving (P.Eq, P.Show)

-- ** FieldData
newtype FieldData = FieldData { unFieldData :: A.Value } deriving (P.Eq, P.Show)

-- ** FieldType
newtype FieldType = FieldType { unFieldType :: Int } deriving (P.Eq, P.Show)

-- ** Filename
newtype Filename = Filename { unFilename :: FilePath } deriving (P.Eq, P.Show)

-- ** FilenameText
newtype FilenameText = FilenameText { unFilenameText :: Text } deriving (P.Eq, P.Show)

-- ** FilterId
newtype FilterId = FilterId { unFilterId :: Int } deriving (P.Eq, P.Show)

-- ** Flag
newtype Flag = Flag { unFlag :: Text } deriving (P.Eq, P.Show)

-- ** FluidLayoutWidth
newtype FluidLayoutWidth = FluidLayoutWidth { unFluidLayoutWidth :: Bool } deriving (P.Eq, P.Show)

-- ** FullName
newtype FullName = FullName { unFullName :: Text } deriving (P.Eq, P.Show)

-- ** HighContrastMode
newtype HighContrastMode = HighContrastMode { unHighContrastMode :: Bool } deriving (P.Eq, P.Show)

-- ** Hint
newtype Hint = Hint { unHint :: Text } deriving (P.Eq, P.Show)

-- ** HistoryPublicToSubscribers
newtype HistoryPublicToSubscribers = HistoryPublicToSubscribers { unHistoryPublicToSubscribers :: Bool } deriving (P.Eq, P.Show)

-- ** IncludeAllActive
newtype IncludeAllActive = IncludeAllActive { unIncludeAllActive :: Bool } deriving (P.Eq, P.Show)

-- ** IncludeCustomProfileFields
newtype IncludeCustomProfileFields = IncludeCustomProfileFields { unIncludeCustomProfileFields :: Bool } deriving (P.Eq, P.Show)

-- ** IncludeDefault
newtype IncludeDefault = IncludeDefault { unIncludeDefault :: Bool } deriving (P.Eq, P.Show)

-- ** IncludeOwnerSubscribed
newtype IncludeOwnerSubscribed = IncludeOwnerSubscribed { unIncludeOwnerSubscribed :: Bool } deriving (P.Eq, P.Show)

-- ** IncludePublic
newtype IncludePublic = IncludePublic { unIncludePublic :: Bool } deriving (P.Eq, P.Show)

-- ** IncludeSubscribed
newtype IncludeSubscribed = IncludeSubscribed { unIncludeSubscribed :: Bool } deriving (P.Eq, P.Show)

-- ** IncludeSubscribers
newtype IncludeSubscribers = IncludeSubscribers { unIncludeSubscribers :: Bool } deriving (P.Eq, P.Show)

-- ** IncludeWebPublic
newtype IncludeWebPublic = IncludeWebPublic { unIncludeWebPublic :: Bool } deriving (P.Eq, P.Show)

-- ** InviteOnly
newtype InviteOnly = InviteOnly { unInviteOnly :: Bool } deriving (P.Eq, P.Show)

-- ** IsAnnouncementOnly
newtype IsAnnouncementOnly = IsAnnouncementOnly { unIsAnnouncementOnly :: Bool } deriving (P.Eq, P.Show)

-- ** IsPrivate
newtype IsPrivate = IsPrivate { unIsPrivate :: Bool } deriving (P.Eq, P.Show)

-- ** LastEventId
newtype LastEventId = LastEventId { unLastEventId :: Int } deriving (P.Eq, P.Show)

-- ** LeftSideUserlist
newtype LeftSideUserlist = LeftSideUserlist { unLeftSideUserlist :: Bool } deriving (P.Eq, P.Show)

-- ** LocalId
newtype LocalId = LocalId { unLocalId :: Text } deriving (P.Eq, P.Show)

-- ** Members
newtype Members = Members { unMembers :: [Int] } deriving (P.Eq, P.Show)

-- ** MessageContentInEmailNotifications
newtype MessageContentInEmailNotifications = MessageContentInEmailNotifications { unMessageContentInEmailNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** MessageId
newtype MessageId = MessageId { unMessageId :: Int } deriving (P.Eq, P.Show)

-- ** MessageRetentionDays
newtype MessageRetentionDays = MessageRetentionDays { unMessageRetentionDays :: OneOfstringinteger } deriving (P.Eq, P.Show)

-- ** Messages2
newtype Messages2 = Messages2 { unMessages2 :: [Int] } deriving (P.Eq, P.Show)

-- ** MsgIds
newtype MsgIds = MsgIds { unMsgIds :: [Int] } deriving (P.Eq, P.Show)

-- ** MutedUserId
newtype MutedUserId = MutedUserId { unMutedUserId :: Int } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Narrow
newtype Narrow = Narrow { unNarrow :: [A.Value] } deriving (P.Eq, P.Show)

-- ** NarrowText
newtype NarrowText = NarrowText { unNarrowText :: [[Text]] } deriving (P.Eq, P.Show)

-- ** NewName
newtype NewName = NewName { unNewName :: Text } deriving (P.Eq, P.Show)

-- ** NotificationSound
newtype NotificationSound = NotificationSound { unNotificationSound :: Text } deriving (P.Eq, P.Show)

-- ** NumAfter
newtype NumAfter = NumAfter { unNumAfter :: Int } deriving (P.Eq, P.Show)

-- ** NumBefore
newtype NumBefore = NumBefore { unNumBefore :: Int } deriving (P.Eq, P.Show)

-- ** Op
newtype Op = Op { unOp :: E'Op } deriving (P.Eq, P.Show)

-- ** Op2
newtype Op2 = Op2 { unOp2 :: E'Op2 } deriving (P.Eq, P.Show)

-- ** Order
newtype Order = Order { unOrder :: [Int] } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: E'Type } deriving (P.Eq, P.Show)

-- ** Password
newtype Password = Password { unPassword :: Text } deriving (P.Eq, P.Show)

-- ** Pattern
newtype Pattern = Pattern { unPattern :: Text } deriving (P.Eq, P.Show)

-- ** PlaygroundId
newtype PlaygroundId = PlaygroundId { unPlaygroundId :: Int } deriving (P.Eq, P.Show)

-- ** PmContentInDesktopNotifications
newtype PmContentInDesktopNotifications = PmContentInDesktopNotifications { unPmContentInDesktopNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** PresenceEnabled
newtype PresenceEnabled = PresenceEnabled { unPresenceEnabled :: Bool } deriving (P.Eq, P.Show)

-- ** Principals
newtype Principals = Principals { unPrincipals :: [OneOfstringinteger] } deriving (P.Eq, P.Show)

-- ** ProfileData
newtype ProfileData = ProfileData { unProfileData :: [A.Value] } deriving (P.Eq, P.Show)

-- ** PropagateMode
newtype PropagateMode = PropagateMode { unPropagateMode :: E'PropagateMode } deriving (P.Eq, P.Show)

-- ** PygmentsLanguage
newtype PygmentsLanguage = PygmentsLanguage { unPygmentsLanguage :: Text } deriving (P.Eq, P.Show)

-- ** QueueId
newtype QueueId = QueueId { unQueueId :: Text } deriving (P.Eq, P.Show)

-- ** ReactionType
newtype ReactionType = ReactionType { unReactionType :: Text } deriving (P.Eq, P.Show)

-- ** RealmIdStr
newtype RealmIdStr = RealmIdStr { unRealmIdStr :: Int } deriving (P.Eq, P.Show)

-- ** RealmNameInNotifications
newtype RealmNameInNotifications = RealmNameInNotifications { unRealmNameInNotifications :: Bool } deriving (P.Eq, P.Show)

-- ** Role
newtype Role = Role { unRole :: Int } deriving (P.Eq, P.Show)

-- ** SendNotificationToNewThread
newtype SendNotificationToNewThread = SendNotificationToNewThread { unSendNotificationToNewThread :: Bool } deriving (P.Eq, P.Show)

-- ** SendNotificationToOldThread
newtype SendNotificationToOldThread = SendNotificationToOldThread { unSendNotificationToOldThread :: Bool } deriving (P.Eq, P.Show)

-- ** SlimPresence
newtype SlimPresence = SlimPresence { unSlimPresence :: Bool } deriving (P.Eq, P.Show)

-- ** StarredMessageCounts
newtype StarredMessageCounts = StarredMessageCounts { unStarredMessageCounts :: Bool } deriving (P.Eq, P.Show)

-- ** Stream
newtype Stream = Stream { unStream :: Text } deriving (P.Eq, P.Show)

-- ** StreamId
newtype StreamId = StreamId { unStreamId :: Int } deriving (P.Eq, P.Show)

-- ** StreamPostPolicy
newtype StreamPostPolicy = StreamPostPolicy { unStreamPostPolicy :: Int } deriving (P.Eq, P.Show)

-- ** SubscriptionData
newtype SubscriptionData = SubscriptionData { unSubscriptionData :: [A.Value] } deriving (P.Eq, P.Show)

-- ** Subscriptions2
newtype Subscriptions2 = Subscriptions2 { unSubscriptions2 :: [A.Value] } deriving (P.Eq, P.Show)

-- ** Subscriptions3
newtype Subscriptions3 = Subscriptions3 { unSubscriptions3 :: [Text] } deriving (P.Eq, P.Show)

-- ** Timezone
newtype Timezone = Timezone { unTimezone :: Text } deriving (P.Eq, P.Show)

-- ** To
newtype To = To { unTo :: [Int] } deriving (P.Eq, P.Show)

-- ** Topic
newtype Topic = Topic { unTopic :: Text } deriving (P.Eq, P.Show)

-- ** TopicName
newtype TopicName = TopicName { unTopicName :: Text } deriving (P.Eq, P.Show)

-- ** TranslateEmoticons
newtype TranslateEmoticons = TranslateEmoticons { unTranslateEmoticons :: Bool } deriving (P.Eq, P.Show)

-- ** TwentyFourHourTime
newtype TwentyFourHourTime = TwentyFourHourTime { unTwentyFourHourTime :: Bool } deriving (P.Eq, P.Show)

-- ** UrlFormatString
newtype UrlFormatString = UrlFormatString { unUrlFormatString :: Text } deriving (P.Eq, P.Show)

-- ** UrlPrefix
newtype UrlPrefix = UrlPrefix { unUrlPrefix :: Text } deriving (P.Eq, P.Show)

-- ** UseFirstUnreadAnchor
newtype UseFirstUnreadAnchor = UseFirstUnreadAnchor { unUseFirstUnreadAnchor :: Bool } deriving (P.Eq, P.Show)

-- ** UserGroupId
newtype UserGroupId = UserGroupId { unUserGroupId :: Int } deriving (P.Eq, P.Show)

-- ** UserId
newtype UserId = UserId { unUserId :: Int } deriving (P.Eq, P.Show)

-- ** UserIdOrEmail
newtype UserIdOrEmail = UserIdOrEmail { unUserIdOrEmail :: Text } deriving (P.Eq, P.Show)

-- ** Username
newtype Username = Username { unUsername :: Text } deriving (P.Eq, P.Show)

-- ** WildcardMentionsNotify
newtype WildcardMentionsNotify = WildcardMentionsNotify { unWildcardMentionsNotify :: Bool } deriving (P.Eq, P.Show)

-- * Models


-- ** AddSubscriptionsResponse
-- | AddSubscriptionsResponse
data AddSubscriptionsResponse = AddSubscriptionsResponse
  { addSubscriptionsResponseResult :: !(AnyType) -- ^ /Required/ "result"
  , addSubscriptionsResponseMsg :: !(AnyType) -- ^ /Required/ "msg"
  , addSubscriptionsResponseSubscribed :: !(Maybe (Map.Map String [Text])) -- ^ "subscribed" - A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that were subscribed to as a result of the query. 
  , addSubscriptionsResponseAlreadySubscribed :: !(Maybe (Map.Map String [Text])) -- ^ "already_subscribed" - A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that the user/bot is already subscribed to. 
  , addSubscriptionsResponseUnauthorized :: !(Maybe [Text]) -- ^ "unauthorized" - A list of names of streams that the requesting user/bot was not authorized to subscribe to.  Only present if &#x60;authorization_errors_fatal&#x3D;false&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddSubscriptionsResponse
instance A.FromJSON AddSubscriptionsResponse where
  parseJSON = A.withObject "AddSubscriptionsResponse" $ \o ->
    AddSubscriptionsResponse
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "subscribed")
      <*> (o .:? "already_subscribed")
      <*> (o .:? "unauthorized")

-- | ToJSON AddSubscriptionsResponse
instance A.ToJSON AddSubscriptionsResponse where
  toJSON AddSubscriptionsResponse {..} =
   _omitNulls
      [ "result" .= addSubscriptionsResponseResult
      , "msg" .= addSubscriptionsResponseMsg
      , "subscribed" .= addSubscriptionsResponseSubscribed
      , "already_subscribed" .= addSubscriptionsResponseAlreadySubscribed
      , "unauthorized" .= addSubscriptionsResponseUnauthorized
      ]


-- | Construct a value of type 'AddSubscriptionsResponse' (by applying it's required fields, if any)
mkAddSubscriptionsResponse
  :: AnyType -- ^ 'addSubscriptionsResponseResult' 
  -> AnyType -- ^ 'addSubscriptionsResponseMsg' 
  -> AddSubscriptionsResponse
mkAddSubscriptionsResponse addSubscriptionsResponseResult addSubscriptionsResponseMsg =
  AddSubscriptionsResponse
  { addSubscriptionsResponseResult
  , addSubscriptionsResponseMsg
  , addSubscriptionsResponseSubscribed = Nothing
  , addSubscriptionsResponseAlreadySubscribed = Nothing
  , addSubscriptionsResponseUnauthorized = Nothing
  }

-- ** AddSubscriptionsResponseAllOf
-- | AddSubscriptionsResponseAllOf
data AddSubscriptionsResponseAllOf = AddSubscriptionsResponseAllOf
  { addSubscriptionsResponseAllOfResult :: !(Maybe AnyType) -- ^ "result"
  , addSubscriptionsResponseAllOfMsg :: !(Maybe AnyType) -- ^ "msg"
  , addSubscriptionsResponseAllOfSubscribed :: !(Maybe (Map.Map String [Text])) -- ^ "subscribed" - A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that were subscribed to as a result of the query. 
  , addSubscriptionsResponseAllOfAlreadySubscribed :: !(Maybe (Map.Map String [Text])) -- ^ "already_subscribed" - A dictionary where the key is the email address of the user/bot and the value is a list of the names of the streams that the user/bot is already subscribed to. 
  , addSubscriptionsResponseAllOfUnauthorized :: !(Maybe [Text]) -- ^ "unauthorized" - A list of names of streams that the requesting user/bot was not authorized to subscribe to.  Only present if &#x60;authorization_errors_fatal&#x3D;false&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddSubscriptionsResponseAllOf
instance A.FromJSON AddSubscriptionsResponseAllOf where
  parseJSON = A.withObject "AddSubscriptionsResponseAllOf" $ \o ->
    AddSubscriptionsResponseAllOf
      <$> (o .:? "result")
      <*> (o .:? "msg")
      <*> (o .:? "subscribed")
      <*> (o .:? "already_subscribed")
      <*> (o .:? "unauthorized")

-- | ToJSON AddSubscriptionsResponseAllOf
instance A.ToJSON AddSubscriptionsResponseAllOf where
  toJSON AddSubscriptionsResponseAllOf {..} =
   _omitNulls
      [ "result" .= addSubscriptionsResponseAllOfResult
      , "msg" .= addSubscriptionsResponseAllOfMsg
      , "subscribed" .= addSubscriptionsResponseAllOfSubscribed
      , "already_subscribed" .= addSubscriptionsResponseAllOfAlreadySubscribed
      , "unauthorized" .= addSubscriptionsResponseAllOfUnauthorized
      ]


-- | Construct a value of type 'AddSubscriptionsResponseAllOf' (by applying it's required fields, if any)
mkAddSubscriptionsResponseAllOf
  :: AddSubscriptionsResponseAllOf
mkAddSubscriptionsResponseAllOf =
  AddSubscriptionsResponseAllOf
  { addSubscriptionsResponseAllOfResult = Nothing
  , addSubscriptionsResponseAllOfMsg = Nothing
  , addSubscriptionsResponseAllOfSubscribed = Nothing
  , addSubscriptionsResponseAllOfAlreadySubscribed = Nothing
  , addSubscriptionsResponseAllOfUnauthorized = Nothing
  }

-- ** ApiKeyResponse
-- | ApiKeyResponse
data ApiKeyResponse = ApiKeyResponse
  { apiKeyResponseResult :: !(AnyType) -- ^ /Required/ "result"
  , apiKeyResponseMsg :: !(AnyType) -- ^ /Required/ "msg"
  , apiKeyResponseApiKey :: !(Text) -- ^ /Required/ "api_key" - The API key that can be used to authenticate as the requested user. 
  , apiKeyResponseEmail :: !(Text) -- ^ /Required/ "email" - The email address of the user who owns the API key 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiKeyResponse
instance A.FromJSON ApiKeyResponse where
  parseJSON = A.withObject "ApiKeyResponse" $ \o ->
    ApiKeyResponse
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:  "api_key")
      <*> (o .:  "email")

-- | ToJSON ApiKeyResponse
instance A.ToJSON ApiKeyResponse where
  toJSON ApiKeyResponse {..} =
   _omitNulls
      [ "result" .= apiKeyResponseResult
      , "msg" .= apiKeyResponseMsg
      , "api_key" .= apiKeyResponseApiKey
      , "email" .= apiKeyResponseEmail
      ]


-- | Construct a value of type 'ApiKeyResponse' (by applying it's required fields, if any)
mkApiKeyResponse
  :: AnyType -- ^ 'apiKeyResponseResult' 
  -> AnyType -- ^ 'apiKeyResponseMsg' 
  -> Text -- ^ 'apiKeyResponseApiKey': The API key that can be used to authenticate as the requested user. 
  -> Text -- ^ 'apiKeyResponseEmail': The email address of the user who owns the API key 
  -> ApiKeyResponse
mkApiKeyResponse apiKeyResponseResult apiKeyResponseMsg apiKeyResponseApiKey apiKeyResponseEmail =
  ApiKeyResponse
  { apiKeyResponseResult
  , apiKeyResponseMsg
  , apiKeyResponseApiKey
  , apiKeyResponseEmail
  }

-- ** ApiKeyResponseAllOf
-- | ApiKeyResponseAllOf
data ApiKeyResponseAllOf = ApiKeyResponseAllOf
  { apiKeyResponseAllOfResult :: !(Maybe AnyType) -- ^ "result"
  , apiKeyResponseAllOfMsg :: !(Maybe AnyType) -- ^ "msg"
  , apiKeyResponseAllOfApiKey :: !(Text) -- ^ /Required/ "api_key" - The API key that can be used to authenticate as the requested user. 
  , apiKeyResponseAllOfEmail :: !(Text) -- ^ /Required/ "email" - The email address of the user who owns the API key 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApiKeyResponseAllOf
instance A.FromJSON ApiKeyResponseAllOf where
  parseJSON = A.withObject "ApiKeyResponseAllOf" $ \o ->
    ApiKeyResponseAllOf
      <$> (o .:? "result")
      <*> (o .:? "msg")
      <*> (o .:  "api_key")
      <*> (o .:  "email")

-- | ToJSON ApiKeyResponseAllOf
instance A.ToJSON ApiKeyResponseAllOf where
  toJSON ApiKeyResponseAllOf {..} =
   _omitNulls
      [ "result" .= apiKeyResponseAllOfResult
      , "msg" .= apiKeyResponseAllOfMsg
      , "api_key" .= apiKeyResponseAllOfApiKey
      , "email" .= apiKeyResponseAllOfEmail
      ]


-- | Construct a value of type 'ApiKeyResponseAllOf' (by applying it's required fields, if any)
mkApiKeyResponseAllOf
  :: Text -- ^ 'apiKeyResponseAllOfApiKey': The API key that can be used to authenticate as the requested user. 
  -> Text -- ^ 'apiKeyResponseAllOfEmail': The email address of the user who owns the API key 
  -> ApiKeyResponseAllOf
mkApiKeyResponseAllOf apiKeyResponseAllOfApiKey apiKeyResponseAllOfEmail =
  ApiKeyResponseAllOf
  { apiKeyResponseAllOfResult = Nothing
  , apiKeyResponseAllOfMsg = Nothing
  , apiKeyResponseAllOfApiKey
  , apiKeyResponseAllOfEmail
  }

-- ** Attachments
-- | Attachments
-- Dictionary containing details of a file uploaded by a user. 
data Attachments = Attachments
  { attachmentsId :: !(Maybe Int) -- ^ "id" - The unique ID for the attachment. 
  , attachmentsName :: !(Maybe Text) -- ^ "name" - Name of the uploaded file. 
  , attachmentsPathId :: !(Maybe Text) -- ^ "path_id" - A representation of the path of the file within the repository of user-uploaded files.  If the &#x60;path_id&#x60; of a file is &#x60;{realm_id}/ab/cdef/temp_file.py&#x60;, its URL will be: &#x60;{server_url}/user_uploads/{realm_id}/ab/cdef/temp_file.py&#x60;. 
  , attachmentsSize :: !(Maybe Int) -- ^ "size" - Size of the file in bytes. 
  , attachmentsCreateTime :: !(Maybe Int) -- ^ "create_time" - Time when the attachment was uploaded as a UNIX timestamp multiplied by 1000 (matching the format of getTime() in JavaScript).  **Changes**: Changed in Zulip 2.2 (feature level 22).  This field was previously a floating point number. 
  , attachmentsMessages :: !(Maybe [AttachmentsMessages]) -- ^ "messages" - Contains basic details on any Zulip messages that have been sent referencing this [uploaded file](/api/upload-file). This includes messages sent by any user in the Zulip organization who sent a message containing a link to the uploaded file. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Attachments
instance A.FromJSON Attachments where
  parseJSON = A.withObject "Attachments" $ \o ->
    Attachments
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "path_id")
      <*> (o .:? "size")
      <*> (o .:? "create_time")
      <*> (o .:? "messages")

-- | ToJSON Attachments
instance A.ToJSON Attachments where
  toJSON Attachments {..} =
   _omitNulls
      [ "id" .= attachmentsId
      , "name" .= attachmentsName
      , "path_id" .= attachmentsPathId
      , "size" .= attachmentsSize
      , "create_time" .= attachmentsCreateTime
      , "messages" .= attachmentsMessages
      ]


-- | Construct a value of type 'Attachments' (by applying it's required fields, if any)
mkAttachments
  :: Attachments
mkAttachments =
  Attachments
  { attachmentsId = Nothing
  , attachmentsName = Nothing
  , attachmentsPathId = Nothing
  , attachmentsSize = Nothing
  , attachmentsCreateTime = Nothing
  , attachmentsMessages = Nothing
  }

-- ** AttachmentsMessages
-- | AttachmentsMessages
data AttachmentsMessages = AttachmentsMessages
  { attachmentsMessagesDateSent :: !(Maybe Int) -- ^ "date_sent" - Time when the message was sent as a UNIX timestamp multiplied by 1000 (matching the format of getTime() in JavaScript).  **Changes**: Changed in Zulip 2.2 (feature level 22).  This field was previously strangely called &#x60;name&#x60; and was a floating point number. 
  , attachmentsMessagesId :: !(Maybe Int) -- ^ "id" - The unique message ID.  Messages should always be displayed sorted by ID. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AttachmentsMessages
instance A.FromJSON AttachmentsMessages where
  parseJSON = A.withObject "AttachmentsMessages" $ \o ->
    AttachmentsMessages
      <$> (o .:? "date_sent")
      <*> (o .:? "id")

-- | ToJSON AttachmentsMessages
instance A.ToJSON AttachmentsMessages where
  toJSON AttachmentsMessages {..} =
   _omitNulls
      [ "date_sent" .= attachmentsMessagesDateSent
      , "id" .= attachmentsMessagesId
      ]


-- | Construct a value of type 'AttachmentsMessages' (by applying it's required fields, if any)
mkAttachmentsMessages
  :: AttachmentsMessages
mkAttachmentsMessages =
  AttachmentsMessages
  { attachmentsMessagesDateSent = Nothing
  , attachmentsMessagesId = Nothing
  }

-- ** BadEventQueueIdError
-- | BadEventQueueIdError
data BadEventQueueIdError = BadEventQueueIdError
  { badEventQueueIdErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , badEventQueueIdErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  , badEventQueueIdErrorCode :: !(Maybe AnyType) -- ^ "code"
  , badEventQueueIdErrorQueueId :: !(Maybe Text) -- ^ "queue_id" - The string that identifies the invalid event queue. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BadEventQueueIdError
instance A.FromJSON BadEventQueueIdError where
  parseJSON = A.withObject "BadEventQueueIdError" $ \o ->
    BadEventQueueIdError
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "code")
      <*> (o .:? "queue_id")

-- | ToJSON BadEventQueueIdError
instance A.ToJSON BadEventQueueIdError where
  toJSON BadEventQueueIdError {..} =
   _omitNulls
      [ "result" .= badEventQueueIdErrorResult
      , "msg" .= badEventQueueIdErrorMsg
      , "code" .= badEventQueueIdErrorCode
      , "queue_id" .= badEventQueueIdErrorQueueId
      ]


-- | Construct a value of type 'BadEventQueueIdError' (by applying it's required fields, if any)
mkBadEventQueueIdError
  :: AnyType -- ^ 'badEventQueueIdErrorResult' 
  -> AnyType -- ^ 'badEventQueueIdErrorMsg' 
  -> BadEventQueueIdError
mkBadEventQueueIdError badEventQueueIdErrorResult badEventQueueIdErrorMsg =
  BadEventQueueIdError
  { badEventQueueIdErrorResult
  , badEventQueueIdErrorMsg
  , badEventQueueIdErrorCode = Nothing
  , badEventQueueIdErrorQueueId = Nothing
  }

-- ** BadEventQueueIdErrorAllOf
-- | BadEventQueueIdErrorAllOf
data BadEventQueueIdErrorAllOf = BadEventQueueIdErrorAllOf
  { badEventQueueIdErrorAllOfResult :: !(Maybe AnyType) -- ^ "result"
  , badEventQueueIdErrorAllOfMsg :: !(Maybe AnyType) -- ^ "msg"
  , badEventQueueIdErrorAllOfCode :: !(Maybe AnyType) -- ^ "code"
  , badEventQueueIdErrorAllOfQueueId :: !(Maybe Text) -- ^ "queue_id" - The string that identifies the invalid event queue. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BadEventQueueIdErrorAllOf
instance A.FromJSON BadEventQueueIdErrorAllOf where
  parseJSON = A.withObject "BadEventQueueIdErrorAllOf" $ \o ->
    BadEventQueueIdErrorAllOf
      <$> (o .:? "result")
      <*> (o .:? "msg")
      <*> (o .:? "code")
      <*> (o .:? "queue_id")

-- | ToJSON BadEventQueueIdErrorAllOf
instance A.ToJSON BadEventQueueIdErrorAllOf where
  toJSON BadEventQueueIdErrorAllOf {..} =
   _omitNulls
      [ "result" .= badEventQueueIdErrorAllOfResult
      , "msg" .= badEventQueueIdErrorAllOfMsg
      , "code" .= badEventQueueIdErrorAllOfCode
      , "queue_id" .= badEventQueueIdErrorAllOfQueueId
      ]


-- | Construct a value of type 'BadEventQueueIdErrorAllOf' (by applying it's required fields, if any)
mkBadEventQueueIdErrorAllOf
  :: BadEventQueueIdErrorAllOf
mkBadEventQueueIdErrorAllOf =
  BadEventQueueIdErrorAllOf
  { badEventQueueIdErrorAllOfResult = Nothing
  , badEventQueueIdErrorAllOfMsg = Nothing
  , badEventQueueIdErrorAllOfCode = Nothing
  , badEventQueueIdErrorAllOfQueueId = Nothing
  }

-- ** BasicBot
-- | BasicBot
data BasicBot = BasicBot
  { basicBotUserId :: !(Maybe AnyType) -- ^ "user_id"
  , basicBotFullName :: !(Maybe AnyType) -- ^ "full_name"
  , basicBotApiKey :: !(Maybe AnyType) -- ^ "api_key"
  , basicBotDefaultSendingStream :: !(Maybe AnyType) -- ^ "default_sending_stream"
  , basicBotDefaultEventsRegisterStream :: !(Maybe AnyType) -- ^ "default_events_register_stream"
  , basicBotDefaultAllPublicStreams :: !(Maybe AnyType) -- ^ "default_all_public_streams"
  , basicBotAvatarUrl :: !(Maybe AnyType) -- ^ "avatar_url"
  , basicBotOwnerId :: !(Maybe AnyType) -- ^ "owner_id"
  , basicBotServices :: !(Maybe AnyType) -- ^ "services"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicBot
instance A.FromJSON BasicBot where
  parseJSON = A.withObject "BasicBot" $ \o ->
    BasicBot
      <$> (o .:? "user_id")
      <*> (o .:? "full_name")
      <*> (o .:? "api_key")
      <*> (o .:? "default_sending_stream")
      <*> (o .:? "default_events_register_stream")
      <*> (o .:? "default_all_public_streams")
      <*> (o .:? "avatar_url")
      <*> (o .:? "owner_id")
      <*> (o .:? "services")

-- | ToJSON BasicBot
instance A.ToJSON BasicBot where
  toJSON BasicBot {..} =
   _omitNulls
      [ "user_id" .= basicBotUserId
      , "full_name" .= basicBotFullName
      , "api_key" .= basicBotApiKey
      , "default_sending_stream" .= basicBotDefaultSendingStream
      , "default_events_register_stream" .= basicBotDefaultEventsRegisterStream
      , "default_all_public_streams" .= basicBotDefaultAllPublicStreams
      , "avatar_url" .= basicBotAvatarUrl
      , "owner_id" .= basicBotOwnerId
      , "services" .= basicBotServices
      ]


-- | Construct a value of type 'BasicBot' (by applying it's required fields, if any)
mkBasicBot
  :: BasicBot
mkBasicBot =
  BasicBot
  { basicBotUserId = Nothing
  , basicBotFullName = Nothing
  , basicBotApiKey = Nothing
  , basicBotDefaultSendingStream = Nothing
  , basicBotDefaultEventsRegisterStream = Nothing
  , basicBotDefaultAllPublicStreams = Nothing
  , basicBotAvatarUrl = Nothing
  , basicBotOwnerId = Nothing
  , basicBotServices = Nothing
  }

-- ** BasicBotAllOf
-- | BasicBotAllOf
data BasicBotAllOf = BasicBotAllOf
  { basicBotAllOfUserId :: !(Maybe AnyType) -- ^ "user_id"
  , basicBotAllOfFullName :: !(Maybe AnyType) -- ^ "full_name"
  , basicBotAllOfApiKey :: !(Maybe AnyType) -- ^ "api_key"
  , basicBotAllOfDefaultSendingStream :: !(Maybe AnyType) -- ^ "default_sending_stream"
  , basicBotAllOfDefaultEventsRegisterStream :: !(Maybe AnyType) -- ^ "default_events_register_stream"
  , basicBotAllOfDefaultAllPublicStreams :: !(Maybe AnyType) -- ^ "default_all_public_streams"
  , basicBotAllOfAvatarUrl :: !(Maybe AnyType) -- ^ "avatar_url"
  , basicBotAllOfOwnerId :: !(Maybe AnyType) -- ^ "owner_id"
  , basicBotAllOfServices :: !(Maybe AnyType) -- ^ "services"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicBotAllOf
instance A.FromJSON BasicBotAllOf where
  parseJSON = A.withObject "BasicBotAllOf" $ \o ->
    BasicBotAllOf
      <$> (o .:? "user_id")
      <*> (o .:? "full_name")
      <*> (o .:? "api_key")
      <*> (o .:? "default_sending_stream")
      <*> (o .:? "default_events_register_stream")
      <*> (o .:? "default_all_public_streams")
      <*> (o .:? "avatar_url")
      <*> (o .:? "owner_id")
      <*> (o .:? "services")

-- | ToJSON BasicBotAllOf
instance A.ToJSON BasicBotAllOf where
  toJSON BasicBotAllOf {..} =
   _omitNulls
      [ "user_id" .= basicBotAllOfUserId
      , "full_name" .= basicBotAllOfFullName
      , "api_key" .= basicBotAllOfApiKey
      , "default_sending_stream" .= basicBotAllOfDefaultSendingStream
      , "default_events_register_stream" .= basicBotAllOfDefaultEventsRegisterStream
      , "default_all_public_streams" .= basicBotAllOfDefaultAllPublicStreams
      , "avatar_url" .= basicBotAllOfAvatarUrl
      , "owner_id" .= basicBotAllOfOwnerId
      , "services" .= basicBotAllOfServices
      ]


-- | Construct a value of type 'BasicBotAllOf' (by applying it's required fields, if any)
mkBasicBotAllOf
  :: BasicBotAllOf
mkBasicBotAllOf =
  BasicBotAllOf
  { basicBotAllOfUserId = Nothing
  , basicBotAllOfFullName = Nothing
  , basicBotAllOfApiKey = Nothing
  , basicBotAllOfDefaultSendingStream = Nothing
  , basicBotAllOfDefaultEventsRegisterStream = Nothing
  , basicBotAllOfDefaultAllPublicStreams = Nothing
  , basicBotAllOfAvatarUrl = Nothing
  , basicBotAllOfOwnerId = Nothing
  , basicBotAllOfServices = Nothing
  }

-- ** BasicBotBase
-- | BasicBotBase
data BasicBotBase = BasicBotBase
  { basicBotBaseUserId :: !(Maybe Int) -- ^ "user_id" - The user id of the bot. 
  , basicBotBaseFullName :: !(Maybe Text) -- ^ "full_name" - The full name of the bot. 
  , basicBotBaseApiKey :: !(Maybe Text) -- ^ "api_key" - The API key of the bot which it uses to make API requests. 
  , basicBotBaseDefaultSendingStream :: !(Maybe Text) -- ^ "default_sending_stream" - The default sending stream of the bot. Null if the bot doesn&#39;t have a default sending stream. 
  , basicBotBaseDefaultEventsRegisterStream :: !(Maybe Text) -- ^ "default_events_register_stream" - The default stream for which the bot receives events/register data. Null if the bot doesn&#39;t have such a default stream. 
  , basicBotBaseDefaultAllPublicStreams :: !(Maybe Bool) -- ^ "default_all_public_streams" - Whether the bot can send messages to all streams by default. 
  , basicBotBaseAvatarUrl :: !(Maybe Text) -- ^ "avatar_url" - The URL of the bot&#39;s avatar. 
  , basicBotBaseOwnerId :: !(Maybe Int) -- ^ "owner_id" - The user id of the bot&#39;s owner.  Null if the bot has no owner. 
  , basicBotBaseServices :: !(Maybe [OneOfobjectobject]) -- ^ "services" - The \&quot;Services\&quot; array contains extra configuration fields only relevant for Outgoing webhook bots and Embedded bots.  It is always a single-element array.  We consider this part of the Zulip API to be unstable; it is used only for UI elements for administering bots and is likely to change. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicBotBase
instance A.FromJSON BasicBotBase where
  parseJSON = A.withObject "BasicBotBase" $ \o ->
    BasicBotBase
      <$> (o .:? "user_id")
      <*> (o .:? "full_name")
      <*> (o .:? "api_key")
      <*> (o .:? "default_sending_stream")
      <*> (o .:? "default_events_register_stream")
      <*> (o .:? "default_all_public_streams")
      <*> (o .:? "avatar_url")
      <*> (o .:? "owner_id")
      <*> (o .:? "services")

-- | ToJSON BasicBotBase
instance A.ToJSON BasicBotBase where
  toJSON BasicBotBase {..} =
   _omitNulls
      [ "user_id" .= basicBotBaseUserId
      , "full_name" .= basicBotBaseFullName
      , "api_key" .= basicBotBaseApiKey
      , "default_sending_stream" .= basicBotBaseDefaultSendingStream
      , "default_events_register_stream" .= basicBotBaseDefaultEventsRegisterStream
      , "default_all_public_streams" .= basicBotBaseDefaultAllPublicStreams
      , "avatar_url" .= basicBotBaseAvatarUrl
      , "owner_id" .= basicBotBaseOwnerId
      , "services" .= basicBotBaseServices
      ]


-- | Construct a value of type 'BasicBotBase' (by applying it's required fields, if any)
mkBasicBotBase
  :: BasicBotBase
mkBasicBotBase =
  BasicBotBase
  { basicBotBaseUserId = Nothing
  , basicBotBaseFullName = Nothing
  , basicBotBaseApiKey = Nothing
  , basicBotBaseDefaultSendingStream = Nothing
  , basicBotBaseDefaultEventsRegisterStream = Nothing
  , basicBotBaseDefaultAllPublicStreams = Nothing
  , basicBotBaseAvatarUrl = Nothing
  , basicBotBaseOwnerId = Nothing
  , basicBotBaseServices = Nothing
  }

-- ** BasicStream
-- | BasicStream
data BasicStream = BasicStream
  { basicStreamStreamId :: !(Maybe AnyType) -- ^ "stream_id"
  , basicStreamName :: !(Maybe AnyType) -- ^ "name"
  , basicStreamDescription :: !(Maybe AnyType) -- ^ "description"
  , basicStreamDateCreated :: !(Maybe AnyType) -- ^ "date_created"
  , basicStreamInviteOnly :: !(Maybe AnyType) -- ^ "invite_only"
  , basicStreamRenderedDescription :: !(Maybe AnyType) -- ^ "rendered_description"
  , basicStreamIsWebPublic :: !(Maybe AnyType) -- ^ "is_web_public"
  , basicStreamStreamPostPolicy :: !(Maybe AnyType) -- ^ "stream_post_policy"
  , basicStreamMessageRetentionDays :: !(Maybe AnyType) -- ^ "message_retention_days"
  , basicStreamHistoryPublicToSubscribers :: !(Maybe AnyType) -- ^ "history_public_to_subscribers"
  , basicStreamFirstMessageId :: !(Maybe AnyType) -- ^ "first_message_id"
  , basicStreamIsAnnouncementOnly :: !(Maybe AnyType) -- ^ "is_announcement_only"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicStream
instance A.FromJSON BasicStream where
  parseJSON = A.withObject "BasicStream" $ \o ->
    BasicStream
      <$> (o .:? "stream_id")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "date_created")
      <*> (o .:? "invite_only")
      <*> (o .:? "rendered_description")
      <*> (o .:? "is_web_public")
      <*> (o .:? "stream_post_policy")
      <*> (o .:? "message_retention_days")
      <*> (o .:? "history_public_to_subscribers")
      <*> (o .:? "first_message_id")
      <*> (o .:? "is_announcement_only")

-- | ToJSON BasicStream
instance A.ToJSON BasicStream where
  toJSON BasicStream {..} =
   _omitNulls
      [ "stream_id" .= basicStreamStreamId
      , "name" .= basicStreamName
      , "description" .= basicStreamDescription
      , "date_created" .= basicStreamDateCreated
      , "invite_only" .= basicStreamInviteOnly
      , "rendered_description" .= basicStreamRenderedDescription
      , "is_web_public" .= basicStreamIsWebPublic
      , "stream_post_policy" .= basicStreamStreamPostPolicy
      , "message_retention_days" .= basicStreamMessageRetentionDays
      , "history_public_to_subscribers" .= basicStreamHistoryPublicToSubscribers
      , "first_message_id" .= basicStreamFirstMessageId
      , "is_announcement_only" .= basicStreamIsAnnouncementOnly
      ]


-- | Construct a value of type 'BasicStream' (by applying it's required fields, if any)
mkBasicStream
  :: BasicStream
mkBasicStream =
  BasicStream
  { basicStreamStreamId = Nothing
  , basicStreamName = Nothing
  , basicStreamDescription = Nothing
  , basicStreamDateCreated = Nothing
  , basicStreamInviteOnly = Nothing
  , basicStreamRenderedDescription = Nothing
  , basicStreamIsWebPublic = Nothing
  , basicStreamStreamPostPolicy = Nothing
  , basicStreamMessageRetentionDays = Nothing
  , basicStreamHistoryPublicToSubscribers = Nothing
  , basicStreamFirstMessageId = Nothing
  , basicStreamIsAnnouncementOnly = Nothing
  }

-- ** BasicStreamAllOf
-- | BasicStreamAllOf
data BasicStreamAllOf = BasicStreamAllOf
  { basicStreamAllOfStreamId :: !(Maybe AnyType) -- ^ "stream_id"
  , basicStreamAllOfName :: !(Maybe AnyType) -- ^ "name"
  , basicStreamAllOfDescription :: !(Maybe AnyType) -- ^ "description"
  , basicStreamAllOfDateCreated :: !(Maybe AnyType) -- ^ "date_created"
  , basicStreamAllOfInviteOnly :: !(Maybe AnyType) -- ^ "invite_only"
  , basicStreamAllOfRenderedDescription :: !(Maybe AnyType) -- ^ "rendered_description"
  , basicStreamAllOfIsWebPublic :: !(Maybe AnyType) -- ^ "is_web_public"
  , basicStreamAllOfStreamPostPolicy :: !(Maybe AnyType) -- ^ "stream_post_policy"
  , basicStreamAllOfMessageRetentionDays :: !(Maybe AnyType) -- ^ "message_retention_days"
  , basicStreamAllOfHistoryPublicToSubscribers :: !(Maybe AnyType) -- ^ "history_public_to_subscribers"
  , basicStreamAllOfFirstMessageId :: !(Maybe AnyType) -- ^ "first_message_id"
  , basicStreamAllOfIsAnnouncementOnly :: !(Maybe AnyType) -- ^ "is_announcement_only"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicStreamAllOf
instance A.FromJSON BasicStreamAllOf where
  parseJSON = A.withObject "BasicStreamAllOf" $ \o ->
    BasicStreamAllOf
      <$> (o .:? "stream_id")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "date_created")
      <*> (o .:? "invite_only")
      <*> (o .:? "rendered_description")
      <*> (o .:? "is_web_public")
      <*> (o .:? "stream_post_policy")
      <*> (o .:? "message_retention_days")
      <*> (o .:? "history_public_to_subscribers")
      <*> (o .:? "first_message_id")
      <*> (o .:? "is_announcement_only")

-- | ToJSON BasicStreamAllOf
instance A.ToJSON BasicStreamAllOf where
  toJSON BasicStreamAllOf {..} =
   _omitNulls
      [ "stream_id" .= basicStreamAllOfStreamId
      , "name" .= basicStreamAllOfName
      , "description" .= basicStreamAllOfDescription
      , "date_created" .= basicStreamAllOfDateCreated
      , "invite_only" .= basicStreamAllOfInviteOnly
      , "rendered_description" .= basicStreamAllOfRenderedDescription
      , "is_web_public" .= basicStreamAllOfIsWebPublic
      , "stream_post_policy" .= basicStreamAllOfStreamPostPolicy
      , "message_retention_days" .= basicStreamAllOfMessageRetentionDays
      , "history_public_to_subscribers" .= basicStreamAllOfHistoryPublicToSubscribers
      , "first_message_id" .= basicStreamAllOfFirstMessageId
      , "is_announcement_only" .= basicStreamAllOfIsAnnouncementOnly
      ]


-- | Construct a value of type 'BasicStreamAllOf' (by applying it's required fields, if any)
mkBasicStreamAllOf
  :: BasicStreamAllOf
mkBasicStreamAllOf =
  BasicStreamAllOf
  { basicStreamAllOfStreamId = Nothing
  , basicStreamAllOfName = Nothing
  , basicStreamAllOfDescription = Nothing
  , basicStreamAllOfDateCreated = Nothing
  , basicStreamAllOfInviteOnly = Nothing
  , basicStreamAllOfRenderedDescription = Nothing
  , basicStreamAllOfIsWebPublic = Nothing
  , basicStreamAllOfStreamPostPolicy = Nothing
  , basicStreamAllOfMessageRetentionDays = Nothing
  , basicStreamAllOfHistoryPublicToSubscribers = Nothing
  , basicStreamAllOfFirstMessageId = Nothing
  , basicStreamAllOfIsAnnouncementOnly = Nothing
  }

-- ** BasicStreamBase
-- | BasicStreamBase
-- Object containing basic details about the stream. 
data BasicStreamBase = BasicStreamBase
  { basicStreamBaseStreamId :: !(Maybe Int) -- ^ "stream_id" - The unique ID of the stream. 
  , basicStreamBaseName :: !(Maybe Text) -- ^ "name" - The name of the stream. 
  , basicStreamBaseDescription :: !(Maybe Text) -- ^ "description" - The short description of the stream in text/markdown format, intended to be used to prepopulate UI for editing a stream&#39;s description. 
  , basicStreamBaseDateCreated :: !(Maybe Int) -- ^ "date_created" - The UNIX timestamp for when the stream was created, in UTC seconds.  **Changes**: New in Zulip 4.0 (feature level 30). 
  , basicStreamBaseInviteOnly :: !(Maybe Bool) -- ^ "invite_only" - Specifies whether the stream is private or not. Only people who have been invited can access a private stream. 
  , basicStreamBaseRenderedDescription :: !(Maybe Text) -- ^ "rendered_description" - The short description of the stream rendered as HTML, intended to be used when displaying the stream description in a UI.  One should use the standard Zulip rendered_markdown CSS when displaying this content so that emoji, LaTeX, and other syntax work correctly.  And any client-side security logic for user-generated message content should be applied when displaying this HTML as though it were the body of a Zulip message. 
  , basicStreamBaseIsWebPublic :: !(Maybe Bool) -- ^ "is_web_public" - Whether the stream has been configured to allow unauthenticated access to its message history from the web. 
  , basicStreamBaseStreamPostPolicy :: !(Maybe Int) -- ^ "stream_post_policy" - Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean. 
  , basicStreamBaseMessageRetentionDays :: !(Maybe Int) -- ^ "message_retention_days" - Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  There are two special values:  * &#x60;null&#x60;, the default, means the stream will inherit the organization   level setting. * &#x60;-1&#x60; encodes retaining messages in this stream forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
  , basicStreamBaseHistoryPublicToSubscribers :: !(Maybe Bool) -- ^ "history_public_to_subscribers" - Whether the history of the stream is public to its subscribers.  Currently always true for public streams (i.e. invite_only&#x3D;False implies history_public_to_subscribers&#x3D;True), but clients should not make that assumption, as we may change that behavior in the future. 
  , basicStreamBaseFirstMessageId :: !(Maybe Int) -- ^ "first_message_id" - The id of the first message in the stream.  Intended to help clients determine whether they need to display UI like the \&quot;more topics\&quot; widget that would suggest the stream has older history that can be accessed.  Null is used for streams with no message history. 
  , basicStreamBaseIsAnnouncementOnly :: !(Maybe Bool) -- ^ "is_announcement_only" - Whether the given stream is announcement only or not.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use &#x60;stream_post_policy&#x60; instead. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BasicStreamBase
instance A.FromJSON BasicStreamBase where
  parseJSON = A.withObject "BasicStreamBase" $ \o ->
    BasicStreamBase
      <$> (o .:? "stream_id")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "date_created")
      <*> (o .:? "invite_only")
      <*> (o .:? "rendered_description")
      <*> (o .:? "is_web_public")
      <*> (o .:? "stream_post_policy")
      <*> (o .:? "message_retention_days")
      <*> (o .:? "history_public_to_subscribers")
      <*> (o .:? "first_message_id")
      <*> (o .:? "is_announcement_only")

-- | ToJSON BasicStreamBase
instance A.ToJSON BasicStreamBase where
  toJSON BasicStreamBase {..} =
   _omitNulls
      [ "stream_id" .= basicStreamBaseStreamId
      , "name" .= basicStreamBaseName
      , "description" .= basicStreamBaseDescription
      , "date_created" .= basicStreamBaseDateCreated
      , "invite_only" .= basicStreamBaseInviteOnly
      , "rendered_description" .= basicStreamBaseRenderedDescription
      , "is_web_public" .= basicStreamBaseIsWebPublic
      , "stream_post_policy" .= basicStreamBaseStreamPostPolicy
      , "message_retention_days" .= basicStreamBaseMessageRetentionDays
      , "history_public_to_subscribers" .= basicStreamBaseHistoryPublicToSubscribers
      , "first_message_id" .= basicStreamBaseFirstMessageId
      , "is_announcement_only" .= basicStreamBaseIsAnnouncementOnly
      ]


-- | Construct a value of type 'BasicStreamBase' (by applying it's required fields, if any)
mkBasicStreamBase
  :: BasicStreamBase
mkBasicStreamBase =
  BasicStreamBase
  { basicStreamBaseStreamId = Nothing
  , basicStreamBaseName = Nothing
  , basicStreamBaseDescription = Nothing
  , basicStreamBaseDateCreated = Nothing
  , basicStreamBaseInviteOnly = Nothing
  , basicStreamBaseRenderedDescription = Nothing
  , basicStreamBaseIsWebPublic = Nothing
  , basicStreamBaseStreamPostPolicy = Nothing
  , basicStreamBaseMessageRetentionDays = Nothing
  , basicStreamBaseHistoryPublicToSubscribers = Nothing
  , basicStreamBaseFirstMessageId = Nothing
  , basicStreamBaseIsAnnouncementOnly = Nothing
  }

-- ** Bot
-- | Bot
data Bot = Bot
  { botUserId :: !(Maybe AnyType) -- ^ "user_id"
  , botFullName :: !(Maybe AnyType) -- ^ "full_name"
  , botApiKey :: !(Maybe AnyType) -- ^ "api_key"
  , botDefaultSendingStream :: !(Maybe AnyType) -- ^ "default_sending_stream"
  , botDefaultEventsRegisterStream :: !(Maybe AnyType) -- ^ "default_events_register_stream"
  , botDefaultAllPublicStreams :: !(Maybe AnyType) -- ^ "default_all_public_streams"
  , botAvatarUrl :: !(Maybe AnyType) -- ^ "avatar_url"
  , botOwnerId :: !(Maybe AnyType) -- ^ "owner_id"
  , botServices :: !(Maybe AnyType) -- ^ "services"
  , botEmail :: !(Maybe Text) -- ^ "email" - The email of the bot. 
  , botBotType :: !(Maybe Int) -- ^ "bot_type" - An integer describing the type of bot: * &#x60;1&#x60; for a &#x60;Generic&#x60; bot. * &#x60;2&#x60; for an &#x60;Incoming webhook&#x60; bot. * &#x60;3&#x60; for an &#x60;Outgoing webhook&#x60; bot. * &#x60;4&#x60; for an &#x60;Embedded&#x60; bot. 
  , botIsActive :: !(Maybe Bool) -- ^ "is_active" - A boolean describing whether the user account has been deactivated. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Bot
instance A.FromJSON Bot where
  parseJSON = A.withObject "Bot" $ \o ->
    Bot
      <$> (o .:? "user_id")
      <*> (o .:? "full_name")
      <*> (o .:? "api_key")
      <*> (o .:? "default_sending_stream")
      <*> (o .:? "default_events_register_stream")
      <*> (o .:? "default_all_public_streams")
      <*> (o .:? "avatar_url")
      <*> (o .:? "owner_id")
      <*> (o .:? "services")
      <*> (o .:? "email")
      <*> (o .:? "bot_type")
      <*> (o .:? "is_active")

-- | ToJSON Bot
instance A.ToJSON Bot where
  toJSON Bot {..} =
   _omitNulls
      [ "user_id" .= botUserId
      , "full_name" .= botFullName
      , "api_key" .= botApiKey
      , "default_sending_stream" .= botDefaultSendingStream
      , "default_events_register_stream" .= botDefaultEventsRegisterStream
      , "default_all_public_streams" .= botDefaultAllPublicStreams
      , "avatar_url" .= botAvatarUrl
      , "owner_id" .= botOwnerId
      , "services" .= botServices
      , "email" .= botEmail
      , "bot_type" .= botBotType
      , "is_active" .= botIsActive
      ]


-- | Construct a value of type 'Bot' (by applying it's required fields, if any)
mkBot
  :: Bot
mkBot =
  Bot
  { botUserId = Nothing
  , botFullName = Nothing
  , botApiKey = Nothing
  , botDefaultSendingStream = Nothing
  , botDefaultEventsRegisterStream = Nothing
  , botDefaultAllPublicStreams = Nothing
  , botAvatarUrl = Nothing
  , botOwnerId = Nothing
  , botServices = Nothing
  , botEmail = Nothing
  , botBotType = Nothing
  , botIsActive = Nothing
  }

-- ** BotAllOf
-- | BotAllOf
-- Object containing details of a bot. 
data BotAllOf = BotAllOf
  { botAllOfUserId :: !(Maybe AnyType) -- ^ "user_id"
  , botAllOfFullName :: !(Maybe AnyType) -- ^ "full_name"
  , botAllOfApiKey :: !(Maybe AnyType) -- ^ "api_key"
  , botAllOfDefaultSendingStream :: !(Maybe AnyType) -- ^ "default_sending_stream"
  , botAllOfDefaultEventsRegisterStream :: !(Maybe AnyType) -- ^ "default_events_register_stream"
  , botAllOfDefaultAllPublicStreams :: !(Maybe AnyType) -- ^ "default_all_public_streams"
  , botAllOfAvatarUrl :: !(Maybe AnyType) -- ^ "avatar_url"
  , botAllOfOwnerId :: !(Maybe AnyType) -- ^ "owner_id"
  , botAllOfServices :: !(Maybe AnyType) -- ^ "services"
  , botAllOfEmail :: !(Maybe Text) -- ^ "email" - The email of the bot. 
  , botAllOfBotType :: !(Maybe Int) -- ^ "bot_type" - An integer describing the type of bot: * &#x60;1&#x60; for a &#x60;Generic&#x60; bot. * &#x60;2&#x60; for an &#x60;Incoming webhook&#x60; bot. * &#x60;3&#x60; for an &#x60;Outgoing webhook&#x60; bot. * &#x60;4&#x60; for an &#x60;Embedded&#x60; bot. 
  , botAllOfIsActive :: !(Maybe Bool) -- ^ "is_active" - A boolean describing whether the user account has been deactivated. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BotAllOf
instance A.FromJSON BotAllOf where
  parseJSON = A.withObject "BotAllOf" $ \o ->
    BotAllOf
      <$> (o .:? "user_id")
      <*> (o .:? "full_name")
      <*> (o .:? "api_key")
      <*> (o .:? "default_sending_stream")
      <*> (o .:? "default_events_register_stream")
      <*> (o .:? "default_all_public_streams")
      <*> (o .:? "avatar_url")
      <*> (o .:? "owner_id")
      <*> (o .:? "services")
      <*> (o .:? "email")
      <*> (o .:? "bot_type")
      <*> (o .:? "is_active")

-- | ToJSON BotAllOf
instance A.ToJSON BotAllOf where
  toJSON BotAllOf {..} =
   _omitNulls
      [ "user_id" .= botAllOfUserId
      , "full_name" .= botAllOfFullName
      , "api_key" .= botAllOfApiKey
      , "default_sending_stream" .= botAllOfDefaultSendingStream
      , "default_events_register_stream" .= botAllOfDefaultEventsRegisterStream
      , "default_all_public_streams" .= botAllOfDefaultAllPublicStreams
      , "avatar_url" .= botAllOfAvatarUrl
      , "owner_id" .= botAllOfOwnerId
      , "services" .= botAllOfServices
      , "email" .= botAllOfEmail
      , "bot_type" .= botAllOfBotType
      , "is_active" .= botAllOfIsActive
      ]


-- | Construct a value of type 'BotAllOf' (by applying it's required fields, if any)
mkBotAllOf
  :: BotAllOf
mkBotAllOf =
  BotAllOf
  { botAllOfUserId = Nothing
  , botAllOfFullName = Nothing
  , botAllOfApiKey = Nothing
  , botAllOfDefaultSendingStream = Nothing
  , botAllOfDefaultEventsRegisterStream = Nothing
  , botAllOfDefaultAllPublicStreams = Nothing
  , botAllOfAvatarUrl = Nothing
  , botAllOfOwnerId = Nothing
  , botAllOfServices = Nothing
  , botAllOfEmail = Nothing
  , botAllOfBotType = Nothing
  , botAllOfIsActive = Nothing
  }

-- ** CodedError
-- | CodedError
data CodedError = CodedError
  { codedErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , codedErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  , codedErrorCode :: !(Maybe AnyType) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CodedError
instance A.FromJSON CodedError where
  parseJSON = A.withObject "CodedError" $ \o ->
    CodedError
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "code")

-- | ToJSON CodedError
instance A.ToJSON CodedError where
  toJSON CodedError {..} =
   _omitNulls
      [ "result" .= codedErrorResult
      , "msg" .= codedErrorMsg
      , "code" .= codedErrorCode
      ]


-- | Construct a value of type 'CodedError' (by applying it's required fields, if any)
mkCodedError
  :: AnyType -- ^ 'codedErrorResult' 
  -> AnyType -- ^ 'codedErrorMsg' 
  -> CodedError
mkCodedError codedErrorResult codedErrorMsg =
  CodedError
  { codedErrorResult
  , codedErrorMsg
  , codedErrorCode = Nothing
  }

-- ** CodedErrorAllOf
-- | CodedErrorAllOf
data CodedErrorAllOf = CodedErrorAllOf
  { codedErrorAllOfResult :: !(Maybe AnyType) -- ^ "result"
  , codedErrorAllOfMsg :: !(Maybe AnyType) -- ^ "msg"
  , codedErrorAllOfCode :: !(Maybe AnyType) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CodedErrorAllOf
instance A.FromJSON CodedErrorAllOf where
  parseJSON = A.withObject "CodedErrorAllOf" $ \o ->
    CodedErrorAllOf
      <$> (o .:? "result")
      <*> (o .:? "msg")
      <*> (o .:? "code")

-- | ToJSON CodedErrorAllOf
instance A.ToJSON CodedErrorAllOf where
  toJSON CodedErrorAllOf {..} =
   _omitNulls
      [ "result" .= codedErrorAllOfResult
      , "msg" .= codedErrorAllOfMsg
      , "code" .= codedErrorAllOfCode
      ]


-- | Construct a value of type 'CodedErrorAllOf' (by applying it's required fields, if any)
mkCodedErrorAllOf
  :: CodedErrorAllOf
mkCodedErrorAllOf =
  CodedErrorAllOf
  { codedErrorAllOfResult = Nothing
  , codedErrorAllOfMsg = Nothing
  , codedErrorAllOfCode = Nothing
  }

-- ** CodedErrorBase
-- | CodedErrorBase
data CodedErrorBase = CodedErrorBase
  { codedErrorBaseResult :: !(AnyType) -- ^ /Required/ "result"
  , codedErrorBaseMsg :: !(AnyType) -- ^ /Required/ "msg"
  , codedErrorBaseCode :: !(Maybe Text) -- ^ "code" - A string that identifies the error. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CodedErrorBase
instance A.FromJSON CodedErrorBase where
  parseJSON = A.withObject "CodedErrorBase" $ \o ->
    CodedErrorBase
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "code")

-- | ToJSON CodedErrorBase
instance A.ToJSON CodedErrorBase where
  toJSON CodedErrorBase {..} =
   _omitNulls
      [ "result" .= codedErrorBaseResult
      , "msg" .= codedErrorBaseMsg
      , "code" .= codedErrorBaseCode
      ]


-- | Construct a value of type 'CodedErrorBase' (by applying it's required fields, if any)
mkCodedErrorBase
  :: AnyType -- ^ 'codedErrorBaseResult' 
  -> AnyType -- ^ 'codedErrorBaseMsg' 
  -> CodedErrorBase
mkCodedErrorBase codedErrorBaseResult codedErrorBaseMsg =
  CodedErrorBase
  { codedErrorBaseResult
  , codedErrorBaseMsg
  , codedErrorBaseCode = Nothing
  }

-- ** CodedErrorBaseAllOf
-- | CodedErrorBaseAllOf
data CodedErrorBaseAllOf = CodedErrorBaseAllOf
  { codedErrorBaseAllOfResult :: !(Maybe AnyType) -- ^ "result"
  , codedErrorBaseAllOfMsg :: !(Maybe AnyType) -- ^ "msg"
  , codedErrorBaseAllOfCode :: !(Maybe Text) -- ^ "code" - A string that identifies the error. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CodedErrorBaseAllOf
instance A.FromJSON CodedErrorBaseAllOf where
  parseJSON = A.withObject "CodedErrorBaseAllOf" $ \o ->
    CodedErrorBaseAllOf
      <$> (o .:? "result")
      <*> (o .:? "msg")
      <*> (o .:? "code")

-- | ToJSON CodedErrorBaseAllOf
instance A.ToJSON CodedErrorBaseAllOf where
  toJSON CodedErrorBaseAllOf {..} =
   _omitNulls
      [ "result" .= codedErrorBaseAllOfResult
      , "msg" .= codedErrorBaseAllOfMsg
      , "code" .= codedErrorBaseAllOfCode
      ]


-- | Construct a value of type 'CodedErrorBaseAllOf' (by applying it's required fields, if any)
mkCodedErrorBaseAllOf
  :: CodedErrorBaseAllOf
mkCodedErrorBaseAllOf =
  CodedErrorBaseAllOf
  { codedErrorBaseAllOfResult = Nothing
  , codedErrorBaseAllOfMsg = Nothing
  , codedErrorBaseAllOfCode = Nothing
  }

-- ** CustomProfileField
-- | CustomProfileField
-- Dictionary containing the details of a custom profile field configured for this organization. 
data CustomProfileField = CustomProfileField
  { customProfileFieldId :: !(Maybe Int) -- ^ "id" - The ID of the custom profile field.  This will be referenced in custom the profile fields section of user objects. 
  , customProfileFieldType :: !(Maybe Int) -- ^ "type" - An integer indicating the type of the custom profile field, which determines how it is configured and displayed to users.  See the [Add custom profile fields](/help/add-custom-profile-fields) article for details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
  , customProfileFieldOrder :: !(Maybe Int) -- ^ "order" - Custom profile fields are displayed in both settings UI and UI showing users&#39; profiles in increasing &#x60;order&#x60;. 
  , customProfileFieldName :: !(Maybe Text) -- ^ "name" - The name of the custom profile field. 
  , customProfileFieldHint :: !(Maybe Text) -- ^ "hint" - The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
  , customProfileFieldFieldData :: !(Maybe Text) -- ^ "field_data" - Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the &#x60;field_data&#x60; attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CustomProfileField
instance A.FromJSON CustomProfileField where
  parseJSON = A.withObject "CustomProfileField" $ \o ->
    CustomProfileField
      <$> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "order")
      <*> (o .:? "name")
      <*> (o .:? "hint")
      <*> (o .:? "field_data")

-- | ToJSON CustomProfileField
instance A.ToJSON CustomProfileField where
  toJSON CustomProfileField {..} =
   _omitNulls
      [ "id" .= customProfileFieldId
      , "type" .= customProfileFieldType
      , "order" .= customProfileFieldOrder
      , "name" .= customProfileFieldName
      , "hint" .= customProfileFieldHint
      , "field_data" .= customProfileFieldFieldData
      ]


-- | Construct a value of type 'CustomProfileField' (by applying it's required fields, if any)
mkCustomProfileField
  :: CustomProfileField
mkCustomProfileField =
  CustomProfileField
  { customProfileFieldId = Nothing
  , customProfileFieldType = Nothing
  , customProfileFieldOrder = Nothing
  , customProfileFieldName = Nothing
  , customProfileFieldHint = Nothing
  , customProfileFieldFieldData = Nothing
  }

-- ** DefaultStreamGroup
-- | DefaultStreamGroup
-- Dictionary containing details of a default stream group. 
data DefaultStreamGroup = DefaultStreamGroup
  { defaultStreamGroupName :: !(Maybe Text) -- ^ "name" - Name of the default stream group. 
  , defaultStreamGroupDescription :: !(Maybe Text) -- ^ "description" - Description of the default stream group. 
  , defaultStreamGroupId :: !(Maybe Int) -- ^ "id" - id of the default stream group. 
  , defaultStreamGroupStreams :: !(Maybe [BasicStream]) -- ^ "streams" - Array containing details about the streams in the default stream group. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DefaultStreamGroup
instance A.FromJSON DefaultStreamGroup where
  parseJSON = A.withObject "DefaultStreamGroup" $ \o ->
    DefaultStreamGroup
      <$> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "id")
      <*> (o .:? "streams")

-- | ToJSON DefaultStreamGroup
instance A.ToJSON DefaultStreamGroup where
  toJSON DefaultStreamGroup {..} =
   _omitNulls
      [ "name" .= defaultStreamGroupName
      , "description" .= defaultStreamGroupDescription
      , "id" .= defaultStreamGroupId
      , "streams" .= defaultStreamGroupStreams
      ]


-- | Construct a value of type 'DefaultStreamGroup' (by applying it's required fields, if any)
mkDefaultStreamGroup
  :: DefaultStreamGroup
mkDefaultStreamGroup =
  DefaultStreamGroup
  { defaultStreamGroupName = Nothing
  , defaultStreamGroupDescription = Nothing
  , defaultStreamGroupId = Nothing
  , defaultStreamGroupStreams = Nothing
  }

-- ** EmojiReaction
-- | EmojiReaction
data EmojiReaction = EmojiReaction
  { emojiReactionEmojiCode :: !(Maybe AnyType) -- ^ "emoji_code"
  , emojiReactionEmojiName :: !(Maybe AnyType) -- ^ "emoji_name"
  , emojiReactionReactionType :: !(Maybe AnyType) -- ^ "reaction_type"
  , emojiReactionUserId :: !(Maybe AnyType) -- ^ "user_id"
  , emojiReactionUser :: !(Maybe AnyType) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmojiReaction
instance A.FromJSON EmojiReaction where
  parseJSON = A.withObject "EmojiReaction" $ \o ->
    EmojiReaction
      <$> (o .:? "emoji_code")
      <*> (o .:? "emoji_name")
      <*> (o .:? "reaction_type")
      <*> (o .:? "user_id")
      <*> (o .:? "user")

-- | ToJSON EmojiReaction
instance A.ToJSON EmojiReaction where
  toJSON EmojiReaction {..} =
   _omitNulls
      [ "emoji_code" .= emojiReactionEmojiCode
      , "emoji_name" .= emojiReactionEmojiName
      , "reaction_type" .= emojiReactionReactionType
      , "user_id" .= emojiReactionUserId
      , "user" .= emojiReactionUser
      ]


-- | Construct a value of type 'EmojiReaction' (by applying it's required fields, if any)
mkEmojiReaction
  :: EmojiReaction
mkEmojiReaction =
  EmojiReaction
  { emojiReactionEmojiCode = Nothing
  , emojiReactionEmojiName = Nothing
  , emojiReactionReactionType = Nothing
  , emojiReactionUserId = Nothing
  , emojiReactionUser = Nothing
  }

-- ** EmojiReactionAllOf
-- | EmojiReactionAllOf
data EmojiReactionAllOf = EmojiReactionAllOf
  { emojiReactionAllOfEmojiCode :: !(Maybe AnyType) -- ^ "emoji_code"
  , emojiReactionAllOfEmojiName :: !(Maybe AnyType) -- ^ "emoji_name"
  , emojiReactionAllOfReactionType :: !(Maybe AnyType) -- ^ "reaction_type"
  , emojiReactionAllOfUserId :: !(Maybe AnyType) -- ^ "user_id"
  , emojiReactionAllOfUser :: !(Maybe AnyType) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmojiReactionAllOf
instance A.FromJSON EmojiReactionAllOf where
  parseJSON = A.withObject "EmojiReactionAllOf" $ \o ->
    EmojiReactionAllOf
      <$> (o .:? "emoji_code")
      <*> (o .:? "emoji_name")
      <*> (o .:? "reaction_type")
      <*> (o .:? "user_id")
      <*> (o .:? "user")

-- | ToJSON EmojiReactionAllOf
instance A.ToJSON EmojiReactionAllOf where
  toJSON EmojiReactionAllOf {..} =
   _omitNulls
      [ "emoji_code" .= emojiReactionAllOfEmojiCode
      , "emoji_name" .= emojiReactionAllOfEmojiName
      , "reaction_type" .= emojiReactionAllOfReactionType
      , "user_id" .= emojiReactionAllOfUserId
      , "user" .= emojiReactionAllOfUser
      ]


-- | Construct a value of type 'EmojiReactionAllOf' (by applying it's required fields, if any)
mkEmojiReactionAllOf
  :: EmojiReactionAllOf
mkEmojiReactionAllOf =
  EmojiReactionAllOf
  { emojiReactionAllOfEmojiCode = Nothing
  , emojiReactionAllOfEmojiName = Nothing
  , emojiReactionAllOfReactionType = Nothing
  , emojiReactionAllOfUserId = Nothing
  , emojiReactionAllOfUser = Nothing
  }

-- ** EmojiReactionBase
-- | EmojiReactionBase
data EmojiReactionBase = EmojiReactionBase
  { emojiReactionBaseEmojiCode :: !(Maybe Text) -- ^ "emoji_code" - A unique identifier, defining the specific emoji codepoint requested, within the namespace of the &#x60;reaction_type&#x60;.  For example, for &#x60;unicode_emoji&#x60;, this will be an encoding of the Unicode codepoint. 
  , emojiReactionBaseEmojiName :: !(Maybe Text) -- ^ "emoji_name" - Name of the emoji. 
  , emojiReactionBaseReactionType :: !(Maybe Text) -- ^ "reaction_type" - One of the following values:  * &#x60;unicode_emoji&#x60;: Unicode emoji (&#x60;emoji_code&#x60; will be its Unicode   codepoint). * &#x60;realm_emoji&#x60;: [Custom emoji](/help/add-custom-emoji).   (&#x60;emoji_code&#x60; will be its ID). * &#x60;zulip_extra_emoji&#x60;: Special emoji included with Zulip.  Exists to   namespace the &#x60;zulip&#x60; emoji. 
  , emojiReactionBaseUserId :: !(Maybe Int) -- ^ "user_id" - The ID of the user who added the reaction.  **Changes**: New in Zulip 3.0 (feature level 2). The &#x60;user&#x60; object is deprecated and will be removed in the future. 
  , emojiReactionBaseUser :: !(Maybe EmojiReactionBaseUser) -- ^ "user"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmojiReactionBase
instance A.FromJSON EmojiReactionBase where
  parseJSON = A.withObject "EmojiReactionBase" $ \o ->
    EmojiReactionBase
      <$> (o .:? "emoji_code")
      <*> (o .:? "emoji_name")
      <*> (o .:? "reaction_type")
      <*> (o .:? "user_id")
      <*> (o .:? "user")

-- | ToJSON EmojiReactionBase
instance A.ToJSON EmojiReactionBase where
  toJSON EmojiReactionBase {..} =
   _omitNulls
      [ "emoji_code" .= emojiReactionBaseEmojiCode
      , "emoji_name" .= emojiReactionBaseEmojiName
      , "reaction_type" .= emojiReactionBaseReactionType
      , "user_id" .= emojiReactionBaseUserId
      , "user" .= emojiReactionBaseUser
      ]


-- | Construct a value of type 'EmojiReactionBase' (by applying it's required fields, if any)
mkEmojiReactionBase
  :: EmojiReactionBase
mkEmojiReactionBase =
  EmojiReactionBase
  { emojiReactionBaseEmojiCode = Nothing
  , emojiReactionBaseEmojiName = Nothing
  , emojiReactionBaseReactionType = Nothing
  , emojiReactionBaseUserId = Nothing
  , emojiReactionBaseUser = Nothing
  }

-- ** EmojiReactionBaseUser
-- | EmojiReactionBaseUser
-- Dictionary with data on the user who added the reaction, including the user ID as the `id` field.  **Note**: In the [events API](/api/get-events), this `user` dictionary confusing had the user ID in a field called `user_id` instead.  We recommend ignoring fields other than the user ID.  **Deprecated** and to be removed in a future release once core clients have migrated to use the `user_id` field. 
data EmojiReactionBaseUser = EmojiReactionBaseUser
  { emojiReactionBaseUserId :: !(Maybe Int) -- ^ "id" - ID of the user. 
  , emojiReactionBaseUserEmail :: !(Maybe Text) -- ^ "email" - Email of the user. 
  , emojiReactionBaseUserFullName :: !(Maybe Text) -- ^ "full_name" - Full name of the user. 
  , emojiReactionBaseUserIsMirrorDummy :: !(Maybe Bool) -- ^ "is_mirror_dummy" - Whether the user is a mirror dummy. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EmojiReactionBaseUser
instance A.FromJSON EmojiReactionBaseUser where
  parseJSON = A.withObject "EmojiReactionBaseUser" $ \o ->
    EmojiReactionBaseUser
      <$> (o .:? "id")
      <*> (o .:? "email")
      <*> (o .:? "full_name")
      <*> (o .:? "is_mirror_dummy")

-- | ToJSON EmojiReactionBaseUser
instance A.ToJSON EmojiReactionBaseUser where
  toJSON EmojiReactionBaseUser {..} =
   _omitNulls
      [ "id" .= emojiReactionBaseUserId
      , "email" .= emojiReactionBaseUserEmail
      , "full_name" .= emojiReactionBaseUserFullName
      , "is_mirror_dummy" .= emojiReactionBaseUserIsMirrorDummy
      ]


-- | Construct a value of type 'EmojiReactionBaseUser' (by applying it's required fields, if any)
mkEmojiReactionBaseUser
  :: EmojiReactionBaseUser
mkEmojiReactionBaseUser =
  EmojiReactionBaseUser
  { emojiReactionBaseUserId = Nothing
  , emojiReactionBaseUserEmail = Nothing
  , emojiReactionBaseUserFullName = Nothing
  , emojiReactionBaseUserIsMirrorDummy = Nothing
  }

-- ** GetMessages
-- | GetMessages
data GetMessages = GetMessages
  { getMessagesAvatarUrl :: !(Maybe AnyType) -- ^ "avatar_url"
  , getMessagesClient :: !(Maybe AnyType) -- ^ "client"
  , getMessagesContent :: !(Maybe AnyType) -- ^ "content"
  , getMessagesContentType :: !(Maybe AnyType) -- ^ "content_type"
  , getMessagesDisplayRecipient :: !(Maybe AnyType) -- ^ "display_recipient"
  , getMessagesId :: !(Maybe AnyType) -- ^ "id"
  , getMessagesIsMeMessage :: !(Maybe AnyType) -- ^ "is_me_message"
  , getMessagesReactions :: !(Maybe AnyType) -- ^ "reactions"
  , getMessagesRecipientId :: !(Maybe AnyType) -- ^ "recipient_id"
  , getMessagesSenderEmail :: !(Maybe AnyType) -- ^ "sender_email"
  , getMessagesSenderFullName :: !(Maybe AnyType) -- ^ "sender_full_name"
  , getMessagesSenderId :: !(Maybe AnyType) -- ^ "sender_id"
  , getMessagesSenderRealmStr :: !(Maybe AnyType) -- ^ "sender_realm_str"
  , getMessagesStreamId :: !(Maybe AnyType) -- ^ "stream_id"
  , getMessagesSubject :: !(Maybe AnyType) -- ^ "subject"
  , getMessagesTopicLinks :: !(Maybe AnyType) -- ^ "topic_links"
  , getMessagesSubmessages :: !(Maybe AnyType) -- ^ "submessages"
  , getMessagesTimestamp :: !(Maybe AnyType) -- ^ "timestamp"
  , getMessagesType :: !(Maybe AnyType) -- ^ "type"
  , getMessagesFlags :: !(Maybe [Text]) -- ^ "flags" - The user&#39;s [message flags][message-flags] for the message.  [message-flags]: /api/update-message-flags#available-flags 
  , getMessagesLastEditTimestamp :: !(Maybe Int) -- ^ "last_edit_timestamp" - The UNIX timestamp for when the message was last edited, in UTC seconds. 
  , getMessagesMatchContent :: !(Maybe Text) -- ^ "match_content" - Only present if keyword search was included among the narrow parameters. HTML content of a queried message that matches the narrow, with &#x60;&lt;span class&#x3D;\&quot;highlight\&quot;&gt;&#x60; elements wrapping the matches for the search keywords. 
  , getMessagesMatchSubject :: !(Maybe Text) -- ^ "match_subject" - Only present if keyword search was included among the narrow parameters. HTML-escaped topic of a queried message that matches the narrow, with &#x60;&lt;span class&#x3D;\&quot;highlight\&quot;&gt;&#x60; elements wrapping the matches for the search keywords. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMessages
instance A.FromJSON GetMessages where
  parseJSON = A.withObject "GetMessages" $ \o ->
    GetMessages
      <$> (o .:? "avatar_url")
      <*> (o .:? "client")
      <*> (o .:? "content")
      <*> (o .:? "content_type")
      <*> (o .:? "display_recipient")
      <*> (o .:? "id")
      <*> (o .:? "is_me_message")
      <*> (o .:? "reactions")
      <*> (o .:? "recipient_id")
      <*> (o .:? "sender_email")
      <*> (o .:? "sender_full_name")
      <*> (o .:? "sender_id")
      <*> (o .:? "sender_realm_str")
      <*> (o .:? "stream_id")
      <*> (o .:? "subject")
      <*> (o .:? "topic_links")
      <*> (o .:? "submessages")
      <*> (o .:? "timestamp")
      <*> (o .:? "type")
      <*> (o .:? "flags")
      <*> (o .:? "last_edit_timestamp")
      <*> (o .:? "match_content")
      <*> (o .:? "match_subject")

-- | ToJSON GetMessages
instance A.ToJSON GetMessages where
  toJSON GetMessages {..} =
   _omitNulls
      [ "avatar_url" .= getMessagesAvatarUrl
      , "client" .= getMessagesClient
      , "content" .= getMessagesContent
      , "content_type" .= getMessagesContentType
      , "display_recipient" .= getMessagesDisplayRecipient
      , "id" .= getMessagesId
      , "is_me_message" .= getMessagesIsMeMessage
      , "reactions" .= getMessagesReactions
      , "recipient_id" .= getMessagesRecipientId
      , "sender_email" .= getMessagesSenderEmail
      , "sender_full_name" .= getMessagesSenderFullName
      , "sender_id" .= getMessagesSenderId
      , "sender_realm_str" .= getMessagesSenderRealmStr
      , "stream_id" .= getMessagesStreamId
      , "subject" .= getMessagesSubject
      , "topic_links" .= getMessagesTopicLinks
      , "submessages" .= getMessagesSubmessages
      , "timestamp" .= getMessagesTimestamp
      , "type" .= getMessagesType
      , "flags" .= getMessagesFlags
      , "last_edit_timestamp" .= getMessagesLastEditTimestamp
      , "match_content" .= getMessagesMatchContent
      , "match_subject" .= getMessagesMatchSubject
      ]


-- | Construct a value of type 'GetMessages' (by applying it's required fields, if any)
mkGetMessages
  :: GetMessages
mkGetMessages =
  GetMessages
  { getMessagesAvatarUrl = Nothing
  , getMessagesClient = Nothing
  , getMessagesContent = Nothing
  , getMessagesContentType = Nothing
  , getMessagesDisplayRecipient = Nothing
  , getMessagesId = Nothing
  , getMessagesIsMeMessage = Nothing
  , getMessagesReactions = Nothing
  , getMessagesRecipientId = Nothing
  , getMessagesSenderEmail = Nothing
  , getMessagesSenderFullName = Nothing
  , getMessagesSenderId = Nothing
  , getMessagesSenderRealmStr = Nothing
  , getMessagesStreamId = Nothing
  , getMessagesSubject = Nothing
  , getMessagesTopicLinks = Nothing
  , getMessagesSubmessages = Nothing
  , getMessagesTimestamp = Nothing
  , getMessagesType = Nothing
  , getMessagesFlags = Nothing
  , getMessagesLastEditTimestamp = Nothing
  , getMessagesMatchContent = Nothing
  , getMessagesMatchSubject = Nothing
  }

-- ** GetMessagesAllOf
-- | GetMessagesAllOf
data GetMessagesAllOf = GetMessagesAllOf
  { getMessagesAllOfAvatarUrl :: !(Maybe AnyType) -- ^ "avatar_url"
  , getMessagesAllOfClient :: !(Maybe AnyType) -- ^ "client"
  , getMessagesAllOfContent :: !(Maybe AnyType) -- ^ "content"
  , getMessagesAllOfContentType :: !(Maybe AnyType) -- ^ "content_type"
  , getMessagesAllOfDisplayRecipient :: !(Maybe AnyType) -- ^ "display_recipient"
  , getMessagesAllOfId :: !(Maybe AnyType) -- ^ "id"
  , getMessagesAllOfIsMeMessage :: !(Maybe AnyType) -- ^ "is_me_message"
  , getMessagesAllOfReactions :: !(Maybe AnyType) -- ^ "reactions"
  , getMessagesAllOfRecipientId :: !(Maybe AnyType) -- ^ "recipient_id"
  , getMessagesAllOfSenderEmail :: !(Maybe AnyType) -- ^ "sender_email"
  , getMessagesAllOfSenderFullName :: !(Maybe AnyType) -- ^ "sender_full_name"
  , getMessagesAllOfSenderId :: !(Maybe AnyType) -- ^ "sender_id"
  , getMessagesAllOfSenderRealmStr :: !(Maybe AnyType) -- ^ "sender_realm_str"
  , getMessagesAllOfStreamId :: !(Maybe AnyType) -- ^ "stream_id"
  , getMessagesAllOfSubject :: !(Maybe AnyType) -- ^ "subject"
  , getMessagesAllOfTopicLinks :: !(Maybe AnyType) -- ^ "topic_links"
  , getMessagesAllOfSubmessages :: !(Maybe AnyType) -- ^ "submessages"
  , getMessagesAllOfTimestamp :: !(Maybe AnyType) -- ^ "timestamp"
  , getMessagesAllOfType :: !(Maybe AnyType) -- ^ "type"
  , getMessagesAllOfFlags :: !(Maybe [Text]) -- ^ "flags" - The user&#39;s [message flags][message-flags] for the message.  [message-flags]: /api/update-message-flags#available-flags 
  , getMessagesAllOfLastEditTimestamp :: !(Maybe Int) -- ^ "last_edit_timestamp" - The UNIX timestamp for when the message was last edited, in UTC seconds. 
  , getMessagesAllOfMatchContent :: !(Maybe Text) -- ^ "match_content" - Only present if keyword search was included among the narrow parameters. HTML content of a queried message that matches the narrow, with &#x60;&lt;span class&#x3D;\&quot;highlight\&quot;&gt;&#x60; elements wrapping the matches for the search keywords. 
  , getMessagesAllOfMatchSubject :: !(Maybe Text) -- ^ "match_subject" - Only present if keyword search was included among the narrow parameters. HTML-escaped topic of a queried message that matches the narrow, with &#x60;&lt;span class&#x3D;\&quot;highlight\&quot;&gt;&#x60; elements wrapping the matches for the search keywords. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GetMessagesAllOf
instance A.FromJSON GetMessagesAllOf where
  parseJSON = A.withObject "GetMessagesAllOf" $ \o ->
    GetMessagesAllOf
      <$> (o .:? "avatar_url")
      <*> (o .:? "client")
      <*> (o .:? "content")
      <*> (o .:? "content_type")
      <*> (o .:? "display_recipient")
      <*> (o .:? "id")
      <*> (o .:? "is_me_message")
      <*> (o .:? "reactions")
      <*> (o .:? "recipient_id")
      <*> (o .:? "sender_email")
      <*> (o .:? "sender_full_name")
      <*> (o .:? "sender_id")
      <*> (o .:? "sender_realm_str")
      <*> (o .:? "stream_id")
      <*> (o .:? "subject")
      <*> (o .:? "topic_links")
      <*> (o .:? "submessages")
      <*> (o .:? "timestamp")
      <*> (o .:? "type")
      <*> (o .:? "flags")
      <*> (o .:? "last_edit_timestamp")
      <*> (o .:? "match_content")
      <*> (o .:? "match_subject")

-- | ToJSON GetMessagesAllOf
instance A.ToJSON GetMessagesAllOf where
  toJSON GetMessagesAllOf {..} =
   _omitNulls
      [ "avatar_url" .= getMessagesAllOfAvatarUrl
      , "client" .= getMessagesAllOfClient
      , "content" .= getMessagesAllOfContent
      , "content_type" .= getMessagesAllOfContentType
      , "display_recipient" .= getMessagesAllOfDisplayRecipient
      , "id" .= getMessagesAllOfId
      , "is_me_message" .= getMessagesAllOfIsMeMessage
      , "reactions" .= getMessagesAllOfReactions
      , "recipient_id" .= getMessagesAllOfRecipientId
      , "sender_email" .= getMessagesAllOfSenderEmail
      , "sender_full_name" .= getMessagesAllOfSenderFullName
      , "sender_id" .= getMessagesAllOfSenderId
      , "sender_realm_str" .= getMessagesAllOfSenderRealmStr
      , "stream_id" .= getMessagesAllOfStreamId
      , "subject" .= getMessagesAllOfSubject
      , "topic_links" .= getMessagesAllOfTopicLinks
      , "submessages" .= getMessagesAllOfSubmessages
      , "timestamp" .= getMessagesAllOfTimestamp
      , "type" .= getMessagesAllOfType
      , "flags" .= getMessagesAllOfFlags
      , "last_edit_timestamp" .= getMessagesAllOfLastEditTimestamp
      , "match_content" .= getMessagesAllOfMatchContent
      , "match_subject" .= getMessagesAllOfMatchSubject
      ]


-- | Construct a value of type 'GetMessagesAllOf' (by applying it's required fields, if any)
mkGetMessagesAllOf
  :: GetMessagesAllOf
mkGetMessagesAllOf =
  GetMessagesAllOf
  { getMessagesAllOfAvatarUrl = Nothing
  , getMessagesAllOfClient = Nothing
  , getMessagesAllOfContent = Nothing
  , getMessagesAllOfContentType = Nothing
  , getMessagesAllOfDisplayRecipient = Nothing
  , getMessagesAllOfId = Nothing
  , getMessagesAllOfIsMeMessage = Nothing
  , getMessagesAllOfReactions = Nothing
  , getMessagesAllOfRecipientId = Nothing
  , getMessagesAllOfSenderEmail = Nothing
  , getMessagesAllOfSenderFullName = Nothing
  , getMessagesAllOfSenderId = Nothing
  , getMessagesAllOfSenderRealmStr = Nothing
  , getMessagesAllOfStreamId = Nothing
  , getMessagesAllOfSubject = Nothing
  , getMessagesAllOfTopicLinks = Nothing
  , getMessagesAllOfSubmessages = Nothing
  , getMessagesAllOfTimestamp = Nothing
  , getMessagesAllOfType = Nothing
  , getMessagesAllOfFlags = Nothing
  , getMessagesAllOfLastEditTimestamp = Nothing
  , getMessagesAllOfMatchContent = Nothing
  , getMessagesAllOfMatchSubject = Nothing
  }

-- ** Hotspot
-- | Hotspot
-- Dictionary containing details of a single hotspot. 
data Hotspot = Hotspot
  { hotspotDelay :: !(Maybe Double) -- ^ "delay" - The delay after which the user should be shown the hotspot. 
  , hotspotName :: !(Maybe Text) -- ^ "name" - The name of the hotspot. 
  , hotspotTitle :: !(Maybe Text) -- ^ "title" - The title of the hotspot, as will be displayed to the user. 
  , hotspotDescription :: !(Maybe Text) -- ^ "description" - The description of the hotspot, as will be displayed to the user. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Hotspot
instance A.FromJSON Hotspot where
  parseJSON = A.withObject "Hotspot" $ \o ->
    Hotspot
      <$> (o .:? "delay")
      <*> (o .:? "name")
      <*> (o .:? "title")
      <*> (o .:? "description")

-- | ToJSON Hotspot
instance A.ToJSON Hotspot where
  toJSON Hotspot {..} =
   _omitNulls
      [ "delay" .= hotspotDelay
      , "name" .= hotspotName
      , "title" .= hotspotTitle
      , "description" .= hotspotDescription
      ]


-- | Construct a value of type 'Hotspot' (by applying it's required fields, if any)
mkHotspot
  :: Hotspot
mkHotspot =
  Hotspot
  { hotspotDelay = Nothing
  , hotspotName = Nothing
  , hotspotTitle = Nothing
  , hotspotDescription = Nothing
  }

-- ** InlineResponse200
-- | InlineResponse200
-- This is an example of the JSON payload that the Zulip server will `POST` to your server 
data InlineResponse200 = InlineResponse200
  { inlineResponse200BotEmail :: !(Maybe Text) -- ^ "bot_email" - Email of the bot user. 
  , inlineResponse200BotFullName :: !(Maybe Text) -- ^ "bot_full_name" - The full name of the bot user. 
  , inlineResponse200Data :: !(Maybe Text) -- ^ "data" - The message content, in raw Markdown format (not rendered to HTML). 
  , inlineResponse200Trigger :: !(Maybe Text) -- ^ "trigger" - What aspect of the message triggered the outgoing webhook notification. Possible values include &#x60;private_message&#x60; and &#x60;mention&#x60;. 
  , inlineResponse200Token :: !(Maybe Text) -- ^ "token" - A string of alphanumeric characters that can be used to authenticate the webhook request (each bot user uses a fixed token). You can get the token used by a given outgoing webhook bot in the &#x60;zuliprc&#x60; file downloaded when creating the bot. 
  , inlineResponse200Message :: !(Maybe MessagesBase) -- ^ "message" - A dict containing details on the message that triggered the outgoing webhook, in the format used by [&#x60;GET /messages&#x60;](/api/get-messages). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InlineResponse200
instance A.FromJSON InlineResponse200 where
  parseJSON = A.withObject "InlineResponse200" $ \o ->
    InlineResponse200
      <$> (o .:? "bot_email")
      <*> (o .:? "bot_full_name")
      <*> (o .:? "data")
      <*> (o .:? "trigger")
      <*> (o .:? "token")
      <*> (o .:? "message")

-- | ToJSON InlineResponse200
instance A.ToJSON InlineResponse200 where
  toJSON InlineResponse200 {..} =
   _omitNulls
      [ "bot_email" .= inlineResponse200BotEmail
      , "bot_full_name" .= inlineResponse200BotFullName
      , "data" .= inlineResponse200Data
      , "trigger" .= inlineResponse200Trigger
      , "token" .= inlineResponse200Token
      , "message" .= inlineResponse200Message
      ]


-- | Construct a value of type 'InlineResponse200' (by applying it's required fields, if any)
mkInlineResponse200
  :: InlineResponse200
mkInlineResponse200 =
  InlineResponse200
  { inlineResponse200BotEmail = Nothing
  , inlineResponse200BotFullName = Nothing
  , inlineResponse200Data = Nothing
  , inlineResponse200Trigger = Nothing
  , inlineResponse200Token = Nothing
  , inlineResponse200Message = Nothing
  }

-- ** InvalidApiKeyError
-- | InvalidApiKeyError
data InvalidApiKeyError = InvalidApiKeyError
  { invalidApiKeyErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , invalidApiKeyErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvalidApiKeyError
instance A.FromJSON InvalidApiKeyError where
  parseJSON = A.withObject "InvalidApiKeyError" $ \o ->
    InvalidApiKeyError
      <$> (o .:  "result")
      <*> (o .:  "msg")

-- | ToJSON InvalidApiKeyError
instance A.ToJSON InvalidApiKeyError where
  toJSON InvalidApiKeyError {..} =
   _omitNulls
      [ "result" .= invalidApiKeyErrorResult
      , "msg" .= invalidApiKeyErrorMsg
      ]


-- | Construct a value of type 'InvalidApiKeyError' (by applying it's required fields, if any)
mkInvalidApiKeyError
  :: AnyType -- ^ 'invalidApiKeyErrorResult' 
  -> AnyType -- ^ 'invalidApiKeyErrorMsg' 
  -> InvalidApiKeyError
mkInvalidApiKeyError invalidApiKeyErrorResult invalidApiKeyErrorMsg =
  InvalidApiKeyError
  { invalidApiKeyErrorResult
  , invalidApiKeyErrorMsg
  }

-- ** InvalidMessageError
-- | InvalidMessageError
data InvalidMessageError = InvalidMessageError
  { invalidMessageErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , invalidMessageErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  , invalidMessageErrorRawContent :: !(Maybe Text) -- ^ "raw_content" - The raw content of the message. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvalidMessageError
instance A.FromJSON InvalidMessageError where
  parseJSON = A.withObject "InvalidMessageError" $ \o ->
    InvalidMessageError
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "raw_content")

-- | ToJSON InvalidMessageError
instance A.ToJSON InvalidMessageError where
  toJSON InvalidMessageError {..} =
   _omitNulls
      [ "result" .= invalidMessageErrorResult
      , "msg" .= invalidMessageErrorMsg
      , "raw_content" .= invalidMessageErrorRawContent
      ]


-- | Construct a value of type 'InvalidMessageError' (by applying it's required fields, if any)
mkInvalidMessageError
  :: AnyType -- ^ 'invalidMessageErrorResult' 
  -> AnyType -- ^ 'invalidMessageErrorMsg' 
  -> InvalidMessageError
mkInvalidMessageError invalidMessageErrorResult invalidMessageErrorMsg =
  InvalidMessageError
  { invalidMessageErrorResult
  , invalidMessageErrorMsg
  , invalidMessageErrorRawContent = Nothing
  }

-- ** InvalidMessageErrorAllOf
-- | InvalidMessageErrorAllOf
data InvalidMessageErrorAllOf = InvalidMessageErrorAllOf
  { invalidMessageErrorAllOfResult :: !(Maybe AnyType) -- ^ "result"
  , invalidMessageErrorAllOfMsg :: !(Maybe AnyType) -- ^ "msg"
  , invalidMessageErrorAllOfRawContent :: !(Maybe Text) -- ^ "raw_content" - The raw content of the message. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InvalidMessageErrorAllOf
instance A.FromJSON InvalidMessageErrorAllOf where
  parseJSON = A.withObject "InvalidMessageErrorAllOf" $ \o ->
    InvalidMessageErrorAllOf
      <$> (o .:? "result")
      <*> (o .:? "msg")
      <*> (o .:? "raw_content")

-- | ToJSON InvalidMessageErrorAllOf
instance A.ToJSON InvalidMessageErrorAllOf where
  toJSON InvalidMessageErrorAllOf {..} =
   _omitNulls
      [ "result" .= invalidMessageErrorAllOfResult
      , "msg" .= invalidMessageErrorAllOfMsg
      , "raw_content" .= invalidMessageErrorAllOfRawContent
      ]


-- | Construct a value of type 'InvalidMessageErrorAllOf' (by applying it's required fields, if any)
mkInvalidMessageErrorAllOf
  :: InvalidMessageErrorAllOf
mkInvalidMessageErrorAllOf =
  InvalidMessageErrorAllOf
  { invalidMessageErrorAllOfResult = Nothing
  , invalidMessageErrorAllOfMsg = Nothing
  , invalidMessageErrorAllOfRawContent = Nothing
  }

-- ** JsonError
-- | JsonError
data JsonError = JsonError
  { jsonErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , jsonErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JsonError
instance A.FromJSON JsonError where
  parseJSON = A.withObject "JsonError" $ \o ->
    JsonError
      <$> (o .:  "result")
      <*> (o .:  "msg")

-- | ToJSON JsonError
instance A.ToJSON JsonError where
  toJSON JsonError {..} =
   _omitNulls
      [ "result" .= jsonErrorResult
      , "msg" .= jsonErrorMsg
      ]


-- | Construct a value of type 'JsonError' (by applying it's required fields, if any)
mkJsonError
  :: AnyType -- ^ 'jsonErrorResult' 
  -> AnyType -- ^ 'jsonErrorMsg' 
  -> JsonError
mkJsonError jsonErrorResult jsonErrorMsg =
  JsonError
  { jsonErrorResult
  , jsonErrorMsg
  }

-- ** JsonErrorBase
-- | JsonErrorBase
data JsonErrorBase = JsonErrorBase
  { jsonErrorBaseResult :: !(E'Result2) -- ^ /Required/ "result"
  , jsonErrorBaseMsg :: !(Text) -- ^ /Required/ "msg"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JsonErrorBase
instance A.FromJSON JsonErrorBase where
  parseJSON = A.withObject "JsonErrorBase" $ \o ->
    JsonErrorBase
      <$> (o .:  "result")
      <*> (o .:  "msg")

-- | ToJSON JsonErrorBase
instance A.ToJSON JsonErrorBase where
  toJSON JsonErrorBase {..} =
   _omitNulls
      [ "result" .= jsonErrorBaseResult
      , "msg" .= jsonErrorBaseMsg
      ]


-- | Construct a value of type 'JsonErrorBase' (by applying it's required fields, if any)
mkJsonErrorBase
  :: E'Result2 -- ^ 'jsonErrorBaseResult' 
  -> Text -- ^ 'jsonErrorBaseMsg' 
  -> JsonErrorBase
mkJsonErrorBase jsonErrorBaseResult jsonErrorBaseMsg =
  JsonErrorBase
  { jsonErrorBaseResult
  , jsonErrorBaseMsg
  }

-- ** JsonErrorBaseAllOf
-- | JsonErrorBaseAllOf
data JsonErrorBaseAllOf = JsonErrorBaseAllOf
  { jsonErrorBaseAllOfResult :: !(E'Result2) -- ^ /Required/ "result"
  , jsonErrorBaseAllOfMsg :: !(Text) -- ^ /Required/ "msg"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JsonErrorBaseAllOf
instance A.FromJSON JsonErrorBaseAllOf where
  parseJSON = A.withObject "JsonErrorBaseAllOf" $ \o ->
    JsonErrorBaseAllOf
      <$> (o .:  "result")
      <*> (o .:  "msg")

-- | ToJSON JsonErrorBaseAllOf
instance A.ToJSON JsonErrorBaseAllOf where
  toJSON JsonErrorBaseAllOf {..} =
   _omitNulls
      [ "result" .= jsonErrorBaseAllOfResult
      , "msg" .= jsonErrorBaseAllOfMsg
      ]


-- | Construct a value of type 'JsonErrorBaseAllOf' (by applying it's required fields, if any)
mkJsonErrorBaseAllOf
  :: E'Result2 -- ^ 'jsonErrorBaseAllOfResult' 
  -> Text -- ^ 'jsonErrorBaseAllOfMsg' 
  -> JsonErrorBaseAllOf
mkJsonErrorBaseAllOf jsonErrorBaseAllOfResult jsonErrorBaseAllOfMsg =
  JsonErrorBaseAllOf
  { jsonErrorBaseAllOfResult
  , jsonErrorBaseAllOfMsg
  }

-- ** JsonResponseBase
-- | JsonResponseBase
data JsonResponseBase = JsonResponseBase
  { jsonResponseBaseResult :: !(Maybe Text) -- ^ "result"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JsonResponseBase
instance A.FromJSON JsonResponseBase where
  parseJSON = A.withObject "JsonResponseBase" $ \o ->
    JsonResponseBase
      <$> (o .:? "result")

-- | ToJSON JsonResponseBase
instance A.ToJSON JsonResponseBase where
  toJSON JsonResponseBase {..} =
   _omitNulls
      [ "result" .= jsonResponseBaseResult
      ]


-- | Construct a value of type 'JsonResponseBase' (by applying it's required fields, if any)
mkJsonResponseBase
  :: JsonResponseBase
mkJsonResponseBase =
  JsonResponseBase
  { jsonResponseBaseResult = Nothing
  }

-- ** JsonSuccess
-- | JsonSuccess
data JsonSuccess = JsonSuccess
  { jsonSuccessResult :: !(AnyType) -- ^ /Required/ "result"
  , jsonSuccessMsg :: !(AnyType) -- ^ /Required/ "msg"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JsonSuccess
instance A.FromJSON JsonSuccess where
  parseJSON = A.withObject "JsonSuccess" $ \o ->
    JsonSuccess
      <$> (o .:  "result")
      <*> (o .:  "msg")

-- | ToJSON JsonSuccess
instance A.ToJSON JsonSuccess where
  toJSON JsonSuccess {..} =
   _omitNulls
      [ "result" .= jsonSuccessResult
      , "msg" .= jsonSuccessMsg
      ]


-- | Construct a value of type 'JsonSuccess' (by applying it's required fields, if any)
mkJsonSuccess
  :: AnyType -- ^ 'jsonSuccessResult' 
  -> AnyType -- ^ 'jsonSuccessMsg' 
  -> JsonSuccess
mkJsonSuccess jsonSuccessResult jsonSuccessMsg =
  JsonSuccess
  { jsonSuccessResult
  , jsonSuccessMsg
  }

-- ** JsonSuccessAllOf
-- | JsonSuccessAllOf
data JsonSuccessAllOf = JsonSuccessAllOf
  { jsonSuccessAllOfResult :: !(Maybe AnyType) -- ^ "result"
  , jsonSuccessAllOfMsg :: !(Maybe AnyType) -- ^ "msg"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JsonSuccessAllOf
instance A.FromJSON JsonSuccessAllOf where
  parseJSON = A.withObject "JsonSuccessAllOf" $ \o ->
    JsonSuccessAllOf
      <$> (o .:? "result")
      <*> (o .:? "msg")

-- | ToJSON JsonSuccessAllOf
instance A.ToJSON JsonSuccessAllOf where
  toJSON JsonSuccessAllOf {..} =
   _omitNulls
      [ "result" .= jsonSuccessAllOfResult
      , "msg" .= jsonSuccessAllOfMsg
      ]


-- | Construct a value of type 'JsonSuccessAllOf' (by applying it's required fields, if any)
mkJsonSuccessAllOf
  :: JsonSuccessAllOf
mkJsonSuccessAllOf =
  JsonSuccessAllOf
  { jsonSuccessAllOfResult = Nothing
  , jsonSuccessAllOfMsg = Nothing
  }

-- ** JsonSuccessBase
-- | JsonSuccessBase
data JsonSuccessBase = JsonSuccessBase
  { jsonSuccessBaseResult :: !(E'Result) -- ^ /Required/ "result"
  , jsonSuccessBaseMsg :: !(Text) -- ^ /Required/ "msg"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JsonSuccessBase
instance A.FromJSON JsonSuccessBase where
  parseJSON = A.withObject "JsonSuccessBase" $ \o ->
    JsonSuccessBase
      <$> (o .:  "result")
      <*> (o .:  "msg")

-- | ToJSON JsonSuccessBase
instance A.ToJSON JsonSuccessBase where
  toJSON JsonSuccessBase {..} =
   _omitNulls
      [ "result" .= jsonSuccessBaseResult
      , "msg" .= jsonSuccessBaseMsg
      ]


-- | Construct a value of type 'JsonSuccessBase' (by applying it's required fields, if any)
mkJsonSuccessBase
  :: E'Result -- ^ 'jsonSuccessBaseResult' 
  -> Text -- ^ 'jsonSuccessBaseMsg' 
  -> JsonSuccessBase
mkJsonSuccessBase jsonSuccessBaseResult jsonSuccessBaseMsg =
  JsonSuccessBase
  { jsonSuccessBaseResult
  , jsonSuccessBaseMsg
  }

-- ** JsonSuccessBaseAllOf
-- | JsonSuccessBaseAllOf
data JsonSuccessBaseAllOf = JsonSuccessBaseAllOf
  { jsonSuccessBaseAllOfResult :: !(E'Result) -- ^ /Required/ "result"
  , jsonSuccessBaseAllOfMsg :: !(Text) -- ^ /Required/ "msg"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JsonSuccessBaseAllOf
instance A.FromJSON JsonSuccessBaseAllOf where
  parseJSON = A.withObject "JsonSuccessBaseAllOf" $ \o ->
    JsonSuccessBaseAllOf
      <$> (o .:  "result")
      <*> (o .:  "msg")

-- | ToJSON JsonSuccessBaseAllOf
instance A.ToJSON JsonSuccessBaseAllOf where
  toJSON JsonSuccessBaseAllOf {..} =
   _omitNulls
      [ "result" .= jsonSuccessBaseAllOfResult
      , "msg" .= jsonSuccessBaseAllOfMsg
      ]


-- | Construct a value of type 'JsonSuccessBaseAllOf' (by applying it's required fields, if any)
mkJsonSuccessBaseAllOf
  :: E'Result -- ^ 'jsonSuccessBaseAllOfResult' 
  -> Text -- ^ 'jsonSuccessBaseAllOfMsg' 
  -> JsonSuccessBaseAllOf
mkJsonSuccessBaseAllOf jsonSuccessBaseAllOfResult jsonSuccessBaseAllOfMsg =
  JsonSuccessBaseAllOf
  { jsonSuccessBaseAllOfResult
  , jsonSuccessBaseAllOfMsg
  }

-- ** Messages
-- | Messages
data Messages = Messages
  { messagesAvatarUrl :: !(Maybe AnyType) -- ^ "avatar_url"
  , messagesClient :: !(Maybe AnyType) -- ^ "client"
  , messagesContent :: !(Maybe AnyType) -- ^ "content"
  , messagesContentType :: !(Maybe AnyType) -- ^ "content_type"
  , messagesDisplayRecipient :: !(Maybe AnyType) -- ^ "display_recipient"
  , messagesId :: !(Maybe AnyType) -- ^ "id"
  , messagesIsMeMessage :: !(Maybe AnyType) -- ^ "is_me_message"
  , messagesReactions :: !(Maybe AnyType) -- ^ "reactions"
  , messagesRecipientId :: !(Maybe AnyType) -- ^ "recipient_id"
  , messagesSenderEmail :: !(Maybe AnyType) -- ^ "sender_email"
  , messagesSenderFullName :: !(Maybe AnyType) -- ^ "sender_full_name"
  , messagesSenderId :: !(Maybe AnyType) -- ^ "sender_id"
  , messagesSenderRealmStr :: !(Maybe AnyType) -- ^ "sender_realm_str"
  , messagesStreamId :: !(Maybe AnyType) -- ^ "stream_id"
  , messagesSubject :: !(Maybe AnyType) -- ^ "subject"
  , messagesTopicLinks :: !(Maybe AnyType) -- ^ "topic_links"
  , messagesSubmessages :: !(Maybe AnyType) -- ^ "submessages"
  , messagesTimestamp :: !(Maybe AnyType) -- ^ "timestamp"
  , messagesType :: !(Maybe AnyType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Messages
instance A.FromJSON Messages where
  parseJSON = A.withObject "Messages" $ \o ->
    Messages
      <$> (o .:? "avatar_url")
      <*> (o .:? "client")
      <*> (o .:? "content")
      <*> (o .:? "content_type")
      <*> (o .:? "display_recipient")
      <*> (o .:? "id")
      <*> (o .:? "is_me_message")
      <*> (o .:? "reactions")
      <*> (o .:? "recipient_id")
      <*> (o .:? "sender_email")
      <*> (o .:? "sender_full_name")
      <*> (o .:? "sender_id")
      <*> (o .:? "sender_realm_str")
      <*> (o .:? "stream_id")
      <*> (o .:? "subject")
      <*> (o .:? "topic_links")
      <*> (o .:? "submessages")
      <*> (o .:? "timestamp")
      <*> (o .:? "type")

-- | ToJSON Messages
instance A.ToJSON Messages where
  toJSON Messages {..} =
   _omitNulls
      [ "avatar_url" .= messagesAvatarUrl
      , "client" .= messagesClient
      , "content" .= messagesContent
      , "content_type" .= messagesContentType
      , "display_recipient" .= messagesDisplayRecipient
      , "id" .= messagesId
      , "is_me_message" .= messagesIsMeMessage
      , "reactions" .= messagesReactions
      , "recipient_id" .= messagesRecipientId
      , "sender_email" .= messagesSenderEmail
      , "sender_full_name" .= messagesSenderFullName
      , "sender_id" .= messagesSenderId
      , "sender_realm_str" .= messagesSenderRealmStr
      , "stream_id" .= messagesStreamId
      , "subject" .= messagesSubject
      , "topic_links" .= messagesTopicLinks
      , "submessages" .= messagesSubmessages
      , "timestamp" .= messagesTimestamp
      , "type" .= messagesType
      ]


-- | Construct a value of type 'Messages' (by applying it's required fields, if any)
mkMessages
  :: Messages
mkMessages =
  Messages
  { messagesAvatarUrl = Nothing
  , messagesClient = Nothing
  , messagesContent = Nothing
  , messagesContentType = Nothing
  , messagesDisplayRecipient = Nothing
  , messagesId = Nothing
  , messagesIsMeMessage = Nothing
  , messagesReactions = Nothing
  , messagesRecipientId = Nothing
  , messagesSenderEmail = Nothing
  , messagesSenderFullName = Nothing
  , messagesSenderId = Nothing
  , messagesSenderRealmStr = Nothing
  , messagesStreamId = Nothing
  , messagesSubject = Nothing
  , messagesTopicLinks = Nothing
  , messagesSubmessages = Nothing
  , messagesTimestamp = Nothing
  , messagesType = Nothing
  }

-- ** MessagesAllOf
-- | MessagesAllOf
data MessagesAllOf = MessagesAllOf
  { messagesAllOfAvatarUrl :: !(Maybe AnyType) -- ^ "avatar_url"
  , messagesAllOfClient :: !(Maybe AnyType) -- ^ "client"
  , messagesAllOfContent :: !(Maybe AnyType) -- ^ "content"
  , messagesAllOfContentType :: !(Maybe AnyType) -- ^ "content_type"
  , messagesAllOfDisplayRecipient :: !(Maybe AnyType) -- ^ "display_recipient"
  , messagesAllOfId :: !(Maybe AnyType) -- ^ "id"
  , messagesAllOfIsMeMessage :: !(Maybe AnyType) -- ^ "is_me_message"
  , messagesAllOfReactions :: !(Maybe AnyType) -- ^ "reactions"
  , messagesAllOfRecipientId :: !(Maybe AnyType) -- ^ "recipient_id"
  , messagesAllOfSenderEmail :: !(Maybe AnyType) -- ^ "sender_email"
  , messagesAllOfSenderFullName :: !(Maybe AnyType) -- ^ "sender_full_name"
  , messagesAllOfSenderId :: !(Maybe AnyType) -- ^ "sender_id"
  , messagesAllOfSenderRealmStr :: !(Maybe AnyType) -- ^ "sender_realm_str"
  , messagesAllOfStreamId :: !(Maybe AnyType) -- ^ "stream_id"
  , messagesAllOfSubject :: !(Maybe AnyType) -- ^ "subject"
  , messagesAllOfTopicLinks :: !(Maybe AnyType) -- ^ "topic_links"
  , messagesAllOfSubmessages :: !(Maybe AnyType) -- ^ "submessages"
  , messagesAllOfTimestamp :: !(Maybe AnyType) -- ^ "timestamp"
  , messagesAllOfType :: !(Maybe AnyType) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessagesAllOf
instance A.FromJSON MessagesAllOf where
  parseJSON = A.withObject "MessagesAllOf" $ \o ->
    MessagesAllOf
      <$> (o .:? "avatar_url")
      <*> (o .:? "client")
      <*> (o .:? "content")
      <*> (o .:? "content_type")
      <*> (o .:? "display_recipient")
      <*> (o .:? "id")
      <*> (o .:? "is_me_message")
      <*> (o .:? "reactions")
      <*> (o .:? "recipient_id")
      <*> (o .:? "sender_email")
      <*> (o .:? "sender_full_name")
      <*> (o .:? "sender_id")
      <*> (o .:? "sender_realm_str")
      <*> (o .:? "stream_id")
      <*> (o .:? "subject")
      <*> (o .:? "topic_links")
      <*> (o .:? "submessages")
      <*> (o .:? "timestamp")
      <*> (o .:? "type")

-- | ToJSON MessagesAllOf
instance A.ToJSON MessagesAllOf where
  toJSON MessagesAllOf {..} =
   _omitNulls
      [ "avatar_url" .= messagesAllOfAvatarUrl
      , "client" .= messagesAllOfClient
      , "content" .= messagesAllOfContent
      , "content_type" .= messagesAllOfContentType
      , "display_recipient" .= messagesAllOfDisplayRecipient
      , "id" .= messagesAllOfId
      , "is_me_message" .= messagesAllOfIsMeMessage
      , "reactions" .= messagesAllOfReactions
      , "recipient_id" .= messagesAllOfRecipientId
      , "sender_email" .= messagesAllOfSenderEmail
      , "sender_full_name" .= messagesAllOfSenderFullName
      , "sender_id" .= messagesAllOfSenderId
      , "sender_realm_str" .= messagesAllOfSenderRealmStr
      , "stream_id" .= messagesAllOfStreamId
      , "subject" .= messagesAllOfSubject
      , "topic_links" .= messagesAllOfTopicLinks
      , "submessages" .= messagesAllOfSubmessages
      , "timestamp" .= messagesAllOfTimestamp
      , "type" .= messagesAllOfType
      ]


-- | Construct a value of type 'MessagesAllOf' (by applying it's required fields, if any)
mkMessagesAllOf
  :: MessagesAllOf
mkMessagesAllOf =
  MessagesAllOf
  { messagesAllOfAvatarUrl = Nothing
  , messagesAllOfClient = Nothing
  , messagesAllOfContent = Nothing
  , messagesAllOfContentType = Nothing
  , messagesAllOfDisplayRecipient = Nothing
  , messagesAllOfId = Nothing
  , messagesAllOfIsMeMessage = Nothing
  , messagesAllOfReactions = Nothing
  , messagesAllOfRecipientId = Nothing
  , messagesAllOfSenderEmail = Nothing
  , messagesAllOfSenderFullName = Nothing
  , messagesAllOfSenderId = Nothing
  , messagesAllOfSenderRealmStr = Nothing
  , messagesAllOfStreamId = Nothing
  , messagesAllOfSubject = Nothing
  , messagesAllOfTopicLinks = Nothing
  , messagesAllOfSubmessages = Nothing
  , messagesAllOfTimestamp = Nothing
  , messagesAllOfType = Nothing
  }

-- ** MessagesBase
-- | MessagesBase
-- Object containing details of the message. 
data MessagesBase = MessagesBase
  { messagesBaseAvatarUrl :: !(Maybe Text) -- ^ "avatar_url" - The URL of the user&#39;s avatar.  Can be null only if client_gravatar was passed, which means that the user has not uploaded an avatar in Zulip, and the client should compute the gravatar URL by hashing the user&#39;s email address itself for this user. 
  , messagesBaseClient :: !(Maybe Text) -- ^ "client" - A Zulip \&quot;client\&quot; string, describing what Zulip client sent the message. 
  , messagesBaseContent :: !(Maybe Text) -- ^ "content" - The content/body of the message. 
  , messagesBaseContentType :: !(Maybe Text) -- ^ "content_type" - The HTTP &#x60;content_type&#x60; for the message content.  This will be &#x60;text/html&#x60; or &#x60;text/x-markdown&#x60;, depending on whether &#x60;apply_markdown&#x60; was set. 
  , messagesBaseDisplayRecipient :: !(Maybe OneOfstringarray) -- ^ "display_recipient" - Data on the recipient of the message; either the name of a stream or a dictionary containing basic data on the users who received the message. 
  , messagesBaseId :: !(Maybe Int) -- ^ "id" - The unique message ID.  Messages should always be displayed sorted by ID. 
  , messagesBaseIsMeMessage :: !(Maybe Bool) -- ^ "is_me_message" - Whether the message is a [/me status message][status-messages]  [status-messages]: /help/format-your-message-using-markdown#status-messages 
  , messagesBaseReactions :: !(Maybe [EmojiReaction]) -- ^ "reactions" - Data on any reactions to the message. 
  , messagesBaseRecipientId :: !(Maybe Int) -- ^ "recipient_id" - A unique ID for the set of users receiving the message (either a stream or group of users).  Useful primarily for hashing. 
  , messagesBaseSenderEmail :: !(Maybe Text) -- ^ "sender_email" - The Zulip display email address of the message&#39;s sender. 
  , messagesBaseSenderFullName :: !(Maybe Text) -- ^ "sender_full_name" - The full name of the message&#39;s sender. 
  , messagesBaseSenderId :: !(Maybe Int) -- ^ "sender_id" - The user ID of the message&#39;s sender. 
  , messagesBaseSenderRealmStr :: !(Maybe Text) -- ^ "sender_realm_str" - A string identifier for the realm the sender is in.  Unique only within the context of a given Zulip server.  E.g. on &#x60;example.zulip.com&#x60;, this will be &#x60;example&#x60;. 
  , messagesBaseStreamId :: !(Maybe Int) -- ^ "stream_id" - Only present for stream messages; the ID of the stream. 
  , messagesBaseSubject :: !(Maybe Text) -- ^ "subject" - The &#x60;topic&#x60; of the message.  Currently always &#x60;\&quot;\&quot;&#x60; for private messages, though this could change if Zulip adds support for topics in private message conversations.  The field name is a legacy holdover from when topics were called \&quot;subjects\&quot; and will eventually change. 
  , messagesBaseTopicLinks :: !(Maybe [MessagesBaseTopicLinks]) -- ^ "topic_links" - Data on any links to be included in the &#x60;topic&#x60; line (these are generated by [custom linkification filters](/help/add-a-custom-linkifier) that match content in the message&#39;s topic.)  **Changes**: This field contained a list of urls before   Zulip 4.0 (feature level 46).  New in Zulip 3.0 (feature level 1): Previously, this field was called &#x60;subject_links&#x60;; clients are recommended to rename &#x60;subject_links&#x60; to &#x60;topic_links&#x60; if present for compatibility with older Zulip servers. 
  , messagesBaseSubmessages :: !(Maybe [Text]) -- ^ "submessages" - Data used for certain experimental Zulip integrations. 
  , messagesBaseTimestamp :: !(Maybe Int) -- ^ "timestamp" - The UNIX timestamp for when the message was sent, in UTC seconds. 
  , messagesBaseType :: !(Maybe Text) -- ^ "type" - The type of the message: &#x60;stream&#x60; or &#x60;private&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessagesBase
instance A.FromJSON MessagesBase where
  parseJSON = A.withObject "MessagesBase" $ \o ->
    MessagesBase
      <$> (o .:? "avatar_url")
      <*> (o .:? "client")
      <*> (o .:? "content")
      <*> (o .:? "content_type")
      <*> (o .:? "display_recipient")
      <*> (o .:? "id")
      <*> (o .:? "is_me_message")
      <*> (o .:? "reactions")
      <*> (o .:? "recipient_id")
      <*> (o .:? "sender_email")
      <*> (o .:? "sender_full_name")
      <*> (o .:? "sender_id")
      <*> (o .:? "sender_realm_str")
      <*> (o .:? "stream_id")
      <*> (o .:? "subject")
      <*> (o .:? "topic_links")
      <*> (o .:? "submessages")
      <*> (o .:? "timestamp")
      <*> (o .:? "type")

-- | ToJSON MessagesBase
instance A.ToJSON MessagesBase where
  toJSON MessagesBase {..} =
   _omitNulls
      [ "avatar_url" .= messagesBaseAvatarUrl
      , "client" .= messagesBaseClient
      , "content" .= messagesBaseContent
      , "content_type" .= messagesBaseContentType
      , "display_recipient" .= messagesBaseDisplayRecipient
      , "id" .= messagesBaseId
      , "is_me_message" .= messagesBaseIsMeMessage
      , "reactions" .= messagesBaseReactions
      , "recipient_id" .= messagesBaseRecipientId
      , "sender_email" .= messagesBaseSenderEmail
      , "sender_full_name" .= messagesBaseSenderFullName
      , "sender_id" .= messagesBaseSenderId
      , "sender_realm_str" .= messagesBaseSenderRealmStr
      , "stream_id" .= messagesBaseStreamId
      , "subject" .= messagesBaseSubject
      , "topic_links" .= messagesBaseTopicLinks
      , "submessages" .= messagesBaseSubmessages
      , "timestamp" .= messagesBaseTimestamp
      , "type" .= messagesBaseType
      ]


-- | Construct a value of type 'MessagesBase' (by applying it's required fields, if any)
mkMessagesBase
  :: MessagesBase
mkMessagesBase =
  MessagesBase
  { messagesBaseAvatarUrl = Nothing
  , messagesBaseClient = Nothing
  , messagesBaseContent = Nothing
  , messagesBaseContentType = Nothing
  , messagesBaseDisplayRecipient = Nothing
  , messagesBaseId = Nothing
  , messagesBaseIsMeMessage = Nothing
  , messagesBaseReactions = Nothing
  , messagesBaseRecipientId = Nothing
  , messagesBaseSenderEmail = Nothing
  , messagesBaseSenderFullName = Nothing
  , messagesBaseSenderId = Nothing
  , messagesBaseSenderRealmStr = Nothing
  , messagesBaseStreamId = Nothing
  , messagesBaseSubject = Nothing
  , messagesBaseTopicLinks = Nothing
  , messagesBaseSubmessages = Nothing
  , messagesBaseTimestamp = Nothing
  , messagesBaseType = Nothing
  }

-- ** MessagesBaseTopicLinks
-- | MessagesBaseTopicLinks
data MessagesBaseTopicLinks = MessagesBaseTopicLinks
  { messagesBaseTopicLinksText :: !(Maybe Text) -- ^ "text" - The original link text present in the topic. 
  , messagesBaseTopicLinksUrl :: !(Maybe Text) -- ^ "url" - The expanded target url which the link points to. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessagesBaseTopicLinks
instance A.FromJSON MessagesBaseTopicLinks where
  parseJSON = A.withObject "MessagesBaseTopicLinks" $ \o ->
    MessagesBaseTopicLinks
      <$> (o .:? "text")
      <*> (o .:? "url")

-- | ToJSON MessagesBaseTopicLinks
instance A.ToJSON MessagesBaseTopicLinks where
  toJSON MessagesBaseTopicLinks {..} =
   _omitNulls
      [ "text" .= messagesBaseTopicLinksText
      , "url" .= messagesBaseTopicLinksUrl
      ]


-- | Construct a value of type 'MessagesBaseTopicLinks' (by applying it's required fields, if any)
mkMessagesBaseTopicLinks
  :: MessagesBaseTopicLinks
mkMessagesBaseTopicLinks =
  MessagesBaseTopicLinks
  { messagesBaseTopicLinksText = Nothing
  , messagesBaseTopicLinksUrl = Nothing
  }

-- ** MissingArgumentError
-- | MissingArgumentError
data MissingArgumentError = MissingArgumentError
  { missingArgumentErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , missingArgumentErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  , missingArgumentErrorCode :: !(Maybe AnyType) -- ^ "code"
  , missingArgumentErrorVarName :: !(Maybe Text) -- ^ "var_name" - It contains the information about the missing parameter. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MissingArgumentError
instance A.FromJSON MissingArgumentError where
  parseJSON = A.withObject "MissingArgumentError" $ \o ->
    MissingArgumentError
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "code")
      <*> (o .:? "var_name")

-- | ToJSON MissingArgumentError
instance A.ToJSON MissingArgumentError where
  toJSON MissingArgumentError {..} =
   _omitNulls
      [ "result" .= missingArgumentErrorResult
      , "msg" .= missingArgumentErrorMsg
      , "code" .= missingArgumentErrorCode
      , "var_name" .= missingArgumentErrorVarName
      ]


-- | Construct a value of type 'MissingArgumentError' (by applying it's required fields, if any)
mkMissingArgumentError
  :: AnyType -- ^ 'missingArgumentErrorResult' 
  -> AnyType -- ^ 'missingArgumentErrorMsg' 
  -> MissingArgumentError
mkMissingArgumentError missingArgumentErrorResult missingArgumentErrorMsg =
  MissingArgumentError
  { missingArgumentErrorResult
  , missingArgumentErrorMsg
  , missingArgumentErrorCode = Nothing
  , missingArgumentErrorVarName = Nothing
  }

-- ** MissingArgumentErrorAllOf
-- | MissingArgumentErrorAllOf
-- ## Missing request parameter(s)  A typical failed JSON response for when a required request parameter is not supplied 
data MissingArgumentErrorAllOf = MissingArgumentErrorAllOf
  { missingArgumentErrorAllOfResult :: !(Maybe AnyType) -- ^ "result"
  , missingArgumentErrorAllOfMsg :: !(Maybe AnyType) -- ^ "msg"
  , missingArgumentErrorAllOfCode :: !(Maybe AnyType) -- ^ "code"
  , missingArgumentErrorAllOfVarName :: !(Maybe Text) -- ^ "var_name" - It contains the information about the missing parameter. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MissingArgumentErrorAllOf
instance A.FromJSON MissingArgumentErrorAllOf where
  parseJSON = A.withObject "MissingArgumentErrorAllOf" $ \o ->
    MissingArgumentErrorAllOf
      <$> (o .:? "result")
      <*> (o .:? "msg")
      <*> (o .:? "code")
      <*> (o .:? "var_name")

-- | ToJSON MissingArgumentErrorAllOf
instance A.ToJSON MissingArgumentErrorAllOf where
  toJSON MissingArgumentErrorAllOf {..} =
   _omitNulls
      [ "result" .= missingArgumentErrorAllOfResult
      , "msg" .= missingArgumentErrorAllOfMsg
      , "code" .= missingArgumentErrorAllOfCode
      , "var_name" .= missingArgumentErrorAllOfVarName
      ]


-- | Construct a value of type 'MissingArgumentErrorAllOf' (by applying it's required fields, if any)
mkMissingArgumentErrorAllOf
  :: MissingArgumentErrorAllOf
mkMissingArgumentErrorAllOf =
  MissingArgumentErrorAllOf
  { missingArgumentErrorAllOfResult = Nothing
  , missingArgumentErrorAllOfMsg = Nothing
  , missingArgumentErrorAllOfCode = Nothing
  , missingArgumentErrorAllOfVarName = Nothing
  }

-- ** NonExistingStreamError
-- | NonExistingStreamError
data NonExistingStreamError = NonExistingStreamError
  { nonExistingStreamErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , nonExistingStreamErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  , nonExistingStreamErrorCode :: !(Maybe AnyType) -- ^ "code"
  , nonExistingStreamErrorStream :: !(Maybe Text) -- ^ "stream" - The name of the stream that could not be found. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NonExistingStreamError
instance A.FromJSON NonExistingStreamError where
  parseJSON = A.withObject "NonExistingStreamError" $ \o ->
    NonExistingStreamError
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "code")
      <*> (o .:? "stream")

-- | ToJSON NonExistingStreamError
instance A.ToJSON NonExistingStreamError where
  toJSON NonExistingStreamError {..} =
   _omitNulls
      [ "result" .= nonExistingStreamErrorResult
      , "msg" .= nonExistingStreamErrorMsg
      , "code" .= nonExistingStreamErrorCode
      , "stream" .= nonExistingStreamErrorStream
      ]


-- | Construct a value of type 'NonExistingStreamError' (by applying it's required fields, if any)
mkNonExistingStreamError
  :: AnyType -- ^ 'nonExistingStreamErrorResult' 
  -> AnyType -- ^ 'nonExistingStreamErrorMsg' 
  -> NonExistingStreamError
mkNonExistingStreamError nonExistingStreamErrorResult nonExistingStreamErrorMsg =
  NonExistingStreamError
  { nonExistingStreamErrorResult
  , nonExistingStreamErrorMsg
  , nonExistingStreamErrorCode = Nothing
  , nonExistingStreamErrorStream = Nothing
  }

-- ** NonExistingStreamErrorAllOf
-- | NonExistingStreamErrorAllOf
data NonExistingStreamErrorAllOf = NonExistingStreamErrorAllOf
  { nonExistingStreamErrorAllOfResult :: !(Maybe AnyType) -- ^ "result"
  , nonExistingStreamErrorAllOfMsg :: !(Maybe AnyType) -- ^ "msg"
  , nonExistingStreamErrorAllOfCode :: !(Maybe AnyType) -- ^ "code"
  , nonExistingStreamErrorAllOfStream :: !(Maybe Text) -- ^ "stream" - The name of the stream that could not be found. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NonExistingStreamErrorAllOf
instance A.FromJSON NonExistingStreamErrorAllOf where
  parseJSON = A.withObject "NonExistingStreamErrorAllOf" $ \o ->
    NonExistingStreamErrorAllOf
      <$> (o .:? "result")
      <*> (o .:? "msg")
      <*> (o .:? "code")
      <*> (o .:? "stream")

-- | ToJSON NonExistingStreamErrorAllOf
instance A.ToJSON NonExistingStreamErrorAllOf where
  toJSON NonExistingStreamErrorAllOf {..} =
   _omitNulls
      [ "result" .= nonExistingStreamErrorAllOfResult
      , "msg" .= nonExistingStreamErrorAllOfMsg
      , "code" .= nonExistingStreamErrorAllOfCode
      , "stream" .= nonExistingStreamErrorAllOfStream
      ]


-- | Construct a value of type 'NonExistingStreamErrorAllOf' (by applying it's required fields, if any)
mkNonExistingStreamErrorAllOf
  :: NonExistingStreamErrorAllOf
mkNonExistingStreamErrorAllOf =
  NonExistingStreamErrorAllOf
  { nonExistingStreamErrorAllOfResult = Nothing
  , nonExistingStreamErrorAllOfMsg = Nothing
  , nonExistingStreamErrorAllOfCode = Nothing
  , nonExistingStreamErrorAllOfStream = Nothing
  }

-- ** Presence
-- | Presence
-- `{client_name}`: Object containing the details of the user's presence on a particular platform with the client's platform name being the object key. 
data Presence = Presence
  { presenceClient :: !(Maybe Text) -- ^ "client" - The client&#39;s platform name. 
  , presenceStatus :: !(Maybe E'Status) -- ^ "status" - The status of the user on this client. It is either &#x60;idle&#x60; or &#x60;active&#x60;. 
  , presenceTimestamp :: !(Maybe Int) -- ^ "timestamp" - The UNIX timestamp of when this client sent the user&#39;s presence to the server with the precision of a second. 
  , presencePushable :: !(Maybe Bool) -- ^ "pushable" - Whether the client is capable of showing mobile/push notifications to the user. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Presence
instance A.FromJSON Presence where
  parseJSON = A.withObject "Presence" $ \o ->
    Presence
      <$> (o .:? "client")
      <*> (o .:? "status")
      <*> (o .:? "timestamp")
      <*> (o .:? "pushable")

-- | ToJSON Presence
instance A.ToJSON Presence where
  toJSON Presence {..} =
   _omitNulls
      [ "client" .= presenceClient
      , "status" .= presenceStatus
      , "timestamp" .= presenceTimestamp
      , "pushable" .= presencePushable
      ]


-- | Construct a value of type 'Presence' (by applying it's required fields, if any)
mkPresence
  :: Presence
mkPresence =
  Presence
  { presenceClient = Nothing
  , presenceStatus = Nothing
  , presenceTimestamp = Nothing
  , presencePushable = Nothing
  }

-- ** RateLimitedError
-- | RateLimitedError
data RateLimitedError = RateLimitedError
  { rateLimitedErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , rateLimitedErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  , rateLimitedErrorCode :: !(Maybe AnyType) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RateLimitedError
instance A.FromJSON RateLimitedError where
  parseJSON = A.withObject "RateLimitedError" $ \o ->
    RateLimitedError
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "code")

-- | ToJSON RateLimitedError
instance A.ToJSON RateLimitedError where
  toJSON RateLimitedError {..} =
   _omitNulls
      [ "result" .= rateLimitedErrorResult
      , "msg" .= rateLimitedErrorMsg
      , "code" .= rateLimitedErrorCode
      ]


-- | Construct a value of type 'RateLimitedError' (by applying it's required fields, if any)
mkRateLimitedError
  :: AnyType -- ^ 'rateLimitedErrorResult' 
  -> AnyType -- ^ 'rateLimitedErrorMsg' 
  -> RateLimitedError
mkRateLimitedError rateLimitedErrorResult rateLimitedErrorMsg =
  RateLimitedError
  { rateLimitedErrorResult
  , rateLimitedErrorMsg
  , rateLimitedErrorCode = Nothing
  }

-- ** RealmDeactivatedError
-- | RealmDeactivatedError
data RealmDeactivatedError = RealmDeactivatedError
  { realmDeactivatedErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , realmDeactivatedErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  , realmDeactivatedErrorCode :: !(Maybe AnyType) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RealmDeactivatedError
instance A.FromJSON RealmDeactivatedError where
  parseJSON = A.withObject "RealmDeactivatedError" $ \o ->
    RealmDeactivatedError
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "code")

-- | ToJSON RealmDeactivatedError
instance A.ToJSON RealmDeactivatedError where
  toJSON RealmDeactivatedError {..} =
   _omitNulls
      [ "result" .= realmDeactivatedErrorResult
      , "msg" .= realmDeactivatedErrorMsg
      , "code" .= realmDeactivatedErrorCode
      ]


-- | Construct a value of type 'RealmDeactivatedError' (by applying it's required fields, if any)
mkRealmDeactivatedError
  :: AnyType -- ^ 'realmDeactivatedErrorResult' 
  -> AnyType -- ^ 'realmDeactivatedErrorMsg' 
  -> RealmDeactivatedError
mkRealmDeactivatedError realmDeactivatedErrorResult realmDeactivatedErrorMsg =
  RealmDeactivatedError
  { realmDeactivatedErrorResult
  , realmDeactivatedErrorMsg
  , realmDeactivatedErrorCode = Nothing
  }

-- ** RealmDomain
-- | RealmDomain
-- Object containing details of the newly added domain. 
data RealmDomain = RealmDomain
  { realmDomainDomain :: !(Maybe Text) -- ^ "domain" - The new allowed domain. 
  , realmDomainAllowSubdomains :: !(Maybe Bool) -- ^ "allow_subdomains" - Whether subdomains are allowed for this domain. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RealmDomain
instance A.FromJSON RealmDomain where
  parseJSON = A.withObject "RealmDomain" $ \o ->
    RealmDomain
      <$> (o .:? "domain")
      <*> (o .:? "allow_subdomains")

-- | ToJSON RealmDomain
instance A.ToJSON RealmDomain where
  toJSON RealmDomain {..} =
   _omitNulls
      [ "domain" .= realmDomainDomain
      , "allow_subdomains" .= realmDomainAllowSubdomains
      ]


-- | Construct a value of type 'RealmDomain' (by applying it's required fields, if any)
mkRealmDomain
  :: RealmDomain
mkRealmDomain =
  RealmDomain
  { realmDomainDomain = Nothing
  , realmDomainAllowSubdomains = Nothing
  }

-- ** RealmEmoji
-- | RealmEmoji
-- `{emoji_id}`: Object containing details about the emoji with  the specified ID. It has the following properties: 
data RealmEmoji = RealmEmoji
  { realmEmojiId :: !(Maybe Text) -- ^ "id" - The ID for this emoji, same as the object&#39;s key. 
  , realmEmojiName :: !(Maybe Text) -- ^ "name" - The user-friendly name for this emoji. Users in the organization can use this emoji by writing this name between colons (&#x60;:name  :&#x60;). 
  , realmEmojiSourceUrl :: !(Maybe Text) -- ^ "source_url" - The path relative to the organization&#39;s URL where the emoji&#39;s image can be found. 
  , realmEmojiDeactivated :: !(Maybe Bool) -- ^ "deactivated" - Whether the emoji has been deactivated or not. 
  , realmEmojiAuthorId :: !(Maybe Int) -- ^ "author_id" - The user ID of the user who uploaded the custom emoji. Will be null if the uploader is unknown.  **Changes**: New in Zulip 3.0 (feature level 7).  Previously was accessible via and &#x60;author&#x60; object with an &#x60;id&#x60; field. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RealmEmoji
instance A.FromJSON RealmEmoji where
  parseJSON = A.withObject "RealmEmoji" $ \o ->
    RealmEmoji
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "source_url")
      <*> (o .:? "deactivated")
      <*> (o .:? "author_id")

-- | ToJSON RealmEmoji
instance A.ToJSON RealmEmoji where
  toJSON RealmEmoji {..} =
   _omitNulls
      [ "id" .= realmEmojiId
      , "name" .= realmEmojiName
      , "source_url" .= realmEmojiSourceUrl
      , "deactivated" .= realmEmojiDeactivated
      , "author_id" .= realmEmojiAuthorId
      ]


-- | Construct a value of type 'RealmEmoji' (by applying it's required fields, if any)
mkRealmEmoji
  :: RealmEmoji
mkRealmEmoji =
  RealmEmoji
  { realmEmojiId = Nothing
  , realmEmojiName = Nothing
  , realmEmojiSourceUrl = Nothing
  , realmEmojiDeactivated = Nothing
  , realmEmojiAuthorId = Nothing
  }

-- ** RealmExport
-- | RealmExport
-- Object containing details about a realm export. 
data RealmExport = RealmExport
  { realmExportId :: !(Maybe Int) -- ^ "id" - The id of the export. 
  , realmExportActingUserId :: !(Maybe Int) -- ^ "acting_user_id" - The id of the user who did the export. 
  , realmExportExportTime :: !(Maybe Double) -- ^ "export_time" - The UNIX timestamp of when the export was made. 
  , realmExportDeletedTimestamp :: !(Maybe Double) -- ^ "deleted_timestamp" - The timestamp of when the export was deleted. Null if it wasn&#39;t. 
  , realmExportFailedTimestamp :: !(Maybe Double) -- ^ "failed_timestamp" - The timestamp of when the export failed. Null if it didn&#39;t. 
  , realmExportExportUrl :: !(Maybe Text) -- ^ "export_url" - The URL of the export. &#x60;null&#x60; if there&#39;s no URL. 
  , realmExportPending :: !(Maybe Bool) -- ^ "pending" - Whether the export is pending or not. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RealmExport
instance A.FromJSON RealmExport where
  parseJSON = A.withObject "RealmExport" $ \o ->
    RealmExport
      <$> (o .:? "id")
      <*> (o .:? "acting_user_id")
      <*> (o .:? "export_time")
      <*> (o .:? "deleted_timestamp")
      <*> (o .:? "failed_timestamp")
      <*> (o .:? "export_url")
      <*> (o .:? "pending")

-- | ToJSON RealmExport
instance A.ToJSON RealmExport where
  toJSON RealmExport {..} =
   _omitNulls
      [ "id" .= realmExportId
      , "acting_user_id" .= realmExportActingUserId
      , "export_time" .= realmExportExportTime
      , "deleted_timestamp" .= realmExportDeletedTimestamp
      , "failed_timestamp" .= realmExportFailedTimestamp
      , "export_url" .= realmExportExportUrl
      , "pending" .= realmExportPending
      ]


-- | Construct a value of type 'RealmExport' (by applying it's required fields, if any)
mkRealmExport
  :: RealmExport
mkRealmExport =
  RealmExport
  { realmExportId = Nothing
  , realmExportActingUserId = Nothing
  , realmExportExportTime = Nothing
  , realmExportDeletedTimestamp = Nothing
  , realmExportFailedTimestamp = Nothing
  , realmExportExportUrl = Nothing
  , realmExportPending = Nothing
  }

-- ** RealmPlayground
-- | RealmPlayground
-- Object containing details about a realm playground. 
data RealmPlayground = RealmPlayground
  { realmPlaygroundId :: !(Maybe Int) -- ^ "id" - The unique ID for the realm playground. 
  , realmPlaygroundName :: !(Maybe Text) -- ^ "name" - The user-visible display name of the playground.  Clients should display this in UI for picking which playground to open a code block in, to differentiate between multiple configured playground options for a given pygments language.  **Changes**: New in Zulip 4.0 (feature level 49). 
  , realmPlaygroundPygmentsLanguage :: !(Maybe Text) -- ^ "pygments_language" - The name of the Pygments language lexer for that programming language. 
  , realmPlaygroundUrlPrefix :: !(Maybe Text) -- ^ "url_prefix" - The url prefix for the playground. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RealmPlayground
instance A.FromJSON RealmPlayground where
  parseJSON = A.withObject "RealmPlayground" $ \o ->
    RealmPlayground
      <$> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "pygments_language")
      <*> (o .:? "url_prefix")

-- | ToJSON RealmPlayground
instance A.ToJSON RealmPlayground where
  toJSON RealmPlayground {..} =
   _omitNulls
      [ "id" .= realmPlaygroundId
      , "name" .= realmPlaygroundName
      , "pygments_language" .= realmPlaygroundPygmentsLanguage
      , "url_prefix" .= realmPlaygroundUrlPrefix
      ]


-- | Construct a value of type 'RealmPlayground' (by applying it's required fields, if any)
mkRealmPlayground
  :: RealmPlayground
mkRealmPlayground =
  RealmPlayground
  { realmPlaygroundId = Nothing
  , realmPlaygroundName = Nothing
  , realmPlaygroundPygmentsLanguage = Nothing
  , realmPlaygroundUrlPrefix = Nothing
  }

-- ** Subscriptions
-- | Subscriptions
data Subscriptions = Subscriptions
  { subscriptionsStreamId :: !(Maybe Int) -- ^ "stream_id" - The unique ID of a stream. 
  , subscriptionsName :: !(Maybe Text) -- ^ "name" - The name of a stream. 
  , subscriptionsDescription :: !(Maybe Text) -- ^ "description" - The short description of a stream in text/markdown format, intended to be used to prepopulate UI for editing a stream&#39;s description. 
  , subscriptionsRenderedDescription :: !(Maybe Text) -- ^ "rendered_description" - A short description of a stream rendered as HTML, intended to be used when displaying the stream description in a UI.  One should use the standard Zulip rendered_markdown CSS when displaying this content so that emoji, LaTeX, and other syntax work correctly.  And any client-side security logic for user-generated message content should be applied when displaying this HTML as though it were the body of a Zulip message. 
  , subscriptionsDateCreated :: !(Maybe Int) -- ^ "date_created" - The UNIX timestamp for when the stream was created, in UTC seconds.  **Changes**: New in Zulip 4.0 (feature level 30). 
  , subscriptionsInviteOnly :: !(Maybe Bool) -- ^ "invite_only" - Specifies whether the stream is private or not. Only people who have been invited can access a private stream. 
  , subscriptionsSubscribers :: !(Maybe [Int]) -- ^ "subscribers" - A list of user IDs of users who are also subscribed to a given stream. Included only if &#x60;include_subscribers&#x60; is &#x60;true&#x60;. 
  , subscriptionsDesktopNotifications :: !(Maybe Bool) -- ^ "desktop_notifications" - A boolean specifying whether desktop notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_desktop_notifications, for this stream. 
  , subscriptionsEmailNotifications :: !(Maybe Bool) -- ^ "email_notifications" - A boolean specifying whether email notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_email_notifications, for this stream. 
  , subscriptionsWildcardMentionsNotify :: !(Maybe Bool) -- ^ "wildcard_mentions_notify" - A boolean specifying whether wildcard mentions trigger notifications as though they were personal mentions in this stream.  A null value means the value of this setting should be inherited from the user-level default setting, wildcard_mentions_notify, for this stream. 
  , subscriptionsPushNotifications :: !(Maybe Bool) -- ^ "push_notifications" - A boolean specifying whether push notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_push_notifications, for this stream. 
  , subscriptionsAudibleNotifications :: !(Maybe Bool) -- ^ "audible_notifications" - A boolean specifying whether audible notifications are enabled for the given stream.  A null value means the value of this setting should be inherited from the user-level default setting, enable_stream_audible_notifications, for this stream. 
  , subscriptionsPinToTop :: !(Maybe Bool) -- ^ "pin_to_top" - A boolean specifying whether the given stream has been pinned to the top. 
  , subscriptionsEmailAddress :: !(Maybe Text) -- ^ "email_address" - Email address of the given stream, used for [sending emails to the stream](/help/message-a-stream-by-email). 
  , subscriptionsIsMuted :: !(Maybe Bool) -- ^ "is_muted" - Whether the user has muted the stream. Muted streams do not count towards your total unread count and do not show up in &#x60;All messages&#x60; view (previously known as &#x60;Home&#x60; view).  **Changes**: Prior to Zulip 2.1, this feature was represented by the more confusingly named &#x60;in_home_view&#x60; (with the opposite value, &#x60;in_home_view&#x3D;!is_muted&#x60;). 
  , subscriptionsInHomeView :: !(Maybe Bool) -- ^ "in_home_view" - Legacy property for if the given stream is muted, with inverted meeting.  **Deprecated**; clients should use is_muted where available. 
  , subscriptionsIsAnnouncementOnly :: !(Maybe Bool) -- ^ "is_announcement_only" - Whether only organization administrators can post to the stream.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use &#x60;stream_post_policy&#x60; instead. 
  , subscriptionsIsWebPublic :: !(Maybe Bool) -- ^ "is_web_public" - Whether the stream has been configured to allow unauthenticated access to its message history from the web. 
  , subscriptionsRole :: !(Maybe E'Role) -- ^ "role" - The user&#39;s role within the stream (distinct from the user&#39;s [organization-level role](/help/roles-and-permissions)). Valid values are:  * 20 &#x3D;&gt; Stream administrator. * 50 &#x3D;&gt; Subscriber.  **Changes**: New in Zulip 4.0 (feature level 31). 
  , subscriptionsColor :: !(Maybe Text) -- ^ "color" - The user&#39;s personal color for the stream. 
  , subscriptionsStreamPostPolicy :: !(Maybe Int) -- ^ "stream_post_policy" - Policy for which users can post messages to the stream.  * 1 &#x3D;&gt; Any user can post. * 2 &#x3D;&gt; Only administrators can post. * 3 &#x3D;&gt; Only full members can post. * 4 &#x3D;&gt; Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous &#x60;is_announcement_only&#x60; boolean. 
  , subscriptionsMessageRetentionDays :: !(Maybe Int) -- ^ "message_retention_days" - Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  There are two special values:  * &#x60;null&#x60;, the default, means the stream will inherit the organization   level setting. * &#x60;-1&#x60; encodes retaining messages in this stream forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
  , subscriptionsHistoryPublicToSubscribers :: !(Maybe Bool) -- ^ "history_public_to_subscribers" - Whether the history of the stream is public to its subscribers.  Currently always true for public streams (i.e. invite_only&#x3D;False implies history_public_to_subscribers&#x3D;True), but clients should not make that assumption, as we may change that behavior in the future. 
  , subscriptionsFirstMessageId :: !(Maybe Int) -- ^ "first_message_id" - The id of the first message in the stream.  Intended to help clients determine whether they need to display UI like the \&quot;more topics\&quot; widget that would suggest the stream has older history that can be accessed.  Null is used for streams with no message history. 
  , subscriptionsStreamWeeklyTraffic :: !(Maybe Int) -- ^ "stream_weekly_traffic" - The average number of messages sent to the stream in recent weeks, rounded to the nearest integer.  Null means the stream was recently created and there is insufficient data to estimate the average traffic. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Subscriptions
instance A.FromJSON Subscriptions where
  parseJSON = A.withObject "Subscriptions" $ \o ->
    Subscriptions
      <$> (o .:? "stream_id")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "rendered_description")
      <*> (o .:? "date_created")
      <*> (o .:? "invite_only")
      <*> (o .:? "subscribers")
      <*> (o .:? "desktop_notifications")
      <*> (o .:? "email_notifications")
      <*> (o .:? "wildcard_mentions_notify")
      <*> (o .:? "push_notifications")
      <*> (o .:? "audible_notifications")
      <*> (o .:? "pin_to_top")
      <*> (o .:? "email_address")
      <*> (o .:? "is_muted")
      <*> (o .:? "in_home_view")
      <*> (o .:? "is_announcement_only")
      <*> (o .:? "is_web_public")
      <*> (o .:? "role")
      <*> (o .:? "color")
      <*> (o .:? "stream_post_policy")
      <*> (o .:? "message_retention_days")
      <*> (o .:? "history_public_to_subscribers")
      <*> (o .:? "first_message_id")
      <*> (o .:? "stream_weekly_traffic")

-- | ToJSON Subscriptions
instance A.ToJSON Subscriptions where
  toJSON Subscriptions {..} =
   _omitNulls
      [ "stream_id" .= subscriptionsStreamId
      , "name" .= subscriptionsName
      , "description" .= subscriptionsDescription
      , "rendered_description" .= subscriptionsRenderedDescription
      , "date_created" .= subscriptionsDateCreated
      , "invite_only" .= subscriptionsInviteOnly
      , "subscribers" .= subscriptionsSubscribers
      , "desktop_notifications" .= subscriptionsDesktopNotifications
      , "email_notifications" .= subscriptionsEmailNotifications
      , "wildcard_mentions_notify" .= subscriptionsWildcardMentionsNotify
      , "push_notifications" .= subscriptionsPushNotifications
      , "audible_notifications" .= subscriptionsAudibleNotifications
      , "pin_to_top" .= subscriptionsPinToTop
      , "email_address" .= subscriptionsEmailAddress
      , "is_muted" .= subscriptionsIsMuted
      , "in_home_view" .= subscriptionsInHomeView
      , "is_announcement_only" .= subscriptionsIsAnnouncementOnly
      , "is_web_public" .= subscriptionsIsWebPublic
      , "role" .= subscriptionsRole
      , "color" .= subscriptionsColor
      , "stream_post_policy" .= subscriptionsStreamPostPolicy
      , "message_retention_days" .= subscriptionsMessageRetentionDays
      , "history_public_to_subscribers" .= subscriptionsHistoryPublicToSubscribers
      , "first_message_id" .= subscriptionsFirstMessageId
      , "stream_weekly_traffic" .= subscriptionsStreamWeeklyTraffic
      ]


-- | Construct a value of type 'Subscriptions' (by applying it's required fields, if any)
mkSubscriptions
  :: Subscriptions
mkSubscriptions =
  Subscriptions
  { subscriptionsStreamId = Nothing
  , subscriptionsName = Nothing
  , subscriptionsDescription = Nothing
  , subscriptionsRenderedDescription = Nothing
  , subscriptionsDateCreated = Nothing
  , subscriptionsInviteOnly = Nothing
  , subscriptionsSubscribers = Nothing
  , subscriptionsDesktopNotifications = Nothing
  , subscriptionsEmailNotifications = Nothing
  , subscriptionsWildcardMentionsNotify = Nothing
  , subscriptionsPushNotifications = Nothing
  , subscriptionsAudibleNotifications = Nothing
  , subscriptionsPinToTop = Nothing
  , subscriptionsEmailAddress = Nothing
  , subscriptionsIsMuted = Nothing
  , subscriptionsInHomeView = Nothing
  , subscriptionsIsAnnouncementOnly = Nothing
  , subscriptionsIsWebPublic = Nothing
  , subscriptionsRole = Nothing
  , subscriptionsColor = Nothing
  , subscriptionsStreamPostPolicy = Nothing
  , subscriptionsMessageRetentionDays = Nothing
  , subscriptionsHistoryPublicToSubscribers = Nothing
  , subscriptionsFirstMessageId = Nothing
  , subscriptionsStreamWeeklyTraffic = Nothing
  }

-- ** User
-- | User
data User = User
  { userEmail :: !(Maybe AnyType) -- ^ "email"
  , userIsBot :: !(Maybe AnyType) -- ^ "is_bot"
  , userAvatarUrl :: !(Maybe AnyType) -- ^ "avatar_url"
  , userAvatarVersion :: !(Maybe AnyType) -- ^ "avatar_version"
  , userFullName :: !(Maybe AnyType) -- ^ "full_name"
  , userIsAdmin :: !(Maybe AnyType) -- ^ "is_admin"
  , userIsOwner :: !(Maybe AnyType) -- ^ "is_owner"
  , userIsBillingAdmin :: !(Maybe AnyType) -- ^ "is_billing_admin"
  , userRole :: !(Maybe AnyType) -- ^ "role"
  , userBotType :: !(Maybe AnyType) -- ^ "bot_type"
  , userUserId :: !(Maybe AnyType) -- ^ "user_id"
  , userBotOwnerId :: !(Maybe AnyType) -- ^ "bot_owner_id"
  , userIsActive :: !(Maybe AnyType) -- ^ "is_active"
  , userIsGuest :: !(Maybe AnyType) -- ^ "is_guest"
  , userTimezone :: !(Maybe AnyType) -- ^ "timezone"
  , userDateJoined :: !(Maybe AnyType) -- ^ "date_joined"
  , userDeliveryEmail :: !(Maybe AnyType) -- ^ "delivery_email"
  , userProfileData :: !(Maybe AnyType) -- ^ "profile_data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON User
instance A.FromJSON User where
  parseJSON = A.withObject "User" $ \o ->
    User
      <$> (o .:? "email")
      <*> (o .:? "is_bot")
      <*> (o .:? "avatar_url")
      <*> (o .:? "avatar_version")
      <*> (o .:? "full_name")
      <*> (o .:? "is_admin")
      <*> (o .:? "is_owner")
      <*> (o .:? "is_billing_admin")
      <*> (o .:? "role")
      <*> (o .:? "bot_type")
      <*> (o .:? "user_id")
      <*> (o .:? "bot_owner_id")
      <*> (o .:? "is_active")
      <*> (o .:? "is_guest")
      <*> (o .:? "timezone")
      <*> (o .:? "date_joined")
      <*> (o .:? "delivery_email")
      <*> (o .:? "profile_data")

-- | ToJSON User
instance A.ToJSON User where
  toJSON User {..} =
   _omitNulls
      [ "email" .= userEmail
      , "is_bot" .= userIsBot
      , "avatar_url" .= userAvatarUrl
      , "avatar_version" .= userAvatarVersion
      , "full_name" .= userFullName
      , "is_admin" .= userIsAdmin
      , "is_owner" .= userIsOwner
      , "is_billing_admin" .= userIsBillingAdmin
      , "role" .= userRole
      , "bot_type" .= userBotType
      , "user_id" .= userUserId
      , "bot_owner_id" .= userBotOwnerId
      , "is_active" .= userIsActive
      , "is_guest" .= userIsGuest
      , "timezone" .= userTimezone
      , "date_joined" .= userDateJoined
      , "delivery_email" .= userDeliveryEmail
      , "profile_data" .= userProfileData
      ]


-- | Construct a value of type 'User' (by applying it's required fields, if any)
mkUser
  :: User
mkUser =
  User
  { userEmail = Nothing
  , userIsBot = Nothing
  , userAvatarUrl = Nothing
  , userAvatarVersion = Nothing
  , userFullName = Nothing
  , userIsAdmin = Nothing
  , userIsOwner = Nothing
  , userIsBillingAdmin = Nothing
  , userRole = Nothing
  , userBotType = Nothing
  , userUserId = Nothing
  , userBotOwnerId = Nothing
  , userIsActive = Nothing
  , userIsGuest = Nothing
  , userTimezone = Nothing
  , userDateJoined = Nothing
  , userDeliveryEmail = Nothing
  , userProfileData = Nothing
  }

-- ** UserAllOf
-- | UserAllOf
data UserAllOf = UserAllOf
  { userAllOfEmail :: !(Maybe AnyType) -- ^ "email"
  , userAllOfIsBot :: !(Maybe AnyType) -- ^ "is_bot"
  , userAllOfAvatarUrl :: !(Maybe AnyType) -- ^ "avatar_url"
  , userAllOfAvatarVersion :: !(Maybe AnyType) -- ^ "avatar_version"
  , userAllOfFullName :: !(Maybe AnyType) -- ^ "full_name"
  , userAllOfIsAdmin :: !(Maybe AnyType) -- ^ "is_admin"
  , userAllOfIsOwner :: !(Maybe AnyType) -- ^ "is_owner"
  , userAllOfIsBillingAdmin :: !(Maybe AnyType) -- ^ "is_billing_admin"
  , userAllOfRole :: !(Maybe AnyType) -- ^ "role"
  , userAllOfBotType :: !(Maybe AnyType) -- ^ "bot_type"
  , userAllOfUserId :: !(Maybe AnyType) -- ^ "user_id"
  , userAllOfBotOwnerId :: !(Maybe AnyType) -- ^ "bot_owner_id"
  , userAllOfIsActive :: !(Maybe AnyType) -- ^ "is_active"
  , userAllOfIsGuest :: !(Maybe AnyType) -- ^ "is_guest"
  , userAllOfTimezone :: !(Maybe AnyType) -- ^ "timezone"
  , userAllOfDateJoined :: !(Maybe AnyType) -- ^ "date_joined"
  , userAllOfDeliveryEmail :: !(Maybe AnyType) -- ^ "delivery_email"
  , userAllOfProfileData :: !(Maybe AnyType) -- ^ "profile_data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserAllOf
instance A.FromJSON UserAllOf where
  parseJSON = A.withObject "UserAllOf" $ \o ->
    UserAllOf
      <$> (o .:? "email")
      <*> (o .:? "is_bot")
      <*> (o .:? "avatar_url")
      <*> (o .:? "avatar_version")
      <*> (o .:? "full_name")
      <*> (o .:? "is_admin")
      <*> (o .:? "is_owner")
      <*> (o .:? "is_billing_admin")
      <*> (o .:? "role")
      <*> (o .:? "bot_type")
      <*> (o .:? "user_id")
      <*> (o .:? "bot_owner_id")
      <*> (o .:? "is_active")
      <*> (o .:? "is_guest")
      <*> (o .:? "timezone")
      <*> (o .:? "date_joined")
      <*> (o .:? "delivery_email")
      <*> (o .:? "profile_data")

-- | ToJSON UserAllOf
instance A.ToJSON UserAllOf where
  toJSON UserAllOf {..} =
   _omitNulls
      [ "email" .= userAllOfEmail
      , "is_bot" .= userAllOfIsBot
      , "avatar_url" .= userAllOfAvatarUrl
      , "avatar_version" .= userAllOfAvatarVersion
      , "full_name" .= userAllOfFullName
      , "is_admin" .= userAllOfIsAdmin
      , "is_owner" .= userAllOfIsOwner
      , "is_billing_admin" .= userAllOfIsBillingAdmin
      , "role" .= userAllOfRole
      , "bot_type" .= userAllOfBotType
      , "user_id" .= userAllOfUserId
      , "bot_owner_id" .= userAllOfBotOwnerId
      , "is_active" .= userAllOfIsActive
      , "is_guest" .= userAllOfIsGuest
      , "timezone" .= userAllOfTimezone
      , "date_joined" .= userAllOfDateJoined
      , "delivery_email" .= userAllOfDeliveryEmail
      , "profile_data" .= userAllOfProfileData
      ]


-- | Construct a value of type 'UserAllOf' (by applying it's required fields, if any)
mkUserAllOf
  :: UserAllOf
mkUserAllOf =
  UserAllOf
  { userAllOfEmail = Nothing
  , userAllOfIsBot = Nothing
  , userAllOfAvatarUrl = Nothing
  , userAllOfAvatarVersion = Nothing
  , userAllOfFullName = Nothing
  , userAllOfIsAdmin = Nothing
  , userAllOfIsOwner = Nothing
  , userAllOfIsBillingAdmin = Nothing
  , userAllOfRole = Nothing
  , userAllOfBotType = Nothing
  , userAllOfUserId = Nothing
  , userAllOfBotOwnerId = Nothing
  , userAllOfIsActive = Nothing
  , userAllOfIsGuest = Nothing
  , userAllOfTimezone = Nothing
  , userAllOfDateJoined = Nothing
  , userAllOfDeliveryEmail = Nothing
  , userAllOfProfileData = Nothing
  }

-- ** UserBase
-- | UserBase
-- A dictionary containing basic data on a given Zulip user. 
data UserBase = UserBase
  { userBaseEmail :: !(Maybe Text) -- ^ "email" - The Zulip API email address of the user or bot.  If you do not have permission to view the email address of the target user, this will be a fake email address that is usable for the Zulip API but nothing else. 
  , userBaseIsBot :: !(Maybe Bool) -- ^ "is_bot" - A boolean specifying whether the user is a bot or full account. 
  , userBaseAvatarUrl :: !(Maybe Text) -- ^ "avatar_url" - URL for the user&#39;s avatar.  Will be &#x60;null&#x60; if the &#x60;client_gravatar&#x60; query parameter was set to &#x60;True&#x60; and the user&#39;s avatar is hosted by the Gravatar provider (i.e. the user has never uploaded an avatar).  **Changes**: In Zulip 3.0 (feature level 18), if the client has the &#x60;user_avatar_url_field_optional&#x60; capability, this will be missing at the server&#39;s sole discretion. 
  , userBaseAvatarVersion :: !(Maybe Int) -- ^ "avatar_version" - Version for the user&#39;s avatar.  Used for cache-busting requests for the user&#39;s avatar.  Clients generally shouldn&#39;t need to use this; most avatar URLs sent by Zulip will already end with &#x60;?v&#x3D;{avatar_version}&#x60;. 
  , userBaseFullName :: !(Maybe Text) -- ^ "full_name" - Full name of the user or bot, used for all display purposes. 
  , userBaseIsAdmin :: !(Maybe Bool) -- ^ "is_admin" - A boolean specifying whether the user is an organization administrator. 
  , userBaseIsOwner :: !(Maybe Bool) -- ^ "is_owner" - A boolean specifying whether the user is an organization owner. If true, is_admin will also be true.  **Changes**: New in Zulip 3.0 (feature level 8). 
  , userBaseIsBillingAdmin :: !(Maybe Bool) -- ^ "is_billing_admin" - A boolean specifying whether the user is a billing administrator.  **Changes**: New in Zulip 5.0 (feature level 73). 
  , userBaseRole :: !(Maybe E'Role2) -- ^ "role" - [Organization-level role](/help/roles-and-permissions)) of the user. Poosible values are:  * Organization owner &#x3D;&gt; 100 * Organization administrator &#x3D;&gt; 200 * Organization moderator &#x3D;&gt; 300 * Member &#x3D;&gt; 400 * Guest &#x3D;&gt; 600  **Changes**: New in Zulip 4.0 (feature level 59). 
  , userBaseBotType :: !(Maybe Int) -- ^ "bot_type" - An integer describing the type of bot: * &#x60;null&#x60; if the user isn&#39;t a bot. * &#x60;1&#x60; for a &#x60;Generic&#x60; bot. * &#x60;2&#x60; for an &#x60;Incoming webhook&#x60; bot. * &#x60;3&#x60; for an &#x60;Outgoing webhook&#x60; bot. * &#x60;4&#x60; for an &#x60;Embedded&#x60; bot. 
  , userBaseUserId :: !(Maybe Int) -- ^ "user_id" - The unique ID of the user. 
  , userBaseBotOwnerId :: !(Maybe Int) -- ^ "bot_owner_id" - If the user is a bot (i.e. &#x60;is_bot&#x60; is &#x60;True&#x60;), &#x60;bot_owner&#x60; is the user ID of the bot&#39;s owner (usually, whoever created the bot).  Will be null for legacy bots that do not have an owner.  **Changes**: New in Zulip 3.0 (feature level 1).  In previous versions, there was a &#x60;bot_owner&#x60; field containing the email address of the bot&#39;s owner. 
  , userBaseIsActive :: !(Maybe Bool) -- ^ "is_active" - A boolean specifying whether the user account has been deactivated. 
  , userBaseIsGuest :: !(Maybe Bool) -- ^ "is_guest" - A boolean specifying whether the user is a guest user. 
  , userBaseTimezone :: !(Maybe Text) -- ^ "timezone" - The time zone of the user. 
  , userBaseDateJoined :: !(Maybe Text) -- ^ "date_joined" - The time the user account was created. 
  , userBaseDeliveryEmail :: !(Maybe Text) -- ^ "delivery_email" - The user&#39;s real email address.  This field is present only if [email address visibility](/help/restrict-visibility-of-email-addresses) is limited and you are an administrator with access to real email addresses under the configured policy. 
  , userBaseProfileData :: !(Maybe (Map.Map String A.Value)) -- ^ "profile_data" - A dictionary containing custom profile field data for the user. Each entry maps the integer ID of a custom profile field in the organization to a dictionary containing the user&#39;s data for that field.  Generally the data includes just a single &#x60;value&#x60; key; for those custom profile fields supporting Markdown, a &#x60;rendered_value&#x60; key will also be present. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserBase
instance A.FromJSON UserBase where
  parseJSON = A.withObject "UserBase" $ \o ->
    UserBase
      <$> (o .:? "email")
      <*> (o .:? "is_bot")
      <*> (o .:? "avatar_url")
      <*> (o .:? "avatar_version")
      <*> (o .:? "full_name")
      <*> (o .:? "is_admin")
      <*> (o .:? "is_owner")
      <*> (o .:? "is_billing_admin")
      <*> (o .:? "role")
      <*> (o .:? "bot_type")
      <*> (o .:? "user_id")
      <*> (o .:? "bot_owner_id")
      <*> (o .:? "is_active")
      <*> (o .:? "is_guest")
      <*> (o .:? "timezone")
      <*> (o .:? "date_joined")
      <*> (o .:? "delivery_email")
      <*> (o .:? "profile_data")

-- | ToJSON UserBase
instance A.ToJSON UserBase where
  toJSON UserBase {..} =
   _omitNulls
      [ "email" .= userBaseEmail
      , "is_bot" .= userBaseIsBot
      , "avatar_url" .= userBaseAvatarUrl
      , "avatar_version" .= userBaseAvatarVersion
      , "full_name" .= userBaseFullName
      , "is_admin" .= userBaseIsAdmin
      , "is_owner" .= userBaseIsOwner
      , "is_billing_admin" .= userBaseIsBillingAdmin
      , "role" .= userBaseRole
      , "bot_type" .= userBaseBotType
      , "user_id" .= userBaseUserId
      , "bot_owner_id" .= userBaseBotOwnerId
      , "is_active" .= userBaseIsActive
      , "is_guest" .= userBaseIsGuest
      , "timezone" .= userBaseTimezone
      , "date_joined" .= userBaseDateJoined
      , "delivery_email" .= userBaseDeliveryEmail
      , "profile_data" .= userBaseProfileData
      ]


-- | Construct a value of type 'UserBase' (by applying it's required fields, if any)
mkUserBase
  :: UserBase
mkUserBase =
  UserBase
  { userBaseEmail = Nothing
  , userBaseIsBot = Nothing
  , userBaseAvatarUrl = Nothing
  , userBaseAvatarVersion = Nothing
  , userBaseFullName = Nothing
  , userBaseIsAdmin = Nothing
  , userBaseIsOwner = Nothing
  , userBaseIsBillingAdmin = Nothing
  , userBaseRole = Nothing
  , userBaseBotType = Nothing
  , userBaseUserId = Nothing
  , userBaseBotOwnerId = Nothing
  , userBaseIsActive = Nothing
  , userBaseIsGuest = Nothing
  , userBaseTimezone = Nothing
  , userBaseDateJoined = Nothing
  , userBaseDeliveryEmail = Nothing
  , userBaseProfileData = Nothing
  }

-- ** UserDeactivatedError
-- | UserDeactivatedError
data UserDeactivatedError = UserDeactivatedError
  { userDeactivatedErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , userDeactivatedErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  , userDeactivatedErrorCode :: !(Maybe AnyType) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserDeactivatedError
instance A.FromJSON UserDeactivatedError where
  parseJSON = A.withObject "UserDeactivatedError" $ \o ->
    UserDeactivatedError
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "code")

-- | ToJSON UserDeactivatedError
instance A.ToJSON UserDeactivatedError where
  toJSON UserDeactivatedError {..} =
   _omitNulls
      [ "result" .= userDeactivatedErrorResult
      , "msg" .= userDeactivatedErrorMsg
      , "code" .= userDeactivatedErrorCode
      ]


-- | Construct a value of type 'UserDeactivatedError' (by applying it's required fields, if any)
mkUserDeactivatedError
  :: AnyType -- ^ 'userDeactivatedErrorResult' 
  -> AnyType -- ^ 'userDeactivatedErrorMsg' 
  -> UserDeactivatedError
mkUserDeactivatedError userDeactivatedErrorResult userDeactivatedErrorMsg =
  UserDeactivatedError
  { userDeactivatedErrorResult
  , userDeactivatedErrorMsg
  , userDeactivatedErrorCode = Nothing
  }

-- ** UserGroup
-- | UserGroup
-- Object containing the user group's attributes. 
data UserGroup = UserGroup
  { userGroupName :: !(Maybe Text) -- ^ "name" - The name of the user group. 
  , userGroupDescription :: !(Maybe Text) -- ^ "description" - The description of the user group. 
  , userGroupMembers :: !(Maybe [Int]) -- ^ "members" - Array containing the id of the users who are members of this user group. 
  , userGroupId :: !(Maybe Int) -- ^ "id" - The ID of the user group. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserGroup
instance A.FromJSON UserGroup where
  parseJSON = A.withObject "UserGroup" $ \o ->
    UserGroup
      <$> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "members")
      <*> (o .:? "id")

-- | ToJSON UserGroup
instance A.ToJSON UserGroup where
  toJSON UserGroup {..} =
   _omitNulls
      [ "name" .= userGroupName
      , "description" .= userGroupDescription
      , "members" .= userGroupMembers
      , "id" .= userGroupId
      ]


-- | Construct a value of type 'UserGroup' (by applying it's required fields, if any)
mkUserGroup
  :: UserGroup
mkUserGroup =
  UserGroup
  { userGroupName = Nothing
  , userGroupDescription = Nothing
  , userGroupMembers = Nothing
  , userGroupId = Nothing
  }

-- ** UserNotAuthorizedError
-- | UserNotAuthorizedError
data UserNotAuthorizedError = UserNotAuthorizedError
  { userNotAuthorizedErrorResult :: !(AnyType) -- ^ /Required/ "result"
  , userNotAuthorizedErrorMsg :: !(AnyType) -- ^ /Required/ "msg"
  , userNotAuthorizedErrorCode :: !(Maybe AnyType) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserNotAuthorizedError
instance A.FromJSON UserNotAuthorizedError where
  parseJSON = A.withObject "UserNotAuthorizedError" $ \o ->
    UserNotAuthorizedError
      <$> (o .:  "result")
      <*> (o .:  "msg")
      <*> (o .:? "code")

-- | ToJSON UserNotAuthorizedError
instance A.ToJSON UserNotAuthorizedError where
  toJSON UserNotAuthorizedError {..} =
   _omitNulls
      [ "result" .= userNotAuthorizedErrorResult
      , "msg" .= userNotAuthorizedErrorMsg
      , "code" .= userNotAuthorizedErrorCode
      ]


-- | Construct a value of type 'UserNotAuthorizedError' (by applying it's required fields, if any)
mkUserNotAuthorizedError
  :: AnyType -- ^ 'userNotAuthorizedErrorResult' 
  -> AnyType -- ^ 'userNotAuthorizedErrorMsg' 
  -> UserNotAuthorizedError
mkUserNotAuthorizedError userNotAuthorizedErrorResult userNotAuthorizedErrorMsg =
  UserNotAuthorizedError
  { userNotAuthorizedErrorResult
  , userNotAuthorizedErrorMsg
  , userNotAuthorizedErrorCode = Nothing
  }


-- * Enums


-- ** E'DesktopIconCountDisplay

-- | Enum of 'Int'
data E'DesktopIconCountDisplay
  = E'DesktopIconCountDisplay'Num1 -- ^ @1@
  | E'DesktopIconCountDisplay'Num2 -- ^ @2@
  | E'DesktopIconCountDisplay'Num3 -- ^ @3@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'DesktopIconCountDisplay where toJSON = A.toJSON . fromE'DesktopIconCountDisplay
instance A.FromJSON E'DesktopIconCountDisplay where parseJSON o = P.either P.fail (pure . P.id) . toE'DesktopIconCountDisplay =<< A.parseJSON o
instance WH.ToHttpApiData E'DesktopIconCountDisplay where toQueryParam = WH.toQueryParam . fromE'DesktopIconCountDisplay
instance WH.FromHttpApiData E'DesktopIconCountDisplay where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'DesktopIconCountDisplay
instance MimeRender MimeMultipartFormData E'DesktopIconCountDisplay where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'DesktopIconCountDisplay' enum
fromE'DesktopIconCountDisplay :: E'DesktopIconCountDisplay -> Int
fromE'DesktopIconCountDisplay = \case
  E'DesktopIconCountDisplay'Num1 -> 1
  E'DesktopIconCountDisplay'Num2 -> 2
  E'DesktopIconCountDisplay'Num3 -> 3

-- | parse 'E'DesktopIconCountDisplay' enum
toE'DesktopIconCountDisplay :: Int -> P.Either String E'DesktopIconCountDisplay
toE'DesktopIconCountDisplay = \case
  1 -> P.Right E'DesktopIconCountDisplay'Num1
  2 -> P.Right E'DesktopIconCountDisplay'Num2
  3 -> P.Right E'DesktopIconCountDisplay'Num3
  s -> P.Left $ "toE'DesktopIconCountDisplay: enum parse failure: " P.++ P.show s


-- ** E'Op

-- | Enum of 'Text'
data E'Op
  = E'Op'Add -- ^ @"add"@
  | E'Op'Remove -- ^ @"remove"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Op where toJSON = A.toJSON . fromE'Op
instance A.FromJSON E'Op where parseJSON o = P.either P.fail (pure . P.id) . toE'Op =<< A.parseJSON o
instance WH.ToHttpApiData E'Op where toQueryParam = WH.toQueryParam . fromE'Op
instance WH.FromHttpApiData E'Op where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Op
instance MimeRender MimeMultipartFormData E'Op where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Op' enum
fromE'Op :: E'Op -> Text
fromE'Op = \case
  E'Op'Add -> "add"
  E'Op'Remove -> "remove"

-- | parse 'E'Op' enum
toE'Op :: Text -> P.Either String E'Op
toE'Op = \case
  "add" -> P.Right E'Op'Add
  "remove" -> P.Right E'Op'Remove
  s -> P.Left $ "toE'Op: enum parse failure: " P.++ P.show s


-- ** E'Op2

-- | Enum of 'Text'
data E'Op2
  = E'Op2'Start -- ^ @"start"@
  | E'Op2'Stop -- ^ @"stop"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Op2 where toJSON = A.toJSON . fromE'Op2
instance A.FromJSON E'Op2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Op2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Op2 where toQueryParam = WH.toQueryParam . fromE'Op2
instance WH.FromHttpApiData E'Op2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Op2
instance MimeRender MimeMultipartFormData E'Op2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Op2' enum
fromE'Op2 :: E'Op2 -> Text
fromE'Op2 = \case
  E'Op2'Start -> "start"
  E'Op2'Stop -> "stop"

-- | parse 'E'Op2' enum
toE'Op2 :: Text -> P.Either String E'Op2
toE'Op2 = \case
  "start" -> P.Right E'Op2'Start
  "stop" -> P.Right E'Op2'Stop
  s -> P.Left $ "toE'Op2: enum parse failure: " P.++ P.show s


-- ** E'PropagateMode

-- | Enum of 'Text'
data E'PropagateMode
  = E'PropagateMode'One -- ^ @"change_one"@
  | E'PropagateMode'Later -- ^ @"change_later"@
  | E'PropagateMode'All -- ^ @"change_all"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'PropagateMode where toJSON = A.toJSON . fromE'PropagateMode
instance A.FromJSON E'PropagateMode where parseJSON o = P.either P.fail (pure . P.id) . toE'PropagateMode =<< A.parseJSON o
instance WH.ToHttpApiData E'PropagateMode where toQueryParam = WH.toQueryParam . fromE'PropagateMode
instance WH.FromHttpApiData E'PropagateMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'PropagateMode
instance MimeRender MimeMultipartFormData E'PropagateMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'PropagateMode' enum
fromE'PropagateMode :: E'PropagateMode -> Text
fromE'PropagateMode = \case
  E'PropagateMode'One -> "change_one"
  E'PropagateMode'Later -> "change_later"
  E'PropagateMode'All -> "change_all"

-- | parse 'E'PropagateMode' enum
toE'PropagateMode :: Text -> P.Either String E'PropagateMode
toE'PropagateMode = \case
  "change_one" -> P.Right E'PropagateMode'One
  "change_later" -> P.Right E'PropagateMode'Later
  "change_all" -> P.Right E'PropagateMode'All
  s -> P.Left $ "toE'PropagateMode: enum parse failure: " P.++ P.show s


-- ** E'Result

-- | Enum of 'Text'
data E'Result
  = E'Result'Success -- ^ @"success"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Result where toJSON = A.toJSON . fromE'Result
instance A.FromJSON E'Result where parseJSON o = P.either P.fail (pure . P.id) . toE'Result =<< A.parseJSON o
instance WH.ToHttpApiData E'Result where toQueryParam = WH.toQueryParam . fromE'Result
instance WH.FromHttpApiData E'Result where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Result
instance MimeRender MimeMultipartFormData E'Result where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Result' enum
fromE'Result :: E'Result -> Text
fromE'Result = \case
  E'Result'Success -> "success"

-- | parse 'E'Result' enum
toE'Result :: Text -> P.Either String E'Result
toE'Result = \case
  "success" -> P.Right E'Result'Success
  s -> P.Left $ "toE'Result: enum parse failure: " P.++ P.show s


-- ** E'Result2

-- | Enum of 'Text'
data E'Result2
  = E'Result2'Error -- ^ @"error"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Result2 where toJSON = A.toJSON . fromE'Result2
instance A.FromJSON E'Result2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Result2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Result2 where toQueryParam = WH.toQueryParam . fromE'Result2
instance WH.FromHttpApiData E'Result2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Result2
instance MimeRender MimeMultipartFormData E'Result2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Result2' enum
fromE'Result2 :: E'Result2 -> Text
fromE'Result2 = \case
  E'Result2'Error -> "error"

-- | parse 'E'Result2' enum
toE'Result2 :: Text -> P.Either String E'Result2
toE'Result2 = \case
  "error" -> P.Right E'Result2'Error
  s -> P.Left $ "toE'Result2: enum parse failure: " P.++ P.show s


-- ** E'Role

-- | Enum of 'Int' .
-- The user's role within the stream (distinct from the user's [organization-level role](/help/roles-and-permissions)). Valid values are:  * 20 => Stream administrator. * 50 => Subscriber.  **Changes**: New in Zulip 4.0 (feature level 31). 
data E'Role
  = E'Role'Num20 -- ^ @20@
  | E'Role'Num50 -- ^ @50@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role where toJSON = A.toJSON . fromE'Role
instance A.FromJSON E'Role where parseJSON o = P.either P.fail (pure . P.id) . toE'Role =<< A.parseJSON o
instance WH.ToHttpApiData E'Role where toQueryParam = WH.toQueryParam . fromE'Role
instance WH.FromHttpApiData E'Role where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role
instance MimeRender MimeMultipartFormData E'Role where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role' enum
fromE'Role :: E'Role -> Int
fromE'Role = \case
  E'Role'Num20 -> 20
  E'Role'Num50 -> 50

-- | parse 'E'Role' enum
toE'Role :: Int -> P.Either String E'Role
toE'Role = \case
  20 -> P.Right E'Role'Num20
  50 -> P.Right E'Role'Num50
  s -> P.Left $ "toE'Role: enum parse failure: " P.++ P.show s


-- ** E'Role2

-- | Enum of 'Int' .
-- [Organization-level role](/help/roles-and-permissions)) of the user. Poosible values are:  * Organization owner => 100 * Organization administrator => 200 * Organization moderator => 300 * Member => 400 * Guest => 600  **Changes**: New in Zulip 4.0 (feature level 59). 
data E'Role2
  = E'Role2'Num100 -- ^ @100@
  | E'Role2'Num200 -- ^ @200@
  | E'Role2'Num300 -- ^ @300@
  | E'Role2'Num400 -- ^ @400@
  | E'Role2'Num600 -- ^ @600@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role2 where toJSON = A.toJSON . fromE'Role2
instance A.FromJSON E'Role2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Role2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Role2 where toQueryParam = WH.toQueryParam . fromE'Role2
instance WH.FromHttpApiData E'Role2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role2
instance MimeRender MimeMultipartFormData E'Role2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role2' enum
fromE'Role2 :: E'Role2 -> Int
fromE'Role2 = \case
  E'Role2'Num100 -> 100
  E'Role2'Num200 -> 200
  E'Role2'Num300 -> 300
  E'Role2'Num400 -> 400
  E'Role2'Num600 -> 600

-- | parse 'E'Role2' enum
toE'Role2 :: Int -> P.Either String E'Role2
toE'Role2 = \case
  100 -> P.Right E'Role2'Num100
  200 -> P.Right E'Role2'Num200
  300 -> P.Right E'Role2'Num300
  400 -> P.Right E'Role2'Num400
  600 -> P.Right E'Role2'Num600
  s -> P.Left $ "toE'Role2: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' .
-- The status of the user on this client. It is either `idle` or `active`. 
data E'Status
  = E'Status'Idle -- ^ @"idle"@
  | E'Status'Active -- ^ @"active"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'Idle -> "idle"
  E'Status'Active -> "active"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "idle" -> P.Right E'Status'Idle
  "active" -> P.Right E'Status'Active
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'Private -- ^ @"private"@
  | E'Type'Stream -- ^ @"stream"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Private -> "private"
  E'Type'Stream -> "stream"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "private" -> P.Right E'Type'Private
  "stream" -> P.Right E'Type'Stream
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthBasicBasicAuth
data AuthBasicBasicAuth =
  AuthBasicBasicAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicBasicAuth where
  applyAuthMethod _ a@(AuthBasicBasicAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])


