/**
* Zulip REST API
* Powerful open source group chat 
*
* The version of the OpenAPI document: 1.0.0
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.openapitools.database.models

import org.ktorm.dsl.*
import org.ktorm.schema.*
import org.ktorm.database.Database
import .*


/**
 * 
 * @param avatarUrl 
 * @param client 
 * @param content 
 * @param contentType 
 * @param displayRecipient 
 * @param id 
 * @param isMeMessage 
 * @param reactions 
 * @param recipientId 
 * @param senderEmail 
 * @param senderFullName 
 * @param senderId 
 * @param senderRealmStr 
 * @param streamId 
 * @param subject 
 * @param topicLinks 
 * @param submessages 
 * @param timestamp 
 * @param type 
 * @param flags The user's [message flags][message-flags] for the message.  [message-flags]: /api/update-message-flags#available-flags 
 * @param lastEditTimestamp The UNIX timestamp for when the message was last edited, in UTC seconds. 
 * @param matchContent Only present if keyword search was included among the narrow parameters. HTML content of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords. 
 * @param matchSubject Only present if keyword search was included among the narrow parameters. HTML-escaped topic of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords. 
 */
object GetMessagess : BaseTable<GetMessages>("GetMessages") {
    val avatarUrl = blob("avatar_url") /* null */
    val client = blob("client") /* null */
    val content = blob("content") /* null */
    val contentType = blob("content_type") /* null */
    val displayRecipient = blob("display_recipient") /* null */
    val id = blob("id") /* null */
    val isMeMessage = blob("is_me_message") /* null */
    val reactions = blob("reactions") /* null */
    val recipientId = blob("recipient_id") /* null */
    val senderEmail = blob("sender_email") /* null */
    val senderFullName = blob("sender_full_name") /* null */
    val senderId = blob("sender_id") /* null */
    val senderRealmStr = blob("sender_realm_str") /* null */
    val streamId = blob("stream_id") /* null */
    val subject = blob("subject") /* null */
    val topicLinks = blob("topic_links") /* null */
    val submessages = blob("submessages") /* null */
    val timestamp = blob("timestamp") /* null */
    val type = blob("type") /* null */
    val lastEditTimestamp = int("last_edit_timestamp") /* null */ /* The UNIX timestamp for when the message was last edited, in UTC seconds.  */
    val matchContent = text("match_content") /* null */ /* Only present if keyword search was included among the narrow parameters. HTML content of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords.  */
    val matchSubject = text("match_subject") /* null */ /* Only present if keyword search was included among the narrow parameters. HTML-escaped topic of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords.  */

    /**
     * Create an entity of type GetMessages from the model
     */
    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean) = GetMessages(
        avatarUrl = row[avatarUrl]  /* kotlin.Any? */,
        client = row[client]  /* kotlin.Any? */,
        content = row[content]  /* kotlin.Any? */,
        contentType = row[contentType]  /* kotlin.Any? */,
        displayRecipient = row[displayRecipient]  /* kotlin.Any? */,
        id = row[id]  /* kotlin.Any? */,
        isMeMessage = row[isMeMessage]  /* kotlin.Any? */,
        reactions = row[reactions]  /* kotlin.Any? */,
        recipientId = row[recipientId]  /* kotlin.Any? */,
        senderEmail = row[senderEmail]  /* kotlin.Any? */,
        senderFullName = row[senderFullName]  /* kotlin.Any? */,
        senderId = row[senderId]  /* kotlin.Any? */,
        senderRealmStr = row[senderRealmStr]  /* kotlin.Any? */,
        streamId = row[streamId]  /* kotlin.Any? */,
        subject = row[subject]  /* kotlin.Any? */,
        topicLinks = row[topicLinks]  /* kotlin.Any? */,
        submessages = row[submessages]  /* kotlin.Any? */,
        timestamp = row[timestamp]  /* kotlin.Any? */,
        type = row[type]  /* kotlin.Any? */,
        flags = emptyList() /* kotlin.Array<kotlin.String>? */ /* The user's [message flags][message-flags] for the message.  [message-flags]: /api/update-message-flags#available-flags  */,
        lastEditTimestamp = row[lastEditTimestamp]  /* kotlin.Int? */ /* The UNIX timestamp for when the message was last edited, in UTC seconds.  */,
        matchContent = row[matchContent]  /* kotlin.String? */ /* Only present if keyword search was included among the narrow parameters. HTML content of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords.  */,
        matchSubject = row[matchSubject]  /* kotlin.String? */ /* Only present if keyword search was included among the narrow parameters. HTML-escaped topic of a queried message that matches the narrow, with `<span class=\"highlight\">` elements wrapping the matches for the search keywords.  */
    )

    /**
    * Assign all the columns from the entity of type GetMessages to the DML expression.
    *
    * Usage:
    *
    * ```kotlin
    * let entity = GetMessages()
    * database.update(GetMessagess, {
    *     assignFrom(entity)
    * })
    * ```
    * @return the builder with the columns for the update or insert.
    */
    fun AssignmentsBuilder.assignFrom(entity: GetMessages) {
        this.apply {
            set(GetMessagess.avatarUrl, entity.avatarUrl)
            set(GetMessagess.client, entity.client)
            set(GetMessagess.content, entity.content)
            set(GetMessagess.contentType, entity.contentType)
            set(GetMessagess.displayRecipient, entity.displayRecipient)
            set(GetMessagess.id, entity.id)
            set(GetMessagess.isMeMessage, entity.isMeMessage)
            set(GetMessagess.reactions, entity.reactions)
            set(GetMessagess.recipientId, entity.recipientId)
            set(GetMessagess.senderEmail, entity.senderEmail)
            set(GetMessagess.senderFullName, entity.senderFullName)
            set(GetMessagess.senderId, entity.senderId)
            set(GetMessagess.senderRealmStr, entity.senderRealmStr)
            set(GetMessagess.streamId, entity.streamId)
            set(GetMessagess.subject, entity.subject)
            set(GetMessagess.topicLinks, entity.topicLinks)
            set(GetMessagess.submessages, entity.submessages)
            set(GetMessagess.timestamp, entity.timestamp)
            set(GetMessagess.type, entity.type)
            set(GetMessagess.lastEditTimestamp, entity.lastEditTimestamp)
            set(GetMessagess.matchContent, entity.matchContent)
            set(GetMessagess.matchSubject, entity.matchSubject)
        }
    }

}


object GetMessagesFlags : BaseTable<Pair<kotlin.Long, kotlin.String>>("GetMessagesFlags") {
    val getMessages = long("getMessages")
    val flags = text("flags")

    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean): Pair<kotlin.Long, kotlin.String> =
        Pair(row[getMessages] ?: 0, row[flags] ?: "")

    fun AssignmentsBuilder.assignFrom(entity: Pair<kotlin.Long, kotlin.String>) {
        this.apply {
            set(GetMessagesFlags.getMessages, entity.first)
            set(GetMessagesFlags.flags, entity.second)
        }
    }

}

