# coding: utf-8

"""
    Zulip REST API

    Powerful open source group chat   # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class StreamsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def archive_stream(self, stream_id, **kwargs):  # noqa: E501
        """Archive a stream  # noqa: E501

        [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.archive_stream(stream_id, async_req=True)
        >>> result = thread.get()

        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccess
        """
        kwargs['_return_http_data_only'] = True
        return self.archive_stream_with_http_info(stream_id, **kwargs)  # noqa: E501

    def archive_stream_with_http_info(self, stream_id, **kwargs):  # noqa: E501
        """Archive a stream  # noqa: E501

        [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.  `DELETE {{ api_url }}/v1/streams/{stream_id}`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.archive_stream_with_http_info(stream_id, async_req=True)
        >>> result = thread.get()

        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccess, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'stream_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_stream" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'stream_id' is set
        if self.api_client.client_side_validation and ('stream_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['stream_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stream_id` when calling `archive_stream`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stream_id' in local_var_params:
            path_params['stream_id'] = local_var_params['stream_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccess",
            400: "JsonError",
        }

        return self.api_client.call_api(
            '/streams/{stream_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def create_big_blue_button_video_call(self, **kwargs):  # noqa: E501
        """Create BigBlueButton video call  # noqa: E501

        Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_big_blue_button_video_call(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccessBase
        """
        kwargs['_return_http_data_only'] = True
        return self.create_big_blue_button_video_call_with_http_info(**kwargs)  # noqa: E501

    def create_big_blue_button_video_call_with_http_info(self, **kwargs):  # noqa: E501
        """Create BigBlueButton video call  # noqa: E501

        Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_big_blue_button_video_call_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccessBase, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_big_blue_button_video_call" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccessBase",
        }

        return self.api_client.call_api(
            '/calls/bigbluebutton/create', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def delete_topic(self, stream_id, topic_name, **kwargs):  # noqa: E501
        """Delete a topic  # noqa: E501

        Delete all messages in a topic.  `POST {{ api_url }}/v1/streams/{stream_id}/delete_topic`  Topics are a field on messages (not an independent data structure), so deleting all the messages in the topic deletes the topic from Zulip.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_topic(stream_id, topic_name, async_req=True)
        >>> result = thread.get()

        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param topic_name: The name of the topic to delete.  (required)
        :type topic_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccess
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_topic_with_http_info(stream_id, topic_name, **kwargs)  # noqa: E501

    def delete_topic_with_http_info(self, stream_id, topic_name, **kwargs):  # noqa: E501
        """Delete a topic  # noqa: E501

        Delete all messages in a topic.  `POST {{ api_url }}/v1/streams/{stream_id}/delete_topic`  Topics are a field on messages (not an independent data structure), so deleting all the messages in the topic deletes the topic from Zulip.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_topic_with_http_info(stream_id, topic_name, async_req=True)
        >>> result = thread.get()

        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param topic_name: The name of the topic to delete.  (required)
        :type topic_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccess, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'stream_id',
            'topic_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_topic" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'stream_id' is set
        if self.api_client.client_side_validation and ('stream_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['stream_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stream_id` when calling `delete_topic`")  # noqa: E501
        # verify the required parameter 'topic_name' is set
        if self.api_client.client_side_validation and ('topic_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['topic_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `topic_name` when calling `delete_topic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stream_id' in local_var_params:
            path_params['stream_id'] = local_var_params['stream_id']  # noqa: E501

        query_params = []
        if 'topic_name' in local_var_params and local_var_params['topic_name'] is not None:  # noqa: E501
            query_params.append(('topic_name', local_var_params['topic_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccess",
            400: "JsonError",
        }

        return self.api_client.call_api(
            '/streams/{stream_id}/delete_topic', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_stream_id(self, stream, **kwargs):  # noqa: E501
        """Get stream ID  # noqa: E501

        Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_stream_id(stream, async_req=True)
        >>> result = thread.get()

        :param stream: The name of the stream to access.  (required)
        :type stream: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccessBase
        """
        kwargs['_return_http_data_only'] = True
        return self.get_stream_id_with_http_info(stream, **kwargs)  # noqa: E501

    def get_stream_id_with_http_info(self, stream, **kwargs):  # noqa: E501
        """Get stream ID  # noqa: E501

        Get the unique ID of a given stream.  `GET {{ api_url }}/v1/get_stream_id`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_stream_id_with_http_info(stream, async_req=True)
        >>> result = thread.get()

        :param stream: The name of the stream to access.  (required)
        :type stream: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccessBase, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'stream'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_stream_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'stream' is set
        if self.api_client.client_side_validation and ('stream' not in local_var_params or  # noqa: E501
                                                        local_var_params['stream'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stream` when calling `get_stream_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'stream' in local_var_params and local_var_params['stream'] is not None:  # noqa: E501
            query_params.append(('stream', local_var_params['stream']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccessBase",
            400: "CodedError",
        }

        return self.api_client.call_api(
            '/get_stream_id', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_stream_topics(self, stream_id, **kwargs):  # noqa: E501
        """Get topics in a stream  # noqa: E501

        Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_stream_topics(stream_id, async_req=True)
        >>> result = thread.get()

        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccessBase
        """
        kwargs['_return_http_data_only'] = True
        return self.get_stream_topics_with_http_info(stream_id, **kwargs)  # noqa: E501

    def get_stream_topics_with_http_info(self, stream_id, **kwargs):  # noqa: E501
        """Get topics in a stream  # noqa: E501

        Get all the topics in a specific stream  `GET {{ api_url }}/v1/users/me/{stream_id}/topics`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_stream_topics_with_http_info(stream_id, async_req=True)
        >>> result = thread.get()

        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccessBase, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'stream_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_stream_topics" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'stream_id' is set
        if self.api_client.client_side_validation and ('stream_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['stream_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stream_id` when calling `get_stream_topics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stream_id' in local_var_params:
            path_params['stream_id'] = local_var_params['stream_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccessBase",
            400: "JsonError",
        }

        return self.api_client.call_api(
            '/users/me/{stream_id}/topics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_streams(self, **kwargs):  # noqa: E501
        """Get all streams  # noqa: E501

        Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_streams(async_req=True)
        >>> result = thread.get()

        :param include_public: Include all public streams. 
        :type include_public: bool
        :param include_web_public: Include all web public streams. 
        :type include_web_public: bool
        :param include_subscribed: Include all streams that the user is subscribed to. 
        :type include_subscribed: bool
        :param include_all_active: Include all active streams. The user must have administrative privileges to use this parameter. 
        :type include_all_active: bool
        :param include_default: Include all default streams for the user's realm. 
        :type include_default: bool
        :param include_owner_subscribed: If the user is a bot, include all streams that the bot's owner is subscribed to. 
        :type include_owner_subscribed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccessBase
        """
        kwargs['_return_http_data_only'] = True
        return self.get_streams_with_http_info(**kwargs)  # noqa: E501

    def get_streams_with_http_info(self, **kwargs):  # noqa: E501
        """Get all streams  # noqa: E501

        Get all streams that the user has access to.  `GET {{ api_url }}/v1/streams`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_streams_with_http_info(async_req=True)
        >>> result = thread.get()

        :param include_public: Include all public streams. 
        :type include_public: bool
        :param include_web_public: Include all web public streams. 
        :type include_web_public: bool
        :param include_subscribed: Include all streams that the user is subscribed to. 
        :type include_subscribed: bool
        :param include_all_active: Include all active streams. The user must have administrative privileges to use this parameter. 
        :type include_all_active: bool
        :param include_default: Include all default streams for the user's realm. 
        :type include_default: bool
        :param include_owner_subscribed: If the user is a bot, include all streams that the bot's owner is subscribed to. 
        :type include_owner_subscribed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccessBase, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'include_public',
            'include_web_public',
            'include_subscribed',
            'include_all_active',
            'include_default',
            'include_owner_subscribed'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_streams" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include_public' in local_var_params and local_var_params['include_public'] is not None:  # noqa: E501
            query_params.append(('include_public', local_var_params['include_public']))  # noqa: E501
        if 'include_web_public' in local_var_params and local_var_params['include_web_public'] is not None:  # noqa: E501
            query_params.append(('include_web_public', local_var_params['include_web_public']))  # noqa: E501
        if 'include_subscribed' in local_var_params and local_var_params['include_subscribed'] is not None:  # noqa: E501
            query_params.append(('include_subscribed', local_var_params['include_subscribed']))  # noqa: E501
        if 'include_all_active' in local_var_params and local_var_params['include_all_active'] is not None:  # noqa: E501
            query_params.append(('include_all_active', local_var_params['include_all_active']))  # noqa: E501
        if 'include_default' in local_var_params and local_var_params['include_default'] is not None:  # noqa: E501
            query_params.append(('include_default', local_var_params['include_default']))  # noqa: E501
        if 'include_owner_subscribed' in local_var_params and local_var_params['include_owner_subscribed'] is not None:  # noqa: E501
            query_params.append(('include_owner_subscribed', local_var_params['include_owner_subscribed']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccessBase",
            400: "CodedError",
        }

        return self.api_client.call_api(
            '/streams', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_subscribers(self, stream_id, **kwargs):  # noqa: E501
        """Get the subscribers of a stream  # noqa: E501

        Get all users subscribed to a stream.  `Get {{ api_url }}/v1/streams/{stream_id}/members`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_subscribers(stream_id, async_req=True)
        >>> result = thread.get()

        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccessBase
        """
        kwargs['_return_http_data_only'] = True
        return self.get_subscribers_with_http_info(stream_id, **kwargs)  # noqa: E501

    def get_subscribers_with_http_info(self, stream_id, **kwargs):  # noqa: E501
        """Get the subscribers of a stream  # noqa: E501

        Get all users subscribed to a stream.  `Get {{ api_url }}/v1/streams/{stream_id}/members`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_subscribers_with_http_info(stream_id, async_req=True)
        >>> result = thread.get()

        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccessBase, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'stream_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscribers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'stream_id' is set
        if self.api_client.client_side_validation and ('stream_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['stream_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stream_id` when calling `get_subscribers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stream_id' in local_var_params:
            path_params['stream_id'] = local_var_params['stream_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccessBase",
            400: "JsonError",
        }

        return self.api_client.call_api(
            '/streams/{stream_id}/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_subscription_status(self, user_id, stream_id, **kwargs):  # noqa: E501
        """Get subscription status  # noqa: E501

        Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_subscription_status(user_id, stream_id, async_req=True)
        >>> result = thread.get()

        :param user_id: The target user's ID.  (required)
        :type user_id: int
        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccessBase
        """
        kwargs['_return_http_data_only'] = True
        return self.get_subscription_status_with_http_info(user_id, stream_id, **kwargs)  # noqa: E501

    def get_subscription_status_with_http_info(self, user_id, stream_id, **kwargs):  # noqa: E501
        """Get subscription status  # noqa: E501

        Check whether a user is subscribed to a stream.  `GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`  **Changes**: New in Zulip 3.0 (feature level 11).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_subscription_status_with_http_info(user_id, stream_id, async_req=True)
        >>> result = thread.get()

        :param user_id: The target user's ID.  (required)
        :type user_id: int
        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccessBase, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'stream_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscription_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `get_subscription_status`")  # noqa: E501
        # verify the required parameter 'stream_id' is set
        if self.api_client.client_side_validation and ('stream_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['stream_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stream_id` when calling `get_subscription_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['user_id'] = local_var_params['user_id']  # noqa: E501
        if 'stream_id' in local_var_params:
            path_params['stream_id'] = local_var_params['stream_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccessBase",
        }

        return self.api_client.call_api(
            '/users/{user_id}/subscriptions/{stream_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def get_subscriptions(self, **kwargs):  # noqa: E501
        """Get subscribed streams  # noqa: E501

        Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_subscriptions(async_req=True)
        >>> result = thread.get()

        :param include_subscribers: Whether each returned stream object should include a `subscribers` field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
        :type include_subscribers: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccessBase
        """
        kwargs['_return_http_data_only'] = True
        return self.get_subscriptions_with_http_info(**kwargs)  # noqa: E501

    def get_subscriptions_with_http_info(self, **kwargs):  # noqa: E501
        """Get subscribed streams  # noqa: E501

        Get all streams that the user is subscribed to.  `GET {{ api_url }}/v1/users/me/subscriptions`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_subscriptions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param include_subscribers: Whether each returned stream object should include a `subscribers` field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
        :type include_subscribers: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccessBase, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'include_subscribers'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subscriptions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include_subscribers' in local_var_params and local_var_params['include_subscribers'] is not None:  # noqa: E501
            query_params.append(('include_subscribers', local_var_params['include_subscribers']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccessBase",
        }

        return self.api_client.call_api(
            '/users/me/subscriptions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def mute_topic(self, topic, op, **kwargs):  # noqa: E501
        """Topic muting  # noqa: E501

        This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user's unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mute_topic(topic, op, async_req=True)
        >>> result = thread.get()

        :param topic: The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic.  (required)
        :type topic: str
        :param op: Whether to mute (`add`) or unmute (`remove`) the provided topic.  (required)
        :type op: str
        :param stream: The name of the stream to access. 
        :type stream: str
        :param stream_id: The ID of the stream to access. 
        :type stream_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccess
        """
        kwargs['_return_http_data_only'] = True
        return self.mute_topic_with_http_info(topic, op, **kwargs)  # noqa: E501

    def mute_topic_with_http_info(self, topic, op, **kwargs):  # noqa: E501
        """Topic muting  # noqa: E501

        This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user's unread count totals.  `PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mute_topic_with_http_info(topic, op, async_req=True)
        >>> result = thread.get()

        :param topic: The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic.  (required)
        :type topic: str
        :param op: Whether to mute (`add`) or unmute (`remove`) the provided topic.  (required)
        :type op: str
        :param stream: The name of the stream to access. 
        :type stream: str
        :param stream_id: The ID of the stream to access. 
        :type stream_id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccess, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'topic',
            'op',
            'stream',
            'stream_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mute_topic" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'topic' is set
        if self.api_client.client_side_validation and ('topic' not in local_var_params or  # noqa: E501
                                                        local_var_params['topic'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `topic` when calling `mute_topic`")  # noqa: E501
        # verify the required parameter 'op' is set
        if self.api_client.client_side_validation and ('op' not in local_var_params or  # noqa: E501
                                                        local_var_params['op'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `op` when calling `mute_topic`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'stream' in local_var_params and local_var_params['stream'] is not None:  # noqa: E501
            query_params.append(('stream', local_var_params['stream']))  # noqa: E501
        if 'stream_id' in local_var_params and local_var_params['stream_id'] is not None:  # noqa: E501
            query_params.append(('stream_id', local_var_params['stream_id']))  # noqa: E501
        if 'topic' in local_var_params and local_var_params['topic'] is not None:  # noqa: E501
            query_params.append(('topic', local_var_params['topic']))  # noqa: E501
        if 'op' in local_var_params and local_var_params['op'] is not None:  # noqa: E501
            query_params.append(('op', local_var_params['op']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccess",
            400: "OneOfobjectobject",
        }

        return self.api_client.call_api(
            '/users/me/subscriptions/muted_topics', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def subscribe(self, subscriptions, **kwargs):  # noqa: E501
        """Subscribe to a stream  # noqa: E501

        Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.subscribe(subscriptions, async_req=True)
        >>> result = thread.get()

        :param subscriptions: A list of dictionaries containing the key `name` and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key `description` with an appropriate value.  (required)
        :type subscriptions: list[object]
        :param principals: A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the `subscriptions` parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
        :type principals: list[OneOfstringinteger]
        :param authorization_errors_fatal: A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When `True`, an authorization error is reported as such. When set to `False`, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the `unauthorized` key. 
        :type authorization_errors_fatal: bool
        :param announce: If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream's creation. 
        :type announce: bool
        :param invite_only: As described above, this endpoint will create a new stream if passed a stream name that doesn't already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams. 
        :type invite_only: bool
        :param history_public_to_subscribers: Whether the stream's message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
        :type history_public_to_subscribers: bool
        :param stream_post_policy: Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
        :type stream_post_policy: int
        :param message_retention_days: Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \"realm_default\" => Return to the organization-level setting. * \"forever\" => Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
        :type message_retention_days: OneOfstringinteger
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: OneOfobjectobject
        """
        kwargs['_return_http_data_only'] = True
        return self.subscribe_with_http_info(subscriptions, **kwargs)  # noqa: E501

    def subscribe_with_http_info(self, subscriptions, **kwargs):  # noqa: E501
        """Subscribe to a stream  # noqa: E501

        Subscribe one or more users to one or more streams.  `POST {{ api_url }}/v1/users/me/subscriptions`  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like `invite_only` detailed below.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.subscribe_with_http_info(subscriptions, async_req=True)
        >>> result = thread.get()

        :param subscriptions: A list of dictionaries containing the key `name` and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key `description` with an appropriate value.  (required)
        :type subscriptions: list[object]
        :param principals: A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the `subscriptions` parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
        :type principals: list[OneOfstringinteger]
        :param authorization_errors_fatal: A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When `True`, an authorization error is reported as such. When set to `False`, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the `unauthorized` key. 
        :type authorization_errors_fatal: bool
        :param announce: If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream's creation. 
        :type announce: bool
        :param invite_only: As described above, this endpoint will create a new stream if passed a stream name that doesn't already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams. 
        :type invite_only: bool
        :param history_public_to_subscribers: Whether the stream's message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
        :type history_public_to_subscribers: bool
        :param stream_post_policy: Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
        :type stream_post_policy: int
        :param message_retention_days: Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \"realm_default\" => Return to the organization-level setting. * \"forever\" => Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
        :type message_retention_days: OneOfstringinteger
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(OneOfobjectobject, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'subscriptions',
            'principals',
            'authorization_errors_fatal',
            'announce',
            'invite_only',
            'history_public_to_subscribers',
            'stream_post_policy',
            'message_retention_days'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'subscriptions' is set
        if self.api_client.client_side_validation and ('subscriptions' not in local_var_params or  # noqa: E501
                                                        local_var_params['subscriptions'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `subscriptions` when calling `subscribe`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'subscriptions' in local_var_params and local_var_params['subscriptions'] is not None:  # noqa: E501
            query_params.append(('subscriptions', local_var_params['subscriptions']))  # noqa: E501
            collection_formats['subscriptions'] = 'multi'  # noqa: E501
        if 'principals' in local_var_params and local_var_params['principals'] is not None:  # noqa: E501
            query_params.append(('principals', local_var_params['principals']))  # noqa: E501
            collection_formats['principals'] = 'multi'  # noqa: E501
        if 'authorization_errors_fatal' in local_var_params and local_var_params['authorization_errors_fatal'] is not None:  # noqa: E501
            query_params.append(('authorization_errors_fatal', local_var_params['authorization_errors_fatal']))  # noqa: E501
        if 'announce' in local_var_params and local_var_params['announce'] is not None:  # noqa: E501
            query_params.append(('announce', local_var_params['announce']))  # noqa: E501
        if 'invite_only' in local_var_params and local_var_params['invite_only'] is not None:  # noqa: E501
            query_params.append(('invite_only', local_var_params['invite_only']))  # noqa: E501
        if 'history_public_to_subscribers' in local_var_params and local_var_params['history_public_to_subscribers'] is not None:  # noqa: E501
            query_params.append(('history_public_to_subscribers', local_var_params['history_public_to_subscribers']))  # noqa: E501
        if 'stream_post_policy' in local_var_params and local_var_params['stream_post_policy'] is not None:  # noqa: E501
            query_params.append(('stream_post_policy', local_var_params['stream_post_policy']))  # noqa: E501
        if 'message_retention_days' in local_var_params and local_var_params['message_retention_days'] is not None:  # noqa: E501
            query_params.append(('message_retention_days', local_var_params['message_retention_days']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "OneOfobjectobject",
            400: "OneOfobjectobject",
        }

        return self.api_client.call_api(
            '/users/me/subscriptions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def unsubscribe(self, subscriptions, **kwargs):  # noqa: E501
        """Unsubscribe from a stream  # noqa: E501

        Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.unsubscribe(subscriptions, async_req=True)
        >>> result = thread.get()

        :param subscriptions: A list of stream names to unsubscribe from. This parameter is called `streams` in our Python API.  (required)
        :type subscriptions: list[str]
        :param principals: A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the `subscriptions` parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
        :type principals: list[OneOfstringinteger]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccessBase
        """
        kwargs['_return_http_data_only'] = True
        return self.unsubscribe_with_http_info(subscriptions, **kwargs)  # noqa: E501

    def unsubscribe_with_http_info(self, subscriptions, **kwargs):  # noqa: E501
        """Unsubscribe from a stream  # noqa: E501

        Unsubscribe yourself or other users from one or more streams.  `DELETE {{ api_url }}/v1/users/me/subscriptions`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.unsubscribe_with_http_info(subscriptions, async_req=True)
        >>> result = thread.get()

        :param subscriptions: A list of stream names to unsubscribe from. This parameter is called `streams` in our Python API.  (required)
        :type subscriptions: list[str]
        :param principals: A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the `subscriptions` parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
        :type principals: list[OneOfstringinteger]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccessBase, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'subscriptions',
            'principals'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unsubscribe" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'subscriptions' is set
        if self.api_client.client_side_validation and ('subscriptions' not in local_var_params or  # noqa: E501
                                                        local_var_params['subscriptions'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `subscriptions` when calling `unsubscribe`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'subscriptions' in local_var_params and local_var_params['subscriptions'] is not None:  # noqa: E501
            query_params.append(('subscriptions', local_var_params['subscriptions']))  # noqa: E501
            collection_formats['subscriptions'] = 'multi'  # noqa: E501
        if 'principals' in local_var_params and local_var_params['principals'] is not None:  # noqa: E501
            query_params.append(('principals', local_var_params['principals']))  # noqa: E501
            collection_formats['principals'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccessBase",
            400: "NonExistingStreamError",
        }

        return self.api_client.call_api(
            '/users/me/subscriptions', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def update_stream(self, stream_id, **kwargs):  # noqa: E501
        """Update a stream  # noqa: E501

        Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_stream(stream_id, async_req=True)
        >>> result = thread.get()

        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param description: The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
        :type description: str
        :param new_name: The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
        :type new_name: str
        :param is_private: Change whether the stream is a private stream. 
        :type is_private: bool
        :param is_announcement_only: Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   `stream_post_policy` instead. 
        :type is_announcement_only: bool
        :param stream_post_policy: Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
        :type stream_post_policy: int
        :param history_public_to_subscribers: Whether the stream's message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
        :type history_public_to_subscribers: bool
        :param message_retention_days: Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \"realm_default\" => Return to the organization-level setting. * \"forever\" => Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
        :type message_retention_days: OneOfstringinteger
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccess
        """
        kwargs['_return_http_data_only'] = True
        return self.update_stream_with_http_info(stream_id, **kwargs)  # noqa: E501

    def update_stream_with_http_info(self, stream_id, **kwargs):  # noqa: E501
        """Update a stream  # noqa: E501

        Configure the stream with the ID `stream_id`.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  `PATCH {{ api_url }}/v1/streams/{stream_id}`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_stream_with_http_info(stream_id, async_req=True)
        >>> result = thread.get()

        :param stream_id: The ID of the stream to access.  (required)
        :type stream_id: int
        :param description: The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
        :type description: str
        :param new_name: The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
        :type new_name: str
        :param is_private: Change whether the stream is a private stream. 
        :type is_private: bool
        :param is_announcement_only: Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   `stream_post_policy` instead. 
        :type is_announcement_only: bool
        :param stream_post_policy: Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
        :type stream_post_policy: int
        :param history_public_to_subscribers: Whether the stream's message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
        :type history_public_to_subscribers: bool
        :param message_retention_days: Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \"realm_default\" => Return to the organization-level setting. * \"forever\" => Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
        :type message_retention_days: OneOfstringinteger
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccess, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'stream_id',
            'description',
            'new_name',
            'is_private',
            'is_announcement_only',
            'stream_post_policy',
            'history_public_to_subscribers',
            'message_retention_days'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_stream" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'stream_id' is set
        if self.api_client.client_side_validation and ('stream_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['stream_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `stream_id` when calling `update_stream`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stream_id' in local_var_params:
            path_params['stream_id'] = local_var_params['stream_id']  # noqa: E501

        query_params = []
        if 'description' in local_var_params and local_var_params['description'] is not None:  # noqa: E501
            query_params.append(('description', local_var_params['description']))  # noqa: E501
        if 'new_name' in local_var_params and local_var_params['new_name'] is not None:  # noqa: E501
            query_params.append(('new_name', local_var_params['new_name']))  # noqa: E501
        if 'is_private' in local_var_params and local_var_params['is_private'] is not None:  # noqa: E501
            query_params.append(('is_private', local_var_params['is_private']))  # noqa: E501
        if 'is_announcement_only' in local_var_params and local_var_params['is_announcement_only'] is not None:  # noqa: E501
            query_params.append(('is_announcement_only', local_var_params['is_announcement_only']))  # noqa: E501
        if 'stream_post_policy' in local_var_params and local_var_params['stream_post_policy'] is not None:  # noqa: E501
            query_params.append(('stream_post_policy', local_var_params['stream_post_policy']))  # noqa: E501
        if 'history_public_to_subscribers' in local_var_params and local_var_params['history_public_to_subscribers'] is not None:  # noqa: E501
            query_params.append(('history_public_to_subscribers', local_var_params['history_public_to_subscribers']))  # noqa: E501
        if 'message_retention_days' in local_var_params and local_var_params['message_retention_days'] is not None:  # noqa: E501
            query_params.append(('message_retention_days', local_var_params['message_retention_days']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccess",
            400: "JsonError",
        }

        return self.api_client.call_api(
            '/streams/{stream_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def update_subscription_settings(self, subscription_data, **kwargs):  # noqa: E501
        """Update subscription settings  # noqa: E501

        This endpoint is used to update the user's personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_subscription_settings(subscription_data, async_req=True)
        >>> result = thread.get()

        :param subscription_data: A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a `stream_id` key that identifies the stream, as well as the `property` being modified and its new `value`.  The possible values for each `property` and `value` pairs are:  * `color` (string): the hex value of the user's display color for the stream. * `is_muted` (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named `in_home_view` (with the   opposite value, `in_home_view=!is_muted`); for   backwards-compatibility, modern Zulip still accepts that value. * `pin_to_top` (boolean): whether to pin the stream at the top of the stream list. * `desktop_notifications` (boolean): whether to show desktop notifications     for all messages sent to the stream. * `audible_notifications` (boolean): whether to play a sound   notification for all messages sent to the stream. * `push_notifications` (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * `email_notifications` (boolean): whether to trigger an email     notification for all messages sent to the stream.  (required)
        :type subscription_data: list[object]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccessBase
        """
        kwargs['_return_http_data_only'] = True
        return self.update_subscription_settings_with_http_info(subscription_data, **kwargs)  # noqa: E501

    def update_subscription_settings_with_http_info(self, subscription_data, **kwargs):  # noqa: E501
        """Update subscription settings  # noqa: E501

        This endpoint is used to update the user's personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  `POST {{ api_url }}/v1/users/me/subscriptions/properties`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_subscription_settings_with_http_info(subscription_data, async_req=True)
        >>> result = thread.get()

        :param subscription_data: A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a `stream_id` key that identifies the stream, as well as the `property` being modified and its new `value`.  The possible values for each `property` and `value` pairs are:  * `color` (string): the hex value of the user's display color for the stream. * `is_muted` (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named `in_home_view` (with the   opposite value, `in_home_view=!is_muted`); for   backwards-compatibility, modern Zulip still accepts that value. * `pin_to_top` (boolean): whether to pin the stream at the top of the stream list. * `desktop_notifications` (boolean): whether to show desktop notifications     for all messages sent to the stream. * `audible_notifications` (boolean): whether to play a sound   notification for all messages sent to the stream. * `push_notifications` (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * `email_notifications` (boolean): whether to trigger an email     notification for all messages sent to the stream.  (required)
        :type subscription_data: list[object]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccessBase, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'subscription_data'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_subscription_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'subscription_data' is set
        if self.api_client.client_side_validation and ('subscription_data' not in local_var_params or  # noqa: E501
                                                        local_var_params['subscription_data'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `subscription_data` when calling `update_subscription_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'subscription_data' in local_var_params and local_var_params['subscription_data'] is not None:  # noqa: E501
            query_params.append(('subscription_data', local_var_params['subscription_data']))  # noqa: E501
            collection_formats['subscription_data'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccessBase",
        }

        return self.api_client.call_api(
            '/users/me/subscriptions/properties', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def update_subscriptions(self, **kwargs):  # noqa: E501
        """Update subscriptions  # noqa: E501

        Update which streams you are are subscribed to.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_subscriptions(async_req=True)
        >>> result = thread.get()

        :param delete: A list of stream names to unsubscribe from. 
        :type delete: list[str]
        :param add: A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description. 
        :type add: list[object]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: JsonSuccessBase
        """
        kwargs['_return_http_data_only'] = True
        return self.update_subscriptions_with_http_info(**kwargs)  # noqa: E501

    def update_subscriptions_with_http_info(self, **kwargs):  # noqa: E501
        """Update subscriptions  # noqa: E501

        Update which streams you are are subscribed to.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_subscriptions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param delete: A list of stream names to unsubscribe from. 
        :type delete: list[str]
        :param add: A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description. 
        :type add: list[object]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(JsonSuccessBase, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'delete',
            'add'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_subscriptions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'delete' in local_var_params and local_var_params['delete'] is not None:  # noqa: E501
            query_params.append(('delete', local_var_params['delete']))  # noqa: E501
            collection_formats['delete'] = 'multi'  # noqa: E501
        if 'add' in local_var_params and local_var_params['add'] is not None:  # noqa: E501
            query_params.append(('add', local_var_params['add']))  # noqa: E501
            collection_formats['add'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "JsonSuccessBase",
        }

        return self.api_client.call_api(
            '/users/me/subscriptions', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
