/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * API version: 1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// RealTimeEventsApiService RealTimeEventsApi service
type RealTimeEventsApiService service

type ApiDeleteQueueRequest struct {
	ctx _context.Context
	ApiService *RealTimeEventsApiService
	queueId *string
}

func (r ApiDeleteQueueRequest) QueueId(queueId string) ApiDeleteQueueRequest {
	r.queueId = &queueId
	return r
}

func (r ApiDeleteQueueRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.DeleteQueueExecute(r)
}

/*
 * DeleteQueue Delete an event queue
 * Delete a previously registered queue.

`DELETE {{ api_url }}/v1/events`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDeleteQueueRequest
 */
func (a *RealTimeEventsApiService) DeleteQueue(ctx _context.Context) ApiDeleteQueueRequest {
	return ApiDeleteQueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *RealTimeEventsApiService) DeleteQueueExecute(r ApiDeleteQueueRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeEventsApiService.DeleteQueue")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.queueId == nil {
		return localVarReturnValue, nil, reportError("queueId is required and must be specified")
	}

	localVarQueryParams.Add("queue_id", parameterToString(*r.queueId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadEventQueueIdError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventsRequest struct {
	ctx _context.Context
	ApiService *RealTimeEventsApiService
	queueId *string
	lastEventId *int32
	dontBlock *bool
}

func (r ApiGetEventsRequest) QueueId(queueId string) ApiGetEventsRequest {
	r.queueId = &queueId
	return r
}
func (r ApiGetEventsRequest) LastEventId(lastEventId int32) ApiGetEventsRequest {
	r.lastEventId = &lastEventId
	return r
}
func (r ApiGetEventsRequest) DontBlock(dontBlock bool) ApiGetEventsRequest {
	r.dontBlock = &dontBlock
	return r
}

func (r ApiGetEventsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetEventsExecute(r)
}

/*
 * GetEvents Get events from an event queue
 * `GET {{ api_url }}/v1/events`

This endpoint allows you to receive new events from
[a registered event queue](/api/register-queue).

Long-lived clients should use the
`event_queue_longpoll_timeout_seconds` property returned by
`POST /register` as the client-side HTTP request timeout for
calls to this endpoint.  It is guaranteed to be higher than
heartbeat frequency and should be respected by clients to
avoid breaking when heartbeat frequency increases.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetEventsRequest
 */
func (a *RealTimeEventsApiService) GetEvents(ctx _context.Context) ApiGetEventsRequest {
	return ApiGetEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *RealTimeEventsApiService) GetEventsExecute(r ApiGetEventsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeEventsApiService.GetEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.queueId == nil {
		return localVarReturnValue, nil, reportError("queueId is required and must be specified")
	}

	localVarQueryParams.Add("queue_id", parameterToString(*r.queueId, ""))
	if r.lastEventId != nil {
		localVarQueryParams.Add("last_event_id", parameterToString(*r.lastEventId, ""))
	}
	if r.dontBlock != nil {
		localVarQueryParams.Add("dont_block", parameterToString(*r.dontBlock, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadEventQueueIdError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRealTimePostRequest struct {
	ctx _context.Context
	ApiService *RealTimeEventsApiService
	eventTypes *[]string
	narrow *[][]string
	allPublicStreams *bool
}

func (r ApiRealTimePostRequest) EventTypes(eventTypes []string) ApiRealTimePostRequest {
	r.eventTypes = &eventTypes
	return r
}
func (r ApiRealTimePostRequest) Narrow(narrow [][]string) ApiRealTimePostRequest {
	r.narrow = &narrow
	return r
}
func (r ApiRealTimePostRequest) AllPublicStreams(allPublicStreams bool) ApiRealTimePostRequest {
	r.allPublicStreams = &allPublicStreams
	return r
}

func (r ApiRealTimePostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RealTimePostExecute(r)
}

/*
 * RealTimePost Method for RealTimePost
 * (Ignored)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiRealTimePostRequest
 */
func (a *RealTimeEventsApiService) RealTimePost(ctx _context.Context) ApiRealTimePostRequest {
	return ApiRealTimePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *RealTimeEventsApiService) RealTimePostExecute(r ApiRealTimePostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeEventsApiService.RealTimePost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/real-time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.eventTypes != nil {
		t := *r.eventTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("event_types", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("event_types", parameterToString(t, "multi"))
		}
	}
	if r.narrow != nil {
		t := *r.narrow
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("narrow", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("narrow", parameterToString(t, "multi"))
		}
	}
	if r.allPublicStreams != nil {
		localVarQueryParams.Add("all_public_streams", parameterToString(*r.allPublicStreams, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRegisterQueueRequest struct {
	ctx _context.Context
	ApiService *RealTimeEventsApiService
	applyMarkdown *bool
	clientGravatar *bool
	slimPresence *bool
	eventTypes *[]string
	allPublicStreams *bool
	includeSubscribers *bool
	clientCapabilities *map[string]interface{}
	fetchEventTypes *[]string
	narrow *[][]string
}

func (r ApiRegisterQueueRequest) ApplyMarkdown(applyMarkdown bool) ApiRegisterQueueRequest {
	r.applyMarkdown = &applyMarkdown
	return r
}
func (r ApiRegisterQueueRequest) ClientGravatar(clientGravatar bool) ApiRegisterQueueRequest {
	r.clientGravatar = &clientGravatar
	return r
}
func (r ApiRegisterQueueRequest) SlimPresence(slimPresence bool) ApiRegisterQueueRequest {
	r.slimPresence = &slimPresence
	return r
}
func (r ApiRegisterQueueRequest) EventTypes(eventTypes []string) ApiRegisterQueueRequest {
	r.eventTypes = &eventTypes
	return r
}
func (r ApiRegisterQueueRequest) AllPublicStreams(allPublicStreams bool) ApiRegisterQueueRequest {
	r.allPublicStreams = &allPublicStreams
	return r
}
func (r ApiRegisterQueueRequest) IncludeSubscribers(includeSubscribers bool) ApiRegisterQueueRequest {
	r.includeSubscribers = &includeSubscribers
	return r
}
func (r ApiRegisterQueueRequest) ClientCapabilities(clientCapabilities map[string]interface{}) ApiRegisterQueueRequest {
	r.clientCapabilities = &clientCapabilities
	return r
}
func (r ApiRegisterQueueRequest) FetchEventTypes(fetchEventTypes []string) ApiRegisterQueueRequest {
	r.fetchEventTypes = &fetchEventTypes
	return r
}
func (r ApiRegisterQueueRequest) Narrow(narrow [][]string) ApiRegisterQueueRequest {
	r.narrow = &narrow
	return r
}

func (r ApiRegisterQueueRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.RegisterQueueExecute(r)
}

/*
 * RegisterQueue Register an event queue
 * `POST {{ api_url }}/v1/register`

This powerful endpoint can be used to register a Zulip "event queue"
(subscribed to certain types of "events", or updates to the messages
and other Zulip data the current user has access to), as well as to
fetch the current state of that data.

(`register` also powers the `call_on_each_event` Python API, and is
intended primarily for complex applications for which the more convenient
`call_on_each_event` API is insufficient).

This endpoint returns a `queue_id` and a `last_event_id`; these can be
used in subsequent calls to the
["events" endpoint](/api/get-events) to request events from
the Zulip server using long-polling.

The server will queue events for up to 10 minutes of inactivity.
After 10 minutes, your event queue will be garbage-collected.  The
server will send `heartbeat` events every minute, which makes it easy
to implement a robust client that does not miss events unless the
client loses network connectivity with the Zulip server for 10 minutes
or longer.

Once the server garbage-collects your event queue, the server will
[return an error](/api/get-events#bad_event_queue_id-errors)
with a code of `BAD_EVENT_QUEUE_ID` if you try to fetch events from
the event queue.  Your software will need to handle that error
condition by re-initializing itself (e.g. this is what triggers your
browser reloading the Zulip web app when your laptop comes back online
after being offline for more than 10 minutes).

When prototyping with this API, we recommend first calling `register`
with no `event_types` parameter to see all the available data from all
supported event types.  Before using your client in production, you
should set appropriate `event_types` and `fetch_event_types` filters
so that your client only requests the data it needs.  A few minutes
doing this often saves 90% of the total bandwidth and other resources
consumed by a client using this API.

See the
[events system developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/events-system.html)
if you need deeper details about how the Zulip event queue system
works, avoids clients needing to worry about large classes of
potentially messy races, etc.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiRegisterQueueRequest
 */
func (a *RealTimeEventsApiService) RegisterQueue(ctx _context.Context) ApiRegisterQueueRequest {
	return ApiRegisterQueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *RealTimeEventsApiService) RegisterQueueExecute(r ApiRegisterQueueRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeEventsApiService.RegisterQueue")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.applyMarkdown != nil {
		localVarQueryParams.Add("apply_markdown", parameterToString(*r.applyMarkdown, ""))
	}
	if r.clientGravatar != nil {
		localVarQueryParams.Add("client_gravatar", parameterToString(*r.clientGravatar, ""))
	}
	if r.slimPresence != nil {
		localVarQueryParams.Add("slim_presence", parameterToString(*r.slimPresence, ""))
	}
	if r.eventTypes != nil {
		t := *r.eventTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("event_types", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("event_types", parameterToString(t, "multi"))
		}
	}
	if r.allPublicStreams != nil {
		localVarQueryParams.Add("all_public_streams", parameterToString(*r.allPublicStreams, ""))
	}
	if r.includeSubscribers != nil {
		localVarQueryParams.Add("include_subscribers", parameterToString(*r.includeSubscribers, ""))
	}
	if r.clientCapabilities != nil {
		localVarQueryParams.Add("client_capabilities", parameterToString(*r.clientCapabilities, ""))
	}
	if r.fetchEventTypes != nil {
		t := *r.fetchEventTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("fetch_event_types", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("fetch_event_types", parameterToString(t, "multi"))
		}
	}
	if r.narrow != nil {
		t := *r.narrow
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("narrow", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("narrow", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestErrorHandlingRequest struct {
	ctx _context.Context
	ApiService *RealTimeEventsApiService
}


func (r ApiRestErrorHandlingRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RestErrorHandlingExecute(r)
}

/*
 * RestErrorHandling Error handling
 * Common error to many endpoints

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiRestErrorHandlingRequest
 */
func (a *RealTimeEventsApiService) RestErrorHandling(ctx _context.Context) ApiRestErrorHandlingRequest {
	return ApiRestErrorHandlingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *RealTimeEventsApiService) RestErrorHandlingExecute(r ApiRestErrorHandlingRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RealTimeEventsApiService.RestErrorHandling")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest-error-handling"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OneOfInvalidApiKeyErrorMissingArgumentErrorUserNotAuthorizedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v OneOfUserDeactivatedErrorRealmDeactivatedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v OneOfRateLimitedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
