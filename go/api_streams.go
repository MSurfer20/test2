/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * API version: 1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// StreamsApiService StreamsApi service
type StreamsApiService service

type ApiArchiveStreamRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	streamId int32
}


func (r ApiArchiveStreamRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.ArchiveStreamExecute(r)
}

/*
 * ArchiveStream Archive a stream
 * [Archive the stream](/help/archive-a-stream) with the ID `stream_id`.

`DELETE {{ api_url }}/v1/streams/{stream_id}`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param streamId The ID of the stream to access. 
 * @return ApiArchiveStreamRequest
 */
func (a *StreamsApiService) ArchiveStream(ctx _context.Context, streamId int32) ApiArchiveStreamRequest {
	return ApiArchiveStreamRequest{
		ApiService: a,
		ctx: ctx,
		streamId: streamId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *StreamsApiService) ArchiveStreamExecute(r ApiArchiveStreamRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.ArchiveStream")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams/{stream_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", _neturl.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBigBlueButtonVideoCallRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
}


func (r ApiCreateBigBlueButtonVideoCallRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.CreateBigBlueButtonVideoCallExecute(r)
}

/*
 * CreateBigBlueButtonVideoCall Create BigBlueButton video call
 * Create a video call URL for a BigBlueButton video call.
Requires BigBlueButton to be configured on the Zulip server.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateBigBlueButtonVideoCallRequest
 */
func (a *StreamsApiService) CreateBigBlueButtonVideoCall(ctx _context.Context) ApiCreateBigBlueButtonVideoCallRequest {
	return ApiCreateBigBlueButtonVideoCallRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *StreamsApiService) CreateBigBlueButtonVideoCallExecute(r ApiCreateBigBlueButtonVideoCallRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.CreateBigBlueButtonVideoCall")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/calls/bigbluebutton/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTopicRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	streamId int32
	topicName *string
}

func (r ApiDeleteTopicRequest) TopicName(topicName string) ApiDeleteTopicRequest {
	r.topicName = &topicName
	return r
}

func (r ApiDeleteTopicRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.DeleteTopicExecute(r)
}

/*
 * DeleteTopic Delete a topic
 * Delete all messages in a topic.

`POST {{ api_url }}/v1/streams/{stream_id}/delete_topic`

Topics are a field on messages (not an independent
data structure), so deleting all the messages in the topic
deletes the topic from Zulip.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param streamId The ID of the stream to access. 
 * @return ApiDeleteTopicRequest
 */
func (a *StreamsApiService) DeleteTopic(ctx _context.Context, streamId int32) ApiDeleteTopicRequest {
	return ApiDeleteTopicRequest{
		ApiService: a,
		ctx: ctx,
		streamId: streamId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *StreamsApiService) DeleteTopicExecute(r ApiDeleteTopicRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.DeleteTopic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams/{stream_id}/delete_topic"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", _neturl.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.topicName == nil {
		return localVarReturnValue, nil, reportError("topicName is required and must be specified")
	}

	localVarQueryParams.Add("topic_name", parameterToString(*r.topicName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStreamIdRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	stream *string
}

func (r ApiGetStreamIdRequest) Stream(stream string) ApiGetStreamIdRequest {
	r.stream = &stream
	return r
}

func (r ApiGetStreamIdRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetStreamIdExecute(r)
}

/*
 * GetStreamId Get stream ID
 * Get the unique ID of a given stream.

`GET {{ api_url }}/v1/get_stream_id`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetStreamIdRequest
 */
func (a *StreamsApiService) GetStreamId(ctx _context.Context) ApiGetStreamIdRequest {
	return ApiGetStreamIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *StreamsApiService) GetStreamIdExecute(r ApiGetStreamIdRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.GetStreamId")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/get_stream_id"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.stream == nil {
		return localVarReturnValue, nil, reportError("stream is required and must be specified")
	}

	localVarQueryParams.Add("stream", parameterToString(*r.stream, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CodedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStreamTopicsRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	streamId int32
}


func (r ApiGetStreamTopicsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetStreamTopicsExecute(r)
}

/*
 * GetStreamTopics Get topics in a stream
 * Get all the topics in a specific stream

`GET {{ api_url }}/v1/users/me/{stream_id}/topics`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param streamId The ID of the stream to access. 
 * @return ApiGetStreamTopicsRequest
 */
func (a *StreamsApiService) GetStreamTopics(ctx _context.Context, streamId int32) ApiGetStreamTopicsRequest {
	return ApiGetStreamTopicsRequest{
		ApiService: a,
		ctx: ctx,
		streamId: streamId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *StreamsApiService) GetStreamTopicsExecute(r ApiGetStreamTopicsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.GetStreamTopics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/{stream_id}/topics"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", _neturl.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStreamsRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	includePublic *bool
	includeWebPublic *bool
	includeSubscribed *bool
	includeAllActive *bool
	includeDefault *bool
	includeOwnerSubscribed *bool
}

func (r ApiGetStreamsRequest) IncludePublic(includePublic bool) ApiGetStreamsRequest {
	r.includePublic = &includePublic
	return r
}
func (r ApiGetStreamsRequest) IncludeWebPublic(includeWebPublic bool) ApiGetStreamsRequest {
	r.includeWebPublic = &includeWebPublic
	return r
}
func (r ApiGetStreamsRequest) IncludeSubscribed(includeSubscribed bool) ApiGetStreamsRequest {
	r.includeSubscribed = &includeSubscribed
	return r
}
func (r ApiGetStreamsRequest) IncludeAllActive(includeAllActive bool) ApiGetStreamsRequest {
	r.includeAllActive = &includeAllActive
	return r
}
func (r ApiGetStreamsRequest) IncludeDefault(includeDefault bool) ApiGetStreamsRequest {
	r.includeDefault = &includeDefault
	return r
}
func (r ApiGetStreamsRequest) IncludeOwnerSubscribed(includeOwnerSubscribed bool) ApiGetStreamsRequest {
	r.includeOwnerSubscribed = &includeOwnerSubscribed
	return r
}

func (r ApiGetStreamsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetStreamsExecute(r)
}

/*
 * GetStreams Get all streams
 * Get all streams that the user has access to.

`GET {{ api_url }}/v1/streams`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetStreamsRequest
 */
func (a *StreamsApiService) GetStreams(ctx _context.Context) ApiGetStreamsRequest {
	return ApiGetStreamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *StreamsApiService) GetStreamsExecute(r ApiGetStreamsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.GetStreams")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.includePublic != nil {
		localVarQueryParams.Add("include_public", parameterToString(*r.includePublic, ""))
	}
	if r.includeWebPublic != nil {
		localVarQueryParams.Add("include_web_public", parameterToString(*r.includeWebPublic, ""))
	}
	if r.includeSubscribed != nil {
		localVarQueryParams.Add("include_subscribed", parameterToString(*r.includeSubscribed, ""))
	}
	if r.includeAllActive != nil {
		localVarQueryParams.Add("include_all_active", parameterToString(*r.includeAllActive, ""))
	}
	if r.includeDefault != nil {
		localVarQueryParams.Add("include_default", parameterToString(*r.includeDefault, ""))
	}
	if r.includeOwnerSubscribed != nil {
		localVarQueryParams.Add("include_owner_subscribed", parameterToString(*r.includeOwnerSubscribed, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CodedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscribersRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	streamId int32
}


func (r ApiGetSubscribersRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetSubscribersExecute(r)
}

/*
 * GetSubscribers Get the subscribers of a stream
 * Get all users subscribed to a stream.

`Get {{ api_url }}/v1/streams/{stream_id}/members`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param streamId The ID of the stream to access. 
 * @return ApiGetSubscribersRequest
 */
func (a *StreamsApiService) GetSubscribers(ctx _context.Context, streamId int32) ApiGetSubscribersRequest {
	return ApiGetSubscribersRequest{
		ApiService: a,
		ctx: ctx,
		streamId: streamId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *StreamsApiService) GetSubscribersExecute(r ApiGetSubscribersRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.GetSubscribers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams/{stream_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", _neturl.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionStatusRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	userId int32
	streamId int32
}


func (r ApiGetSubscriptionStatusRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetSubscriptionStatusExecute(r)
}

/*
 * GetSubscriptionStatus Get subscription status
 * Check whether a user is subscribed to a stream.

`GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}`

**Changes**: New in Zulip 3.0 (feature level 11).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId The target user's ID. 
 * @param streamId The ID of the stream to access. 
 * @return ApiGetSubscriptionStatusRequest
 */
func (a *StreamsApiService) GetSubscriptionStatus(ctx _context.Context, userId int32, streamId int32) ApiGetSubscriptionStatusRequest {
	return ApiGetSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		streamId: streamId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *StreamsApiService) GetSubscriptionStatusExecute(r ApiGetSubscriptionStatusRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.GetSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/subscriptions/{stream_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", _neturl.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	includeSubscribers *bool
}

func (r ApiGetSubscriptionsRequest) IncludeSubscribers(includeSubscribers bool) ApiGetSubscriptionsRequest {
	r.includeSubscribers = &includeSubscribers
	return r
}

func (r ApiGetSubscriptionsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetSubscriptionsExecute(r)
}

/*
 * GetSubscriptions Get subscribed streams
 * Get all streams that the user is subscribed to.

`GET {{ api_url }}/v1/users/me/subscriptions`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetSubscriptionsRequest
 */
func (a *StreamsApiService) GetSubscriptions(ctx _context.Context) ApiGetSubscriptionsRequest {
	return ApiGetSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *StreamsApiService) GetSubscriptionsExecute(r ApiGetSubscriptionsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.GetSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.includeSubscribers != nil {
		localVarQueryParams.Add("include_subscribers", parameterToString(*r.includeSubscribers, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMuteTopicRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	topic *string
	op *string
	stream *string
	streamId *int32
}

func (r ApiMuteTopicRequest) Topic(topic string) ApiMuteTopicRequest {
	r.topic = &topic
	return r
}
func (r ApiMuteTopicRequest) Op(op string) ApiMuteTopicRequest {
	r.op = &op
	return r
}
func (r ApiMuteTopicRequest) Stream(stream string) ApiMuteTopicRequest {
	r.stream = &stream
	return r
}
func (r ApiMuteTopicRequest) StreamId(streamId int32) ApiMuteTopicRequest {
	r.streamId = &streamId
	return r
}

func (r ApiMuteTopicRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.MuteTopicExecute(r)
}

/*
 * MuteTopic Topic muting
 * This endpoint mutes/unmutes a topic within a stream that the current
user is subscribed to.  Muted topics are displayed faded in the Zulip
UI, and are not included in the user's unread count totals.

`PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiMuteTopicRequest
 */
func (a *StreamsApiService) MuteTopic(ctx _context.Context) ApiMuteTopicRequest {
	return ApiMuteTopicRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *StreamsApiService) MuteTopicExecute(r ApiMuteTopicRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.MuteTopic")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions/muted_topics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.topic == nil {
		return localVarReturnValue, nil, reportError("topic is required and must be specified")
	}
	if r.op == nil {
		return localVarReturnValue, nil, reportError("op is required and must be specified")
	}

	if r.stream != nil {
		localVarQueryParams.Add("stream", parameterToString(*r.stream, ""))
	}
	if r.streamId != nil {
		localVarQueryParams.Add("stream_id", parameterToString(*r.streamId, ""))
	}
	localVarQueryParams.Add("topic", parameterToString(*r.topic, ""))
	localVarQueryParams.Add("op", parameterToString(*r.op, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OneOfobjectobject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscribeRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	subscriptions *[]map[string]interface{}
	principals *[]OneOfstringinteger
	authorizationErrorsFatal *bool
	announce *bool
	inviteOnly *bool
	historyPublicToSubscribers *bool
	streamPostPolicy *int32
	messageRetentionDays *OneOfstringinteger
}

func (r ApiSubscribeRequest) Subscriptions(subscriptions []map[string]interface{}) ApiSubscribeRequest {
	r.subscriptions = &subscriptions
	return r
}
func (r ApiSubscribeRequest) Principals(principals []OneOfstringinteger) ApiSubscribeRequest {
	r.principals = &principals
	return r
}
func (r ApiSubscribeRequest) AuthorizationErrorsFatal(authorizationErrorsFatal bool) ApiSubscribeRequest {
	r.authorizationErrorsFatal = &authorizationErrorsFatal
	return r
}
func (r ApiSubscribeRequest) Announce(announce bool) ApiSubscribeRequest {
	r.announce = &announce
	return r
}
func (r ApiSubscribeRequest) InviteOnly(inviteOnly bool) ApiSubscribeRequest {
	r.inviteOnly = &inviteOnly
	return r
}
func (r ApiSubscribeRequest) HistoryPublicToSubscribers(historyPublicToSubscribers bool) ApiSubscribeRequest {
	r.historyPublicToSubscribers = &historyPublicToSubscribers
	return r
}
func (r ApiSubscribeRequest) StreamPostPolicy(streamPostPolicy int32) ApiSubscribeRequest {
	r.streamPostPolicy = &streamPostPolicy
	return r
}
func (r ApiSubscribeRequest) MessageRetentionDays(messageRetentionDays OneOfstringinteger) ApiSubscribeRequest {
	r.messageRetentionDays = &messageRetentionDays
	return r
}

func (r ApiSubscribeRequest) Execute() (OneOfobjectobject, *_nethttp.Response, error) {
	return r.ApiService.SubscribeExecute(r)
}

/*
 * Subscribe Subscribe to a stream
 * Subscribe one or more users to one or more streams.

`POST {{ api_url }}/v1/users/me/subscriptions`

If any of the specified streams do not exist, they are automatically
created.  The initial [stream settings](/api/update-stream) will be determined
by the optional parameters like `invite_only` detailed below.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSubscribeRequest
 */
func (a *StreamsApiService) Subscribe(ctx _context.Context) ApiSubscribeRequest {
	return ApiSubscribeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OneOfobjectobject
 */
func (a *StreamsApiService) SubscribeExecute(r ApiSubscribeRequest) (OneOfobjectobject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfobjectobject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.Subscribe")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subscriptions == nil {
		return localVarReturnValue, nil, reportError("subscriptions is required and must be specified")
	}

	{
		t := *r.subscriptions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("subscriptions", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("subscriptions", parameterToString(t, "multi"))
		}
	}
	if r.principals != nil {
		t := *r.principals
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("principals", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("principals", parameterToString(t, "multi"))
		}
	}
	if r.authorizationErrorsFatal != nil {
		localVarQueryParams.Add("authorization_errors_fatal", parameterToString(*r.authorizationErrorsFatal, ""))
	}
	if r.announce != nil {
		localVarQueryParams.Add("announce", parameterToString(*r.announce, ""))
	}
	if r.inviteOnly != nil {
		localVarQueryParams.Add("invite_only", parameterToString(*r.inviteOnly, ""))
	}
	if r.historyPublicToSubscribers != nil {
		localVarQueryParams.Add("history_public_to_subscribers", parameterToString(*r.historyPublicToSubscribers, ""))
	}
	if r.streamPostPolicy != nil {
		localVarQueryParams.Add("stream_post_policy", parameterToString(*r.streamPostPolicy, ""))
	}
	if r.messageRetentionDays != nil {
		localVarQueryParams.Add("message_retention_days", parameterToString(*r.messageRetentionDays, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OneOfobjectobject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsubscribeRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	subscriptions *[]string
	principals *[]OneOfstringinteger
}

func (r ApiUnsubscribeRequest) Subscriptions(subscriptions []string) ApiUnsubscribeRequest {
	r.subscriptions = &subscriptions
	return r
}
func (r ApiUnsubscribeRequest) Principals(principals []OneOfstringinteger) ApiUnsubscribeRequest {
	r.principals = &principals
	return r
}

func (r ApiUnsubscribeRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.UnsubscribeExecute(r)
}

/*
 * Unsubscribe Unsubscribe from a stream
 * Unsubscribe yourself or other users from one or more streams.

`DELETE {{ api_url }}/v1/users/me/subscriptions`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUnsubscribeRequest
 */
func (a *StreamsApiService) Unsubscribe(ctx _context.Context) ApiUnsubscribeRequest {
	return ApiUnsubscribeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *StreamsApiService) UnsubscribeExecute(r ApiUnsubscribeRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.Unsubscribe")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subscriptions == nil {
		return localVarReturnValue, nil, reportError("subscriptions is required and must be specified")
	}

	{
		t := *r.subscriptions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("subscriptions", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("subscriptions", parameterToString(t, "multi"))
		}
	}
	if r.principals != nil {
		t := *r.principals
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("principals", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("principals", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NonExistingStreamError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateStreamRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	streamId int32
	description *string
	newName *string
	isPrivate *bool
	isAnnouncementOnly *bool
	streamPostPolicy *int32
	historyPublicToSubscribers *bool
	messageRetentionDays *OneOfstringinteger
}

func (r ApiUpdateStreamRequest) Description(description string) ApiUpdateStreamRequest {
	r.description = &description
	return r
}
func (r ApiUpdateStreamRequest) NewName(newName string) ApiUpdateStreamRequest {
	r.newName = &newName
	return r
}
func (r ApiUpdateStreamRequest) IsPrivate(isPrivate bool) ApiUpdateStreamRequest {
	r.isPrivate = &isPrivate
	return r
}
func (r ApiUpdateStreamRequest) IsAnnouncementOnly(isAnnouncementOnly bool) ApiUpdateStreamRequest {
	r.isAnnouncementOnly = &isAnnouncementOnly
	return r
}
func (r ApiUpdateStreamRequest) StreamPostPolicy(streamPostPolicy int32) ApiUpdateStreamRequest {
	r.streamPostPolicy = &streamPostPolicy
	return r
}
func (r ApiUpdateStreamRequest) HistoryPublicToSubscribers(historyPublicToSubscribers bool) ApiUpdateStreamRequest {
	r.historyPublicToSubscribers = &historyPublicToSubscribers
	return r
}
func (r ApiUpdateStreamRequest) MessageRetentionDays(messageRetentionDays OneOfstringinteger) ApiUpdateStreamRequest {
	r.messageRetentionDays = &messageRetentionDays
	return r
}

func (r ApiUpdateStreamRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateStreamExecute(r)
}

/*
 * UpdateStream Update a stream
 * Configure the stream with the ID `stream_id`.  This endpoint supports
an organization administrator editing any property of a stream,
including:

* Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description)
* Stream [permissions](/help/stream-permissions), including
[privacy](/help/change-the-privacy-of-a-stream) and [who can
send](/help/stream-sending-policy).

`PATCH {{ api_url }}/v1/streams/{stream_id}`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param streamId The ID of the stream to access. 
 * @return ApiUpdateStreamRequest
 */
func (a *StreamsApiService) UpdateStream(ctx _context.Context, streamId int32) ApiUpdateStreamRequest {
	return ApiUpdateStreamRequest{
		ApiService: a,
		ctx: ctx,
		streamId: streamId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *StreamsApiService) UpdateStreamExecute(r ApiUpdateStreamRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.UpdateStream")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/streams/{stream_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"stream_id"+"}", _neturl.PathEscape(parameterToString(r.streamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.description != nil {
		localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	}
	if r.newName != nil {
		localVarQueryParams.Add("new_name", parameterToString(*r.newName, ""))
	}
	if r.isPrivate != nil {
		localVarQueryParams.Add("is_private", parameterToString(*r.isPrivate, ""))
	}
	if r.isAnnouncementOnly != nil {
		localVarQueryParams.Add("is_announcement_only", parameterToString(*r.isAnnouncementOnly, ""))
	}
	if r.streamPostPolicy != nil {
		localVarQueryParams.Add("stream_post_policy", parameterToString(*r.streamPostPolicy, ""))
	}
	if r.historyPublicToSubscribers != nil {
		localVarQueryParams.Add("history_public_to_subscribers", parameterToString(*r.historyPublicToSubscribers, ""))
	}
	if r.messageRetentionDays != nil {
		localVarQueryParams.Add("message_retention_days", parameterToString(*r.messageRetentionDays, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubscriptionSettingsRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	subscriptionData *[]map[string]interface{}
}

func (r ApiUpdateSubscriptionSettingsRequest) SubscriptionData(subscriptionData []map[string]interface{}) ApiUpdateSubscriptionSettingsRequest {
	r.subscriptionData = &subscriptionData
	return r
}

func (r ApiUpdateSubscriptionSettingsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.UpdateSubscriptionSettingsExecute(r)
}

/*
 * UpdateSubscriptionSettings Update subscription settings
 * This endpoint is used to update the user's personal settings for the
streams they are subscribed to, including muting, color, pinning, and
per-stream notification settings.

`POST {{ api_url }}/v1/users/me/subscriptions/properties`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateSubscriptionSettingsRequest
 */
func (a *StreamsApiService) UpdateSubscriptionSettings(ctx _context.Context) ApiUpdateSubscriptionSettingsRequest {
	return ApiUpdateSubscriptionSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *StreamsApiService) UpdateSubscriptionSettingsExecute(r ApiUpdateSubscriptionSettingsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.UpdateSubscriptionSettings")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions/properties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subscriptionData == nil {
		return localVarReturnValue, nil, reportError("subscriptionData is required and must be specified")
	}

	{
		t := *r.subscriptionData
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("subscription_data", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("subscription_data", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubscriptionsRequest struct {
	ctx _context.Context
	ApiService *StreamsApiService
	delete *[]string
	add *[]map[string]interface{}
}

func (r ApiUpdateSubscriptionsRequest) Delete(delete []string) ApiUpdateSubscriptionsRequest {
	r.delete = &delete
	return r
}
func (r ApiUpdateSubscriptionsRequest) Add(add []map[string]interface{}) ApiUpdateSubscriptionsRequest {
	r.add = &add
	return r
}

func (r ApiUpdateSubscriptionsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.UpdateSubscriptionsExecute(r)
}

/*
 * UpdateSubscriptions Update subscriptions
 * Update which streams you are are subscribed to.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateSubscriptionsRequest
 */
func (a *StreamsApiService) UpdateSubscriptions(ctx _context.Context) ApiUpdateSubscriptionsRequest {
	return ApiUpdateSubscriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *StreamsApiService) UpdateSubscriptionsExecute(r ApiUpdateSubscriptionsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StreamsApiService.UpdateSubscriptions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.delete != nil {
		t := *r.delete
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("delete", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("delete", parameterToString(t, "multi"))
		}
	}
	if r.add != nil {
		t := *r.add
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("add", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("add", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
