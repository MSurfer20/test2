/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * API version: 1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// MessagesApiService MessagesApi service
type MessagesApiService service

type ApiAddReactionRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	messageId int32
	emojiName *string
	emojiCode *string
	reactionType *string
}

func (r ApiAddReactionRequest) EmojiName(emojiName string) ApiAddReactionRequest {
	r.emojiName = &emojiName
	return r
}
func (r ApiAddReactionRequest) EmojiCode(emojiCode string) ApiAddReactionRequest {
	r.emojiCode = &emojiCode
	return r
}
func (r ApiAddReactionRequest) ReactionType(reactionType string) ApiAddReactionRequest {
	r.reactionType = &reactionType
	return r
}

func (r ApiAddReactionRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.AddReactionExecute(r)
}

/*
 * AddReaction Add an emoji reaction
 * Add an [emoji reaction](/help/emoji-reactions) to a message.

`POST {{ api_url }}/v1/messages/{message_id}/reactions`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param messageId The target message's ID. 
 * @return ApiAddReactionRequest
 */
func (a *MessagesApiService) AddReaction(ctx _context.Context, messageId int32) ApiAddReactionRequest {
	return ApiAddReactionRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *MessagesApiService) AddReactionExecute(r ApiAddReactionRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.AddReaction")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{message_id}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.emojiName == nil {
		return localVarReturnValue, nil, reportError("emojiName is required and must be specified")
	}

	localVarQueryParams.Add("emoji_name", parameterToString(*r.emojiName, ""))
	if r.emojiCode != nil {
		localVarQueryParams.Add("emoji_code", parameterToString(*r.emojiCode, ""))
	}
	if r.reactionType != nil {
		localVarQueryParams.Add("reaction_type", parameterToString(*r.reactionType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CodedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckMessagesMatchNarrowRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	msgIds *[]int32
	narrow *[]map[string]interface{}
}

func (r ApiCheckMessagesMatchNarrowRequest) MsgIds(msgIds []int32) ApiCheckMessagesMatchNarrowRequest {
	r.msgIds = &msgIds
	return r
}
func (r ApiCheckMessagesMatchNarrowRequest) Narrow(narrow []map[string]interface{}) ApiCheckMessagesMatchNarrowRequest {
	r.narrow = &narrow
	return r
}

func (r ApiCheckMessagesMatchNarrowRequest) Execute() (interface{}, *_nethttp.Response, error) {
	return r.ApiService.CheckMessagesMatchNarrowExecute(r)
}

/*
 * CheckMessagesMatchNarrow Check if messages match a narrow
 * Check whether a set of messages match a [narrow](/api/construct-narrow).

`GET {{ api_url }}/v1/messages/matches_narrow`

For many common narrows (E.g. a topic), clients can write an
efficient client-side check to determine whether a
newly arrived message belongs in the view.

This endpoint is designed to allow clients to handle more complex narrows
for which the client does not (or in the case of full-text search,
cannot) implement this check.

The format of the `match_subject` and `match_content` objects is designed to match
those of `GET /messages`, so that a client can splice these fields into a
`message` object received from `GET /events` and end up with an extended message
object identical to how a `GET /messages` for the current narrow would have
returned the message.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCheckMessagesMatchNarrowRequest
 */
func (a *MessagesApiService) CheckMessagesMatchNarrow(ctx _context.Context) ApiCheckMessagesMatchNarrowRequest {
	return ApiCheckMessagesMatchNarrowRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return interface{}
 */
func (a *MessagesApiService) CheckMessagesMatchNarrowExecute(r ApiCheckMessagesMatchNarrowRequest) (interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.CheckMessagesMatchNarrow")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/matches_narrow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.msgIds == nil {
		return localVarReturnValue, nil, reportError("msgIds is required and must be specified")
	}
	if r.narrow == nil {
		return localVarReturnValue, nil, reportError("narrow is required and must be specified")
	}

	{
		t := *r.msgIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("msg_ids", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("msg_ids", parameterToString(t, "multi"))
		}
	}
	{
		t := *r.narrow
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("narrow", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("narrow", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMessageRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	messageId int32
}


func (r ApiDeleteMessageRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.DeleteMessageExecute(r)
}

/*
 * DeleteMessage Delete a message
 * Permanently delete a message.

`DELETE {{ api_url }}/v1/messages/{msg_id}`

This API corresponds to the
[delete a message completely][delete-completely] feature documented in
the Zulip Help Center.

[delete-completely]: /help/edit-or-delete-a-message#delete-a-message-completely

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param messageId The target message's ID. 
 * @return ApiDeleteMessageRequest
 */
func (a *MessagesApiService) DeleteMessage(ctx _context.Context, messageId int32) ApiDeleteMessageRequest {
	return ApiDeleteMessageRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *MessagesApiService) DeleteMessageExecute(r ApiDeleteMessageRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.DeleteMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OneOfobjectobject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFileTemporaryUrlRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	realmIdStr int32
	filename string
}


func (r ApiGetFileTemporaryUrlRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetFileTemporaryUrlExecute(r)
}

/*
 * GetFileTemporaryUrl Get public temporary URL
 * Get a temporary URL for access to the file that doesn't require authentication.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param realmIdStr The realm id. 
 * @param filename Path to the URL. 
 * @return ApiGetFileTemporaryUrlRequest
 */
func (a *MessagesApiService) GetFileTemporaryUrl(ctx _context.Context, realmIdStr int32, filename string) ApiGetFileTemporaryUrlRequest {
	return ApiGetFileTemporaryUrlRequest{
		ApiService: a,
		ctx: ctx,
		realmIdStr: realmIdStr,
		filename: filename,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *MessagesApiService) GetFileTemporaryUrlExecute(r ApiGetFileTemporaryUrlRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.GetFileTemporaryUrl")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_uploads/{realm_id_str}/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"realm_id_str"+"}", _neturl.PathEscape(parameterToString(r.realmIdStr, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", _neturl.PathEscape(parameterToString(r.filename, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessageHistoryRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	messageId int32
}


func (r ApiGetMessageHistoryRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetMessageHistoryExecute(r)
}

/*
 * GetMessageHistory Get a message's edit history
 * Fetch the message edit history of a previously edited message.

`GET {{ api_url }}/v1/messages/{message_id}/history`

Note that edit history may be disabled in some organizations; see the
[Zulip Help Center documentation on editing messages][edit-settings].

[edit-settings]: /help/view-a-messages-edit-history

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param messageId The target message's ID. 
 * @return ApiGetMessageHistoryRequest
 */
func (a *MessagesApiService) GetMessageHistory(ctx _context.Context, messageId int32) ApiGetMessageHistoryRequest {
	return ApiGetMessageHistoryRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *MessagesApiService) GetMessageHistoryExecute(r ApiGetMessageHistoryRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.GetMessageHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{message_id}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMessageError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessagesRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	numBefore *int32
	numAfter *int32
	anchor *OneOfstringinteger
	narrow *[]map[string]interface{}
	clientGravatar *bool
	applyMarkdown *bool
	useFirstUnreadAnchor *bool
}

func (r ApiGetMessagesRequest) NumBefore(numBefore int32) ApiGetMessagesRequest {
	r.numBefore = &numBefore
	return r
}
func (r ApiGetMessagesRequest) NumAfter(numAfter int32) ApiGetMessagesRequest {
	r.numAfter = &numAfter
	return r
}
func (r ApiGetMessagesRequest) Anchor(anchor OneOfstringinteger) ApiGetMessagesRequest {
	r.anchor = &anchor
	return r
}
func (r ApiGetMessagesRequest) Narrow(narrow []map[string]interface{}) ApiGetMessagesRequest {
	r.narrow = &narrow
	return r
}
func (r ApiGetMessagesRequest) ClientGravatar(clientGravatar bool) ApiGetMessagesRequest {
	r.clientGravatar = &clientGravatar
	return r
}
func (r ApiGetMessagesRequest) ApplyMarkdown(applyMarkdown bool) ApiGetMessagesRequest {
	r.applyMarkdown = &applyMarkdown
	return r
}
func (r ApiGetMessagesRequest) UseFirstUnreadAnchor(useFirstUnreadAnchor bool) ApiGetMessagesRequest {
	r.useFirstUnreadAnchor = &useFirstUnreadAnchor
	return r
}

func (r ApiGetMessagesRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetMessagesExecute(r)
}

/*
 * GetMessages Get messages
 * Fetch message history from a Zulip server.

`GET {{ api_url }}/v1/messages`

This `GET /api/v1/messages` endpoint is the primary way to fetch
message history from a Zulip server.  It is useful both for Zulip
clients (e.g. the web, desktop, mobile, and terminal clients) as well
as bots, API clients, backup scripts, etc.

By specifying a [narrow filter](/api/construct-narrow), you can use
this endpoint to fetch the messages matching any search query that is
supported by Zulip's powerful full-text search backend.

When a narrow is not specified, it can be used to fetch a user's
message history. (We recommend paginating to 1000 messages at a time.)

In either case, you specify an `anchor` message (or ask the server to
calculate the first unread message for you and use that as the
anchor), as well as a number of messages before and after the anchor
message.  The server returns those messages, sorted by message ID, as
well as some metadata that makes it easy for a client to determine
whether there are more messages matching the query that were not
returned due to the `num_before` and `num_after` limits.

We recommend using `num_before <= 1000` and `num_after <= 1000` to
avoid generating very large HTTP responses. A maximum of 5000 messages
can be obtained per request; attempting to exceed this will result in an
error.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetMessagesRequest
 */
func (a *MessagesApiService) GetMessages(ctx _context.Context) ApiGetMessagesRequest {
	return ApiGetMessagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *MessagesApiService) GetMessagesExecute(r ApiGetMessagesRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.GetMessages")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.numBefore == nil {
		return localVarReturnValue, nil, reportError("numBefore is required and must be specified")
	}
	if *r.numBefore < 0 {
		return localVarReturnValue, nil, reportError("numBefore must be greater than 0")
	}
	if r.numAfter == nil {
		return localVarReturnValue, nil, reportError("numAfter is required and must be specified")
	}
	if *r.numAfter < 0 {
		return localVarReturnValue, nil, reportError("numAfter must be greater than 0")
	}

	if r.anchor != nil {
		localVarQueryParams.Add("anchor", parameterToString(*r.anchor, ""))
	}
	localVarQueryParams.Add("num_before", parameterToString(*r.numBefore, ""))
	localVarQueryParams.Add("num_after", parameterToString(*r.numAfter, ""))
	if r.narrow != nil {
		t := *r.narrow
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("narrow", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("narrow", parameterToString(t, "multi"))
		}
	}
	if r.clientGravatar != nil {
		localVarQueryParams.Add("client_gravatar", parameterToString(*r.clientGravatar, ""))
	}
	if r.applyMarkdown != nil {
		localVarQueryParams.Add("apply_markdown", parameterToString(*r.applyMarkdown, ""))
	}
	if r.useFirstUnreadAnchor != nil {
		localVarQueryParams.Add("use_first_unread_anchor", parameterToString(*r.useFirstUnreadAnchor, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawMessageRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	messageId int32
}


func (r ApiGetRawMessageRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetRawMessageExecute(r)
}

/*
 * GetRawMessage Get a message's raw Markdown
 * Get the raw content of a message.

`GET {{ api_url }}/v1/messages/{msg_id}`

This is a rarely-used endpoint relevant for clients that primarily
work with HTML-rendered messages but might need to occasionally fetch
the message's raw Markdown (e.g. for pre-filling a message-editing
UI).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param messageId The target message's ID. 
 * @return ApiGetRawMessageRequest
 */
func (a *MessagesApiService) GetRawMessage(ctx _context.Context, messageId int32) ApiGetRawMessageRequest {
	return ApiGetRawMessageRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *MessagesApiService) GetRawMessageExecute(r ApiGetRawMessageRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.GetRawMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMessageError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarkAllAsReadRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
}


func (r ApiMarkAllAsReadRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.MarkAllAsReadExecute(r)
}

/*
 * MarkAllAsRead Mark all messages as read
 * Marks all of the current user's unread messages as read.

`POST {{ api_url }}/v1/mark_all_as_read`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiMarkAllAsReadRequest
 */
func (a *MessagesApiService) MarkAllAsRead(ctx _context.Context) ApiMarkAllAsReadRequest {
	return ApiMarkAllAsReadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *MessagesApiService) MarkAllAsReadExecute(r ApiMarkAllAsReadRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.MarkAllAsRead")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mark_all_as_read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarkStreamAsReadRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	streamId *int32
}

func (r ApiMarkStreamAsReadRequest) StreamId(streamId int32) ApiMarkStreamAsReadRequest {
	r.streamId = &streamId
	return r
}

func (r ApiMarkStreamAsReadRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.MarkStreamAsReadExecute(r)
}

/*
 * MarkStreamAsRead Mark messages in a stream as read
 * Mark all the unread messages in a stream as read.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiMarkStreamAsReadRequest
 */
func (a *MessagesApiService) MarkStreamAsRead(ctx _context.Context) ApiMarkStreamAsReadRequest {
	return ApiMarkStreamAsReadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *MessagesApiService) MarkStreamAsReadExecute(r ApiMarkStreamAsReadRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.MarkStreamAsRead")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mark_stream_as_read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.streamId == nil {
		return localVarReturnValue, nil, reportError("streamId is required and must be specified")
	}

	localVarQueryParams.Add("stream_id", parameterToString(*r.streamId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarkTopicAsReadRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	streamId *int32
	topicName *string
}

func (r ApiMarkTopicAsReadRequest) StreamId(streamId int32) ApiMarkTopicAsReadRequest {
	r.streamId = &streamId
	return r
}
func (r ApiMarkTopicAsReadRequest) TopicName(topicName string) ApiMarkTopicAsReadRequest {
	r.topicName = &topicName
	return r
}

func (r ApiMarkTopicAsReadRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.MarkTopicAsReadExecute(r)
}

/*
 * MarkTopicAsRead Mark messages in a topic as read
 * Mark all the unread messages in a topic as read.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiMarkTopicAsReadRequest
 */
func (a *MessagesApiService) MarkTopicAsRead(ctx _context.Context) ApiMarkTopicAsReadRequest {
	return ApiMarkTopicAsReadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *MessagesApiService) MarkTopicAsReadExecute(r ApiMarkTopicAsReadRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.MarkTopicAsRead")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mark_topic_as_read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.streamId == nil {
		return localVarReturnValue, nil, reportError("streamId is required and must be specified")
	}
	if r.topicName == nil {
		return localVarReturnValue, nil, reportError("topicName is required and must be specified")
	}

	localVarQueryParams.Add("stream_id", parameterToString(*r.streamId, ""))
	localVarQueryParams.Add("topic_name", parameterToString(*r.topicName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveReactionRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	messageId int32
	emojiName *string
	emojiCode *string
	reactionType *string
}

func (r ApiRemoveReactionRequest) EmojiName(emojiName string) ApiRemoveReactionRequest {
	r.emojiName = &emojiName
	return r
}
func (r ApiRemoveReactionRequest) EmojiCode(emojiCode string) ApiRemoveReactionRequest {
	r.emojiCode = &emojiCode
	return r
}
func (r ApiRemoveReactionRequest) ReactionType(reactionType string) ApiRemoveReactionRequest {
	r.reactionType = &reactionType
	return r
}

func (r ApiRemoveReactionRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.RemoveReactionExecute(r)
}

/*
 * RemoveReaction Remove an emoji reaction
 * Remove an [emoji reaction](/help/emoji-reactions) from a message.

`DELETE {{ api_url }}/v1/messages/{message_id}/reactions`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param messageId The target message's ID. 
 * @return ApiRemoveReactionRequest
 */
func (a *MessagesApiService) RemoveReaction(ctx _context.Context, messageId int32) ApiRemoveReactionRequest {
	return ApiRemoveReactionRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *MessagesApiService) RemoveReactionExecute(r ApiRemoveReactionRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.RemoveReaction")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{message_id}/reactions"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.emojiName != nil {
		localVarQueryParams.Add("emoji_name", parameterToString(*r.emojiName, ""))
	}
	if r.emojiCode != nil {
		localVarQueryParams.Add("emoji_code", parameterToString(*r.emojiCode, ""))
	}
	if r.reactionType != nil {
		localVarQueryParams.Add("reaction_type", parameterToString(*r.reactionType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CodedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRenderMessageRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	content *string
}

func (r ApiRenderMessageRequest) Content(content string) ApiRenderMessageRequest {
	r.content = &content
	return r
}

func (r ApiRenderMessageRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.RenderMessageExecute(r)
}

/*
 * RenderMessage Render message
 * Render a message to HTML.

`POST {{ api_url }}/v1/messages/render`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiRenderMessageRequest
 */
func (a *MessagesApiService) RenderMessage(ctx _context.Context) ApiRenderMessageRequest {
	return ApiRenderMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *MessagesApiService) RenderMessageExecute(r ApiRenderMessageRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.RenderMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/render"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}

	localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendMessageRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	type_ *string
	to *[]int32
	content *string
	topic *string
	queueId *string
	localId *string
}

func (r ApiSendMessageRequest) Type_(type_ string) ApiSendMessageRequest {
	r.type_ = &type_
	return r
}
func (r ApiSendMessageRequest) To(to []int32) ApiSendMessageRequest {
	r.to = &to
	return r
}
func (r ApiSendMessageRequest) Content(content string) ApiSendMessageRequest {
	r.content = &content
	return r
}
func (r ApiSendMessageRequest) Topic(topic string) ApiSendMessageRequest {
	r.topic = &topic
	return r
}
func (r ApiSendMessageRequest) QueueId(queueId string) ApiSendMessageRequest {
	r.queueId = &queueId
	return r
}
func (r ApiSendMessageRequest) LocalId(localId string) ApiSendMessageRequest {
	r.localId = &localId
	return r
}

func (r ApiSendMessageRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.SendMessageExecute(r)
}

/*
 * SendMessage Send a message
 * Send a stream or a private message.

`POST {{ api_url }}/v1/messages`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSendMessageRequest
 */
func (a *MessagesApiService) SendMessage(ctx _context.Context) ApiSendMessageRequest {
	return ApiSendMessageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *MessagesApiService) SendMessageExecute(r ApiSendMessageRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.SendMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}

	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	{
		t := *r.to
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("to", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("to", parameterToString(t, "multi"))
		}
	}
	localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	if r.topic != nil {
		localVarQueryParams.Add("topic", parameterToString(*r.topic, ""))
	}
	if r.queueId != nil {
		localVarQueryParams.Add("queue_id", parameterToString(*r.queueId, ""))
	}
	if r.localId != nil {
		localVarQueryParams.Add("local_id", parameterToString(*r.localId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OneOfobjectobject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMessageRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	messageId int32
	topic *string
	propagateMode *string
	sendNotificationToOldThread *bool
	sendNotificationToNewThread *bool
	content *string
	streamId *int32
}

func (r ApiUpdateMessageRequest) Topic(topic string) ApiUpdateMessageRequest {
	r.topic = &topic
	return r
}
func (r ApiUpdateMessageRequest) PropagateMode(propagateMode string) ApiUpdateMessageRequest {
	r.propagateMode = &propagateMode
	return r
}
func (r ApiUpdateMessageRequest) SendNotificationToOldThread(sendNotificationToOldThread bool) ApiUpdateMessageRequest {
	r.sendNotificationToOldThread = &sendNotificationToOldThread
	return r
}
func (r ApiUpdateMessageRequest) SendNotificationToNewThread(sendNotificationToNewThread bool) ApiUpdateMessageRequest {
	r.sendNotificationToNewThread = &sendNotificationToNewThread
	return r
}
func (r ApiUpdateMessageRequest) Content(content string) ApiUpdateMessageRequest {
	r.content = &content
	return r
}
func (r ApiUpdateMessageRequest) StreamId(streamId int32) ApiUpdateMessageRequest {
	r.streamId = &streamId
	return r
}

func (r ApiUpdateMessageRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateMessageExecute(r)
}

/*
 * UpdateMessage Edit a message
 * Edit/update the content or topic of a message.

`PATCH {{ api_url }}/v1/messages/{msg_id}`

`{msg_id}` in the above URL should be replaced with the ID of the
message you wish you update.

You can [resolve topics](/help/resolve-a-topic) by editing the
topic to `✔ {original_topic}`.

**Note**: See [configuring message
editing][config-message-editing] for detailed documentation on
when users are allowed to edit topics.

[config-message-editing]: /help/configure-message-editing-and-deletion

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param messageId The target message's ID. 
 * @return ApiUpdateMessageRequest
 */
func (a *MessagesApiService) UpdateMessage(ctx _context.Context, messageId int32) ApiUpdateMessageRequest {
	return ApiUpdateMessageRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *MessagesApiService) UpdateMessageExecute(r ApiUpdateMessageRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.UpdateMessage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", _neturl.PathEscape(parameterToString(r.messageId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.topic != nil {
		localVarQueryParams.Add("topic", parameterToString(*r.topic, ""))
	}
	if r.propagateMode != nil {
		localVarQueryParams.Add("propagate_mode", parameterToString(*r.propagateMode, ""))
	}
	if r.sendNotificationToOldThread != nil {
		localVarQueryParams.Add("send_notification_to_old_thread", parameterToString(*r.sendNotificationToOldThread, ""))
	}
	if r.sendNotificationToNewThread != nil {
		localVarQueryParams.Add("send_notification_to_new_thread", parameterToString(*r.sendNotificationToNewThread, ""))
	}
	if r.content != nil {
		localVarQueryParams.Add("content", parameterToString(*r.content, ""))
	}
	if r.streamId != nil {
		localVarQueryParams.Add("stream_id", parameterToString(*r.streamId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CodedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMessageFlagsRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	messages *[]int32
	op *string
	flag *string
}

func (r ApiUpdateMessageFlagsRequest) Messages(messages []int32) ApiUpdateMessageFlagsRequest {
	r.messages = &messages
	return r
}
func (r ApiUpdateMessageFlagsRequest) Op(op string) ApiUpdateMessageFlagsRequest {
	r.op = &op
	return r
}
func (r ApiUpdateMessageFlagsRequest) Flag(flag string) ApiUpdateMessageFlagsRequest {
	r.flag = &flag
	return r
}

func (r ApiUpdateMessageFlagsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.UpdateMessageFlagsExecute(r)
}

/*
 * UpdateMessageFlags Update personal message flags
 * Add or remove personal message flags like `read` and `starred`
on a collection of message IDs.

`POST {{ api_url }}/v1/messages/flags`

For updating the `read` flag on common collections of messages, see also
the
[special endpoints for marking message as read in bulk](/api/mark-all-as-read).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateMessageFlagsRequest
 */
func (a *MessagesApiService) UpdateMessageFlags(ctx _context.Context) ApiUpdateMessageFlagsRequest {
	return ApiUpdateMessageFlagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *MessagesApiService) UpdateMessageFlagsExecute(r ApiUpdateMessageFlagsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.UpdateMessageFlags")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/flags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.messages == nil {
		return localVarReturnValue, nil, reportError("messages is required and must be specified")
	}
	if r.op == nil {
		return localVarReturnValue, nil, reportError("op is required and must be specified")
	}
	if r.flag == nil {
		return localVarReturnValue, nil, reportError("flag is required and must be specified")
	}

	{
		t := *r.messages
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("messages", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("messages", parameterToString(t, "multi"))
		}
	}
	localVarQueryParams.Add("op", parameterToString(*r.op, ""))
	localVarQueryParams.Add("flag", parameterToString(*r.flag, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadFileRequest struct {
	ctx _context.Context
	ApiService *MessagesApiService
	filename **os.File
}

func (r ApiUploadFileRequest) Filename(filename *os.File) ApiUploadFileRequest {
	r.filename = &filename
	return r
}

func (r ApiUploadFileRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.UploadFileExecute(r)
}

/*
 * UploadFile Upload a file
 * Upload a single file and get the corresponding URI.

`POST {{ api_url }}/v1/user_uploads`

Initially, only you will be able to access the link.  To share the
uploaded file, you'll need to [send a message][send-message]
containing the resulting link.  Users who can already access the link
can reshare it with other users by sending additional Zulip messages
containing the link.

[uploaded-files]: /help/manage-your-uploaded-files
[send-message]: /api/send-message

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUploadFileRequest
 */
func (a *MessagesApiService) UploadFile(ctx _context.Context) ApiUploadFileRequest {
	return ApiUploadFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *MessagesApiService) UploadFileExecute(r ApiUploadFileRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MessagesApiService.UploadFile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_uploads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormFileName = "filename"
	var localVarFile *os.File
	if r.filename != nil {
		localVarFile = *r.filename
	}
	if localVarFile != nil {
		fbs, _ := _ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
