/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * API version: 1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// UsersApiService UsersApi service
type UsersApiService service

type ApiCreateUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	email *string
	password *string
	fullName *string
}

func (r ApiCreateUserRequest) Email(email string) ApiCreateUserRequest {
	r.email = &email
	return r
}
func (r ApiCreateUserRequest) Password(password string) ApiCreateUserRequest {
	r.password = &password
	return r
}
func (r ApiCreateUserRequest) FullName(fullName string) ApiCreateUserRequest {
	r.fullName = &fullName
	return r
}

func (r ApiCreateUserRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.CreateUserExecute(r)
}

/*
 * CreateUser Create a user
 * {!can-create-users-only.md!}

Create a new user account via the API.

`POST {{ api_url }}/v1/users`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateUserRequest
 */
func (a *UsersApiService) CreateUser(ctx _context.Context) ApiCreateUserRequest {
	return ApiCreateUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) CreateUserExecute(r ApiCreateUserRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.CreateUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.password == nil {
		return localVarReturnValue, nil, reportError("password is required and must be specified")
	}
	if r.fullName == nil {
		return localVarReturnValue, nil, reportError("fullName is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("password", parameterToString(*r.password, ""))
	localVarQueryParams.Add("full_name", parameterToString(*r.fullName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserGroupRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	name *string
	description *string
	members *[]int32
}

func (r ApiCreateUserGroupRequest) Name(name string) ApiCreateUserGroupRequest {
	r.name = &name
	return r
}
func (r ApiCreateUserGroupRequest) Description(description string) ApiCreateUserGroupRequest {
	r.description = &description
	return r
}
func (r ApiCreateUserGroupRequest) Members(members []int32) ApiCreateUserGroupRequest {
	r.members = &members
	return r
}

func (r ApiCreateUserGroupRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.CreateUserGroupExecute(r)
}

/*
 * CreateUserGroup Create a user group
 * Create a new [user group](/help/user-groups).

`POST {{ api_url }}/v1/user_groups/create`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateUserGroupRequest
 */
func (a *UsersApiService) CreateUserGroup(ctx _context.Context) ApiCreateUserGroupRequest {
	return ApiCreateUserGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) CreateUserGroupExecute(r ApiCreateUserGroupRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.CreateUserGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_groups/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if r.members == nil {
		return localVarReturnValue, nil, reportError("members is required and must be specified")
	}

	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	{
		t := *r.members
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("members", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("members", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeactivateOwnUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
}


func (r ApiDeactivateOwnUserRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.DeactivateOwnUserExecute(r)
}

/*
 * DeactivateOwnUser Deactivate own user
 * Deactivates the user's account.  See also the administrative endpoint for
[deactivating another user](/api/deactivate-user).

`DELETE {{ api_url }}/v1/users/me`

This endpoint is primarily useful to Zulip clients providing a user settings UI.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDeactivateOwnUserRequest
 */
func (a *UsersApiService) DeactivateOwnUser(ctx _context.Context) ApiDeactivateOwnUserRequest {
	return ApiDeactivateOwnUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) DeactivateOwnUserExecute(r ApiDeactivateOwnUserRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.DeactivateOwnUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeactivateUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userId int32
}


func (r ApiDeactivateUserRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.DeactivateUserExecute(r)
}

/*
 * DeactivateUser Deactivate a user
 * [Deactivates a
user](https://zulip.com/help/deactivate-or-reactivate-a-user)
given their user ID.

`DELETE {{ api_url }}/v1/users/{user_id}`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId The target user's ID. 
 * @return ApiDeactivateUserRequest
 */
func (a *UsersApiService) DeactivateUser(ctx _context.Context, userId int32) ApiDeactivateUserRequest {
	return ApiDeactivateUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) DeactivateUserExecute(r ApiDeactivateUserRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.DeactivateUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
}


func (r ApiGetAttachmentsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetAttachmentsExecute(r)
}

/*
 * GetAttachments Get attachments
 * Fetch metadata on files uploaded by the requesting user.

`GET {{ api_url }}/v1/attachments`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAttachmentsRequest
 */
func (a *UsersApiService) GetAttachments(ctx _context.Context) ApiGetAttachmentsRequest {
	return ApiGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetAttachmentsExecute(r ApiGetAttachmentsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOwnUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
}


func (r ApiGetOwnUserRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetOwnUserExecute(r)
}

/*
 * GetOwnUser Get own user
 * Get basic data about the user/bot that requests this endpoint.

`GET {{ api_url }}/v1/users/me`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetOwnUserRequest
 */
func (a *UsersApiService) GetOwnUser(ctx _context.Context) ApiGetOwnUserRequest {
	return ApiGetOwnUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetOwnUserExecute(r ApiGetOwnUserRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetOwnUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userId int32
	clientGravatar *bool
	includeCustomProfileFields *bool
}

func (r ApiGetUserRequest) ClientGravatar(clientGravatar bool) ApiGetUserRequest {
	r.clientGravatar = &clientGravatar
	return r
}
func (r ApiGetUserRequest) IncludeCustomProfileFields(includeCustomProfileFields bool) ApiGetUserRequest {
	r.includeCustomProfileFields = &includeCustomProfileFields
	return r
}

func (r ApiGetUserRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetUserExecute(r)
}

/*
 * GetUser Get a user
 * Fetch details for a single user in the organization.

`GET {{ api_url }}/v1/users/{user_id}`

You can also fetch details on [all users in the organization](/api/get-users)
or [by email](/api/get-user-by-email).

*This endpoint is new in Zulip Server 3.0 (feature level 1).*

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId The target user's ID. 
 * @return ApiGetUserRequest
 */
func (a *UsersApiService) GetUser(ctx _context.Context, userId int32) ApiGetUserRequest {
	return ApiGetUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetUserExecute(r ApiGetUserRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.clientGravatar != nil {
		localVarQueryParams.Add("client_gravatar", parameterToString(*r.clientGravatar, ""))
	}
	if r.includeCustomProfileFields != nil {
		localVarQueryParams.Add("include_custom_profile_fields", parameterToString(*r.includeCustomProfileFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserByEmailRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	email string
	clientGravatar *bool
	includeCustomProfileFields *bool
}

func (r ApiGetUserByEmailRequest) ClientGravatar(clientGravatar bool) ApiGetUserByEmailRequest {
	r.clientGravatar = &clientGravatar
	return r
}
func (r ApiGetUserByEmailRequest) IncludeCustomProfileFields(includeCustomProfileFields bool) ApiGetUserByEmailRequest {
	r.includeCustomProfileFields = &includeCustomProfileFields
	return r
}

func (r ApiGetUserByEmailRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetUserByEmailExecute(r)
}

/*
 * GetUserByEmail Get a user by email
 * Fetch details for a single user in the organization given a Zulip display
email address.

`GET {{ api_url }}/v1/users/{email}`

Note that this endpoint uses Zulip display emails addresses
for organizations that have configured limited [email address
visibility](/help/restrict-visibility-of-email-addresses).

You can also fetch details on [all users in the organization](/api/get-users) or
[by user ID](/api/get-user).  Fetching by user ID is generally recommended
when possible, as users can
[change their email address](/help/change-your-email-address).

*This endpoint is new in Zulip Server 4.0 (feature level 39).*

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param email The email address of the user whose details you want to fetch. 
 * @return ApiGetUserByEmailRequest
 */
func (a *UsersApiService) GetUserByEmail(ctx _context.Context, email string) ApiGetUserByEmailRequest {
	return ApiGetUserByEmailRequest{
		ApiService: a,
		ctx: ctx,
		email: email,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetUserByEmailExecute(r ApiGetUserByEmailRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetUserByEmail")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{email}"
	localVarPath = strings.Replace(localVarPath, "{"+"email"+"}", _neturl.PathEscape(parameterToString(r.email, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.clientGravatar != nil {
		localVarQueryParams.Add("client_gravatar", parameterToString(*r.clientGravatar, ""))
	}
	if r.includeCustomProfileFields != nil {
		localVarQueryParams.Add("include_custom_profile_fields", parameterToString(*r.includeCustomProfileFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserGroupsRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
}


func (r ApiGetUserGroupsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetUserGroupsExecute(r)
}

/*
 * GetUserGroups Get user groups
 * {!api-members-only.md!}

Fetches all of the user groups in the organization.

`GET {{ api_url }}/v1/user_groups`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetUserGroupsRequest
 */
func (a *UsersApiService) GetUserGroups(ctx _context.Context) ApiGetUserGroupsRequest {
	return ApiGetUserGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetUserGroupsExecute(r ApiGetUserGroupsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetUserGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserPresenceRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userIdOrEmail string
}


func (r ApiGetUserPresenceRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetUserPresenceExecute(r)
}

/*
 * GetUserPresence Get user presence
 * Get the presence status for a specific user.

This endpoint is most useful for embedding data about a user's
presence status in other sites (E.g. an employee directory).  Full
Zulip clients like mobile/desktop apps will want to use the main
presence endpoint, which returns data for all active users in the
organization, instead.

`GET {{ api_url }}/v1/users/{user_id_or_email}/presence`

See
[Zulip's developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html)
for details on the data model for presence in Zulip.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userIdOrEmail The user_id or Zulip display email address of the user whose presence you want to fetch.  **Changes**: New in Zulip 4.0 (feature level 43). Previous versions only supported identifying the user by Zulip display email. 
 * @return ApiGetUserPresenceRequest
 */
func (a *UsersApiService) GetUserPresence(ctx _context.Context, userIdOrEmail string) ApiGetUserPresenceRequest {
	return ApiGetUserPresenceRequest{
		ApiService: a,
		ctx: ctx,
		userIdOrEmail: userIdOrEmail,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetUserPresenceExecute(r ApiGetUserPresenceRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetUserPresence")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id_or_email}/presence"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id_or_email"+"}", _neturl.PathEscape(parameterToString(r.userIdOrEmail, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	clientGravatar *bool
	includeCustomProfileFields *bool
}

func (r ApiGetUsersRequest) ClientGravatar(clientGravatar bool) ApiGetUsersRequest {
	r.clientGravatar = &clientGravatar
	return r
}
func (r ApiGetUsersRequest) IncludeCustomProfileFields(includeCustomProfileFields bool) ApiGetUsersRequest {
	r.includeCustomProfileFields = &includeCustomProfileFields
	return r
}

func (r ApiGetUsersRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetUsersExecute(r)
}

/*
 * GetUsers Get all users
 * Retrieve details on all users in the organization.  Optionally
includes values of [custom profile field](/help/add-custom-profile-fields).

`GET {{ api_url }}/v1/users`

You can also [fetch details on a single user](/api/get-user).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetUsersRequest
 */
func (a *UsersApiService) GetUsers(ctx _context.Context) ApiGetUsersRequest {
	return ApiGetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetUsersExecute(r ApiGetUsersRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.clientGravatar != nil {
		localVarQueryParams.Add("client_gravatar", parameterToString(*r.clientGravatar, ""))
	}
	if r.includeCustomProfileFields != nil {
		localVarQueryParams.Add("include_custom_profile_fields", parameterToString(*r.includeCustomProfileFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMuteUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	mutedUserId int32
}


func (r ApiMuteUserRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.MuteUserExecute(r)
}

/*
 * MuteUser Mute a user
 * This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users
you've muted will be automatically marked as read and hidden.

`POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`

Muted users should be implemented by clients as follows:

* The server will immediately mark all messages sent by the muted
  user as read.  This will automatically clear any existing mobile
  push notifications related to the muted user.
* The server will mark any new messages sent by the muted user as read
  for your account, which prevents all email and mobile push notifications.
* Clients should exclude muted users from presence lists or other UI
  for viewing or composing 1:1 private messages. 1:1 private messages sent by
  muted users should be hidden everywhere in the Zulip UI.
* Stream messages and group private messages sent by the muted
  user should avoid displaying the content and name/avatar,
  but should display that N messages by a muted user were
  hidden (so that it is possible to interpret the messages by
  other users who are talking with the muted user).
* Group private message conversations including the muted user
  should display muted users as "Muted user", rather than
  showing their name, in lists of such conversations, along with using
  a blank grey avatar where avatars are displayed.
* Administrative/settings UI elements for showing "All users that exist
  on this stream or realm", e.g. for organization
  administration or showing stream subscribers, should display
  the user's name as normal.

**Changes**: New in Zulip 4.0 (feature level 48).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mutedUserId The ID of the user to mute/un-mute. 
 * @return ApiMuteUserRequest
 */
func (a *UsersApiService) MuteUser(ctx _context.Context, mutedUserId int32) ApiMuteUserRequest {
	return ApiMuteUserRequest{
		ApiService: a,
		ctx: ctx,
		mutedUserId: mutedUserId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) MuteUserExecute(r ApiMuteUserRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.MuteUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/muted_users/{muted_user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"muted_user_id"+"}", _neturl.PathEscape(parameterToString(r.mutedUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OneOfobjectobjectobject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactivateUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userId int32
}


func (r ApiReactivateUserRequest) Execute() (interface{}, *_nethttp.Response, error) {
	return r.ApiService.ReactivateUserExecute(r)
}

/*
 * ReactivateUser Reactivate a user
 * [Reactivates a
user](https://zulip.com/help/deactivate-or-reactivate-a-user)
given their user ID.

`POST {{ api_url }}/v1/users/{user_id}/reactivate`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId The target user's ID. 
 * @return ApiReactivateUserRequest
 */
func (a *UsersApiService) ReactivateUser(ctx _context.Context, userId int32) ApiReactivateUserRequest {
	return ApiReactivateUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

/*
 * Execute executes the request
 * @return interface{}
 */
func (a *UsersApiService) ReactivateUserExecute(r ApiReactivateUserRequest) (interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.ReactivateUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/reactivate"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveUserGroupRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userGroupId int32
}


func (r ApiRemoveUserGroupRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.RemoveUserGroupExecute(r)
}

/*
 * RemoveUserGroup Delete a user group
 * Delete a [user group](/help/user-groups).

`DELETE {{ api_url }}/v1/user_groups/{user_group_id}`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userGroupId The ID of the target user group. 
 * @return ApiRemoveUserGroupRequest
 */
func (a *UsersApiService) RemoveUserGroup(ctx _context.Context, userGroupId int32) ApiRemoveUserGroupRequest {
	return ApiRemoveUserGroupRequest{
		ApiService: a,
		ctx: ctx,
		userGroupId: userGroupId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) RemoveUserGroupExecute(r ApiRemoveUserGroupRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.RemoveUserGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_groups/{user_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_group_id"+"}", _neturl.PathEscape(parameterToString(r.userGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetTypingStatusRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	op *string
	to *[]int32
	type_ *string
	topic *string
}

func (r ApiSetTypingStatusRequest) Op(op string) ApiSetTypingStatusRequest {
	r.op = &op
	return r
}
func (r ApiSetTypingStatusRequest) To(to []int32) ApiSetTypingStatusRequest {
	r.to = &to
	return r
}
func (r ApiSetTypingStatusRequest) Type_(type_ string) ApiSetTypingStatusRequest {
	r.type_ = &type_
	return r
}
func (r ApiSetTypingStatusRequest) Topic(topic string) ApiSetTypingStatusRequest {
	r.topic = &topic
	return r
}

func (r ApiSetTypingStatusRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.SetTypingStatusExecute(r)
}

/*
 * SetTypingStatus Set \"typing\" status
 * Notify other users whether the current user is typing a message.

`POST {{ api_url }}/v1/typing`

Clients implementing Zulip's typing notifications protocol should work as follows:

* Send a request to this endpoint with `op="start"` when a user starts typing a message,
  and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to
  actively type or otherwise interact with the compose UI (E.g. interacting with the
  compose box emoji picker).
* Send a request to this endpoint with `op="stop"` when a user pauses using the
  compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels
  the compose action (if it had previously sent a "start" operation for that
  compose action).
* Start displaying "Sender is typing" for a given conversation when the client
  receives an `op="start"` event from the [events API](/api/get-events).
* Continue displaying "Sender is typing" until they receive an `op="stop"` event
  from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`
  seconds have passed without a new `op="start"` event for that conversation.
* Clients that support displaying stream typing notifications (new in Zulip 4.0)
  should indicate they support processing stream typing events via the
  `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.

This protocol is designed to allow the server-side typing notifications implementation
to be stateless while being resilient; network failures cannot result in a user being
incorrectly displayed as perpetually typing.

See
[the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html)
for additional design details on Zulip's typing notifications protocol.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSetTypingStatusRequest
 */
func (a *UsersApiService) SetTypingStatus(ctx _context.Context) ApiSetTypingStatusRequest {
	return ApiSetTypingStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) SetTypingStatusExecute(r ApiSetTypingStatusRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.SetTypingStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/typing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.op == nil {
		return localVarReturnValue, nil, reportError("op is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	localVarQueryParams.Add("op", parameterToString(*r.op, ""))
	{
		t := *r.to
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("to", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("to", parameterToString(t, "multi"))
		}
	}
	if r.topic != nil {
		localVarQueryParams.Add("topic", parameterToString(*r.topic, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnmuteUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	mutedUserId int32
}


func (r ApiUnmuteUserRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UnmuteUserExecute(r)
}

/*
 * UnmuteUser Unmute a user
 * This endpoint unmutes a user.

`DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`

**Changes**: New in Zulip 4.0 (feature level 48).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mutedUserId The ID of the user to mute/un-mute. 
 * @return ApiUnmuteUserRequest
 */
func (a *UsersApiService) UnmuteUser(ctx _context.Context, mutedUserId int32) ApiUnmuteUserRequest {
	return ApiUnmuteUserRequest{
		ApiService: a,
		ctx: ctx,
		mutedUserId: mutedUserId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) UnmuteUserExecute(r ApiUnmuteUserRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UnmuteUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/muted_users/{muted_user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"muted_user_id"+"}", _neturl.PathEscape(parameterToString(r.mutedUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OneOfobjectobject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSettingsRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	fullName *string
	email *string
	oldPassword *string
	newPassword *string
	twentyFourHourTime *bool
	denseMode *bool
	starredMessageCounts *bool
	fluidLayoutWidth *bool
	highContrastMode *bool
	colorScheme *int32
	enableDraftsSynchronization *bool
	translateEmoticons *bool
	defaultLanguage *string
	defaultView *string
	leftSideUserlist *bool
	emojiset *string
	demoteInactiveStreams *int32
	timezone *string
	enableStreamDesktopNotifications *bool
	enableStreamEmailNotifications *bool
	enableStreamPushNotifications *bool
	enableStreamAudibleNotifications *bool
	notificationSound *string
	enableDesktopNotifications *bool
	enableSounds *bool
	emailNotificationsBatchingPeriodSeconds *int32
	enableOfflineEmailNotifications *bool
	enableOfflinePushNotifications *bool
	enableOnlinePushNotifications *bool
	enableDigestEmails *bool
	enableMarketingEmails *bool
	enableLoginEmails *bool
	messageContentInEmailNotifications *bool
	pmContentInDesktopNotifications *bool
	wildcardMentionsNotify *bool
	desktopIconCountDisplay *int32
	realmNameInNotifications *bool
	presenceEnabled *bool
	enterSends *bool
}

func (r ApiUpdateSettingsRequest) FullName(fullName string) ApiUpdateSettingsRequest {
	r.fullName = &fullName
	return r
}
func (r ApiUpdateSettingsRequest) Email(email string) ApiUpdateSettingsRequest {
	r.email = &email
	return r
}
func (r ApiUpdateSettingsRequest) OldPassword(oldPassword string) ApiUpdateSettingsRequest {
	r.oldPassword = &oldPassword
	return r
}
func (r ApiUpdateSettingsRequest) NewPassword(newPassword string) ApiUpdateSettingsRequest {
	r.newPassword = &newPassword
	return r
}
func (r ApiUpdateSettingsRequest) TwentyFourHourTime(twentyFourHourTime bool) ApiUpdateSettingsRequest {
	r.twentyFourHourTime = &twentyFourHourTime
	return r
}
func (r ApiUpdateSettingsRequest) DenseMode(denseMode bool) ApiUpdateSettingsRequest {
	r.denseMode = &denseMode
	return r
}
func (r ApiUpdateSettingsRequest) StarredMessageCounts(starredMessageCounts bool) ApiUpdateSettingsRequest {
	r.starredMessageCounts = &starredMessageCounts
	return r
}
func (r ApiUpdateSettingsRequest) FluidLayoutWidth(fluidLayoutWidth bool) ApiUpdateSettingsRequest {
	r.fluidLayoutWidth = &fluidLayoutWidth
	return r
}
func (r ApiUpdateSettingsRequest) HighContrastMode(highContrastMode bool) ApiUpdateSettingsRequest {
	r.highContrastMode = &highContrastMode
	return r
}
func (r ApiUpdateSettingsRequest) ColorScheme(colorScheme int32) ApiUpdateSettingsRequest {
	r.colorScheme = &colorScheme
	return r
}
func (r ApiUpdateSettingsRequest) EnableDraftsSynchronization(enableDraftsSynchronization bool) ApiUpdateSettingsRequest {
	r.enableDraftsSynchronization = &enableDraftsSynchronization
	return r
}
func (r ApiUpdateSettingsRequest) TranslateEmoticons(translateEmoticons bool) ApiUpdateSettingsRequest {
	r.translateEmoticons = &translateEmoticons
	return r
}
func (r ApiUpdateSettingsRequest) DefaultLanguage(defaultLanguage string) ApiUpdateSettingsRequest {
	r.defaultLanguage = &defaultLanguage
	return r
}
func (r ApiUpdateSettingsRequest) DefaultView(defaultView string) ApiUpdateSettingsRequest {
	r.defaultView = &defaultView
	return r
}
func (r ApiUpdateSettingsRequest) LeftSideUserlist(leftSideUserlist bool) ApiUpdateSettingsRequest {
	r.leftSideUserlist = &leftSideUserlist
	return r
}
func (r ApiUpdateSettingsRequest) Emojiset(emojiset string) ApiUpdateSettingsRequest {
	r.emojiset = &emojiset
	return r
}
func (r ApiUpdateSettingsRequest) DemoteInactiveStreams(demoteInactiveStreams int32) ApiUpdateSettingsRequest {
	r.demoteInactiveStreams = &demoteInactiveStreams
	return r
}
func (r ApiUpdateSettingsRequest) Timezone(timezone string) ApiUpdateSettingsRequest {
	r.timezone = &timezone
	return r
}
func (r ApiUpdateSettingsRequest) EnableStreamDesktopNotifications(enableStreamDesktopNotifications bool) ApiUpdateSettingsRequest {
	r.enableStreamDesktopNotifications = &enableStreamDesktopNotifications
	return r
}
func (r ApiUpdateSettingsRequest) EnableStreamEmailNotifications(enableStreamEmailNotifications bool) ApiUpdateSettingsRequest {
	r.enableStreamEmailNotifications = &enableStreamEmailNotifications
	return r
}
func (r ApiUpdateSettingsRequest) EnableStreamPushNotifications(enableStreamPushNotifications bool) ApiUpdateSettingsRequest {
	r.enableStreamPushNotifications = &enableStreamPushNotifications
	return r
}
func (r ApiUpdateSettingsRequest) EnableStreamAudibleNotifications(enableStreamAudibleNotifications bool) ApiUpdateSettingsRequest {
	r.enableStreamAudibleNotifications = &enableStreamAudibleNotifications
	return r
}
func (r ApiUpdateSettingsRequest) NotificationSound(notificationSound string) ApiUpdateSettingsRequest {
	r.notificationSound = &notificationSound
	return r
}
func (r ApiUpdateSettingsRequest) EnableDesktopNotifications(enableDesktopNotifications bool) ApiUpdateSettingsRequest {
	r.enableDesktopNotifications = &enableDesktopNotifications
	return r
}
func (r ApiUpdateSettingsRequest) EnableSounds(enableSounds bool) ApiUpdateSettingsRequest {
	r.enableSounds = &enableSounds
	return r
}
func (r ApiUpdateSettingsRequest) EmailNotificationsBatchingPeriodSeconds(emailNotificationsBatchingPeriodSeconds int32) ApiUpdateSettingsRequest {
	r.emailNotificationsBatchingPeriodSeconds = &emailNotificationsBatchingPeriodSeconds
	return r
}
func (r ApiUpdateSettingsRequest) EnableOfflineEmailNotifications(enableOfflineEmailNotifications bool) ApiUpdateSettingsRequest {
	r.enableOfflineEmailNotifications = &enableOfflineEmailNotifications
	return r
}
func (r ApiUpdateSettingsRequest) EnableOfflinePushNotifications(enableOfflinePushNotifications bool) ApiUpdateSettingsRequest {
	r.enableOfflinePushNotifications = &enableOfflinePushNotifications
	return r
}
func (r ApiUpdateSettingsRequest) EnableOnlinePushNotifications(enableOnlinePushNotifications bool) ApiUpdateSettingsRequest {
	r.enableOnlinePushNotifications = &enableOnlinePushNotifications
	return r
}
func (r ApiUpdateSettingsRequest) EnableDigestEmails(enableDigestEmails bool) ApiUpdateSettingsRequest {
	r.enableDigestEmails = &enableDigestEmails
	return r
}
func (r ApiUpdateSettingsRequest) EnableMarketingEmails(enableMarketingEmails bool) ApiUpdateSettingsRequest {
	r.enableMarketingEmails = &enableMarketingEmails
	return r
}
func (r ApiUpdateSettingsRequest) EnableLoginEmails(enableLoginEmails bool) ApiUpdateSettingsRequest {
	r.enableLoginEmails = &enableLoginEmails
	return r
}
func (r ApiUpdateSettingsRequest) MessageContentInEmailNotifications(messageContentInEmailNotifications bool) ApiUpdateSettingsRequest {
	r.messageContentInEmailNotifications = &messageContentInEmailNotifications
	return r
}
func (r ApiUpdateSettingsRequest) PmContentInDesktopNotifications(pmContentInDesktopNotifications bool) ApiUpdateSettingsRequest {
	r.pmContentInDesktopNotifications = &pmContentInDesktopNotifications
	return r
}
func (r ApiUpdateSettingsRequest) WildcardMentionsNotify(wildcardMentionsNotify bool) ApiUpdateSettingsRequest {
	r.wildcardMentionsNotify = &wildcardMentionsNotify
	return r
}
func (r ApiUpdateSettingsRequest) DesktopIconCountDisplay(desktopIconCountDisplay int32) ApiUpdateSettingsRequest {
	r.desktopIconCountDisplay = &desktopIconCountDisplay
	return r
}
func (r ApiUpdateSettingsRequest) RealmNameInNotifications(realmNameInNotifications bool) ApiUpdateSettingsRequest {
	r.realmNameInNotifications = &realmNameInNotifications
	return r
}
func (r ApiUpdateSettingsRequest) PresenceEnabled(presenceEnabled bool) ApiUpdateSettingsRequest {
	r.presenceEnabled = &presenceEnabled
	return r
}
func (r ApiUpdateSettingsRequest) EnterSends(enterSends bool) ApiUpdateSettingsRequest {
	r.enterSends = &enterSends
	return r
}

func (r ApiUpdateSettingsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.UpdateSettingsExecute(r)
}

/*
 * UpdateSettings Update settings
 * This endpoint is used to edit the current user's settings.

`PATCH {{ api_url }}/v1/settings`

**Changes**: Prior to Zulip 5.0 (feature level 80), this
endpoint only supported the `full_name`, `email`,
`old_password`, and `new_password` parameters. Notification
settings were managed by `PATCH /settings/notifications`, and
all other settings by `PATCH /settings/display`. The feature level
80 migration to merge these endpoints did not change how request
parameters are encoded. Note, however, that it did change the
handling of any invalid parameters present in a request to change
notification or display settings, since the merged endpoint uses
the new response format that was introduced for `/settings` in
Zulip 5.0 (feature level 78).

The `/settings/display` and `/settings/notifications`
endpoints are now deprecated aliases for this endpoint for
backwards-compatibility, and will be removed once clients have
migrated to use this endpoint.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateSettingsRequest
 */
func (a *UsersApiService) UpdateSettings(ctx _context.Context) ApiUpdateSettingsRequest {
	return ApiUpdateSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) UpdateSettingsExecute(r ApiUpdateSettingsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UpdateSettings")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fullName != nil {
		localVarQueryParams.Add("full_name", parameterToString(*r.fullName, ""))
	}
	if r.email != nil {
		localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.oldPassword != nil {
		localVarQueryParams.Add("old_password", parameterToString(*r.oldPassword, ""))
	}
	if r.newPassword != nil {
		localVarQueryParams.Add("new_password", parameterToString(*r.newPassword, ""))
	}
	if r.twentyFourHourTime != nil {
		localVarQueryParams.Add("twenty_four_hour_time", parameterToString(*r.twentyFourHourTime, ""))
	}
	if r.denseMode != nil {
		localVarQueryParams.Add("dense_mode", parameterToString(*r.denseMode, ""))
	}
	if r.starredMessageCounts != nil {
		localVarQueryParams.Add("starred_message_counts", parameterToString(*r.starredMessageCounts, ""))
	}
	if r.fluidLayoutWidth != nil {
		localVarQueryParams.Add("fluid_layout_width", parameterToString(*r.fluidLayoutWidth, ""))
	}
	if r.highContrastMode != nil {
		localVarQueryParams.Add("high_contrast_mode", parameterToString(*r.highContrastMode, ""))
	}
	if r.colorScheme != nil {
		localVarQueryParams.Add("color_scheme", parameterToString(*r.colorScheme, ""))
	}
	if r.enableDraftsSynchronization != nil {
		localVarQueryParams.Add("enable_drafts_synchronization", parameterToString(*r.enableDraftsSynchronization, ""))
	}
	if r.translateEmoticons != nil {
		localVarQueryParams.Add("translate_emoticons", parameterToString(*r.translateEmoticons, ""))
	}
	if r.defaultLanguage != nil {
		localVarQueryParams.Add("default_language", parameterToString(*r.defaultLanguage, ""))
	}
	if r.defaultView != nil {
		localVarQueryParams.Add("default_view", parameterToString(*r.defaultView, ""))
	}
	if r.leftSideUserlist != nil {
		localVarQueryParams.Add("left_side_userlist", parameterToString(*r.leftSideUserlist, ""))
	}
	if r.emojiset != nil {
		localVarQueryParams.Add("emojiset", parameterToString(*r.emojiset, ""))
	}
	if r.demoteInactiveStreams != nil {
		localVarQueryParams.Add("demote_inactive_streams", parameterToString(*r.demoteInactiveStreams, ""))
	}
	if r.timezone != nil {
		localVarQueryParams.Add("timezone", parameterToString(*r.timezone, ""))
	}
	if r.enableStreamDesktopNotifications != nil {
		localVarQueryParams.Add("enable_stream_desktop_notifications", parameterToString(*r.enableStreamDesktopNotifications, ""))
	}
	if r.enableStreamEmailNotifications != nil {
		localVarQueryParams.Add("enable_stream_email_notifications", parameterToString(*r.enableStreamEmailNotifications, ""))
	}
	if r.enableStreamPushNotifications != nil {
		localVarQueryParams.Add("enable_stream_push_notifications", parameterToString(*r.enableStreamPushNotifications, ""))
	}
	if r.enableStreamAudibleNotifications != nil {
		localVarQueryParams.Add("enable_stream_audible_notifications", parameterToString(*r.enableStreamAudibleNotifications, ""))
	}
	if r.notificationSound != nil {
		localVarQueryParams.Add("notification_sound", parameterToString(*r.notificationSound, ""))
	}
	if r.enableDesktopNotifications != nil {
		localVarQueryParams.Add("enable_desktop_notifications", parameterToString(*r.enableDesktopNotifications, ""))
	}
	if r.enableSounds != nil {
		localVarQueryParams.Add("enable_sounds", parameterToString(*r.enableSounds, ""))
	}
	if r.emailNotificationsBatchingPeriodSeconds != nil {
		localVarQueryParams.Add("email_notifications_batching_period_seconds", parameterToString(*r.emailNotificationsBatchingPeriodSeconds, ""))
	}
	if r.enableOfflineEmailNotifications != nil {
		localVarQueryParams.Add("enable_offline_email_notifications", parameterToString(*r.enableOfflineEmailNotifications, ""))
	}
	if r.enableOfflinePushNotifications != nil {
		localVarQueryParams.Add("enable_offline_push_notifications", parameterToString(*r.enableOfflinePushNotifications, ""))
	}
	if r.enableOnlinePushNotifications != nil {
		localVarQueryParams.Add("enable_online_push_notifications", parameterToString(*r.enableOnlinePushNotifications, ""))
	}
	if r.enableDigestEmails != nil {
		localVarQueryParams.Add("enable_digest_emails", parameterToString(*r.enableDigestEmails, ""))
	}
	if r.enableMarketingEmails != nil {
		localVarQueryParams.Add("enable_marketing_emails", parameterToString(*r.enableMarketingEmails, ""))
	}
	if r.enableLoginEmails != nil {
		localVarQueryParams.Add("enable_login_emails", parameterToString(*r.enableLoginEmails, ""))
	}
	if r.messageContentInEmailNotifications != nil {
		localVarQueryParams.Add("message_content_in_email_notifications", parameterToString(*r.messageContentInEmailNotifications, ""))
	}
	if r.pmContentInDesktopNotifications != nil {
		localVarQueryParams.Add("pm_content_in_desktop_notifications", parameterToString(*r.pmContentInDesktopNotifications, ""))
	}
	if r.wildcardMentionsNotify != nil {
		localVarQueryParams.Add("wildcard_mentions_notify", parameterToString(*r.wildcardMentionsNotify, ""))
	}
	if r.desktopIconCountDisplay != nil {
		localVarQueryParams.Add("desktop_icon_count_display", parameterToString(*r.desktopIconCountDisplay, ""))
	}
	if r.realmNameInNotifications != nil {
		localVarQueryParams.Add("realm_name_in_notifications", parameterToString(*r.realmNameInNotifications, ""))
	}
	if r.presenceEnabled != nil {
		localVarQueryParams.Add("presence_enabled", parameterToString(*r.presenceEnabled, ""))
	}
	if r.enterSends != nil {
		localVarQueryParams.Add("enter_sends", parameterToString(*r.enterSends, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateStatusRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	statusText *string
	away *bool
	emojiName *string
	emojiCode *string
	reactionType *string
}

func (r ApiUpdateStatusRequest) StatusText(statusText string) ApiUpdateStatusRequest {
	r.statusText = &statusText
	return r
}
func (r ApiUpdateStatusRequest) Away(away bool) ApiUpdateStatusRequest {
	r.away = &away
	return r
}
func (r ApiUpdateStatusRequest) EmojiName(emojiName string) ApiUpdateStatusRequest {
	r.emojiName = &emojiName
	return r
}
func (r ApiUpdateStatusRequest) EmojiCode(emojiCode string) ApiUpdateStatusRequest {
	r.emojiCode = &emojiCode
	return r
}
func (r ApiUpdateStatusRequest) ReactionType(reactionType string) ApiUpdateStatusRequest {
	r.reactionType = &reactionType
	return r
}

func (r ApiUpdateStatusRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateStatusExecute(r)
}

/*
 * UpdateStatus Update your status
 * Change your [status](/help/status-and-availability).

`POST {{ api_url }}/v1/users/me/status`

A request to this endpoint will only change the parameters passed.
For example, passing just `status_text` requests a change in the status
text, but will leave the status emoji unchanged.

Clients that wish to set the user's status to a specific value should
pass all supported parameters.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateStatusRequest
 */
func (a *UsersApiService) UpdateStatus(ctx _context.Context) ApiUpdateStatusRequest {
	return ApiUpdateStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) UpdateStatusExecute(r ApiUpdateStatusRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UpdateStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.statusText != nil {
		localVarQueryParams.Add("status_text", parameterToString(*r.statusText, ""))
	}
	if r.away != nil {
		localVarQueryParams.Add("away", parameterToString(*r.away, ""))
	}
	if r.emojiName != nil {
		localVarQueryParams.Add("emoji_name", parameterToString(*r.emojiName, ""))
	}
	if r.emojiCode != nil {
		localVarQueryParams.Add("emoji_code", parameterToString(*r.emojiCode, ""))
	}
	if r.reactionType != nil {
		localVarQueryParams.Add("reaction_type", parameterToString(*r.reactionType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OneOfobjectobjectobjectobjectobjectobject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userId int32
	fullName *string
	role *int32
	profileData *[]map[string]interface{}
}

func (r ApiUpdateUserRequest) FullName(fullName string) ApiUpdateUserRequest {
	r.fullName = &fullName
	return r
}
func (r ApiUpdateUserRequest) Role(role int32) ApiUpdateUserRequest {
	r.role = &role
	return r
}
func (r ApiUpdateUserRequest) ProfileData(profileData []map[string]interface{}) ApiUpdateUserRequest {
	r.profileData = &profileData
	return r
}

func (r ApiUpdateUserRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateUserExecute(r)
}

/*
 * UpdateUser Update a user
 * Administrative endpoint to update the details of another user in the organization.

`PATCH {{ api_url }}/v1/users/{user_id}`

Supports everything an administrator can do to edit details of another
user's account, including editing full name,
[role](/help/roles-and-permissions), and [custom profile
fields](/help/add-custom-profile-fields).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId The target user's ID. 
 * @return ApiUpdateUserRequest
 */
func (a *UsersApiService) UpdateUser(ctx _context.Context, userId int32) ApiUpdateUserRequest {
	return ApiUpdateUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) UpdateUserExecute(r ApiUpdateUserRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UpdateUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fullName != nil {
		localVarQueryParams.Add("full_name", parameterToString(*r.fullName, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.profileData != nil {
		t := *r.profileData
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("profile_data", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("profile_data", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CodedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserGroupRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userGroupId int32
	name *string
	description *string
}

func (r ApiUpdateUserGroupRequest) Name(name string) ApiUpdateUserGroupRequest {
	r.name = &name
	return r
}
func (r ApiUpdateUserGroupRequest) Description(description string) ApiUpdateUserGroupRequest {
	r.description = &description
	return r
}

func (r ApiUpdateUserGroupRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateUserGroupExecute(r)
}

/*
 * UpdateUserGroup Update a user group
 * Update the name or description of a [user group](/help/user-groups).

`PATCH {{ api_url }}/v1/user_groups/{user_group_id}`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userGroupId The ID of the target user group. 
 * @return ApiUpdateUserGroupRequest
 */
func (a *UsersApiService) UpdateUserGroup(ctx _context.Context, userGroupId int32) ApiUpdateUserGroupRequest {
	return ApiUpdateUserGroupRequest{
		ApiService: a,
		ctx: ctx,
		userGroupId: userGroupId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) UpdateUserGroupExecute(r ApiUpdateUserGroupRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UpdateUserGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_groups/{user_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_group_id"+"}", _neturl.PathEscape(parameterToString(r.userGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}

	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserGroupMembersRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userGroupId int32
	delete *[]int32
	add *[]int32
}

func (r ApiUpdateUserGroupMembersRequest) Delete(delete []int32) ApiUpdateUserGroupMembersRequest {
	r.delete = &delete
	return r
}
func (r ApiUpdateUserGroupMembersRequest) Add(add []int32) ApiUpdateUserGroupMembersRequest {
	r.add = &add
	return r
}

func (r ApiUpdateUserGroupMembersRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateUserGroupMembersExecute(r)
}

/*
 * UpdateUserGroupMembers Update user group members
 * Update the members of a [user group](/help/user-groups).

`POST {{ api_url }}/v1/user_groups/{user_group_id}/members`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userGroupId The ID of the target user group. 
 * @return ApiUpdateUserGroupMembersRequest
 */
func (a *UsersApiService) UpdateUserGroupMembers(ctx _context.Context, userGroupId int32) ApiUpdateUserGroupMembersRequest {
	return ApiUpdateUserGroupMembersRequest{
		ApiService: a,
		ctx: ctx,
		userGroupId: userGroupId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) UpdateUserGroupMembersExecute(r ApiUpdateUserGroupMembersRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UpdateUserGroupMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_groups/{user_group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"user_group_id"+"}", _neturl.PathEscape(parameterToString(r.userGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.delete != nil {
		t := *r.delete
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("delete", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("delete", parameterToString(t, "multi"))
		}
	}
	if r.add != nil {
		t := *r.add
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("add", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("add", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
