/*
 * Zulip REST API
 *
 * Powerful open source group chat 
 *
 * API version: 1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// UsersApiService UsersApi service
type UsersApiService service

type ApiCreateUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	email *string
	password *string
	fullName *string
}

func (r ApiCreateUserRequest) Email(email string) ApiCreateUserRequest {
	r.email = &email
	return r
}
func (r ApiCreateUserRequest) Password(password string) ApiCreateUserRequest {
	r.password = &password
	return r
}
func (r ApiCreateUserRequest) FullName(fullName string) ApiCreateUserRequest {
	r.fullName = &fullName
	return r
}

func (r ApiCreateUserRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.CreateUserExecute(r)
}

/*
 * CreateUser Create a user
 * {!can-create-users-only.md!}

Create a new user account via the API.

`POST {{ api_url }}/v1/users`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateUserRequest
 */
func (a *UsersApiService) CreateUser(ctx _context.Context) ApiCreateUserRequest {
	return ApiCreateUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) CreateUserExecute(r ApiCreateUserRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.CreateUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.password == nil {
		return localVarReturnValue, nil, reportError("password is required and must be specified")
	}
	if r.fullName == nil {
		return localVarReturnValue, nil, reportError("fullName is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("password", parameterToString(*r.password, ""))
	localVarQueryParams.Add("full_name", parameterToString(*r.fullName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserGroupRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	name *string
	description *string
	members *[]int32
}

func (r ApiCreateUserGroupRequest) Name(name string) ApiCreateUserGroupRequest {
	r.name = &name
	return r
}
func (r ApiCreateUserGroupRequest) Description(description string) ApiCreateUserGroupRequest {
	r.description = &description
	return r
}
func (r ApiCreateUserGroupRequest) Members(members []int32) ApiCreateUserGroupRequest {
	r.members = &members
	return r
}

func (r ApiCreateUserGroupRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.CreateUserGroupExecute(r)
}

/*
 * CreateUserGroup Create a user group
 * Create a new [user group](/help/user-groups).

`POST {{ api_url }}/v1/user_groups/create`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateUserGroupRequest
 */
func (a *UsersApiService) CreateUserGroup(ctx _context.Context) ApiCreateUserGroupRequest {
	return ApiCreateUserGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) CreateUserGroupExecute(r ApiCreateUserGroupRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.CreateUserGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_groups/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if r.members == nil {
		return localVarReturnValue, nil, reportError("members is required and must be specified")
	}

	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	{
		t := *r.members
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("members", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("members", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeactivateOwnUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
}


func (r ApiDeactivateOwnUserRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.DeactivateOwnUserExecute(r)
}

/*
 * DeactivateOwnUser Deactivate own user
 * Deactivates the user's account.  See also the administrative endpoint for
[deactivating another user](/api/deactivate-user).

`DELETE {{ api_url }}/v1/users/me`

This endpoint is primarily useful to Zulip clients providing a user settings UI.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDeactivateOwnUserRequest
 */
func (a *UsersApiService) DeactivateOwnUser(ctx _context.Context) ApiDeactivateOwnUserRequest {
	return ApiDeactivateOwnUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) DeactivateOwnUserExecute(r ApiDeactivateOwnUserRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.DeactivateOwnUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeactivateUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userId int32
}


func (r ApiDeactivateUserRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.DeactivateUserExecute(r)
}

/*
 * DeactivateUser Deactivate a user
 * [Deactivates a
user](https://zulip.com/help/deactivate-or-reactivate-a-user)
given their user ID.

`DELETE {{ api_url }}/v1/users/{user_id}`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId The target user's ID. 
 * @return ApiDeactivateUserRequest
 */
func (a *UsersApiService) DeactivateUser(ctx _context.Context, userId int32) ApiDeactivateUserRequest {
	return ApiDeactivateUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) DeactivateUserExecute(r ApiDeactivateUserRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.DeactivateUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAttachmentsRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
}


func (r ApiGetAttachmentsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetAttachmentsExecute(r)
}

/*
 * GetAttachments Get attachments
 * Fetch metadata on files uploaded by the requesting user.

`GET {{ api_url }}/v1/attachments`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAttachmentsRequest
 */
func (a *UsersApiService) GetAttachments(ctx _context.Context) ApiGetAttachmentsRequest {
	return ApiGetAttachmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetAttachmentsExecute(r ApiGetAttachmentsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetAttachments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attachments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOwnUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
}


func (r ApiGetOwnUserRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetOwnUserExecute(r)
}

/*
 * GetOwnUser Get own user
 * Get basic data about the user/bot that requests this endpoint.

`GET {{ api_url }}/v1/users/me`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetOwnUserRequest
 */
func (a *UsersApiService) GetOwnUser(ctx _context.Context) ApiGetOwnUserRequest {
	return ApiGetOwnUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetOwnUserExecute(r ApiGetOwnUserRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetOwnUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userId int32
	clientGravatar *bool
	includeCustomProfileFields *bool
}

func (r ApiGetUserRequest) ClientGravatar(clientGravatar bool) ApiGetUserRequest {
	r.clientGravatar = &clientGravatar
	return r
}
func (r ApiGetUserRequest) IncludeCustomProfileFields(includeCustomProfileFields bool) ApiGetUserRequest {
	r.includeCustomProfileFields = &includeCustomProfileFields
	return r
}

func (r ApiGetUserRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetUserExecute(r)
}

/*
 * GetUser Get a user
 * Fetch details for a single user in the organization.

`GET {{ api_url }}/v1/users/{user_id}`

You can also fetch details on [all users in the organization](/api/get-users)
or [by email](/api/get-user-by-email).

*This endpoint is new in Zulip Server 3.0 (feature level 1).*

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId The target user's ID. 
 * @return ApiGetUserRequest
 */
func (a *UsersApiService) GetUser(ctx _context.Context, userId int32) ApiGetUserRequest {
	return ApiGetUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetUserExecute(r ApiGetUserRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.clientGravatar != nil {
		localVarQueryParams.Add("client_gravatar", parameterToString(*r.clientGravatar, ""))
	}
	if r.includeCustomProfileFields != nil {
		localVarQueryParams.Add("include_custom_profile_fields", parameterToString(*r.includeCustomProfileFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserByEmailRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	email string
	clientGravatar *bool
	includeCustomProfileFields *bool
}

func (r ApiGetUserByEmailRequest) ClientGravatar(clientGravatar bool) ApiGetUserByEmailRequest {
	r.clientGravatar = &clientGravatar
	return r
}
func (r ApiGetUserByEmailRequest) IncludeCustomProfileFields(includeCustomProfileFields bool) ApiGetUserByEmailRequest {
	r.includeCustomProfileFields = &includeCustomProfileFields
	return r
}

func (r ApiGetUserByEmailRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetUserByEmailExecute(r)
}

/*
 * GetUserByEmail Get a user by email
 * Fetch details for a single user in the organization given a Zulip display
email address.

`GET {{ api_url }}/v1/users/{email}`

Note that this endpoint uses Zulip display emails addresses
for organizations that have configured limited [email address
visibility](/help/restrict-visibility-of-email-addresses).

You can also fetch details on [all users in the organization](/api/get-users) or
[by user ID](/api/get-user).  Fetching by user ID is generally recommended
when possible, as users can
[change their email address](/help/change-your-email-address).

*This endpoint is new in Zulip Server 4.0 (feature level 39).*

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param email The email address of the user whose details you want to fetch. 
 * @return ApiGetUserByEmailRequest
 */
func (a *UsersApiService) GetUserByEmail(ctx _context.Context, email string) ApiGetUserByEmailRequest {
	return ApiGetUserByEmailRequest{
		ApiService: a,
		ctx: ctx,
		email: email,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetUserByEmailExecute(r ApiGetUserByEmailRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetUserByEmail")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{email}"
	localVarPath = strings.Replace(localVarPath, "{"+"email"+"}", _neturl.PathEscape(parameterToString(r.email, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.clientGravatar != nil {
		localVarQueryParams.Add("client_gravatar", parameterToString(*r.clientGravatar, ""))
	}
	if r.includeCustomProfileFields != nil {
		localVarQueryParams.Add("include_custom_profile_fields", parameterToString(*r.includeCustomProfileFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserGroupsRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
}


func (r ApiGetUserGroupsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetUserGroupsExecute(r)
}

/*
 * GetUserGroups Get user groups
 * {!api-members-only.md!}

Fetches all of the user groups in the organization.

`GET {{ api_url }}/v1/user_groups`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetUserGroupsRequest
 */
func (a *UsersApiService) GetUserGroups(ctx _context.Context) ApiGetUserGroupsRequest {
	return ApiGetUserGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetUserGroupsExecute(r ApiGetUserGroupsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetUserGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserPresenceRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userIdOrEmail string
}


func (r ApiGetUserPresenceRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetUserPresenceExecute(r)
}

/*
 * GetUserPresence Get user presence
 * Get the presence status for a specific user.

This endpoint is most useful for embedding data about a user's
presence status in other sites (E.g. an employee directory).  Full
Zulip clients like mobile/desktop apps will want to use the main
presence endpoint, which returns data for all active users in the
organization, instead.

`GET {{ api_url }}/v1/users/{user_id_or_email}/presence`

See
[Zulip's developer documentation](https://zulip.readthedocs.io/en/latest/subsystems/presence.html)
for details on the data model for presence in Zulip.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userIdOrEmail The user_id or Zulip display email address of the user whose presence you want to fetch.  **Changes**: New in Zulip 4.0 (feature level 43). Previous versions only supported identifying the user by Zulip display email. 
 * @return ApiGetUserPresenceRequest
 */
func (a *UsersApiService) GetUserPresence(ctx _context.Context, userIdOrEmail string) ApiGetUserPresenceRequest {
	return ApiGetUserPresenceRequest{
		ApiService: a,
		ctx: ctx,
		userIdOrEmail: userIdOrEmail,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetUserPresenceExecute(r ApiGetUserPresenceRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetUserPresence")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id_or_email}/presence"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id_or_email"+"}", _neturl.PathEscape(parameterToString(r.userIdOrEmail, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	clientGravatar *bool
	includeCustomProfileFields *bool
}

func (r ApiGetUsersRequest) ClientGravatar(clientGravatar bool) ApiGetUsersRequest {
	r.clientGravatar = &clientGravatar
	return r
}
func (r ApiGetUsersRequest) IncludeCustomProfileFields(includeCustomProfileFields bool) ApiGetUsersRequest {
	r.includeCustomProfileFields = &includeCustomProfileFields
	return r
}

func (r ApiGetUsersRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.GetUsersExecute(r)
}

/*
 * GetUsers Get all users
 * Retrieve details on all users in the organization.  Optionally
includes values of [custom profile field](/help/add-custom-profile-fields).

`GET {{ api_url }}/v1/users`

You can also [fetch details on a single user](/api/get-user).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetUsersRequest
 */
func (a *UsersApiService) GetUsers(ctx _context.Context) ApiGetUsersRequest {
	return ApiGetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) GetUsersExecute(r ApiGetUsersRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.clientGravatar != nil {
		localVarQueryParams.Add("client_gravatar", parameterToString(*r.clientGravatar, ""))
	}
	if r.includeCustomProfileFields != nil {
		localVarQueryParams.Add("include_custom_profile_fields", parameterToString(*r.includeCustomProfileFields, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMuteUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	mutedUserId int32
}


func (r ApiMuteUserRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.MuteUserExecute(r)
}

/*
 * MuteUser Mute a user
 * This endpoint [mutes a user](/help/mute-a-user).  Messages sent by users
you've muted will be automatically marked as read and hidden.

`POST {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`

Muted users should be implemented by clients as follows:

* The server will immediately mark all messages sent by the muted
  user as read.  This will automatically clear any existing mobile
  push notifications related to the muted user.
* The server will mark any new messages sent by the muted user as read
  for your account, which prevents all email and mobile push notifications.
* Clients should exclude muted users from presence lists or other UI
  for viewing or composing 1:1 private messages. 1:1 private messages sent by
  muted users should be hidden everywhere in the Zulip UI.
* Stream messages and group private messages sent by the muted
  user should avoid displaying the content and name/avatar,
  but should display that N messages by a muted user were
  hidden (so that it is possible to interpret the messages by
  other users who are talking with the muted user).
* Group private message conversations including the muted user
  should display muted users as "Muted user", rather than
  showing their name, in lists of such conversations, along with using
  a blank grey avatar where avatars are displayed.
* Administrative/settings UI elements for showing "All users that exist
  on this stream or realm", e.g. for organization
  administration or showing stream subscribers, should display
  the user's name as normal.

**Changes**: New in Zulip 4.0 (feature level 48).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mutedUserId The ID of the user to mute/un-mute. 
 * @return ApiMuteUserRequest
 */
func (a *UsersApiService) MuteUser(ctx _context.Context, mutedUserId int32) ApiMuteUserRequest {
	return ApiMuteUserRequest{
		ApiService: a,
		ctx: ctx,
		mutedUserId: mutedUserId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) MuteUserExecute(r ApiMuteUserRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.MuteUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/muted_users/{muted_user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"muted_user_id"+"}", _neturl.PathEscape(parameterToString(r.mutedUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OneOfobjectobjectobject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReactivateUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userId int32
}


func (r ApiReactivateUserRequest) Execute() (interface{}, *_nethttp.Response, error) {
	return r.ApiService.ReactivateUserExecute(r)
}

/*
 * ReactivateUser Reactivate a user
 * [Reactivates a
user](https://zulip.com/help/deactivate-or-reactivate-a-user)
given their user ID.

`POST {{ api_url }}/v1/users/{user_id}/reactivate`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId The target user's ID. 
 * @return ApiReactivateUserRequest
 */
func (a *UsersApiService) ReactivateUser(ctx _context.Context, userId int32) ApiReactivateUserRequest {
	return ApiReactivateUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

/*
 * Execute executes the request
 * @return interface{}
 */
func (a *UsersApiService) ReactivateUserExecute(r ApiReactivateUserRequest) (interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.ReactivateUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/reactivate"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveUserGroupRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userGroupId int32
}


func (r ApiRemoveUserGroupRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.RemoveUserGroupExecute(r)
}

/*
 * RemoveUserGroup Delete a user group
 * Delete a [user group](/help/user-groups).

`DELETE {{ api_url }}/v1/user_groups/{user_group_id}`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userGroupId The ID of the target user group. 
 * @return ApiRemoveUserGroupRequest
 */
func (a *UsersApiService) RemoveUserGroup(ctx _context.Context, userGroupId int32) ApiRemoveUserGroupRequest {
	return ApiRemoveUserGroupRequest{
		ApiService: a,
		ctx: ctx,
		userGroupId: userGroupId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) RemoveUserGroupExecute(r ApiRemoveUserGroupRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.RemoveUserGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_groups/{user_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_group_id"+"}", _neturl.PathEscape(parameterToString(r.userGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetTypingStatusRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	op *string
	to *[]int32
	type_ *string
	topic *string
}

func (r ApiSetTypingStatusRequest) Op(op string) ApiSetTypingStatusRequest {
	r.op = &op
	return r
}
func (r ApiSetTypingStatusRequest) To(to []int32) ApiSetTypingStatusRequest {
	r.to = &to
	return r
}
func (r ApiSetTypingStatusRequest) Type_(type_ string) ApiSetTypingStatusRequest {
	r.type_ = &type_
	return r
}
func (r ApiSetTypingStatusRequest) Topic(topic string) ApiSetTypingStatusRequest {
	r.topic = &topic
	return r
}

func (r ApiSetTypingStatusRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.SetTypingStatusExecute(r)
}

/*
 * SetTypingStatus Set \"typing\" status
 * Notify other users whether the current user is typing a message.

`POST {{ api_url }}/v1/typing`

Clients implementing Zulip's typing notifications protocol should work as follows:

* Send a request to this endpoint with `op="start"` when a user starts typing a message,
  and also every `TYPING_STARTED_WAIT_PERIOD=10` seconds that the user continues to
  actively type or otherwise interact with the compose UI (E.g. interacting with the
  compose box emoji picker).
* Send a request to this endpoint with `op="stop"` when a user pauses using the
  compose UI for at least `TYPING_STOPPED_WAIT_PERIOD=5` seconds or cancels
  the compose action (if it had previously sent a "start" operation for that
  compose action).
* Start displaying "Sender is typing" for a given conversation when the client
  receives an `op="start"` event from the [events API](/api/get-events).
* Continue displaying "Sender is typing" until they receive an `op="stop"` event
  from the [events API](/api/get-events) or `TYPING_STARTED_EXPIRY_PERIOD=15`
  seconds have passed without a new `op="start"` event for that conversation.
* Clients that support displaying stream typing notifications (new in Zulip 4.0)
  should indicate they support processing stream typing events via the
  `stream_typing_notifications` in the `client_capabilities` parameter to `/register`.

This protocol is designed to allow the server-side typing notifications implementation
to be stateless while being resilient; network failures cannot result in a user being
incorrectly displayed as perpetually typing.

See
[the typing notification docs](https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html)
for additional design details on Zulip's typing notifications protocol.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSetTypingStatusRequest
 */
func (a *UsersApiService) SetTypingStatus(ctx _context.Context) ApiSetTypingStatusRequest {
	return ApiSetTypingStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) SetTypingStatusExecute(r ApiSetTypingStatusRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.SetTypingStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/typing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.op == nil {
		return localVarReturnValue, nil, reportError("op is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	localVarQueryParams.Add("op", parameterToString(*r.op, ""))
	{
		t := *r.to
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("to", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("to", parameterToString(t, "multi"))
		}
	}
	if r.topic != nil {
		localVarQueryParams.Add("topic", parameterToString(*r.topic, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnmuteUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	mutedUserId int32
}


func (r ApiUnmuteUserRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UnmuteUserExecute(r)
}

/*
 * UnmuteUser Unmute a user
 * This endpoint unmutes a user.

`DELETE {{ api_url }}/v1/users/me/muted_users/{muted_user_id}`

**Changes**: New in Zulip 4.0 (feature level 48).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mutedUserId The ID of the user to mute/un-mute. 
 * @return ApiUnmuteUserRequest
 */
func (a *UsersApiService) UnmuteUser(ctx _context.Context, mutedUserId int32) ApiUnmuteUserRequest {
	return ApiUnmuteUserRequest{
		ApiService: a,
		ctx: ctx,
		mutedUserId: mutedUserId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) UnmuteUserExecute(r ApiUnmuteUserRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UnmuteUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/me/muted_users/{muted_user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"muted_user_id"+"}", _neturl.PathEscape(parameterToString(r.mutedUserId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OneOfobjectobject
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDisplaySettingsRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	twentyFourHourTime *bool
	denseMode *bool
	starredMessageCounts *bool
	fluidLayoutWidth *bool
	highContrastMode *bool
	colorScheme *int32
	translateEmoticons *bool
	defaultLanguage *string
	defaultView *string
	leftSideUserlist *bool
	emojiset *string
	demoteInactiveStreams *int32
	timezone *string
}

func (r ApiUpdateDisplaySettingsRequest) TwentyFourHourTime(twentyFourHourTime bool) ApiUpdateDisplaySettingsRequest {
	r.twentyFourHourTime = &twentyFourHourTime
	return r
}
func (r ApiUpdateDisplaySettingsRequest) DenseMode(denseMode bool) ApiUpdateDisplaySettingsRequest {
	r.denseMode = &denseMode
	return r
}
func (r ApiUpdateDisplaySettingsRequest) StarredMessageCounts(starredMessageCounts bool) ApiUpdateDisplaySettingsRequest {
	r.starredMessageCounts = &starredMessageCounts
	return r
}
func (r ApiUpdateDisplaySettingsRequest) FluidLayoutWidth(fluidLayoutWidth bool) ApiUpdateDisplaySettingsRequest {
	r.fluidLayoutWidth = &fluidLayoutWidth
	return r
}
func (r ApiUpdateDisplaySettingsRequest) HighContrastMode(highContrastMode bool) ApiUpdateDisplaySettingsRequest {
	r.highContrastMode = &highContrastMode
	return r
}
func (r ApiUpdateDisplaySettingsRequest) ColorScheme(colorScheme int32) ApiUpdateDisplaySettingsRequest {
	r.colorScheme = &colorScheme
	return r
}
func (r ApiUpdateDisplaySettingsRequest) TranslateEmoticons(translateEmoticons bool) ApiUpdateDisplaySettingsRequest {
	r.translateEmoticons = &translateEmoticons
	return r
}
func (r ApiUpdateDisplaySettingsRequest) DefaultLanguage(defaultLanguage string) ApiUpdateDisplaySettingsRequest {
	r.defaultLanguage = &defaultLanguage
	return r
}
func (r ApiUpdateDisplaySettingsRequest) DefaultView(defaultView string) ApiUpdateDisplaySettingsRequest {
	r.defaultView = &defaultView
	return r
}
func (r ApiUpdateDisplaySettingsRequest) LeftSideUserlist(leftSideUserlist bool) ApiUpdateDisplaySettingsRequest {
	r.leftSideUserlist = &leftSideUserlist
	return r
}
func (r ApiUpdateDisplaySettingsRequest) Emojiset(emojiset string) ApiUpdateDisplaySettingsRequest {
	r.emojiset = &emojiset
	return r
}
func (r ApiUpdateDisplaySettingsRequest) DemoteInactiveStreams(demoteInactiveStreams int32) ApiUpdateDisplaySettingsRequest {
	r.demoteInactiveStreams = &demoteInactiveStreams
	return r
}
func (r ApiUpdateDisplaySettingsRequest) Timezone(timezone string) ApiUpdateDisplaySettingsRequest {
	r.timezone = &timezone
	return r
}

func (r ApiUpdateDisplaySettingsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.UpdateDisplaySettingsExecute(r)
}

/*
 * UpdateDisplaySettings Update display settings
 * This endpoint is used to edit the current user's user interface settings.

`PATCH {{ api_url }}/v1/settings/display`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateDisplaySettingsRequest
 */
func (a *UsersApiService) UpdateDisplaySettings(ctx _context.Context) ApiUpdateDisplaySettingsRequest {
	return ApiUpdateDisplaySettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) UpdateDisplaySettingsExecute(r ApiUpdateDisplaySettingsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UpdateDisplaySettings")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/display"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.twentyFourHourTime != nil {
		localVarQueryParams.Add("twenty_four_hour_time", parameterToString(*r.twentyFourHourTime, ""))
	}
	if r.denseMode != nil {
		localVarQueryParams.Add("dense_mode", parameterToString(*r.denseMode, ""))
	}
	if r.starredMessageCounts != nil {
		localVarQueryParams.Add("starred_message_counts", parameterToString(*r.starredMessageCounts, ""))
	}
	if r.fluidLayoutWidth != nil {
		localVarQueryParams.Add("fluid_layout_width", parameterToString(*r.fluidLayoutWidth, ""))
	}
	if r.highContrastMode != nil {
		localVarQueryParams.Add("high_contrast_mode", parameterToString(*r.highContrastMode, ""))
	}
	if r.colorScheme != nil {
		localVarQueryParams.Add("color_scheme", parameterToString(*r.colorScheme, ""))
	}
	if r.translateEmoticons != nil {
		localVarQueryParams.Add("translate_emoticons", parameterToString(*r.translateEmoticons, ""))
	}
	if r.defaultLanguage != nil {
		localVarQueryParams.Add("default_language", parameterToString(*r.defaultLanguage, ""))
	}
	if r.defaultView != nil {
		localVarQueryParams.Add("default_view", parameterToString(*r.defaultView, ""))
	}
	if r.leftSideUserlist != nil {
		localVarQueryParams.Add("left_side_userlist", parameterToString(*r.leftSideUserlist, ""))
	}
	if r.emojiset != nil {
		localVarQueryParams.Add("emojiset", parameterToString(*r.emojiset, ""))
	}
	if r.demoteInactiveStreams != nil {
		localVarQueryParams.Add("demote_inactive_streams", parameterToString(*r.demoteInactiveStreams, ""))
	}
	if r.timezone != nil {
		localVarQueryParams.Add("timezone", parameterToString(*r.timezone, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNotificationSettingsRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	enableStreamDesktopNotifications *bool
	enableStreamEmailNotifications *bool
	enableStreamPushNotifications *bool
	enableStreamAudibleNotifications *bool
	notificationSound *string
	enableDesktopNotifications *bool
	enableSounds *bool
	enableOfflineEmailNotifications *bool
	enableOfflinePushNotifications *bool
	enableOnlinePushNotifications *bool
	enableDigestEmails *bool
	enableMarketingEmails *bool
	enableLoginEmails *bool
	messageContentInEmailNotifications *bool
	pmContentInDesktopNotifications *bool
	wildcardMentionsNotify *bool
	desktopIconCountDisplay *int32
	realmNameInNotifications *bool
	presenceEnabled *bool
}

func (r ApiUpdateNotificationSettingsRequest) EnableStreamDesktopNotifications(enableStreamDesktopNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.enableStreamDesktopNotifications = &enableStreamDesktopNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableStreamEmailNotifications(enableStreamEmailNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.enableStreamEmailNotifications = &enableStreamEmailNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableStreamPushNotifications(enableStreamPushNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.enableStreamPushNotifications = &enableStreamPushNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableStreamAudibleNotifications(enableStreamAudibleNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.enableStreamAudibleNotifications = &enableStreamAudibleNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) NotificationSound(notificationSound string) ApiUpdateNotificationSettingsRequest {
	r.notificationSound = &notificationSound
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableDesktopNotifications(enableDesktopNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.enableDesktopNotifications = &enableDesktopNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableSounds(enableSounds bool) ApiUpdateNotificationSettingsRequest {
	r.enableSounds = &enableSounds
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableOfflineEmailNotifications(enableOfflineEmailNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.enableOfflineEmailNotifications = &enableOfflineEmailNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableOfflinePushNotifications(enableOfflinePushNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.enableOfflinePushNotifications = &enableOfflinePushNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableOnlinePushNotifications(enableOnlinePushNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.enableOnlinePushNotifications = &enableOnlinePushNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableDigestEmails(enableDigestEmails bool) ApiUpdateNotificationSettingsRequest {
	r.enableDigestEmails = &enableDigestEmails
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableMarketingEmails(enableMarketingEmails bool) ApiUpdateNotificationSettingsRequest {
	r.enableMarketingEmails = &enableMarketingEmails
	return r
}
func (r ApiUpdateNotificationSettingsRequest) EnableLoginEmails(enableLoginEmails bool) ApiUpdateNotificationSettingsRequest {
	r.enableLoginEmails = &enableLoginEmails
	return r
}
func (r ApiUpdateNotificationSettingsRequest) MessageContentInEmailNotifications(messageContentInEmailNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.messageContentInEmailNotifications = &messageContentInEmailNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) PmContentInDesktopNotifications(pmContentInDesktopNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.pmContentInDesktopNotifications = &pmContentInDesktopNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) WildcardMentionsNotify(wildcardMentionsNotify bool) ApiUpdateNotificationSettingsRequest {
	r.wildcardMentionsNotify = &wildcardMentionsNotify
	return r
}
func (r ApiUpdateNotificationSettingsRequest) DesktopIconCountDisplay(desktopIconCountDisplay int32) ApiUpdateNotificationSettingsRequest {
	r.desktopIconCountDisplay = &desktopIconCountDisplay
	return r
}
func (r ApiUpdateNotificationSettingsRequest) RealmNameInNotifications(realmNameInNotifications bool) ApiUpdateNotificationSettingsRequest {
	r.realmNameInNotifications = &realmNameInNotifications
	return r
}
func (r ApiUpdateNotificationSettingsRequest) PresenceEnabled(presenceEnabled bool) ApiUpdateNotificationSettingsRequest {
	r.presenceEnabled = &presenceEnabled
	return r
}

func (r ApiUpdateNotificationSettingsRequest) Execute() (JsonSuccessBase, *_nethttp.Response, error) {
	return r.ApiService.UpdateNotificationSettingsExecute(r)
}

/*
 * UpdateNotificationSettings Update notification settings
 * This endpoint is used to edit the user's global notification settings.
See [this endpoint](/api/update-subscription-settings) for
per-stream notification settings.

`PATCH {{ api_url }}/v1/settings/notifications`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateNotificationSettingsRequest
 */
func (a *UsersApiService) UpdateNotificationSettings(ctx _context.Context) ApiUpdateNotificationSettingsRequest {
	return ApiUpdateNotificationSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccessBase
 */
func (a *UsersApiService) UpdateNotificationSettingsExecute(r ApiUpdateNotificationSettingsRequest) (JsonSuccessBase, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccessBase
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UpdateNotificationSettings")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/notifications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.enableStreamDesktopNotifications != nil {
		localVarQueryParams.Add("enable_stream_desktop_notifications", parameterToString(*r.enableStreamDesktopNotifications, ""))
	}
	if r.enableStreamEmailNotifications != nil {
		localVarQueryParams.Add("enable_stream_email_notifications", parameterToString(*r.enableStreamEmailNotifications, ""))
	}
	if r.enableStreamPushNotifications != nil {
		localVarQueryParams.Add("enable_stream_push_notifications", parameterToString(*r.enableStreamPushNotifications, ""))
	}
	if r.enableStreamAudibleNotifications != nil {
		localVarQueryParams.Add("enable_stream_audible_notifications", parameterToString(*r.enableStreamAudibleNotifications, ""))
	}
	if r.notificationSound != nil {
		localVarQueryParams.Add("notification_sound", parameterToString(*r.notificationSound, ""))
	}
	if r.enableDesktopNotifications != nil {
		localVarQueryParams.Add("enable_desktop_notifications", parameterToString(*r.enableDesktopNotifications, ""))
	}
	if r.enableSounds != nil {
		localVarQueryParams.Add("enable_sounds", parameterToString(*r.enableSounds, ""))
	}
	if r.enableOfflineEmailNotifications != nil {
		localVarQueryParams.Add("enable_offline_email_notifications", parameterToString(*r.enableOfflineEmailNotifications, ""))
	}
	if r.enableOfflinePushNotifications != nil {
		localVarQueryParams.Add("enable_offline_push_notifications", parameterToString(*r.enableOfflinePushNotifications, ""))
	}
	if r.enableOnlinePushNotifications != nil {
		localVarQueryParams.Add("enable_online_push_notifications", parameterToString(*r.enableOnlinePushNotifications, ""))
	}
	if r.enableDigestEmails != nil {
		localVarQueryParams.Add("enable_digest_emails", parameterToString(*r.enableDigestEmails, ""))
	}
	if r.enableMarketingEmails != nil {
		localVarQueryParams.Add("enable_marketing_emails", parameterToString(*r.enableMarketingEmails, ""))
	}
	if r.enableLoginEmails != nil {
		localVarQueryParams.Add("enable_login_emails", parameterToString(*r.enableLoginEmails, ""))
	}
	if r.messageContentInEmailNotifications != nil {
		localVarQueryParams.Add("message_content_in_email_notifications", parameterToString(*r.messageContentInEmailNotifications, ""))
	}
	if r.pmContentInDesktopNotifications != nil {
		localVarQueryParams.Add("pm_content_in_desktop_notifications", parameterToString(*r.pmContentInDesktopNotifications, ""))
	}
	if r.wildcardMentionsNotify != nil {
		localVarQueryParams.Add("wildcard_mentions_notify", parameterToString(*r.wildcardMentionsNotify, ""))
	}
	if r.desktopIconCountDisplay != nil {
		localVarQueryParams.Add("desktop_icon_count_display", parameterToString(*r.desktopIconCountDisplay, ""))
	}
	if r.realmNameInNotifications != nil {
		localVarQueryParams.Add("realm_name_in_notifications", parameterToString(*r.realmNameInNotifications, ""))
	}
	if r.presenceEnabled != nil {
		localVarQueryParams.Add("presence_enabled", parameterToString(*r.presenceEnabled, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userId int32
	fullName *string
	role *int32
	profileData *[]map[string]interface{}
}

func (r ApiUpdateUserRequest) FullName(fullName string) ApiUpdateUserRequest {
	r.fullName = &fullName
	return r
}
func (r ApiUpdateUserRequest) Role(role int32) ApiUpdateUserRequest {
	r.role = &role
	return r
}
func (r ApiUpdateUserRequest) ProfileData(profileData []map[string]interface{}) ApiUpdateUserRequest {
	r.profileData = &profileData
	return r
}

func (r ApiUpdateUserRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateUserExecute(r)
}

/*
 * UpdateUser Update a user
 * Administrative endpoint to update the details of another user in the organization.

`PATCH {{ api_url }}/v1/users/{user_id}`

Supports everything an administrator can do to edit details of another
user's account, including editing full name,
[role](/help/roles-and-permissions), and [custom profile
fields](/help/add-custom-profile-fields).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId The target user's ID. 
 * @return ApiUpdateUserRequest
 */
func (a *UsersApiService) UpdateUser(ctx _context.Context, userId int32) ApiUpdateUserRequest {
	return ApiUpdateUserRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) UpdateUserExecute(r ApiUpdateUserRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UpdateUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fullName != nil {
		localVarQueryParams.Add("full_name", parameterToString(*r.fullName, ""))
	}
	if r.role != nil {
		localVarQueryParams.Add("role", parameterToString(*r.role, ""))
	}
	if r.profileData != nil {
		t := *r.profileData
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("profile_data", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("profile_data", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CodedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserGroupRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userGroupId int32
	name *string
	description *string
}

func (r ApiUpdateUserGroupRequest) Name(name string) ApiUpdateUserGroupRequest {
	r.name = &name
	return r
}
func (r ApiUpdateUserGroupRequest) Description(description string) ApiUpdateUserGroupRequest {
	r.description = &description
	return r
}

func (r ApiUpdateUserGroupRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateUserGroupExecute(r)
}

/*
 * UpdateUserGroup Update a user group
 * Update the name or description of a [user group](/help/user-groups).

`PATCH {{ api_url }}/v1/user_groups/{user_group_id}`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userGroupId The ID of the target user group. 
 * @return ApiUpdateUserGroupRequest
 */
func (a *UsersApiService) UpdateUserGroup(ctx _context.Context, userGroupId int32) ApiUpdateUserGroupRequest {
	return ApiUpdateUserGroupRequest{
		ApiService: a,
		ctx: ctx,
		userGroupId: userGroupId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) UpdateUserGroupExecute(r ApiUpdateUserGroupRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UpdateUserGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_groups/{user_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_group_id"+"}", _neturl.PathEscape(parameterToString(r.userGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}

	localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	localVarQueryParams.Add("description", parameterToString(*r.description, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v JsonError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserGroupMembersRequest struct {
	ctx _context.Context
	ApiService *UsersApiService
	userGroupId int32
	delete *[]int32
	add *[]int32
}

func (r ApiUpdateUserGroupMembersRequest) Delete(delete []int32) ApiUpdateUserGroupMembersRequest {
	r.delete = &delete
	return r
}
func (r ApiUpdateUserGroupMembersRequest) Add(add []int32) ApiUpdateUserGroupMembersRequest {
	r.add = &add
	return r
}

func (r ApiUpdateUserGroupMembersRequest) Execute() (JsonSuccess, *_nethttp.Response, error) {
	return r.ApiService.UpdateUserGroupMembersExecute(r)
}

/*
 * UpdateUserGroupMembers Update user group members
 * Update the members of a [user group](/help/user-groups).

`POST {{ api_url }}/v1/user_groups/{user_group_id}/members`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userGroupId The ID of the target user group. 
 * @return ApiUpdateUserGroupMembersRequest
 */
func (a *UsersApiService) UpdateUserGroupMembers(ctx _context.Context, userGroupId int32) ApiUpdateUserGroupMembersRequest {
	return ApiUpdateUserGroupMembersRequest{
		ApiService: a,
		ctx: ctx,
		userGroupId: userGroupId,
	}
}

/*
 * Execute executes the request
 * @return JsonSuccess
 */
func (a *UsersApiService) UpdateUserGroupMembersExecute(r ApiUpdateUserGroupMembersRequest) (JsonSuccess, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JsonSuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsersApiService.UpdateUserGroupMembers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_groups/{user_group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"user_group_id"+"}", _neturl.PathEscape(parameterToString(r.userGroupId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.delete != nil {
		t := *r.delete
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("delete", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("delete", parameterToString(t, "multi"))
		}
	}
	if r.add != nil {
		t := *r.add
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("add", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("add", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
