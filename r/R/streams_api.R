# Zulip REST API
#
# Powerful open source group chat 
#
# The version of the OpenAPI document: 1.0.0
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Streams operations
#' @description openapi.Streams
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ ArchiveStream } \emph{ Archive a stream }
#' [Archive the stream](/help/archive-a-stream) with the ID &#x60;stream_id&#x60;.  &#x60;DELETE {{ api_url }}/v1/streams/{stream_id}&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } stream.id integer
#' \item \emph{ @returnType } \link{JsonSuccess} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccess 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : JsonError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateBigBlueButtonVideoCall } \emph{ Create BigBlueButton video call }
#' Create a video call URL for a BigBlueButton video call. Requires BigBlueButton to be configured on the Zulip server. 
#'
#' \itemize{
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetStreamId } \emph{ Get stream ID }
#' Get the unique ID of a given stream.  &#x60;GET {{ api_url }}/v1/get_stream_id&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } stream character
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : CodedError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetStreamTopics } \emph{ Get topics in a stream }
#' Get all the topics in a specific stream  &#x60;GET {{ api_url }}/v1/users/me/{stream_id}/topics&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } stream.id integer
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : JsonError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetStreams } \emph{ Get all streams }
#' Get all streams that the user has access to.  &#x60;GET {{ api_url }}/v1/streams&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } include.public character
#' \item \emph{ @param } include.web.public character
#' \item \emph{ @param } include.subscribed character
#' \item \emph{ @param } include.all.active character
#' \item \emph{ @param } include.default character
#' \item \emph{ @param } include.owner.subscribed character
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : CodedError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetSubscriptionStatus } \emph{ Get subscription status }
#' Check whether a user is subscribed to a stream.  &#x60;GET {{ api_url }}/v1/users/{user_id}/subscriptions/{stream_id}&#x60;  **Changes**: New in Zulip 3.0 (feature level 11). 
#'
#' \itemize{
#' \item \emph{ @param } user.id integer
#' \item \emph{ @param } stream.id integer
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetSubscriptions } \emph{ Get subscribed streams }
#' Get all streams that the user is subscribed to.  &#x60;GET {{ api_url }}/v1/users/me/subscriptions&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } include.subscribers character
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ MuteTopic } \emph{ Topic muting }
#' This endpoint mutes/unmutes a topic within a stream that the current user is subscribed to.  Muted topics are displayed faded in the Zulip UI, and are not included in the user&#39;s unread count totals.  &#x60;PATCH {{ api_url }}/v1/users/me/subscriptions/muted_topics&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } topic character
#' \item \emph{ @param } op Enum < [add, remove] > 
#' \item \emph{ @param } stream character
#' \item \emph{ @param } stream.id integer
#' \item \emph{ @returnType } \link{JsonSuccess} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccess 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : OneOfobjectobject 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ Subscribe } \emph{ Subscribe to a stream }
#' Subscribe one or more users to one or more streams.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions&#x60;  If any of the specified streams do not exist, they are automatically created.  The initial [stream settings](/api/update-stream) will be determined by the optional parameters like &#x60;invite_only&#x60; detailed below. 
#'
#' \itemize{
#' \item \emph{ @param } subscriptions list( object )
#' \item \emph{ @param } principals list( \link{OneOfstringinteger} )
#' \item \emph{ @param } authorization.errors.fatal character
#' \item \emph{ @param } announce character
#' \item \emph{ @param } invite.only character
#' \item \emph{ @param } history.public.to.subscribers character
#' \item \emph{ @param } stream.post.policy integer
#' \item \emph{ @param } message.retention.days \link{OneOfstringinteger}
#' \item \emph{ @returnType } \link{OneOfobjectobject} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : OneOfobjectobject 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Success.
#'
#' \item return type : OneOfobjectobject 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ Unsubscribe } \emph{ Unsubscribe from a stream }
#' Unsubscribe yourself or other users from one or more streams.  &#x60;DELETE {{ api_url }}/v1/users/me/subscriptions&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } subscriptions list( character )
#' \item \emph{ @param } principals list( \link{OneOfstringinteger} )
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : NonExistingStreamError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateStream } \emph{ Update a stream }
#' Configure the stream with the ID &#x60;stream_id&#x60;.  This endpoint supports an organization administrator editing any property of a stream, including:  * Stream [name](/help/rename-a-stream) and [description](/help/change-the-stream-description) * Stream [permissions](/help/stream-permissions), including [privacy](/help/change-the-privacy-of-a-stream) and [who can send](/help/stream-sending-policy).  &#x60;PATCH {{ api_url }}/v1/streams/{stream_id}&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } stream.id integer
#' \item \emph{ @param } description character
#' \item \emph{ @param } new.name character
#' \item \emph{ @param } is.private character
#' \item \emph{ @param } is.announcement.only character
#' \item \emph{ @param } stream.post.policy integer
#' \item \emph{ @param } history.public.to.subscribers character
#' \item \emph{ @param } message.retention.days \link{OneOfstringinteger}
#' \item \emph{ @returnType } \link{JsonSuccess} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccess 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Bad request.
#'
#' \item return type : JsonError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateSubscriptionSettings } \emph{ Update subscription settings }
#' This endpoint is used to update the user&#39;s personal settings for the streams they are subscribed to, including muting, color, pinning, and per-stream notification settings.  &#x60;POST {{ api_url }}/v1/users/me/subscriptions/properties&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } subscription.data list( object )
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateSubscriptions } \emph{ Update subscriptions }
#' Update which streams you are are subscribed to. 
#'
#' \itemize{
#' \item \emph{ @param } delete list( character )
#' \item \emph{ @param } add list( object )
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  ArchiveStream  ####################
#'
#' library(openapi)
#' var.stream.id <- 1 # integer | The ID of the stream to access. 
#'
#' #Archive a stream
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$ArchiveStream(var.stream.id)
#'
#'
#' ####################  CreateBigBlueButtonVideoCall  ####################
#'
#' library(openapi)
#'
#' #Create BigBlueButton video call
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$CreateBigBlueButtonVideoCall()
#'
#'
#' ####################  GetStreamId  ####################
#'
#' library(openapi)
#' var.stream <- 'Denmark' # character | The name of the stream to access. 
#'
#' #Get stream ID
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$GetStreamId(var.stream)
#'
#'
#' ####################  GetStreamTopics  ####################
#'
#' library(openapi)
#' var.stream.id <- 1 # integer | The ID of the stream to access. 
#'
#' #Get topics in a stream
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$GetStreamTopics(var.stream.id)
#'
#'
#' ####################  GetStreams  ####################
#'
#' library(openapi)
#' var.include.public <- TRUE # character | Include all public streams. 
#' var.include.web.public <- FALSE # character | Include all web public streams. 
#' var.include.subscribed <- TRUE # character | Include all streams that the user is subscribed to. 
#' var.include.all.active <- FALSE # character | Include all active streams. The user must have administrative privileges to use this parameter. 
#' var.include.default <- FALSE # character | Include all default streams for the user's realm. 
#' var.include.owner.subscribed <- FALSE # character | If the user is a bot, include all streams that the bot's owner is subscribed to. 
#'
#' #Get all streams
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$GetStreams(include.public=var.include.public, include.web.public=var.include.web.public, include.subscribed=var.include.subscribed, include.all.active=var.include.all.active, include.default=var.include.default, include.owner.subscribed=var.include.owner.subscribed)
#'
#'
#' ####################  GetSubscriptionStatus  ####################
#'
#' library(openapi)
#' var.user.id <- 12 # integer | The target user's ID. 
#' var.stream.id <- 1 # integer | The ID of the stream to access. 
#'
#' #Get subscription status
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$GetSubscriptionStatus(var.user.id, var.stream.id)
#'
#'
#' ####################  GetSubscriptions  ####################
#'
#' library(openapi)
#' var.include.subscribers <- FALSE # character | Whether each returned stream object should include a `subscribers` field containing a list of the user IDs of its subscribers.  (This may be significantly slower in organizations with thousands of users subscribed to many streams.)  **Changes**: New in Zulip 2.1.0. 
#'
#' #Get subscribed streams
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$GetSubscriptions(include.subscribers=var.include.subscribers)
#'
#'
#' ####################  MuteTopic  ####################
#'
#' library(openapi)
#' var.topic <- 'dinner' # character | The topic to (un)mute. Note that the request will succeed regardless of whether any messages have been sent to the specified topic. 
#' var.op <- 'add' # character | Whether to mute (`add`) or unmute (`remove`) the provided topic. 
#' var.stream <- 'Denmark' # character | The name of the stream to access. 
#' var.stream.id <- 42 # integer | The ID of the stream to access. 
#'
#' #Topic muting
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$MuteTopic(var.topic, var.op, stream=var.stream, stream.id=var.stream.id)
#'
#'
#' ####################  Subscribe  ####################
#'
#' library(openapi)
#' var.subscriptions <- NULL # array[object] | A list of dictionaries containing the key `name` and value specifying the name of the stream to subscribe. If the stream does not exist a new stream is created. The description of the stream created can be specified by setting the dictionary key `description` with an appropriate value. 
#' var.principals <- [OneOfstringinteger$new()] # array[OneOfstringinteger] | A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the `subscriptions` parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
#' var.authorization.errors.fatal <- TRUE # character | A boolean specifying whether authorization errors (such as when the requesting user is not authorized to access a private stream) should be considered fatal or not. When `True`, an authorization error is reported as such. When set to `False`, the response will be a 200 and any streams where the request encountered an authorization error will be listed in the `unauthorized` key. 
#' var.announce <- FALSE # character | If one of the streams specified did not exist previously and is thus craeted by this call, this determines whether [notification bot](/help/configure-notification-bot) will send an announcement about the new stream's creation. 
#' var.invite.only <- FALSE # character | As described above, this endpoint will create a new stream if passed a stream name that doesn't already exist.  This parameters and the ones that follow are used to request an initial configuration of a created stream; they are ignored for streams that already exist.  This parameter determines whether any newly created streams will be private streams. 
#' var.history.public.to.subscribers <- 'false' # character | Whether the stream's message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
#' var.stream.post.policy <- 1 # integer | Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
#' var.message.retention.days <- OneOfstringinteger$new() # OneOfstringinteger | Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \"realm_default\" => Return to the organization-level setting. * \"forever\" => Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
#'
#' #Subscribe to a stream
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$Subscribe(var.subscriptions, principals=var.principals, authorization.errors.fatal=var.authorization.errors.fatal, announce=var.announce, invite.only=var.invite.only, history.public.to.subscribers=var.history.public.to.subscribers, stream.post.policy=var.stream.post.policy, message.retention.days=var.message.retention.days)
#'
#'
#' ####################  Unsubscribe  ####################
#'
#' library(openapi)
#' var.subscriptions <- ['subscriptions_example'] # array[character] | A list of stream names to unsubscribe from. This parameter is called `streams` in our Python API. 
#' var.principals <- [OneOfstringinteger$new()] # array[OneOfstringinteger] | A list of user ids (preferred) or Zulip display email addresses of the users to be subscribed to or unsubscribed from the streams specified in the `subscriptions` parameter. If not provided, then the requesting user/bot is subscribed.  **Changes**: The integer format is new in Zulip 3.0 (feature level 9). 
#'
#' #Unsubscribe from a stream
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$Unsubscribe(var.subscriptions, principals=var.principals)
#'
#'
#' ####################  UpdateStream  ####################
#'
#' library(openapi)
#' var.stream.id <- 1 # integer | The ID of the stream to access. 
#' var.description <- 'Discuss Italian history and travel destinations.' # character | The new description for the stream. Limited Zulip markdown is allowed in this field.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
#' var.new.name <- 'Italy' # character | The new name for the stream.  **Changes**: Removed unnecessary JSON-encoding of this parameter in Zulip 4.0 (feature level 64). 
#' var.is.private <- 'true' # character | Change whether the stream is a private stream. 
#' var.is.announcement.only <- 'true' # character | Whether the stream is limited to announcements.  **Changes**: Deprecated in Zulip 3.0 (feature level 1), use   `stream_post_policy` instead. 
#' var.stream.post.policy <- 1 # integer | Policy for which users can post messages to the stream.  * 1 => Any user can post. * 2 => Only administrators can post. * 3 => Only full members can post. * 4 => Only moderators can post.  **Changes**: New in Zulip 3.0, replacing the previous `is_announcement_only` boolean. 
#' var.history.public.to.subscribers <- 'false' # character | Whether the stream's message history should be available to newly subscribed members, or users can only access messages they actually received while subscribed to the stream.  Corresponds to the [shared history](/help/stream-permissions) option in documentation. 
#' var.message.retention.days <- OneOfstringinteger$new() # OneOfstringinteger | Number of days that messages sent to this stream will be stored before being automatically deleted by the [message retention policy](/help/message-retention-policy).  Two special string format values are supported:  * \"realm_default\" => Return to the organization-level setting. * \"forever\" => Retain messages forever.  **Changes**: New in Zulip 3.0 (feature level 17). 
#'
#' #Update a stream
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$UpdateStream(var.stream.id, description=var.description, new.name=var.new.name, is.private=var.is.private, is.announcement.only=var.is.announcement.only, stream.post.policy=var.stream.post.policy, history.public.to.subscribers=var.history.public.to.subscribers, message.retention.days=var.message.retention.days)
#'
#'
#' ####################  UpdateSubscriptionSettings  ####################
#'
#' library(openapi)
#' var.subscription.data <- NULL # array[object] | A list of objects that describe the changes that should be applied in each subscription. Each object represents a subscription, and must have a `stream_id` key that identifies the stream, as well as the `property` being modified and its new `value`.  The possible values for each `property` and `value` pairs are:  * `color` (string): the hex value of the user's display color for the stream. * `is_muted` (boolean): whether the stream is   [muted](/help/mute-a-stream).  Prior to Zulip 2.1, this feature was   represented by the more confusingly named `in_home_view` (with the   opposite value, `in_home_view=!is_muted`); for   backwards-compatibility, modern Zulip still accepts that value. * `pin_to_top` (boolean): whether to pin the stream at the top of the stream list. * `desktop_notifications` (boolean): whether to show desktop notifications     for all messages sent to the stream. * `audible_notifications` (boolean): whether to play a sound   notification for all messages sent to the stream. * `push_notifications` (boolean): whether to trigger a mobile push     notification for all messages sent to the stream. * `email_notifications` (boolean): whether to trigger an email     notification for all messages sent to the stream. 
#'
#' #Update subscription settings
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$UpdateSubscriptionSettings(var.subscription.data)
#'
#'
#' ####################  UpdateSubscriptions  ####################
#'
#' library(openapi)
#' var.delete <- ['delete_example'] # array[character] | A list of stream names to unsubscribe from. 
#' var.add <- NULL # array[object] | A list of objects describing which streams to subscribe to, optionally including per-user subscription parameters (e.g. color) and if the stream is to be created, its description. 
#'
#' #Update subscriptions
#' api.instance <- StreamsApi$new()
#'
#' result <- api.instance$UpdateSubscriptions(delete=var.delete, add=var.add)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
StreamsApi <- R6::R6Class(
  'StreamsApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    ArchiveStream = function(stream.id, ...){
      apiResponse <- self$ArchiveStreamWithHttpInfo(stream.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ArchiveStreamWithHttpInfo = function(stream.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`stream.id`)) {
        stop("Missing required parameter `stream.id`.")
      }

      body <- NULL
      urlPath <- "/streams/{stream_id}"
      if (!missing(`stream.id`)) {
        urlPath <- gsub(paste0("\\{", "stream_id", "\\}"), URLencode(as.character(`stream.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccess", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateBigBlueButtonVideoCall = function(...){
      apiResponse <- self$CreateBigBlueButtonVideoCallWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateBigBlueButtonVideoCallWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/calls/bigbluebutton/create"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetStreamId = function(stream, ...){
      apiResponse <- self$GetStreamIdWithHttpInfo(stream, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetStreamIdWithHttpInfo = function(stream, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`stream`)) {
        stop("Missing required parameter `stream`.")
      }

      queryParams['stream'] <- stream

      body <- NULL
      urlPath <- "/get_stream_id"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetStreamTopics = function(stream.id, ...){
      apiResponse <- self$GetStreamTopicsWithHttpInfo(stream.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetStreamTopicsWithHttpInfo = function(stream.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`stream.id`)) {
        stop("Missing required parameter `stream.id`.")
      }

      body <- NULL
      urlPath <- "/users/me/{stream_id}/topics"
      if (!missing(`stream.id`)) {
        urlPath <- gsub(paste0("\\{", "stream_id", "\\}"), URLencode(as.character(`stream.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetStreams = function(include.public=TRUE, include.web.public=FALSE, include.subscribed=TRUE, include.all.active=FALSE, include.default=FALSE, include.owner.subscribed=FALSE, ...){
      apiResponse <- self$GetStreamsWithHttpInfo(include.public, include.web.public, include.subscribed, include.all.active, include.default, include.owner.subscribed, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetStreamsWithHttpInfo = function(include.public=TRUE, include.web.public=FALSE, include.subscribed=TRUE, include.all.active=FALSE, include.default=FALSE, include.owner.subscribed=FALSE, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['include_public'] <- include.public

      queryParams['include_web_public'] <- include.web.public

      queryParams['include_subscribed'] <- include.subscribed

      queryParams['include_all_active'] <- include.all.active

      queryParams['include_default'] <- include.default

      queryParams['include_owner_subscribed'] <- include.owner.subscribed

      body <- NULL
      urlPath <- "/streams"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetSubscriptionStatus = function(user.id, stream.id, ...){
      apiResponse <- self$GetSubscriptionStatusWithHttpInfo(user.id, stream.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetSubscriptionStatusWithHttpInfo = function(user.id, stream.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`user.id`)) {
        stop("Missing required parameter `user.id`.")
      }

      if (missing(`stream.id`)) {
        stop("Missing required parameter `stream.id`.")
      }

      body <- NULL
      urlPath <- "/users/{user_id}/subscriptions/{stream_id}"
      if (!missing(`user.id`)) {
        urlPath <- gsub(paste0("\\{", "user_id", "\\}"), URLencode(as.character(`user.id`), reserved = TRUE), urlPath)
      }

      if (!missing(`stream.id`)) {
        urlPath <- gsub(paste0("\\{", "stream_id", "\\}"), URLencode(as.character(`stream.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetSubscriptions = function(include.subscribers=FALSE, ...){
      apiResponse <- self$GetSubscriptionsWithHttpInfo(include.subscribers, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetSubscriptionsWithHttpInfo = function(include.subscribers=FALSE, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['include_subscribers'] <- include.subscribers

      body <- NULL
      urlPath <- "/users/me/subscriptions"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    MuteTopic = function(topic, op, stream=NULL, stream.id=NULL, ...){
      apiResponse <- self$MuteTopicWithHttpInfo(topic, op, stream, stream.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    MuteTopicWithHttpInfo = function(topic, op, stream=NULL, stream.id=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`topic`)) {
        stop("Missing required parameter `topic`.")
      }

      if (missing(`op`)) {
        stop("Missing required parameter `op`.")
      }

      queryParams['stream'] <- stream

      queryParams['stream_id'] <- stream.id

      queryParams['topic'] <- topic

      queryParams['op'] <- op

      body <- NULL
      urlPath <- "/users/me/subscriptions/muted_topics"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccess", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    Subscribe = function(subscriptions, principals=NULL, authorization.errors.fatal=TRUE, announce=FALSE, invite.only=FALSE, history.public.to.subscribers=NULL, stream.post.policy=1, message.retention.days=NULL, ...){
      apiResponse <- self$SubscribeWithHttpInfo(subscriptions, principals, authorization.errors.fatal, announce, invite.only, history.public.to.subscribers, stream.post.policy, message.retention.days, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SubscribeWithHttpInfo = function(subscriptions, principals=NULL, authorization.errors.fatal=TRUE, announce=FALSE, invite.only=FALSE, history.public.to.subscribers=NULL, stream.post.policy=1, message.retention.days=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`subscriptions`)) {
        stop("Missing required parameter `subscriptions`.")
      }

      queryParams['subscriptions'] <- subscriptions

      queryParams['principals'] <- principals

      queryParams['authorization_errors_fatal'] <- authorization.errors.fatal

      queryParams['announce'] <- announce

      queryParams['invite_only'] <- invite.only

      queryParams['history_public_to_subscribers'] <- history.public.to.subscribers

      queryParams['stream_post_policy'] <- stream.post.policy

      queryParams['message_retention_days'] <- message.retention.days

      body <- NULL
      urlPath <- "/users/me/subscriptions"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "OneOfobjectobject", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    Unsubscribe = function(subscriptions, principals=NULL, ...){
      apiResponse <- self$UnsubscribeWithHttpInfo(subscriptions, principals, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UnsubscribeWithHttpInfo = function(subscriptions, principals=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`subscriptions`)) {
        stop("Missing required parameter `subscriptions`.")
      }

      queryParams['subscriptions'] <- subscriptions

      queryParams['principals'] <- principals

      body <- NULL
      urlPath <- "/users/me/subscriptions"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateStream = function(stream.id, description=NULL, new.name=NULL, is.private=NULL, is.announcement.only=NULL, stream.post.policy=1, history.public.to.subscribers=NULL, message.retention.days=NULL, ...){
      apiResponse <- self$UpdateStreamWithHttpInfo(stream.id, description, new.name, is.private, is.announcement.only, stream.post.policy, history.public.to.subscribers, message.retention.days, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateStreamWithHttpInfo = function(stream.id, description=NULL, new.name=NULL, is.private=NULL, is.announcement.only=NULL, stream.post.policy=1, history.public.to.subscribers=NULL, message.retention.days=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`stream.id`)) {
        stop("Missing required parameter `stream.id`.")
      }

      queryParams['description'] <- description

      queryParams['new_name'] <- new.name

      queryParams['is_private'] <- is.private

      queryParams['is_announcement_only'] <- is.announcement.only

      queryParams['stream_post_policy'] <- stream.post.policy

      queryParams['history_public_to_subscribers'] <- history.public.to.subscribers

      queryParams['message_retention_days'] <- message.retention.days

      body <- NULL
      urlPath <- "/streams/{stream_id}"
      if (!missing(`stream.id`)) {
        urlPath <- gsub(paste0("\\{", "stream_id", "\\}"), URLencode(as.character(`stream.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccess", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateSubscriptionSettings = function(subscription.data, ...){
      apiResponse <- self$UpdateSubscriptionSettingsWithHttpInfo(subscription.data, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateSubscriptionSettingsWithHttpInfo = function(subscription.data, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`subscription.data`)) {
        stop("Missing required parameter `subscription.data`.")
      }

      queryParams['subscription_data'] <- subscription.data

      body <- NULL
      urlPath <- "/users/me/subscriptions/properties"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateSubscriptions = function(delete=NULL, add=NULL, ...){
      apiResponse <- self$UpdateSubscriptionsWithHttpInfo(delete, add, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateSubscriptionsWithHttpInfo = function(delete=NULL, add=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['delete'] <- delete

      queryParams['add'] <- add

      body <- NULL
      urlPath <- "/users/me/subscriptions"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
