# Zulip REST API
#
# Powerful open source group chat 
#
# The version of the OpenAPI document: 1.0.0
# 
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title ServerAndOrganizations operations
#' @description openapi.ServerAndOrganizations
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ AddCodePlayground } \emph{ Add a code playground }
#' Configure [code playgrounds](/help/code-blocks#code-playgrounds) for the organization.  &#x60;POST {{ api_url }}/v1/realm/playgrounds&#x60;  **Changes**: New in Zulip 4.0 (feature level 49). A parameter encoding bug was fixed in Zulip 4.0 (feature level 57). 
#'
#' \itemize{
#' \item \emph{ @param } name character
#' \item \emph{ @param } pygments.language character
#' \item \emph{ @param } url.prefix character
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ AddLinkifier } \emph{ Add a linkifier }
#' Configure [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;POST {{ api_url }}/v1/realm/filters&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } pattern character
#' \item \emph{ @param } url.format.string character
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CreateCustomProfileField } \emph{ Create a custom profile field }
#' [Create a custom profile field](/help/add-custom-profile-fields) in the user&#39;s organization.  &#x60;POST {{ api_url }}/v1/realm/profile_fields&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } field.type integer
#' \item \emph{ @param } name character
#' \item \emph{ @param } hint character
#' \item \emph{ @param } field.data \link{object}
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetCustomEmoji } \emph{ Get all custom emoji }
#' Get all the custom emoji in the user&#39;s organization.  &#x60;GET {{ api_url }}/v1/realm/emoji&#x60; 
#'
#' \itemize{
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetCustomProfileFields } \emph{ Get all custom profile fields }
#' Get all the [custom profile fields](/help/add-custom-profile-fields) configured for the user&#39;s organization.  &#x60;GET {{ api_url }}/v1/realm/profile_fields&#x60; 
#'
#' \itemize{
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetLinkifiers } \emph{ Get linkifiers }
#' List all of an organization&#39;s configured [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;GET {{ api_url }}/v1/realm/linkifiers&#x60;  **Changes**: New in Zulip 4.0 (feature level 54). On older versions, a similar &#x60;GET /realm/filters&#x60; endpoint was available with each entry in a &#x60;[pattern, url_format, id]&#x60; tuple format. 
#'
#' \itemize{
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetServerSettings } \emph{ Get server settings }
#' Fetch global settings for a Zulip server.  &#x60;GET {{ api_url }}/v1/server_settings&#x60;  **Note:** this endpoint does not require any authentication at all, and you can use it to check:  * If this is a Zulip server, and if so, what version of Zulip it&#39;s running. * What a Zulip client (e.g. a mobile app or [zulip-terminal](https://github.com/zulip/zulip-terminal/)) needs to know in order to display a login prompt for the server (e.g. what authentication methods are available). 
#'
#' \itemize{
#' \item \emph{ @returnType } \link{JsonSuccessBase} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccessBase 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ RemoveCodePlayground } \emph{ Remove a code playground }
#' Remove a [code playground](/help/code-blocks#code-playgrounds) previously configured for an organization.  &#x60;DELETE {{ api_url }}/v1/realm/playgrounds/{playground_id}&#x60;  **Changes**: New in Zulip 4.0 (feature level 49). 
#'
#' \itemize{
#' \item \emph{ @param } playground.id integer
#' \item \emph{ @returnType } \link{JsonSuccess} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccess 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ RemoveLinkifier } \emph{ Remove a linkifier }
#' Remove [linkifiers](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;DELETE {{ api_url }}/v1/realm/filters/{filter_id}&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } filter.id integer
#' \item \emph{ @returnType } \link{JsonSuccess} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccess 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ReorderCustomProfileFields } \emph{ Reorder custom profile fields }
#' Reorder the custom profile fields in the user&#39;s organization.  &#x60;PATCH {{ api_url }}/v1/realm/profile_fields&#x60;  Custom profile fields are displayed in Zulip UI widgets in order; this endpoint allows administrative settings UI to change the field ordering.  This endpoint is used to implement the dragging feature described in the [custom profile fields documentation](/help/add-custom-profile-fields). 
#'
#' \itemize{
#' \item \emph{ @param } order list( integer )
#' \item \emph{ @returnType } \link{JsonSuccess} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccess 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UpdateLinkifier } \emph{ Update a linkifier }
#' Update a [linkifier](/help/add-a-custom-linkifier), regular expression patterns that are automatically linkified when they appear in messages and topics.  &#x60;PATCH {{ api_url }}/v1/realm/filters/{filter_id}&#x60;  **Changes**: New in Zulip 4.0 (feature level 57). 
#'
#' \itemize{
#' \item \emph{ @param } filter.id integer
#' \item \emph{ @param } pattern character
#' \item \emph{ @param } url.format.string character
#' \item \emph{ @returnType } \link{JsonSuccess} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccess 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UploadCustomEmoji } \emph{ Upload custom emoji }
#' This endpoint is used to upload a custom emoji for use in the user&#39;s organization.  Access to this endpoint depends on the [organization&#39;s configuration](https://zulip.com/help/only-allow-admins-to-add-emoji).  &#x60;POST {{ api_url }}/v1/realm/emoji/{emoji_name}&#x60; 
#'
#' \itemize{
#' \item \emph{ @param } emoji.name character
#' \item \emph{ @param } filename data.frame
#' \item \emph{ @returnType } \link{JsonSuccess} \cr
#'
#'
#' \item status code : 200 | Success.
#'
#' \item return type : JsonSuccess 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  AddCodePlayground  ####################
#'
#' library(openapi)
#' var.name <- 'Python playground' # character | The user-visible display name of the playground which can be used to pick the target playground, especially when multiple playground options exist for that programming language. 
#' var.pygments.language <- 'Python' # character | The name of the Pygments language lexer for that programming language. 
#' var.url.prefix <- 'https://python.example.com' # character | The url prefix for the playground. 
#'
#' #Add a code playground
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$AddCodePlayground(var.name, var.pygments.language, var.url.prefix)
#'
#'
#' ####################  AddLinkifier  ####################
#'
#' library(openapi)
#' var.pattern <- '#(?P<id>[0-9]+)' # character | The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
#' var.url.format.string <- 'https://github.com/zulip/zulip/issues/%(id)s' # character | The URL used for the link. If you used named groups for the `pattern`, you can insert their content here with `%(name_of_the_capturing_group)s`. 
#'
#' #Add a linkifier
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$AddLinkifier(var.pattern, var.url.format.string)
#'
#'
#' ####################  CreateCustomProfileField  ####################
#'
#' library(openapi)
#' var.field.type <- 3 # integer | The field type can be any of the supported custom profile field types. See the [custom profile fields documentation](/help/add-custom-profile-fields) more details on what each type means.  * **1**: Short text * **2**: Long text * **3**: List of options * **4**: Date picker * **5**: Link * **6**: Person picker * **7**: External account 
#' var.name <- 'Favorite programming language' # character | The name of the custom profile field, which will appear both in user-facing settings UI for configuring custom profile fields and in UI displaying a user's profile. 
#' var.hint <- 'Your favorite programming language.' # character | The help text to be displayed for the custom profile field in user-facing settings UI for configuring custom profile fields. 
#' var.field.data <- NULL # object | Field types 3 (List of options) and 7 (External account) support storing additional configuration for the field type in the `field_data` attribute.  For field type 3 (List of options), this attribute is a JSON dictionary defining the choices and the order they will be displayed in the dropdown UI for individual users to select an option.  The interface for field type 7 is not yet stabilized. 
#'
#' #Create a custom profile field
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$CreateCustomProfileField(var.field.type, name=var.name, hint=var.hint, field.data=var.field.data)
#'
#'
#' ####################  GetCustomEmoji  ####################
#'
#' library(openapi)
#'
#' #Get all custom emoji
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$GetCustomEmoji()
#'
#'
#' ####################  GetCustomProfileFields  ####################
#'
#' library(openapi)
#'
#' #Get all custom profile fields
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$GetCustomProfileFields()
#'
#'
#' ####################  GetLinkifiers  ####################
#'
#' library(openapi)
#'
#' #Get linkifiers
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$GetLinkifiers()
#'
#'
#' ####################  GetServerSettings  ####################
#'
#' library(openapi)
#'
#' #Get server settings
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$GetServerSettings()
#'
#'
#' ####################  RemoveCodePlayground  ####################
#'
#' library(openapi)
#' var.playground.id <- 1 # integer | The ID of the playground that you want to remove. 
#'
#' #Remove a code playground
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$RemoveCodePlayground(var.playground.id)
#'
#'
#' ####################  RemoveLinkifier  ####################
#'
#' library(openapi)
#' var.filter.id <- 42 # integer | The ID of the linkifier that you want to remove. 
#'
#' #Remove a linkifier
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$RemoveLinkifier(var.filter.id)
#'
#'
#' ####################  ReorderCustomProfileFields  ####################
#'
#' library(openapi)
#' var.order <- [56] # array[integer] | A list of the IDs of all the custom profile fields defined in this organization, in the desired new order. 
#'
#' #Reorder custom profile fields
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$ReorderCustomProfileFields(var.order)
#'
#'
#' ####################  UpdateLinkifier  ####################
#'
#' library(openapi)
#' var.filter.id <- 2 # integer | The ID of the linkifier that you want to update. 
#' var.pattern <- '#(?P<id>[0-9]+)' # character | The [Python regular expression](https://docs.python.org/3/howto/regex.html) that should trigger the linkifier. 
#' var.url.format.string <- 'https://github.com/zulip/zulip/issues/%(id)s' # character | The URL used for the link. If you used named groups for the `pattern`, you can insert their content here with `%(name_of_the_capturing_group)s`. 
#'
#' #Update a linkifier
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$UpdateLinkifier(var.filter.id, var.pattern, var.url.format.string)
#'
#'
#' ####################  UploadCustomEmoji  ####################
#'
#' library(openapi)
#' var.emoji.name <- 'smile' # character | The name that should be associated with the uploaded emoji image/gif. The emoji name can only contain letters, numbers, dashes, and spaces. Upper and lower case letters are treated the same, and underscores (_) are treated the same as spaces (consistent with how the Zulip UI handles emoji). 
#' var.filename <- File.new('/path/to/file') # data.frame | 
#'
#' #Upload custom emoji
#' api.instance <- ServerAndOrganizationsApi$new()
#'
#' result <- api.instance$UploadCustomEmoji(var.emoji.name, filename=var.filename)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
ServerAndOrganizationsApi <- R6::R6Class(
  'ServerAndOrganizationsApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    AddCodePlayground = function(name, pygments.language, url.prefix, ...){
      apiResponse <- self$AddCodePlaygroundWithHttpInfo(name, pygments.language, url.prefix, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    AddCodePlaygroundWithHttpInfo = function(name, pygments.language, url.prefix, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (missing(`pygments.language`)) {
        stop("Missing required parameter `pygments.language`.")
      }

      if (missing(`url.prefix`)) {
        stop("Missing required parameter `url.prefix`.")
      }

      queryParams['name'] <- name

      queryParams['pygments_language'] <- pygments.language

      queryParams['url_prefix'] <- url.prefix

      body <- NULL
      urlPath <- "/realm/playgrounds"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    AddLinkifier = function(pattern, url.format.string, ...){
      apiResponse <- self$AddLinkifierWithHttpInfo(pattern, url.format.string, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    AddLinkifierWithHttpInfo = function(pattern, url.format.string, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`pattern`)) {
        stop("Missing required parameter `pattern`.")
      }

      if (missing(`url.format.string`)) {
        stop("Missing required parameter `url.format.string`.")
      }

      queryParams['pattern'] <- pattern

      queryParams['url_format_string'] <- url.format.string

      body <- NULL
      urlPath <- "/realm/filters"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CreateCustomProfileField = function(field.type, name=NULL, hint=NULL, field.data=NULL, ...){
      apiResponse <- self$CreateCustomProfileFieldWithHttpInfo(field.type, name, hint, field.data, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CreateCustomProfileFieldWithHttpInfo = function(field.type, name=NULL, hint=NULL, field.data=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`field.type`)) {
        stop("Missing required parameter `field.type`.")
      }

      queryParams['name'] <- name

      queryParams['hint'] <- hint

      queryParams['field_type'] <- field.type

      queryParams['field_data'] <- field.data

      body <- NULL
      urlPath <- "/realm/profile_fields"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetCustomEmoji = function(...){
      apiResponse <- self$GetCustomEmojiWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetCustomEmojiWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/realm/emoji"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetCustomProfileFields = function(...){
      apiResponse <- self$GetCustomProfileFieldsWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetCustomProfileFieldsWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/realm/profile_fields"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetLinkifiers = function(...){
      apiResponse <- self$GetLinkifiersWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetLinkifiersWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/realm/linkifiers"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetServerSettings = function(...){
      apiResponse <- self$GetServerSettingsWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetServerSettingsWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/server_settings"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccessBase", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    RemoveCodePlayground = function(playground.id, ...){
      apiResponse <- self$RemoveCodePlaygroundWithHttpInfo(playground.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    RemoveCodePlaygroundWithHttpInfo = function(playground.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`playground.id`)) {
        stop("Missing required parameter `playground.id`.")
      }

      body <- NULL
      urlPath <- "/realm/playgrounds/{playground_id}"
      if (!missing(`playground.id`)) {
        urlPath <- gsub(paste0("\\{", "playground_id", "\\}"), URLencode(as.character(`playground.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccess", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    RemoveLinkifier = function(filter.id, ...){
      apiResponse <- self$RemoveLinkifierWithHttpInfo(filter.id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    RemoveLinkifierWithHttpInfo = function(filter.id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`filter.id`)) {
        stop("Missing required parameter `filter.id`.")
      }

      body <- NULL
      urlPath <- "/realm/filters/{filter_id}"
      if (!missing(`filter.id`)) {
        urlPath <- gsub(paste0("\\{", "filter_id", "\\}"), URLencode(as.character(`filter.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "DELETE",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccess", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ReorderCustomProfileFields = function(order, ...){
      apiResponse <- self$ReorderCustomProfileFieldsWithHttpInfo(order, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ReorderCustomProfileFieldsWithHttpInfo = function(order, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`order`)) {
        stop("Missing required parameter `order`.")
      }

      queryParams['order'] <- order

      body <- NULL
      urlPath <- "/realm/profile_fields"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccess", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UpdateLinkifier = function(filter.id, pattern, url.format.string, ...){
      apiResponse <- self$UpdateLinkifierWithHttpInfo(filter.id, pattern, url.format.string, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UpdateLinkifierWithHttpInfo = function(filter.id, pattern, url.format.string, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`filter.id`)) {
        stop("Missing required parameter `filter.id`.")
      }

      if (missing(`pattern`)) {
        stop("Missing required parameter `pattern`.")
      }

      if (missing(`url.format.string`)) {
        stop("Missing required parameter `url.format.string`.")
      }

      queryParams['pattern'] <- pattern

      queryParams['url_format_string'] <- url.format.string

      body <- NULL
      urlPath <- "/realm/filters/{filter_id}"
      if (!missing(`filter.id`)) {
        urlPath <- gsub(paste0("\\{", "filter_id", "\\}"), URLencode(as.character(`filter.id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "PATCH",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccess", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UploadCustomEmoji = function(emoji.name, filename=NULL, ...){
      apiResponse <- self$UploadCustomEmojiWithHttpInfo(emoji.name, filename, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UploadCustomEmojiWithHttpInfo = function(emoji.name, filename=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`emoji.name`)) {
        stop("Missing required parameter `emoji.name`.")
      }

      body <- list(
        "filename" = httr::upload_file(filename)
      )

      urlPath <- "/realm/emoji/{emoji_name}"
      if (!missing(`emoji.name`)) {
        urlPath <- gsub(paste0("\\{", "emoji_name", "\\}"), URLencode(as.character(`emoji.name`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "JsonSuccess", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
